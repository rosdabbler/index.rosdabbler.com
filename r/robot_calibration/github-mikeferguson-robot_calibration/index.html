<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>ROS Index</title>
    <meta name="description" content="a community-maintained index of robotics software
">

    
    <link rel="canonical" href="http://index.rosdabbler.com/r/robot_calibration/github-mikeferguson-robot_calibration/">
    
    
    <link rel="icon" sizes="any" type="image/svg+xml" href="/assets/rosindex_logo.svg">

    

    <link rel="stylesheet" type="text/css" href="/bootstrap/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="/css/main.css">
    

    

    <script type="text/javascript" src=/js/jquery.js></script>
    <script src=/bootstrap/js/bootstrap.min.js type="text/javascript"></script>
    <script src=/js/jquery-cookie.js type="text/javascript"></script>
    
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EVD5Z6G6NH"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EVD5Z6G6NH');
</script>

    <script type="text/javascript" src=/js/toc.js></script>

    <script src=/js/distro_switch.js></script>
  </head>

  <body>

    <header class="site-header">

  <div class="wrapper">
    <div class="container-fluid" style="margin-bottom: 10px">
      <div class="row">
        <!-- title -->
        <div class="col-xs-3" style="white-space:nowrap">
          <a class="site-title" href="/">
            <img src="/assets/rosindex_logo.svg" width="26" height="26" alt="ROS index logo" style="padding-bottom: 3px"/>
            ROS Index</a>
        </div>
        <!-- main internal links -->
        <div class="col-xs-6 text-center" style="padding:0px">
          <div class="btn-group hidden-xs" role="group" aria-label="..." style="padding: 6px">
            <div class="btn-group" role="group">
              <a href="/?search_packages=true" class="btn btn-default" role="button">Package List</a>
            </div>
            <div class="btn-group" role="group">
              <a href="/?search_repos=true" class="btn btn-default" role="button">Repository List</a>
            </div>
            <div class="btn-group" role="group">
              <a href="/search_deps" class="btn btn-default" role="button">System Dependencies</a>
            </div>
          </div>
          <div class="hidden-lg hidden-md hidden-sm">
            <button id="hLabel" class="btn btn-link dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
              Lists <span class="caret"></span>
            </button>
            <ul class="dropdown-menu" aria-labelledby="hLabel">
              <li><a href="/?search_packages=true">Package List</a></li>
              <li><a href="/?search_repos=true">Repository List</a></li>
              <li><a href="/search_deps">System Dependencies</a></li>
            </ul>
          </div>
        </div>
        <!-- additional links -->
        <div class="col-xs-3 text-right" style="white-space:nowrap; padding:0px">
          <ul class="list-inline" style="margin-bottom:0px;">
            <li class="dropdown hidden-xs hidden-sm">
              <button id="rLabel" class="btn btn-link" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                ROS Resources <span class="caret"></span>
              </button>
              <ul class="dropdown-menu" role="menu" aria-labelledby="rLabel">
                <li><a href="http://docs.ros.org/">Documentation</a></li>
                <li><a href="http://wiki.ros.org/Support">Support</a></li>
                <li><a href="http://discourse.ros.org/">Discussion Forum</a></li>
                <li><a href="http://status.ros.org/">Service Status</a></li>
                <li><a href="https://robotics.stackexchange.com/questions/tagged/ros">ros @ Robotics Stack Exchange</a></li>
                <li><a href="https://docs.ros.org/en/ros2_packages/">Package API</a></li>
              </ul>
            </li>
            <li class="dropdown hidden-xs hidden-sm">
              <button id="aLabel" class="btn btn-link" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                About <span class="caret"></span>
              </button>
              <ul class="dropdown-menu dropdown-menu-right" role="menu" aria-labelledby="aLabel">
                <li><a href="/about">About </a></li>
                <li><a href="/contribute">Contribute</a></li>
                <li><a href="/help">Help</a></li>
                <li><a href="/stats">Stats</a></li>
              </ul>
            </li>
            <li class="dropdown hidden-md hidden-lg">
              <button id="qLabel" class="btn btn-link" type="button"
                      data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                Resources <span class="caret"></span>
              </button>
              <ul class="dropdown-menu dropdown-menu-right" role="menu" aria-labelledby="qLabel">
                <li><a href="/about">About </a></li>
                <li><a href="/contribute">Contribute</a></li>
                <li><a href="/help">Help</a></li>
                <li><a href="/stats">Stats</a></li>
                <hr style="margin:7px" />
                <li><a href="http://docs.ros.org/">Documentation</a></li>
                <li><a href="http://wiki.ros.org/Support">Support</a></li>
                <li><a href="http://discourse.ros.org/">Discussion Forum</a></li>
                <li><a href="http://status.ros.org/">Service Status</a></li>
                <li><a href="https://robotics.stackexchange.com/questions/tagged/ros">ros @ Robotics Stack Exchange</a></li>
                <li><a href="https://docs.ros.org/en/ros2_packages/">Package API</a></li>
              </ul>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="container-fluid" style="margin-top:20px">
  <div class="container-fluid">
    <div class="row">
      <ol class="breadcrumb">
        <li><a href="/">Home</a></li>
        <li><a href="/repos">Repos</a></li>
        <li class="active">robot_calibration</li>
        <!--<li class="active">robot_calibration</li>-->
      </ol>
    </div>
    <div class="row">
      

<div id="distro-switch" class="btn-group btn-group-justified" data-toggle="buttons">
  
    <label id="humble-option" class="distro-button btn btn-xs btn-primary" href="#humble" data="humble">
      <input type="radio" name="options" id="humble-radio" autocomplete="off"> humble
    </label>
  
    <label id="jazzy-option" class="distro-button btn btn-xs btn-primary" href="#jazzy" data="jazzy">
      <input type="radio" name="options" id="jazzy-radio" autocomplete="off"> jazzy
    </label>
  
    <label id="kilted-option" class="distro-button btn btn-xs btn-primary" href="#kilted" data="kilted">
      <input type="radio" name="options" id="kilted-radio" autocomplete="off"> kilted
    </label>
  
    <label id="rolling-option" class="distro-button btn btn-xs btn-primary" href="#rolling" data="rolling">
      <input type="radio" name="options" id="rolling-radio" autocomplete="off"> rolling
    </label>
  
    <label id="github-option" class="distro-button btn btn-xs btn-default" href="#github" data="github">
      <input type="radio" name="options" id="github-radio" autocomplete="off"> github
    </label>
  
    <label id="noetic-option" class="distro-button btn btn-xs btn-primary" href="#noetic" data="noetic">
      <input type="radio" name="options" id="noetic-radio" autocomplete="off"> noetic
    </label>
  

  <!-- Older distros -->
  <div class="btn-group dropdown">
    <label type="button" class="btn btn-xs dropdown-toggle btn-primary" data-toggle="dropdown" id="older-distro-button">
        <input type="radio" name="options" autocomplete="off">
      <span id="older-label">Older</span>
      <span class="caret"></span>
    </label>
    <ul class="dropdown-menu" role="menu">
      
        <li data="galactic" id="galactic-option" class="disabled older-distro-option"  href="#galactic">
          <a href="#galactic" data="galactic" id="galactic-button">galactic</a>
        </li>
      
        <li data="iron" id="iron-option" class=" older-distro-option"  href="#iron">
          <a href="#iron" data="iron" id="iron-button">iron</a>
        </li>
      
        <li data="melodic" id="melodic-option" class=" older-distro-option"  href="#melodic">
          <a href="#melodic" data="melodic" id="melodic-button">melodic</a>
        </li>
      
    </ul>
  </div>
</div>

    </div>
    <div class="row">
      &nbsp;
    </div>
  </div>
</div>


  <div class="distro distro-humble">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/robot_calibration">robot_calibration</a> <small>repository</small></h3>
        <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration">robot_calibration</a>
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration_msgs">robot_calibration_msgs</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-mikeferguson-robot_calibration
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-mikeferguson-robot_calibration" role="menuitem" tabindex="-1" href="/r/robot_calibration/github-mikeferguson-robot_calibration" data="github-mikeferguson-robot_calibration">
                    <span class="glyphicon glyphicon-star"></span>
                    github-mikeferguson-robot_calibration
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Generic calibration for robots</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/mikeferguson/robot_calibration.git">https://github.com/mikeferguson/robot_calibration.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">humble</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2024-12-05
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/robot_calibration/#humble-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#humble-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#humble-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/robot_calibration">robot_calibration</a></td>
                    <td>0.8.3</td>
                  </tr>
                
                  <tr>
                    <td><a href="/p/robot_calibration_msgs">robot_calibration_msgs</a></td>
                    <td>0.8.3</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="robot-calibration">Robot Calibration</h1>

<p>This package offers several ROS2 nodes. The primary one is called <em>calibrate</em>,
and can be used to calibrate a number of parameters of a robot, such as:</p>

<ul>
  <li>3D Camera intrinsics and extrinsics</li>
  <li>Joint angle offsets</li>
  <li>Robot frame offsets</li>
</ul>

<p>These parameters are then inserted into an updated URDF, or updated camera
configuration YAML in the case of camera intrinsics.</p>

<p>Two additional ROS nodes are used for mobile-base related parameter tuning:</p>

<ul>
  <li>
<em>base_calibration_node</em> - can determine scaling factors for gyro and track
width parameters by rotating the robot in place and tracking the actual
rotation based on the laser scanner view of a wall.</li>
  <li>
<em>magnetometer_calibration</em> - can be used to do hard iron calibration
of a magnetometer.</li>
</ul>

<h2 id="the-calibrate-node">The <em>calibrate</em> node</h2>

<p>Calibration works in two steps. The first step involves the capture of data
samples from the robot. Each “sample” comprises the measured joint positions
of the robot and two or more “observations”. An observation is a collection
of points that have been detected by a “sensor”. For instance, a robot could
use a camera and an arm to “detect” the pose of corners on a checkerboard.
In the case of the camera sensor, the collection of points is simply the
detected positions of each corner of the checkerboard, relative to the pose
of the camera reference frame. For the arm, it is assumed that the checkerboard
is fixed relative to a virtual frame which is fixed relative to the end
effector of the arm. Within the virtual frame, we know the position of each
point of the checkerboard corners.</p>

<p>The second step of calibration involves optimization of the robot parameters
to minimize the errors. Errors are defined as the difference in the pose
of the points based on reprojection throuhg each sensor. In the case of our
checkerboard above, the transform between the virtual frame and the end
effector becomes additional free parameters. By estimating these parameters
alongside the robot parameters, we can find a set of parameters such that
the reprojection of the checkerboard corners through the arm is as closely
aligned with the reprojection through the camera (and any associated
kinematic chain, for instance, a pan/tilt head).</p>

<h3 id="configuration">Configuration</h3>

<p>Configuration is typically handled through two sets of YAML files. The first
YAML file specifies the details needed for data capture:</p>

<ul>
  <li>chains - The kinematic chains of the robot which should be controlled,
and how to control them so that we can move the robot to each desired pose
for sampling.</li>
  <li>features - The configuration for the various “feature finders” that
will be making our observations at each sample pose. Current finders include
an LED detector, checkerboard finder, and plane finder. Feature finders
are plugin-based, so you can create your own.</li>
</ul>

<p>The second configuration file specifies the configuration for optimization.
This specifies several items:</p>

<ul>
  <li>base_link - Frame used for internal calculations. Typically, the root of the
URDF is used. Often <code class="language-plaintext highlighter-rouge">base_link</code>.</li>
  <li>calibration_steps - In ROS2, multistep calibration is fully supported. The
parameter “calibration_steps” should be a list of step names. A majority of
calibrations probably only use a single step, but the step name must still
be in a YAML list format.</li>
</ul>

<p>For each calibration step, there are several parameters:</p>

<ul>
  <li>models - Models define how to reproject points. The basic model is a
kinematic chain. Additional models can reproject through a kinematic
chain and then a sensor, such as a 3d camera. For IK chains, <code class="language-plaintext highlighter-rouge">frame</code> parameter
is the tip of the IK chain. The “models” parameter is a list of model names.</li>
  <li>free_params - Defines the names of single-value free parameters. These
can be the names of a joint for which the joint offset should be calculated,
camera parameters such as focal lengths or the driver offsets for
Primesense devices. If attempting to calibrate the length of a robot
link, use <code class="language-plaintext highlighter-rouge">free_frames</code> to define the axis that is being calibrated.</li>
  <li>free_frames - Defines the names of multi-valued free parameters that
are 6-d transforms. Also defines which axis are free. X, Y, and Z can all
be independently set to free parameters. Roll, pitch and yaw can also be
set free, however it is important to note that because calibration
internally uses an angle-axis representation, either all 3 should be set
free, or only one should be free. You should never set two out of three
to be free parameters.</li>
  <li>free_frames_initial_values - Defines the initial values for free_frames.
X, Y, Z offsets are in meters. ROLL, PITCH, YAW are in radians. This is most
frequently used for setting the initial estimate of the checkerboard position,
see details below.</li>
  <li>error_blocks - List of error block names, which are then defined under their
own namespaces.</li>
</ul>

<p>For each model, the type must be specified. The type should be one of:</p>

<ul>
  <li>chain3d - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter (which in MoveIt/KDL terms is usually referred to as the <code class="language-plaintext highlighter-rouge">tip</code>).</li>
  <li>camera3d - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter, and includes the pinhole camera model parameters (cx, cy, fx, fy)
when doing projection of the points. This model only works if your sensor
publishes CameraInfo. Further, the calibration obtained when this model is
used and any of the pinhole parameters are free parameters is only valid if
the physical sensor actually uses the CameraInfo for 3d projection (this
is generally true for the Primesense/Astra sensors).</li>
</ul>

<p>For each error block, the type must be specified. The type should be one of:</p>

<ul>
  <li>chain3d_to_chain3d - This error block can compute the difference in
reprojection between two 3D “sensors” which tell us the position of
certain features of interest. Sensors might be a 3D camera or an arm
which is holding a checkerboard. Was previously called “camera3d_to_arm”.</li>
  <li>chain3d_to_mesh - This error block can compute the closeness between
projected 3d points and a mesh. The mesh must be part of the robot body.
This is commonly used to align the robot sensor with the base of the robot.</li>
  <li>chain3d_to_plane - This error block can compute the difference between
projected 3d points and a desired plane. The most common use case is making
sure that the ground plane a robot sees is really on the ground.</li>
  <li>plane_to_plane - This error block is able to compute the difference
between two planes. For instance, 3d cameras may not have the resolution
to actually see a checkerboard, but we can align important axis by
making sure that a wall seen by both cameras is aligned.</li>
  <li>outrageous - Sometimes, the calibration is ill-defined in certain dimensions,
and we would like to avoid one of the free parameters from becoming
absurd. An outrageous error block can be used to limit a particular
parameter.</li>
</ul>

<h4 id="checkerboard-configuration">Checkerboard Configuration</h4>

<p>When using a checkerboard, we need to estimate the transformation from the
the kinematic chain to the checkerboard. Calibration will be faster and more
accurate if the initial estimate of this transformation is close to the actual
value, especially with regards to rotation.</p>

<p>The simplest way to check your initial estimate is to run the calibration with
only the six DOF of the checkerboard as free parameters. The output values will
be the X, Y, Z, and A, B, C of the transformation. It is important to note that
A, B, C are NOT roll, pitch, yaw – they are the axis-magnitude representation.
To get roll, pitch and yaw, run the <code class="language-plaintext highlighter-rouge">to_rpy</code> tool with your values of A, B,
and C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration to_rpy A B C

</code></pre></div></div>
<p>This will print the ROLL, PITCH, YAW values to put in for initial values. Then
insert the values in the calibration.yaml:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">free_frames_initial_values</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">checkerboard</span>
<span class="na">checkerboard_initial_values</span><span class="pi">:</span>
  <span class="na">x</span><span class="pi">:</span> <span class="m">0.0</span>
  <span class="na">y</span><span class="pi">:</span> <span class="m">0.225</span>
  <span class="na">z</span><span class="pi">:</span> <span class="m">0</span>
  <span class="na">roll</span><span class="pi">:</span> <span class="m">0.0</span>
  <span class="na">pitch</span><span class="pi">:</span> <span class="m">1.571</span>
  <span class="na">yaw</span><span class="pi">:</span> <span class="m">0.0</span>

</code></pre></div></div>

<p><a href="https://markhedleyjones.com/projects/calibration-checkerboard-collection">This tool</a>
can be helfpul for creating checkerboards.</p>

<h4 id="migrating-from-ros1">Migrating from ROS1</h4>

<p>There are a number of changes in migrating from ROS1 to ROS2. Some of these are
due to differences in the ROS2 system, others are to finally cleanup mistakes
made in earlier version of robot_calibration.</p>

<p>The <code class="language-plaintext highlighter-rouge">chains</code>, <code class="language-plaintext highlighter-rouge">models</code>, <code class="language-plaintext highlighter-rouge">free_frames</code> and <code class="language-plaintext highlighter-rouge">features</code> parameters used to be lists of YAML
dictionaries. That format is not easily supported in ROS2 and so they are now
lists of string names and the actual dictionaries of information appear under
the associated name. For instance, in ROS1, you might have:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">models</span><span class="pi">:</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">arm</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">chain</span>
   <span class="na">frame</span><span class="pi">:</span> <span class="s">wrist_roll_link</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">camera</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">camera3d</span>
   <span class="na">frame</span><span class="pi">:</span> <span class="s">head_camera_rgb_optical_frame</span>

</code></pre></div></div>

<p>In ROS2, this becomes:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">models</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">arm</span>
<span class="pi">-</span> <span class="s">camera</span>
<span class="na">arm</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">chain3d</span>
  <span class="na">frame</span><span class="pi">:</span> <span class="s">wrist_roll_link</span>
<span class="na">camera</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">camera3d</span>
  <span class="na">frame</span><span class="pi">:</span> <span class="s">head_camera_rgb_optical_frame</span>

</code></pre></div></div>

<p>NOTE: the “chain” type has been renamed “chain3d” in ROS2 for consistency (and to allow
a future chain2d).</p>

<p>Multi-step calibration is now fully supported. A new parameter, <code class="language-plaintext highlighter-rouge">calibration_steps</code> must
be declared as a list of step names. The <code class="language-plaintext highlighter-rouge">models</code> and free parameters are then specified
for each step. As an example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">calibration_steps</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">first_calibration_step</span>
<span class="pi">-</span> <span class="s">second_calibration_step</span>
<span class="na">first_calibration_step</span><span class="pi">:</span>
  <span class="na">models</span><span class="pi">:</span> <span class="s">...</span>
  <span class="na">free_params</span><span class="pi">:</span> <span class="s">...</span>
<span class="na">second_calibration_step</span><span class="pi">:</span>
  <span class="na">models</span><span class="pi">:</span> <span class="s">...</span>
  <span class="na">free_params</span><span class="pi">:</span> <span class="s">...</span>

</code></pre></div></div>

<p>The capture poses can now be specified as YAML. The <code class="language-plaintext highlighter-rouge">convert_ros1_bag_to_yaml</code> script
can be run in ROS1 to export your ROS1 bagfile as a YAML file that can be loaded in ROS2.</p>

<h4 id="example-configuration">Example Configuration</h4>

<p>The UBR-1 robot uses this package to calibrate in ROS2. Start with the <code class="language-plaintext highlighter-rouge">calibrate_launch.py</code>
in <a href="https://github.com/mikeferguson/ubr_reloaded/tree/ros2/ubr1_calibration">ubr1_calibration</a>
package.</p>

<h3 id="exported-results">Exported Results</h3>

<p>The exported results consist of an updated URDF file, and one or more updated
camera calibration YAML files. By default, these files will by exported into
the /tmp folder, with filenames that include a timestamp of generation. These
files need to be installed in the correct places to be properly loaded.</p>

<p>The <a href="https://github.com/fetchrobotics/fetch_ros/tree/indigo-devel/fetch_calibration">fetch_calibration</a>
package has an example python script for installing the updated files.</p>

<p>Within the updated URDF file, there are two types of exported results:</p>

<ul>
  <li>Changes to free_frames are applied as offsets in the joint origins.</li>
  <li>Changes to free_params (joint offsets) are applied as “calibration” tags
in the URDF. In particular, they are applied as “rising” tags. These
should be read by the robot drivers so that the offsets can be applied
before joint values are used for controllers. The offsets need to be added
to the joint position read from the device. The offset then typically
needs to be subtracted from the commanded position sent to the device.</li>
</ul>

<p>If your robot does not support the “calibration” tags, it might be possible
to use only free_frames, setting only the rotation in the joint axis to be
free.</p>

<h2 id="the-base_calibration_node">The <em>base_calibration_node</em>
</h2>

<p>To run the <em>base_calibration_node</em> node, you need a somewhat open space with a large
(~3 meters wide) wall that you can point the robot at. The robot should be
pointed at the wall and it will then spin around at several different speeds.
On each rotation it will stop and capture the laser data. Afterwards, the
node uses the angle of the wall as measured by the laser scanner to determine
how far the robot has actually rotated versus the measurements from the gyro
and odometry. We then compute scalar corrections for both the gyro and the
odometry.</p>

<p>Node parameters:</p>

<ul>
  <li>
<code>/base_controller/track_width</code> - this is the default track width.</li>
  <li>
<code>/imu/gyro/scale</code> - this is the initial gyro scale.</li>
  <li>
<code>~min_angle/~max_angle</code> how much of the laser scan to use when
measuring the wall angle (radians).</li>
  <li>
<code>~accel_limit</code> - acceleration limit for rotation (radians/second^2).</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/odom</code> - the node subscribes to this odom data. Message type
is <code>nav_msgs/Odometry</code>.</li>
  <li>
<code>/imu</code> - the node subscribes to this IMU data. Message type
is <code>sensor_msgs/IMU</code>.</li>
  <li>
<code>/base_scan</code> - the node subscribes to this laser data. Message type
is <code>sensor_msgs/LaserScan</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the node is a new scale for the gyro and the odometry. The application
of these values is largely dependent on the drivers being used for the robot. For
robots using <em>ros_control</em> or <em>robot_control</em> there is a track_width parameter
typically supplied as a ROS parameter in your launch file.</p>

<h2 id="the-magnetometer_calibration-node">The <em>magnetometer_calibration</em> node</h2>

<p>The <em>magnetometer_calibration</em> node records magnetometer data and can compute
the <em>hard iron</em> offsets. After calibration, the magnetometer can be used as
a compass (typically by piping the data through <em>imu_filter_madgwick</em> and
then <em>robot_localization</em>).</p>

<p>Node parameters:</p>

<ul>
  <li>
<code>~rotation_manual</code> - if set to true, the node will not publish command
velocities and the user will have to manually rotate the magnetometer. Default: false.</li>
  <li>
<code>~rotation_duration</code> - how long to rotate the robot, in seconds.</li>
  <li>
<code>~rotation_velocity</code> - the yaw velocity to rotate the robot, in rad/s.</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/imu/mag</code> - the node subscribes to this magnetometer data. Message type
is <code>sensor_msgs/MagneticField</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the calibration is three parameters, <em>mag_bias_x</em>, <em>mag_bias_y</em>,
and <em>mag_bias_z</em>, which can be used with the <code>imu_filter_madgwick</code> package.</p>

</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-jazzy">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/robot_calibration">robot_calibration</a> <small>repository</small></h3>
        <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration">robot_calibration</a>
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration_msgs">robot_calibration_msgs</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-mikeferguson-robot_calibration
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-mikeferguson-robot_calibration" role="menuitem" tabindex="-1" href="/r/robot_calibration/github-mikeferguson-robot_calibration" data="github-mikeferguson-robot_calibration">
                    <span class="glyphicon glyphicon-star"></span>
                    github-mikeferguson-robot_calibration
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Generic calibration for robots</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/mikeferguson/robot_calibration.git">https://github.com/mikeferguson/robot_calibration.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">ros2</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-03-17
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/robot_calibration/#jazzy-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#jazzy-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#jazzy-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/robot_calibration">robot_calibration</a></td>
                    <td>0.10.0</td>
                  </tr>
                
                  <tr>
                    <td><a href="/p/robot_calibration_msgs">robot_calibration_msgs</a></td>
                    <td>0.10.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="robot-calibration">Robot Calibration</h1>

<p>This package offers several ROS2 nodes. The primary one is called <em>calibrate</em>,
and can be used to calibrate a number of parameters of a robot, such as:</p>

<ul>
  <li>3D Camera intrinsics and extrinsics</li>
  <li>Joint angle offsets</li>
  <li>Robot frame offsets</li>
</ul>

<p>These parameters are then inserted into an updated URDF, or updated camera
configuration YAML in the case of camera intrinsics.</p>

<p>Two additional ROS nodes are used for mobile-base related parameter tuning:</p>

<ul>
  <li>
<em>base_calibration_node</em> - can determine scaling factors for wheel diameter,
track width and gyro gain by moving and rotating the robot while tracking
the actual movement based on the laser scanner view of a wall.</li>
  <li>
<em>magnetometer_calibration</em> - can be used to do hard iron calibration
of a magnetometer.</li>
</ul>

<h2 id="the-calibrate-node">The <em>calibrate</em> node</h2>

<p>Calibration works in two steps. The first step involves the capture of data
samples from the robot. Each “sample” comprises the measured joint positions
of the robot and two or more “observations”. An observation is a collection
of points that have been detected by a “sensor”. For instance, a robot could
use a camera and an arm to “detect” the pose of corners on a checkerboard.
In the case of the camera sensor, the collection of points is simply the
detected positions of each corner of the checkerboard, relative to the pose
of the camera reference frame. For the arm, it is assumed that the checkerboard
is fixed relative to a virtual <code class="language-plaintext highlighter-rouge">checkerboard</code> frame which is fixed relative
to the end effector of the arm. Within the virtual frame, we know the ideal
position of each point of the checkerboard corners since the checkerboard
is of known size.</p>

<p>The second step of calibration involves optimization of the robot parameters
to minimize the errors. Errors are defined as the difference in the pose
of the points based on reprojection throuhg each sensor. In the case of our
checkerboard above, the transform between the virtual frame and the end
effector becomes additional free parameters. By estimating these parameters
alongside the robot parameters, we can find a set of parameters such that
the reprojection of the checkerboard corners through the arm is as closely
aligned with the reprojection through the camera (and any associated
kinematic chain, for instance, a pan/tilt head).</p>

<p>Configuration is typically handled through two sets of YAML files: usually
called <code class="language-plaintext highlighter-rouge">capture.yaml</code> and <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</p>

<p>If you want to manually move the robot to poses and capture each time you
hit ENTER on the keyboard, you can run robot calibration with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration calibrate --manual --ros-args --params-file path-to-capture.yaml --params-file path-to-calibrate.yaml

</code></pre></div></div>

<p>More commonly, you will generate a third YAML file with the capture pose
configuration (as documented below in the section “Calibration Poses”):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration calibrate path-to-calibration-poses.yaml --ros-args --params-file path-to-capture.yaml --params-file path-to-calibrate.yaml

</code></pre></div></div>

<p>This is often wrapped into a ROS 2 launch file, which often records
a bagfile of the observations allowing to re-run just the calibration part
instead of needing to run capture each time. For an example, see the
UBR-1 example in the next section.</p>

<h3 id="example-configuration">Example Configuration</h3>

<p>All of the parameters that can be defined in the capture and calibrate steps
are documented below, but sometimes it is just nice to have a full example.
The UBR-1 robot uses this package to calibrate in ROS2. Start with
the <code class="language-plaintext highlighter-rouge">calibrate_launch.py</code> in
<a href="https://github.com/mikeferguson/ubr_reloaded/tree/ros2/ubr1_calibration">ubr1_calibration</a>.</p>

<h3 id="capture-configuration">Capture Configuration</h3>

<p>The <code class="language-plaintext highlighter-rouge">capture.yaml</code> file specifies the details needed for data capture:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chains</code> - A parameter listing the names of the kinematic chains of the
robot which should be controlled.</li>
  <li>
<code class="language-plaintext highlighter-rouge">features</code> - A parameter listing the names of the various “feature finders”
that will be making our observations at each sample pose.</li>
</ul>

<p>Each of these chains and features is then defined by a parameter block of the
same name, for example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">robot_calibration</span><span class="pi">:</span>
  <span class="na">ros_parameters</span><span class="pi">:</span>
    <span class="c1"># List of chains</span>
    <span class="na">chains</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">arm</span>
    <span class="c1"># List of features</span>
    <span class="na">features</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">checkerboard_finder</span>
    <span class="c1"># Parameter block to define the arm chain</span>
    <span class="na">arm</span><span class="pi">:</span>
      <span class="na">topic</span><span class="pi">:</span> <span class="s">/arm_controller/follow_joint_trajectory</span>
      <span class="na">joints</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">first_joint</span>
      <span class="pi">-</span> <span class="s">second_joint</span>
    <span class="c1"># Parameter block to define the feature finder:</span>
    <span class="na">checkerboard_finder</span><span class="pi">:</span>
      <span class="na">type</span><span class="pi">:</span> <span class="s">robot_calibration::CheckerboardFinder</span>
      <span class="na">topic</span><span class="pi">:</span> <span class="s">/head_camera/depth_registered/points</span>
      <span class="na">camera_sensor_name</span><span class="pi">:</span> <span class="s">camera</span>
      <span class="na">chain_sensor_name</span><span class="pi">:</span> <span class="s">arm</span>

</code></pre></div></div>

<h4 id="chain-parameters">Chain Parameters</h4>

<p>For each chain, the following parameters can be defined:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">topic</code> - The namespace of the <code class="language-plaintext highlighter-rouge">control_msgs::FollowJointTrajectory</code>
server used to control this chain.</li>
  <li>
<code class="language-plaintext highlighter-rouge">planning_group</code> - Optional parameter, when set to a non-empty string
<code class="language-plaintext highlighter-rouge">robot_calibration</code> will call MoveIt to plan a collision free path from
the current robot pose to the next capture pose. When this parameter is
not set, the trajectory simply interpolates from the current pose to the
next capture pose without collision awareness - so you need to be careful
when defining your series of capture poses.</li>
  <li>
<code class="language-plaintext highlighter-rouge">joints</code> - A list of joints that this group comprises.</li>
</ul>

<h4 id="finder-parameters">Finder Parameters</h4>

<p>At a minimum, the following parameters must be set for all finders:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">type</code> - Name of the plugin to load.</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera_sensor_name</code> - Every finder outputs observations from some
sensor - this name must match the name used later in <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">chain_sensor_name</code> - Every finder outputs observations from some
chain - this name must match the name used later in <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">debug</code> - Most finders have a debug parameter which will insert the
raw image or point cloud into the observation. This makes the capture
bagfile larger but aids in debugging.</li>
</ul>

<p>The following types are currently included with <code class="language-plaintext highlighter-rouge">robot_calibration</code>
although you can create your own plugins. Each finder has it’s own
additional parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::CheckerboardFinder</code> - Detects checkerboards in
a point cloud.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_x</code> - Number of corners in the X direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_y</code> - Number of corners in the Y direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">size</code> - Size of checkerboard squares, in meters.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::CheckerboardFinder2d</code> - Detects checkerboards in
an image:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::Image</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_x</code> - Number of corners in the X direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_y</code> - Number of corners in the Y direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">size</code> - Size of checkerboard squares, in meters.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::LedFinder</code> - controls and detects a series of LEDs,
which can be a built-in alternative to having a robot hold the checkerboard.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">gripper_led_action</code> - Namespace of the gripper LED action server.</li>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_error</code> - Maximum distance detected LED can be from expected pose,
in meters.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_inconsistency</code> - Maximum relative difference between two LEDs in
the same capture pose, in meters.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_iterations</code> - Maximum number of times to toggle the LEDs for a given
capture pose.</li>
      <li>
<code class="language-plaintext highlighter-rouge">gripper_led_frame</code> - The robot link which the <code class="language-plaintext highlighter-rouge">leds</code> are defined in.</li>
      <li>
<code class="language-plaintext highlighter-rouge">leds</code> - Definition of the LED poses. For each LED, you need to specify
a <code class="language-plaintext highlighter-rouge">code</code> which is sent to the action server to turn that LED on, as well
as <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, and <code class="language-plaintext highlighter-rouge">z</code> offsets relative to <code class="language-plaintext highlighter-rouge">gripper_led_frame</code> for
the expected pose of that LED. These values will be used to generate
the chain observation.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::PlaneFinder</code> - Detects planes in a point cloud. This
will filter out points outside the limits, and then iteratively find the
largest plane until a desired one is found. This is commonly used to align
a sensor with the ground.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_max</code> - Maximum number of points to use in the observation</li>
      <li>The cloud can be pre-filtered using the <code class="language-plaintext highlighter-rouge">min_x</code>, <code class="language-plaintext highlighter-rouge">max_x</code>, <code class="language-plaintext highlighter-rouge">min_y</code>,
<code class="language-plaintext highlighter-rouge">max_y</code>, <code class="language-plaintext highlighter-rouge">min_z</code>, and <code class="language-plaintext highlighter-rouge">max_z</code> parameters.</li>
      <li>The desired orientation of the plane can be used by setting <code class="language-plaintext highlighter-rouge">normal_a</code>,
<code class="language-plaintext highlighter-rouge">normal_b</code>, <code class="language-plaintext highlighter-rouge">normal_c</code> parameters - if all are 0, the biggest plane
will be selected regardless of orientation. This is particularly useful
if the robot might be looking partially at the wall as well as the desired
floor surface.</li>
      <li>
<code class="language-plaintext highlighter-rouge">normal_angle</code> - If a desired orientation vector is set, the candidate
plane normal must be within this angle of the desired normal, in radians.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::ScanFinder</code> - Detects points in a laser scan, and then
repeats them vertically. This can be used to align a laser scanner against
a plane detected by a 3d camera.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::LaserScan</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">transform_frame</code> – Frame to transform the laser scan into, usually
<code class="language-plaintext highlighter-rouge">base_link</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">min_x</code>, <code class="language-plaintext highlighter-rouge">max_x</code>, <code class="language-plaintext highlighter-rouge">min_y</code>, and <code class="language-plaintext highlighter-rouge">max_y</code> are used to limit the
laser scan points that are used. They are defined in the <code class="language-plaintext highlighter-rouge">transform_frame</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">z_repeats</code> - How many times to copy the points vertically.</li>
      <li>
<code class="language-plaintext highlighter-rouge">z_offset</code> - Distance between repeated points.</li>
    </ul>
  </li>
</ul>

<p>Additionally, any finder that subscribes to a depth camera has the following parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">camera_info_topic</code>: The topic name for the camera info.</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera_driver</code>: Namespace of the camera driver, only used for Primesense-like
devices which have <code class="language-plaintext highlighter-rouge">z_offset_mm</code> and <code class="language-plaintext highlighter-rouge">z_scaling</code> parameters.</li>
</ul>

<h3 id="calibration-configuration">Calibration Configuration</h3>

<p>The <code class="language-plaintext highlighter-rouge">calibrate.yaml</code> configuration file specifies the configuration for
optimization. This specifies several items:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">base_link</code> - Frame used for internal calculations. Typically, the root of the
URDF is used. Often <code class="language-plaintext highlighter-rouge">base_link</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">calibration_steps</code> - In ROS 2, multistep calibration is fully supported. The
parameter <code class="language-plaintext highlighter-rouge">calibration_steps</code> should be a list of step names. A majority of
calibrations probably only use a single step, but the step name must still
be in a YAML list format.</li>
</ul>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">robot_calibration</span><span class="pi">:</span>
  <span class="na">ros__parameters</span><span class="pi">:</span>
    <span class="na">base_link</span><span class="pi">:</span> <span class="s">torso_lift_link</span>
    <span class="na">calibration_steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">single_calibration_step</span>
    <span class="na">single_calibration_step</span><span class="pi">:</span>
      <span class="na">models</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">first_model</span>
      <span class="na">first_model</span><span class="pi">:</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">first_model_type</span>

</code></pre></div></div>

<p>For each calibration step, there are several parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">models</code> - List of model names. Each model will then be defined in a
parameter block defined by the name. Models define how to reproject
observation points into the fixed frame. The basic model is a
kinematic chain. Additional models can reproject through a kinematic
chain and then a sensor, such as a 3d camera. Once loaded, models
will be used by the error blocks to compute the reprojection errors
between different sensor observations.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_params</code> - Defines the names of single-value free parameters. These
can be the names of a joint for which the joint offset should be calculated,
camera parameters such as focal lengths or the driver offsets for
Primesense devices. If attempting to calibrate the length of a robot
link, use <code class="language-plaintext highlighter-rouge">free_frames</code> to define the axis that is being calibrated.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_frames</code> - Defines the names of multi-valued free parameters that
are 6-d transforms. Also defines which axis are free. X, Y, and Z can all
be independently set to free parameters. Roll, pitch and yaw can also be
set free, however it is important to note that because calibration
internally uses an angle-axis representation, either all 3 should be set
free, or only one should be free. You should never set two out of three
to be free parameters.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_frames_initial_values</code> - Defines the initial offset values for
<code class="language-plaintext highlighter-rouge">free_frames</code>. X, Y, Z offsets are in meters. ROLL, PITCH, YAW are in
radians. This is most frequently used for setting the initial estimate
of the checkerboard position, see details below.</li>
  <li>
<code class="language-plaintext highlighter-rouge">error_blocks</code> - List of error block names, which are then defined
under their own namespaces.</li>
</ul>

<p>For each model, the <code class="language-plaintext highlighter-rouge">type</code> must be specified. The type should be one of:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d</code> - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter (which in MoveIt/KDL terms is usually referred to as the <code class="language-plaintext highlighter-rouge">tip</code>).</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera3d</code> - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter, and includes the pinhole camera model parameters (cx, cy, fx, fy)
when doing projection of the points. This model only works if your sensor
publishes CameraInfo. Further, the calibration obtained when this model is
used and any of the pinhole parameters are free parameters is only valid if
the physical sensor actually uses the CameraInfo for 3d projection (this
is generally true for the Primesense/Astra sensors).</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera2d</code> - Similar to <code class="language-plaintext highlighter-rouge">camera3d</code>, but for a 2d finder. Currently only
works with the output of the <code class="language-plaintext highlighter-rouge">CheckerboardFinder2d</code>.</li>
</ul>

<p>For each error block, the <code class="language-plaintext highlighter-rouge">type</code> must be specified. In addition to the
<code class="language-plaintext highlighter-rouge">type</code> parameter, each block will have additional parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_chain3d</code> - The most commonly used error block type.
This error block can compute the difference in reprojection
between two 3D “sensors” which tell us the position of
certain features of interest. Sensors might be a 3D camera or an arm
which is holding a checkerboard. Was previously called “camera3d_to_arm”:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_a</code> - First <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_b</code> - Second <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_camera2d</code>- Currently only used for the <code class="language-plaintext highlighter-rouge">CheckerboardFinder2d</code>:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_2d</code> - <code class="language-plaintext highlighter-rouge">camera2d</code> model to use in computing reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_3d</code> - <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">scale</code> - Scalar to multiply summed error by - note that error computed
in this block is in <em>pixel</em> space, rather than <em>metric</em> space like most
other error blocks.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_mesh</code> - This error block type can compute the closeness between
projected 3d points and a mesh. The mesh must be part of the robot body.
This is commonly used to align the robot sensor with the base of the robot,
using points that were found by the <code class="language-plaintext highlighter-rouge">RobotFinder</code> plugin:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model</code> - <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing reprojection
error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">link_name</code> -Name of the link in the URDF for which mesh to use.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_plane</code> - This error block can be used to compare projected
points to a plane. Each observation point is reprojected, then the sum
of distance to plane for each point is computed. The most common use case
is making sure that the ground plane a robot sees is really on the ground:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model</code> - The <code class="language-plaintext highlighter-rouge">camera3d</code> model for reprojection.</li>
      <li>
<code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">d</code> - Parameters for the desired plane equation, in the
form <code class="language-plaintext highlighter-rouge">ax + by + cz + d = 0</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">scale</code> - Since the error computed is a distance from the plane over
many points, scaling the error relative to other error blocks is often
required.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">plane_to_plane</code> - This error block is able to compute the difference
between two planes. For instance, 3d cameras may not have the resolution
to actually see a checkerboard, but we can align important axis by
making sure that a wall seen by both cameras is aligned. For each observation,
the points are assumed to form a plane:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_a</code> - First <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_b</code> - Second <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">normal_scale</code> - The normal error is computed as the difference between
the two plane normals and then multiplied by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">offset_scale</code> - The offset error is computed as the distance from
the centroid of the first plane to the second plane and then
multiplied by this scalar.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">outrageous</code> - Sometimes, the calibration is ill-defined in certain dimensions,
and we would like to avoid one of the free parameters from becoming
absurd. An outrageous error block can be used to limit a particular
parameter:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">param</code> - Free parameter to monitor.</li>
      <li>
<code class="language-plaintext highlighter-rouge">joint_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a joint name, multiply the free param value
by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">position_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a free frame, multiply the metric distance
in X, Y, Z by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">rotation_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a free frame, multiply the angular distance
of the free parameter value by this scalar.</li>
    </ul>
  </li>
</ul>

<h3 id="calibration-poses">Calibration Poses</h3>

<p>The final piece of configuration is the actual poses from which the robot should
capture data. This YAML file can be created by running the <code class="language-plaintext highlighter-rouge">capture_poses</code> script.
You will be prompted to move the robot to the desired pose and press ENTER, when
done collecting all of your poses, you can type EXIT.
This will create <code class="language-plaintext highlighter-rouge">calibration_poses.yaml</code> which is an array of capture poses:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-0.09211555123329163</span>
  <span class="pi">-</span> <span class="m">0.013307283632457256</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-1.747204065322876</span>
  <span class="pi">-</span> <span class="s">-0.07186950743198395</span>

</code></pre></div></div>

<p>By default, every finder is used for every capture pose. In some cases, you might
want to specify specific finders by editing the <code class="language-plaintext highlighter-rouge">features</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This sample pose uses only the `ground_plane_finder` feature finder</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">ground_plane_finder</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-0.09211555123329163</span>
  <span class="pi">-</span> <span class="m">0.013307283632457256</span>
<span class="c1"># This sample pose will use all features</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-1.747204065322876</span>
  <span class="pi">-</span> <span class="s">-0.07186950743198395</span>

</code></pre></div></div>

<h4 id="checkerboard-configuration">Checkerboard Configuration</h4>

<p>When using a checkerboard, we need to estimate the transformation from the
the tip of the kinematic chain to the virtual <code class="language-plaintext highlighter-rouge">checkerboard</code> frame.
Calibration will be faster and more accurate if the initial estimate of
this transformation is close to the actual
value, especially with regards to rotation.</p>

<p>The simplest way to check your initial estimate is to run the calibration with
only the six DOF of the checkerboard as free parameters. The output values will
be the X, Y, Z, and A, B, C of the transformation. It is important to note that
A, B, C are NOT roll, pitch, yaw – they are the axis-magnitude representation.
To get roll, pitch and yaw, run the <code class="language-plaintext highlighter-rouge">to_rpy</code> tool with your values of A, B,
and C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration to_rpy A B C

</code></pre></div></div>
<p>This will print the ROLL, PITCH, YAW values to put in for initial values. Then
insert the values in the calibration.yaml:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">free_frames_initial_values</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">checkerboard</span>
<span class="na">checkerboard_initial_values</span><span class="pi">:</span>
  <span class="na">x</span><span class="pi">:</span> <span class="m">0.0</span>
  <span class="na">y</span><span class="pi">:</span> <span class="m">0.225</span>
  <span class="na">z</span><span class="pi">:</span> <span class="m">0</span>
  <span class="na">roll</span><span class="pi">:</span> <span class="m">0.0</span>
  <span class="na">pitch</span><span class="pi">:</span> <span class="m">1.571</span>
  <span class="na">yaw</span><span class="pi">:</span> <span class="m">0.0</span>

</code></pre></div></div>

<p><a href="https://markhedleyjones.com/projects/calibration-checkerboard-collection">This tool</a>
can be helfpul for creating checkerboards.</p>

<h3 id="exported-results">Exported Results</h3>

<p>The exported results consist of an updated URDF file, and one or more updated
camera calibration YAML files. By default, these files will by exported into
the /tmp folder, with filenames that include a timestamp of generation. These
files need to be installed in the correct places to be properly loaded.</p>

<p>The <a href="https://github.com/fetchrobotics/fetch_ros/tree/indigo-devel/fetch_calibration">fetch_calibration</a>
package has an example python script for installing the updated files.</p>

<p>Within the updated URDF file, there are two types of exported results:</p>

<ul>
  <li>Changes to free_frames are applied as offsets in the joint origins.</li>
  <li>Changes to free_params (joint offsets) are applied as “calibration” tags
in the URDF. In particular, they are applied as “rising” tags. These
should be read by the robot drivers so that the offsets can be applied
before joint values are used for controllers. The offsets need to be added
to the joint position read from the device. The offset then typically
needs to be subtracted from the commanded position sent to the device.</li>
</ul>

<p>If your robot does not support the “calibration” tags, it might be possible
to use only free_frames, setting only the rotation in the joint axis to be
free.</p>

<h2 id="the-base_calibration_node">The <em>base_calibration_node</em>
</h2>

<p>To run the <em>base_calibration_node</em> node, you need a somewhat open space with a large
(~3 meters wide) wall that you can point the robot at.</p>

<p>Starting with the <code class="language-plaintext highlighter-rouge">0.10</code> release of <code class="language-plaintext highlighter-rouge">robot_calibration</code>, the actual movements the
robot does can be programmed via the <code class="language-plaintext highlighter-rouge">calibration_steps</code> parameter:</p>

<ul>
  <li>
<code>calibration_steps</code> - should be a list of string names of calibration
steps to run.</li>
  <li>
<code>step_name/type</code> - should be either <code class="language-plaintext highlighter-rouge">spin</code> or <code class="language-plaintext highlighter-rouge">rollout</code>.</li>
  <li>
<code>step_name/velocity</code> - velocity to move the robot. This will be
interpreted as angular velocity for <code class="language-plaintext highlighter-rouge">spin</code> steps and linear velocity for <code class="language-plaintext highlighter-rouge">rollout</code>
steps.</li>
  <li>
<code>step_name/rotations</code> - only valid for <code class="language-plaintext highlighter-rouge">spin</code> steps. Number of
rotations to complete at given <code class="language-plaintext highlighter-rouge">velocity</code>.</li>
  <li>
<code>step_name/distance</code> - only valid for <code class="language-plaintext highlighter-rouge">rollout</code> steps. Distance
in meters, to rollout the robot.</li>
</ul>

<p>Additional parameters:</p>

<ul>
  <li>
<code>accel_limit</code> - acceleration limit for <code class="language-plaintext highlighter-rouge">spin</code> steps (radians/second^2).</li>
  <li>
<code>linear_accel_limit</code> - acceleration limit for <code class="language-plaintext highlighter-rouge">rollout</code> steps (meters/second^2).</li>
  <li>
<code>min_angle/max_angle</code> how much of the laser scan to use when
measuring the wall angle (radians).</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/odom</code> - the node subscribes to this odom data. Message type
is <code>nav_msgs/Odometry</code>.</li>
  <li>
<code>/imu</code> - the node subscribes to this IMU data. Message type
is <code>sensor_msgs/IMU</code>.</li>
  <li>
<code>/base_scan</code> - the node subscribes to this laser data. Message type
is <code>sensor_msgs/LaserScan</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the node is a series of scalars to apply (where a value of 1.0 means
there is currently no error):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[base_calibration_node-1] track_width_scale: 0.986743
[base_calibration_node-1] imu_scale: 0.984465
[base_calibration_node-1] rollout_scale: 0.981911

</code></pre></div></div>

<p>The application of these values is largely dependent on the drivers being used
for the robot. For robots using <em>ros_control</em> or <em>robot_control</em> there is a
<code class="language-plaintext highlighter-rouge">track_width</code> parameter typically supplied as a ROS parameter in your launch file.</p>

<p>Note: in ROS 1, these scalars were pre-multiplied by the existing <code class="language-plaintext highlighter-rouge">track_width</code>
or <code class="language-plaintext highlighter-rouge">imu_scale</code> - however, with the lack of a unified parameter server in ROS 2,
this is no longer done.</p>

<h2 id="the-magnetometer_calibration-node">The <em>magnetometer_calibration</em> node</h2>

<p>The <em>magnetometer_calibration</em> node records magnetometer data and can compute
the <em>hard iron</em> offsets. After calibration, the magnetometer can be used as
a compass (typically by piping the data through <em>imu_filter_madgwick</em> and
then <em>robot_localization</em>).</p>

<p>Node parameters:</p>

<ul>
  <li>
<code>~rotation_manual</code> - if set to true, the node will not publish command
velocities and the user will have to manually rotate the magnetometer. Default: false.</li>
  <li>
<code>~rotation_duration</code> - how long to rotate the robot, in seconds.</li>
  <li>
<code>~rotation_velocity</code> - the yaw velocity to rotate the robot, in rad/s.</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/imu/mag</code> - the node subscribes to this magnetometer data. Message type
is <code>sensor_msgs/MagneticField</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the calibration is three parameters, <em>mag_bias_x</em>, <em>mag_bias_y</em>,
and <em>mag_bias_z</em>, which can be used with the <code>imu_filter_madgwick</code> package.</p>

<h3 id="migrating-from-ros1">Migrating from ROS1</h3>

<p>There are a number of changes in migrating from ROS1 to ROS2. Some of these are
due to differences in the ROS2 system, others are to finally cleanup mistakes
made in earlier version of robot_calibration.</p>

<p>The <code class="language-plaintext highlighter-rouge">chains</code>, <code class="language-plaintext highlighter-rouge">models</code>, <code class="language-plaintext highlighter-rouge">free_frames</code> and <code class="language-plaintext highlighter-rouge">features</code> parameters used to be lists of YAML
dictionaries. That format is not easily supported in ROS2 and so they are now
lists of string names and the actual dictionaries of information appear under
the associated name. For instance, in ROS1, you might have:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">models</span><span class="pi">:</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">arm</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">chain</span>
   <span class="na">frame</span><span class="pi">:</span> <span class="s">wrist_roll_link</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">camera</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">camera3d</span>
   <span class="na">frame</span><span class="pi">:</span> <span class="s">head_camera_rgb_optical_frame</span>

</code></pre></div></div>

<p>In ROS2, this becomes:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">models</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">arm</span>
<span class="pi">-</span> <span class="s">camera</span>
<span class="na">arm</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">chain3d</span>
  <span class="na">frame</span><span class="pi">:</span> <span class="s">wrist_roll_link</span>
<span class="na">camera</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">camera3d</span>
  <span class="na">frame</span><span class="pi">:</span> <span class="s">head_camera_rgb_optical_frame</span>

</code></pre></div></div>

<p>NOTE: the “chain” type has been renamed “chain3d” in ROS2 for consistency (and to allow
a future chain2d).</p>

<p>Multi-step calibration is now fully supported. A new parameter, <code class="language-plaintext highlighter-rouge">calibration_steps</code> must
be declared as a list of step names. The <code class="language-plaintext highlighter-rouge">models</code> and free parameters are then specified
for each step. As an example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">calibration_steps</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">first_calibration_step</span>
<span class="pi">-</span> <span class="s">second_calibration_step</span>
<span class="na">first_calibration_step</span><span class="pi">:</span>
  <span class="na">models</span><span class="pi">:</span> <span class="s">...</span>
  <span class="na">free_params</span><span class="pi">:</span> <span class="s">...</span>
<span class="na">second_calibration_step</span><span class="pi">:</span>
  <span class="na">models</span><span class="pi">:</span> <span class="s">...</span>
  <span class="na">free_params</span><span class="pi">:</span> <span class="s">...</span>

</code></pre></div></div>

<p>The capture poses can now be specified as YAML. The <code class="language-plaintext highlighter-rouge">convert_ros1_bag_to_yaml</code> script
can be run in ROS1 to export your ROS1 bagfile as a YAML file that can be loaded in ROS2.</p>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-kilted">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/robot_calibration">robot_calibration</a> <small>repository</small></h3>
        <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration">robot_calibration</a>
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration_msgs">robot_calibration_msgs</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-mikeferguson-robot_calibration
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-mikeferguson-robot_calibration" role="menuitem" tabindex="-1" href="/r/robot_calibration/github-mikeferguson-robot_calibration" data="github-mikeferguson-robot_calibration">
                    <span class="glyphicon glyphicon-star"></span>
                    github-mikeferguson-robot_calibration
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Generic calibration for robots</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/mikeferguson/robot_calibration.git">https://github.com/mikeferguson/robot_calibration.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">ros2</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-03-17
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/robot_calibration/#kilted-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#kilted-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#kilted-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/robot_calibration">robot_calibration</a></td>
                    <td>0.10.0</td>
                  </tr>
                
                  <tr>
                    <td><a href="/p/robot_calibration_msgs">robot_calibration_msgs</a></td>
                    <td>0.10.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="robot-calibration">Robot Calibration</h1>

<p>This package offers several ROS2 nodes. The primary one is called <em>calibrate</em>,
and can be used to calibrate a number of parameters of a robot, such as:</p>

<ul>
  <li>3D Camera intrinsics and extrinsics</li>
  <li>Joint angle offsets</li>
  <li>Robot frame offsets</li>
</ul>

<p>These parameters are then inserted into an updated URDF, or updated camera
configuration YAML in the case of camera intrinsics.</p>

<p>Two additional ROS nodes are used for mobile-base related parameter tuning:</p>

<ul>
  <li>
<em>base_calibration_node</em> - can determine scaling factors for wheel diameter,
track width and gyro gain by moving and rotating the robot while tracking
the actual movement based on the laser scanner view of a wall.</li>
  <li>
<em>magnetometer_calibration</em> - can be used to do hard iron calibration
of a magnetometer.</li>
</ul>

<h2 id="the-calibrate-node">The <em>calibrate</em> node</h2>

<p>Calibration works in two steps. The first step involves the capture of data
samples from the robot. Each “sample” comprises the measured joint positions
of the robot and two or more “observations”. An observation is a collection
of points that have been detected by a “sensor”. For instance, a robot could
use a camera and an arm to “detect” the pose of corners on a checkerboard.
In the case of the camera sensor, the collection of points is simply the
detected positions of each corner of the checkerboard, relative to the pose
of the camera reference frame. For the arm, it is assumed that the checkerboard
is fixed relative to a virtual <code class="language-plaintext highlighter-rouge">checkerboard</code> frame which is fixed relative
to the end effector of the arm. Within the virtual frame, we know the ideal
position of each point of the checkerboard corners since the checkerboard
is of known size.</p>

<p>The second step of calibration involves optimization of the robot parameters
to minimize the errors. Errors are defined as the difference in the pose
of the points based on reprojection throuhg each sensor. In the case of our
checkerboard above, the transform between the virtual frame and the end
effector becomes additional free parameters. By estimating these parameters
alongside the robot parameters, we can find a set of parameters such that
the reprojection of the checkerboard corners through the arm is as closely
aligned with the reprojection through the camera (and any associated
kinematic chain, for instance, a pan/tilt head).</p>

<p>Configuration is typically handled through two sets of YAML files: usually
called <code class="language-plaintext highlighter-rouge">capture.yaml</code> and <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</p>

<p>If you want to manually move the robot to poses and capture each time you
hit ENTER on the keyboard, you can run robot calibration with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration calibrate --manual --ros-args --params-file path-to-capture.yaml --params-file path-to-calibrate.yaml

</code></pre></div></div>

<p>More commonly, you will generate a third YAML file with the capture pose
configuration (as documented below in the section “Calibration Poses”):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration calibrate path-to-calibration-poses.yaml --ros-args --params-file path-to-capture.yaml --params-file path-to-calibrate.yaml

</code></pre></div></div>

<p>This is often wrapped into a ROS 2 launch file, which often records
a bagfile of the observations allowing to re-run just the calibration part
instead of needing to run capture each time. For an example, see the
UBR-1 example in the next section.</p>

<h3 id="example-configuration">Example Configuration</h3>

<p>All of the parameters that can be defined in the capture and calibrate steps
are documented below, but sometimes it is just nice to have a full example.
The UBR-1 robot uses this package to calibrate in ROS2. Start with
the <code class="language-plaintext highlighter-rouge">calibrate_launch.py</code> in
<a href="https://github.com/mikeferguson/ubr_reloaded/tree/ros2/ubr1_calibration">ubr1_calibration</a>.</p>

<h3 id="capture-configuration">Capture Configuration</h3>

<p>The <code class="language-plaintext highlighter-rouge">capture.yaml</code> file specifies the details needed for data capture:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chains</code> - A parameter listing the names of the kinematic chains of the
robot which should be controlled.</li>
  <li>
<code class="language-plaintext highlighter-rouge">features</code> - A parameter listing the names of the various “feature finders”
that will be making our observations at each sample pose.</li>
</ul>

<p>Each of these chains and features is then defined by a parameter block of the
same name, for example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">robot_calibration</span><span class="pi">:</span>
  <span class="na">ros_parameters</span><span class="pi">:</span>
    <span class="c1"># List of chains</span>
    <span class="na">chains</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">arm</span>
    <span class="c1"># List of features</span>
    <span class="na">features</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">checkerboard_finder</span>
    <span class="c1"># Parameter block to define the arm chain</span>
    <span class="na">arm</span><span class="pi">:</span>
      <span class="na">topic</span><span class="pi">:</span> <span class="s">/arm_controller/follow_joint_trajectory</span>
      <span class="na">joints</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">first_joint</span>
      <span class="pi">-</span> <span class="s">second_joint</span>
    <span class="c1"># Parameter block to define the feature finder:</span>
    <span class="na">checkerboard_finder</span><span class="pi">:</span>
      <span class="na">type</span><span class="pi">:</span> <span class="s">robot_calibration::CheckerboardFinder</span>
      <span class="na">topic</span><span class="pi">:</span> <span class="s">/head_camera/depth_registered/points</span>
      <span class="na">camera_sensor_name</span><span class="pi">:</span> <span class="s">camera</span>
      <span class="na">chain_sensor_name</span><span class="pi">:</span> <span class="s">arm</span>

</code></pre></div></div>

<h4 id="chain-parameters">Chain Parameters</h4>

<p>For each chain, the following parameters can be defined:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">topic</code> - The namespace of the <code class="language-plaintext highlighter-rouge">control_msgs::FollowJointTrajectory</code>
server used to control this chain.</li>
  <li>
<code class="language-plaintext highlighter-rouge">planning_group</code> - Optional parameter, when set to a non-empty string
<code class="language-plaintext highlighter-rouge">robot_calibration</code> will call MoveIt to plan a collision free path from
the current robot pose to the next capture pose. When this parameter is
not set, the trajectory simply interpolates from the current pose to the
next capture pose without collision awareness - so you need to be careful
when defining your series of capture poses.</li>
  <li>
<code class="language-plaintext highlighter-rouge">joints</code> - A list of joints that this group comprises.</li>
</ul>

<h4 id="finder-parameters">Finder Parameters</h4>

<p>At a minimum, the following parameters must be set for all finders:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">type</code> - Name of the plugin to load.</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera_sensor_name</code> - Every finder outputs observations from some
sensor - this name must match the name used later in <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">chain_sensor_name</code> - Every finder outputs observations from some
chain - this name must match the name used later in <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">debug</code> - Most finders have a debug parameter which will insert the
raw image or point cloud into the observation. This makes the capture
bagfile larger but aids in debugging.</li>
</ul>

<p>The following types are currently included with <code class="language-plaintext highlighter-rouge">robot_calibration</code>
although you can create your own plugins. Each finder has it’s own
additional parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::CheckerboardFinder</code> - Detects checkerboards in
a point cloud.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_x</code> - Number of corners in the X direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_y</code> - Number of corners in the Y direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">size</code> - Size of checkerboard squares, in meters.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::CheckerboardFinder2d</code> - Detects checkerboards in
an image:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::Image</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_x</code> - Number of corners in the X direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_y</code> - Number of corners in the Y direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">size</code> - Size of checkerboard squares, in meters.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::LedFinder</code> - controls and detects a series of LEDs,
which can be a built-in alternative to having a robot hold the checkerboard.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">gripper_led_action</code> - Namespace of the gripper LED action server.</li>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_error</code> - Maximum distance detected LED can be from expected pose,
in meters.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_inconsistency</code> - Maximum relative difference between two LEDs in
the same capture pose, in meters.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_iterations</code> - Maximum number of times to toggle the LEDs for a given
capture pose.</li>
      <li>
<code class="language-plaintext highlighter-rouge">gripper_led_frame</code> - The robot link which the <code class="language-plaintext highlighter-rouge">leds</code> are defined in.</li>
      <li>
<code class="language-plaintext highlighter-rouge">leds</code> - Definition of the LED poses. For each LED, you need to specify
a <code class="language-plaintext highlighter-rouge">code</code> which is sent to the action server to turn that LED on, as well
as <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, and <code class="language-plaintext highlighter-rouge">z</code> offsets relative to <code class="language-plaintext highlighter-rouge">gripper_led_frame</code> for
the expected pose of that LED. These values will be used to generate
the chain observation.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::PlaneFinder</code> - Detects planes in a point cloud. This
will filter out points outside the limits, and then iteratively find the
largest plane until a desired one is found. This is commonly used to align
a sensor with the ground.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_max</code> - Maximum number of points to use in the observation</li>
      <li>The cloud can be pre-filtered using the <code class="language-plaintext highlighter-rouge">min_x</code>, <code class="language-plaintext highlighter-rouge">max_x</code>, <code class="language-plaintext highlighter-rouge">min_y</code>,
<code class="language-plaintext highlighter-rouge">max_y</code>, <code class="language-plaintext highlighter-rouge">min_z</code>, and <code class="language-plaintext highlighter-rouge">max_z</code> parameters.</li>
      <li>The desired orientation of the plane can be used by setting <code class="language-plaintext highlighter-rouge">normal_a</code>,
<code class="language-plaintext highlighter-rouge">normal_b</code>, <code class="language-plaintext highlighter-rouge">normal_c</code> parameters - if all are 0, the biggest plane
will be selected regardless of orientation. This is particularly useful
if the robot might be looking partially at the wall as well as the desired
floor surface.</li>
      <li>
<code class="language-plaintext highlighter-rouge">normal_angle</code> - If a desired orientation vector is set, the candidate
plane normal must be within this angle of the desired normal, in radians.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::ScanFinder</code> - Detects points in a laser scan, and then
repeats them vertically. This can be used to align a laser scanner against
a plane detected by a 3d camera.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::LaserScan</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">transform_frame</code> – Frame to transform the laser scan into, usually
<code class="language-plaintext highlighter-rouge">base_link</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">min_x</code>, <code class="language-plaintext highlighter-rouge">max_x</code>, <code class="language-plaintext highlighter-rouge">min_y</code>, and <code class="language-plaintext highlighter-rouge">max_y</code> are used to limit the
laser scan points that are used. They are defined in the <code class="language-plaintext highlighter-rouge">transform_frame</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">z_repeats</code> - How many times to copy the points vertically.</li>
      <li>
<code class="language-plaintext highlighter-rouge">z_offset</code> - Distance between repeated points.</li>
    </ul>
  </li>
</ul>

<p>Additionally, any finder that subscribes to a depth camera has the following parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">camera_info_topic</code>: The topic name for the camera info.</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera_driver</code>: Namespace of the camera driver, only used for Primesense-like
devices which have <code class="language-plaintext highlighter-rouge">z_offset_mm</code> and <code class="language-plaintext highlighter-rouge">z_scaling</code> parameters.</li>
</ul>

<h3 id="calibration-configuration">Calibration Configuration</h3>

<p>The <code class="language-plaintext highlighter-rouge">calibrate.yaml</code> configuration file specifies the configuration for
optimization. This specifies several items:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">base_link</code> - Frame used for internal calculations. Typically, the root of the
URDF is used. Often <code class="language-plaintext highlighter-rouge">base_link</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">calibration_steps</code> - In ROS 2, multistep calibration is fully supported. The
parameter <code class="language-plaintext highlighter-rouge">calibration_steps</code> should be a list of step names. A majority of
calibrations probably only use a single step, but the step name must still
be in a YAML list format.</li>
</ul>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">robot_calibration</span><span class="pi">:</span>
  <span class="na">ros__parameters</span><span class="pi">:</span>
    <span class="na">base_link</span><span class="pi">:</span> <span class="s">torso_lift_link</span>
    <span class="na">calibration_steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">single_calibration_step</span>
    <span class="na">single_calibration_step</span><span class="pi">:</span>
      <span class="na">models</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">first_model</span>
      <span class="na">first_model</span><span class="pi">:</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">first_model_type</span>

</code></pre></div></div>

<p>For each calibration step, there are several parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">models</code> - List of model names. Each model will then be defined in a
parameter block defined by the name. Models define how to reproject
observation points into the fixed frame. The basic model is a
kinematic chain. Additional models can reproject through a kinematic
chain and then a sensor, such as a 3d camera. Once loaded, models
will be used by the error blocks to compute the reprojection errors
between different sensor observations.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_params</code> - Defines the names of single-value free parameters. These
can be the names of a joint for which the joint offset should be calculated,
camera parameters such as focal lengths or the driver offsets for
Primesense devices. If attempting to calibrate the length of a robot
link, use <code class="language-plaintext highlighter-rouge">free_frames</code> to define the axis that is being calibrated.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_frames</code> - Defines the names of multi-valued free parameters that
are 6-d transforms. Also defines which axis are free. X, Y, and Z can all
be independently set to free parameters. Roll, pitch and yaw can also be
set free, however it is important to note that because calibration
internally uses an angle-axis representation, either all 3 should be set
free, or only one should be free. You should never set two out of three
to be free parameters.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_frames_initial_values</code> - Defines the initial offset values for
<code class="language-plaintext highlighter-rouge">free_frames</code>. X, Y, Z offsets are in meters. ROLL, PITCH, YAW are in
radians. This is most frequently used for setting the initial estimate
of the checkerboard position, see details below.</li>
  <li>
<code class="language-plaintext highlighter-rouge">error_blocks</code> - List of error block names, which are then defined
under their own namespaces.</li>
</ul>

<p>For each model, the <code class="language-plaintext highlighter-rouge">type</code> must be specified. The type should be one of:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d</code> - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter (which in MoveIt/KDL terms is usually referred to as the <code class="language-plaintext highlighter-rouge">tip</code>).</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera3d</code> - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter, and includes the pinhole camera model parameters (cx, cy, fx, fy)
when doing projection of the points. This model only works if your sensor
publishes CameraInfo. Further, the calibration obtained when this model is
used and any of the pinhole parameters are free parameters is only valid if
the physical sensor actually uses the CameraInfo for 3d projection (this
is generally true for the Primesense/Astra sensors).</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera2d</code> - Similar to <code class="language-plaintext highlighter-rouge">camera3d</code>, but for a 2d finder. Currently only
works with the output of the <code class="language-plaintext highlighter-rouge">CheckerboardFinder2d</code>.</li>
</ul>

<p>For each error block, the <code class="language-plaintext highlighter-rouge">type</code> must be specified. In addition to the
<code class="language-plaintext highlighter-rouge">type</code> parameter, each block will have additional parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_chain3d</code> - The most commonly used error block type.
This error block can compute the difference in reprojection
between two 3D “sensors” which tell us the position of
certain features of interest. Sensors might be a 3D camera or an arm
which is holding a checkerboard. Was previously called “camera3d_to_arm”:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_a</code> - First <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_b</code> - Second <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_camera2d</code>- Currently only used for the <code class="language-plaintext highlighter-rouge">CheckerboardFinder2d</code>:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_2d</code> - <code class="language-plaintext highlighter-rouge">camera2d</code> model to use in computing reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_3d</code> - <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">scale</code> - Scalar to multiply summed error by - note that error computed
in this block is in <em>pixel</em> space, rather than <em>metric</em> space like most
other error blocks.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_mesh</code> - This error block type can compute the closeness between
projected 3d points and a mesh. The mesh must be part of the robot body.
This is commonly used to align the robot sensor with the base of the robot,
using points that were found by the <code class="language-plaintext highlighter-rouge">RobotFinder</code> plugin:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model</code> - <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing reprojection
error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">link_name</code> -Name of the link in the URDF for which mesh to use.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_plane</code> - This error block can be used to compare projected
points to a plane. Each observation point is reprojected, then the sum
of distance to plane for each point is computed. The most common use case
is making sure that the ground plane a robot sees is really on the ground:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model</code> - The <code class="language-plaintext highlighter-rouge">camera3d</code> model for reprojection.</li>
      <li>
<code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">d</code> - Parameters for the desired plane equation, in the
form <code class="language-plaintext highlighter-rouge">ax + by + cz + d = 0</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">scale</code> - Since the error computed is a distance from the plane over
many points, scaling the error relative to other error blocks is often
required.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">plane_to_plane</code> - This error block is able to compute the difference
between two planes. For instance, 3d cameras may not have the resolution
to actually see a checkerboard, but we can align important axis by
making sure that a wall seen by both cameras is aligned. For each observation,
the points are assumed to form a plane:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_a</code> - First <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_b</code> - Second <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">normal_scale</code> - The normal error is computed as the difference between
the two plane normals and then multiplied by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">offset_scale</code> - The offset error is computed as the distance from
the centroid of the first plane to the second plane and then
multiplied by this scalar.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">outrageous</code> - Sometimes, the calibration is ill-defined in certain dimensions,
and we would like to avoid one of the free parameters from becoming
absurd. An outrageous error block can be used to limit a particular
parameter:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">param</code> - Free parameter to monitor.</li>
      <li>
<code class="language-plaintext highlighter-rouge">joint_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a joint name, multiply the free param value
by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">position_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a free frame, multiply the metric distance
in X, Y, Z by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">rotation_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a free frame, multiply the angular distance
of the free parameter value by this scalar.</li>
    </ul>
  </li>
</ul>

<h3 id="calibration-poses">Calibration Poses</h3>

<p>The final piece of configuration is the actual poses from which the robot should
capture data. This YAML file can be created by running the <code class="language-plaintext highlighter-rouge">capture_poses</code> script.
You will be prompted to move the robot to the desired pose and press ENTER, when
done collecting all of your poses, you can type EXIT.
This will create <code class="language-plaintext highlighter-rouge">calibration_poses.yaml</code> which is an array of capture poses:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-0.09211555123329163</span>
  <span class="pi">-</span> <span class="m">0.013307283632457256</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-1.747204065322876</span>
  <span class="pi">-</span> <span class="s">-0.07186950743198395</span>

</code></pre></div></div>

<p>By default, every finder is used for every capture pose. In some cases, you might
want to specify specific finders by editing the <code class="language-plaintext highlighter-rouge">features</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This sample pose uses only the `ground_plane_finder` feature finder</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">ground_plane_finder</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-0.09211555123329163</span>
  <span class="pi">-</span> <span class="m">0.013307283632457256</span>
<span class="c1"># This sample pose will use all features</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-1.747204065322876</span>
  <span class="pi">-</span> <span class="s">-0.07186950743198395</span>

</code></pre></div></div>

<h4 id="checkerboard-configuration">Checkerboard Configuration</h4>

<p>When using a checkerboard, we need to estimate the transformation from the
the tip of the kinematic chain to the virtual <code class="language-plaintext highlighter-rouge">checkerboard</code> frame.
Calibration will be faster and more accurate if the initial estimate of
this transformation is close to the actual
value, especially with regards to rotation.</p>

<p>The simplest way to check your initial estimate is to run the calibration with
only the six DOF of the checkerboard as free parameters. The output values will
be the X, Y, Z, and A, B, C of the transformation. It is important to note that
A, B, C are NOT roll, pitch, yaw – they are the axis-magnitude representation.
To get roll, pitch and yaw, run the <code class="language-plaintext highlighter-rouge">to_rpy</code> tool with your values of A, B,
and C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration to_rpy A B C

</code></pre></div></div>
<p>This will print the ROLL, PITCH, YAW values to put in for initial values. Then
insert the values in the calibration.yaml:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">free_frames_initial_values</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">checkerboard</span>
<span class="na">checkerboard_initial_values</span><span class="pi">:</span>
  <span class="na">x</span><span class="pi">:</span> <span class="m">0.0</span>
  <span class="na">y</span><span class="pi">:</span> <span class="m">0.225</span>
  <span class="na">z</span><span class="pi">:</span> <span class="m">0</span>
  <span class="na">roll</span><span class="pi">:</span> <span class="m">0.0</span>
  <span class="na">pitch</span><span class="pi">:</span> <span class="m">1.571</span>
  <span class="na">yaw</span><span class="pi">:</span> <span class="m">0.0</span>

</code></pre></div></div>

<p><a href="https://markhedleyjones.com/projects/calibration-checkerboard-collection">This tool</a>
can be helfpul for creating checkerboards.</p>

<h3 id="exported-results">Exported Results</h3>

<p>The exported results consist of an updated URDF file, and one or more updated
camera calibration YAML files. By default, these files will by exported into
the /tmp folder, with filenames that include a timestamp of generation. These
files need to be installed in the correct places to be properly loaded.</p>

<p>The <a href="https://github.com/fetchrobotics/fetch_ros/tree/indigo-devel/fetch_calibration">fetch_calibration</a>
package has an example python script for installing the updated files.</p>

<p>Within the updated URDF file, there are two types of exported results:</p>

<ul>
  <li>Changes to free_frames are applied as offsets in the joint origins.</li>
  <li>Changes to free_params (joint offsets) are applied as “calibration” tags
in the URDF. In particular, they are applied as “rising” tags. These
should be read by the robot drivers so that the offsets can be applied
before joint values are used for controllers. The offsets need to be added
to the joint position read from the device. The offset then typically
needs to be subtracted from the commanded position sent to the device.</li>
</ul>

<p>If your robot does not support the “calibration” tags, it might be possible
to use only free_frames, setting only the rotation in the joint axis to be
free.</p>

<h2 id="the-base_calibration_node">The <em>base_calibration_node</em>
</h2>

<p>To run the <em>base_calibration_node</em> node, you need a somewhat open space with a large
(~3 meters wide) wall that you can point the robot at.</p>

<p>Starting with the <code class="language-plaintext highlighter-rouge">0.10</code> release of <code class="language-plaintext highlighter-rouge">robot_calibration</code>, the actual movements the
robot does can be programmed via the <code class="language-plaintext highlighter-rouge">calibration_steps</code> parameter:</p>

<ul>
  <li>
<code>calibration_steps</code> - should be a list of string names of calibration
steps to run.</li>
  <li>
<code>step_name/type</code> - should be either <code class="language-plaintext highlighter-rouge">spin</code> or <code class="language-plaintext highlighter-rouge">rollout</code>.</li>
  <li>
<code>step_name/velocity</code> - velocity to move the robot. This will be
interpreted as angular velocity for <code class="language-plaintext highlighter-rouge">spin</code> steps and linear velocity for <code class="language-plaintext highlighter-rouge">rollout</code>
steps.</li>
  <li>
<code>step_name/rotations</code> - only valid for <code class="language-plaintext highlighter-rouge">spin</code> steps. Number of
rotations to complete at given <code class="language-plaintext highlighter-rouge">velocity</code>.</li>
  <li>
<code>step_name/distance</code> - only valid for <code class="language-plaintext highlighter-rouge">rollout</code> steps. Distance
in meters, to rollout the robot.</li>
</ul>

<p>Additional parameters:</p>

<ul>
  <li>
<code>accel_limit</code> - acceleration limit for <code class="language-plaintext highlighter-rouge">spin</code> steps (radians/second^2).</li>
  <li>
<code>linear_accel_limit</code> - acceleration limit for <code class="language-plaintext highlighter-rouge">rollout</code> steps (meters/second^2).</li>
  <li>
<code>min_angle/max_angle</code> how much of the laser scan to use when
measuring the wall angle (radians).</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/odom</code> - the node subscribes to this odom data. Message type
is <code>nav_msgs/Odometry</code>.</li>
  <li>
<code>/imu</code> - the node subscribes to this IMU data. Message type
is <code>sensor_msgs/IMU</code>.</li>
  <li>
<code>/base_scan</code> - the node subscribes to this laser data. Message type
is <code>sensor_msgs/LaserScan</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the node is a series of scalars to apply (where a value of 1.0 means
there is currently no error):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[base_calibration_node-1] track_width_scale: 0.986743
[base_calibration_node-1] imu_scale: 0.984465
[base_calibration_node-1] rollout_scale: 0.981911

</code></pre></div></div>

<p>The application of these values is largely dependent on the drivers being used
for the robot. For robots using <em>ros_control</em> or <em>robot_control</em> there is a
<code class="language-plaintext highlighter-rouge">track_width</code> parameter typically supplied as a ROS parameter in your launch file.</p>

<p>Note: in ROS 1, these scalars were pre-multiplied by the existing <code class="language-plaintext highlighter-rouge">track_width</code>
or <code class="language-plaintext highlighter-rouge">imu_scale</code> - however, with the lack of a unified parameter server in ROS 2,
this is no longer done.</p>

<h2 id="the-magnetometer_calibration-node">The <em>magnetometer_calibration</em> node</h2>

<p>The <em>magnetometer_calibration</em> node records magnetometer data and can compute
the <em>hard iron</em> offsets. After calibration, the magnetometer can be used as
a compass (typically by piping the data through <em>imu_filter_madgwick</em> and
then <em>robot_localization</em>).</p>

<p>Node parameters:</p>

<ul>
  <li>
<code>~rotation_manual</code> - if set to true, the node will not publish command
velocities and the user will have to manually rotate the magnetometer. Default: false.</li>
  <li>
<code>~rotation_duration</code> - how long to rotate the robot, in seconds.</li>
  <li>
<code>~rotation_velocity</code> - the yaw velocity to rotate the robot, in rad/s.</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/imu/mag</code> - the node subscribes to this magnetometer data. Message type
is <code>sensor_msgs/MagneticField</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the calibration is three parameters, <em>mag_bias_x</em>, <em>mag_bias_y</em>,
and <em>mag_bias_z</em>, which can be used with the <code>imu_filter_madgwick</code> package.</p>

<h3 id="migrating-from-ros1">Migrating from ROS1</h3>

<p>There are a number of changes in migrating from ROS1 to ROS2. Some of these are
due to differences in the ROS2 system, others are to finally cleanup mistakes
made in earlier version of robot_calibration.</p>

<p>The <code class="language-plaintext highlighter-rouge">chains</code>, <code class="language-plaintext highlighter-rouge">models</code>, <code class="language-plaintext highlighter-rouge">free_frames</code> and <code class="language-plaintext highlighter-rouge">features</code> parameters used to be lists of YAML
dictionaries. That format is not easily supported in ROS2 and so they are now
lists of string names and the actual dictionaries of information appear under
the associated name. For instance, in ROS1, you might have:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">models</span><span class="pi">:</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">arm</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">chain</span>
   <span class="na">frame</span><span class="pi">:</span> <span class="s">wrist_roll_link</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">camera</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">camera3d</span>
   <span class="na">frame</span><span class="pi">:</span> <span class="s">head_camera_rgb_optical_frame</span>

</code></pre></div></div>

<p>In ROS2, this becomes:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">models</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">arm</span>
<span class="pi">-</span> <span class="s">camera</span>
<span class="na">arm</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">chain3d</span>
  <span class="na">frame</span><span class="pi">:</span> <span class="s">wrist_roll_link</span>
<span class="na">camera</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">camera3d</span>
  <span class="na">frame</span><span class="pi">:</span> <span class="s">head_camera_rgb_optical_frame</span>

</code></pre></div></div>

<p>NOTE: the “chain” type has been renamed “chain3d” in ROS2 for consistency (and to allow
a future chain2d).</p>

<p>Multi-step calibration is now fully supported. A new parameter, <code class="language-plaintext highlighter-rouge">calibration_steps</code> must
be declared as a list of step names. The <code class="language-plaintext highlighter-rouge">models</code> and free parameters are then specified
for each step. As an example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">calibration_steps</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">first_calibration_step</span>
<span class="pi">-</span> <span class="s">second_calibration_step</span>
<span class="na">first_calibration_step</span><span class="pi">:</span>
  <span class="na">models</span><span class="pi">:</span> <span class="s">...</span>
  <span class="na">free_params</span><span class="pi">:</span> <span class="s">...</span>
<span class="na">second_calibration_step</span><span class="pi">:</span>
  <span class="na">models</span><span class="pi">:</span> <span class="s">...</span>
  <span class="na">free_params</span><span class="pi">:</span> <span class="s">...</span>

</code></pre></div></div>

<p>The capture poses can now be specified as YAML. The <code class="language-plaintext highlighter-rouge">convert_ros1_bag_to_yaml</code> script
can be run in ROS1 to export your ROS1 bagfile as a YAML file that can be loaded in ROS2.</p>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-rolling">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/robot_calibration">robot_calibration</a> <small>repository</small></h3>
        <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration">robot_calibration</a>
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration_msgs">robot_calibration_msgs</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-mikeferguson-robot_calibration
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-mikeferguson-robot_calibration" role="menuitem" tabindex="-1" href="/r/robot_calibration/github-mikeferguson-robot_calibration" data="github-mikeferguson-robot_calibration">
                    <span class="glyphicon glyphicon-star"></span>
                    github-mikeferguson-robot_calibration
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Generic calibration for robots</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/mikeferguson/robot_calibration.git">https://github.com/mikeferguson/robot_calibration.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">ros2</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-03-17
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/robot_calibration/#rolling-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#rolling-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#rolling-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/robot_calibration">robot_calibration</a></td>
                    <td>0.10.0</td>
                  </tr>
                
                  <tr>
                    <td><a href="/p/robot_calibration_msgs">robot_calibration_msgs</a></td>
                    <td>0.10.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="robot-calibration">Robot Calibration</h1>

<p>This package offers several ROS2 nodes. The primary one is called <em>calibrate</em>,
and can be used to calibrate a number of parameters of a robot, such as:</p>

<ul>
  <li>3D Camera intrinsics and extrinsics</li>
  <li>Joint angle offsets</li>
  <li>Robot frame offsets</li>
</ul>

<p>These parameters are then inserted into an updated URDF, or updated camera
configuration YAML in the case of camera intrinsics.</p>

<p>Two additional ROS nodes are used for mobile-base related parameter tuning:</p>

<ul>
  <li>
<em>base_calibration_node</em> - can determine scaling factors for wheel diameter,
track width and gyro gain by moving and rotating the robot while tracking
the actual movement based on the laser scanner view of a wall.</li>
  <li>
<em>magnetometer_calibration</em> - can be used to do hard iron calibration
of a magnetometer.</li>
</ul>

<h2 id="the-calibrate-node">The <em>calibrate</em> node</h2>

<p>Calibration works in two steps. The first step involves the capture of data
samples from the robot. Each “sample” comprises the measured joint positions
of the robot and two or more “observations”. An observation is a collection
of points that have been detected by a “sensor”. For instance, a robot could
use a camera and an arm to “detect” the pose of corners on a checkerboard.
In the case of the camera sensor, the collection of points is simply the
detected positions of each corner of the checkerboard, relative to the pose
of the camera reference frame. For the arm, it is assumed that the checkerboard
is fixed relative to a virtual <code class="language-plaintext highlighter-rouge">checkerboard</code> frame which is fixed relative
to the end effector of the arm. Within the virtual frame, we know the ideal
position of each point of the checkerboard corners since the checkerboard
is of known size.</p>

<p>The second step of calibration involves optimization of the robot parameters
to minimize the errors. Errors are defined as the difference in the pose
of the points based on reprojection throuhg each sensor. In the case of our
checkerboard above, the transform between the virtual frame and the end
effector becomes additional free parameters. By estimating these parameters
alongside the robot parameters, we can find a set of parameters such that
the reprojection of the checkerboard corners through the arm is as closely
aligned with the reprojection through the camera (and any associated
kinematic chain, for instance, a pan/tilt head).</p>

<p>Configuration is typically handled through two sets of YAML files: usually
called <code class="language-plaintext highlighter-rouge">capture.yaml</code> and <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</p>

<p>If you want to manually move the robot to poses and capture each time you
hit ENTER on the keyboard, you can run robot calibration with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration calibrate --manual --ros-args --params-file path-to-capture.yaml --params-file path-to-calibrate.yaml

</code></pre></div></div>

<p>More commonly, you will generate a third YAML file with the capture pose
configuration (as documented below in the section “Calibration Poses”):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration calibrate path-to-calibration-poses.yaml --ros-args --params-file path-to-capture.yaml --params-file path-to-calibrate.yaml

</code></pre></div></div>

<p>This is often wrapped into a ROS 2 launch file, which often records
a bagfile of the observations allowing to re-run just the calibration part
instead of needing to run capture each time. For an example, see the
UBR-1 example in the next section.</p>

<h3 id="example-configuration">Example Configuration</h3>

<p>All of the parameters that can be defined in the capture and calibrate steps
are documented below, but sometimes it is just nice to have a full example.
The UBR-1 robot uses this package to calibrate in ROS2. Start with
the <code class="language-plaintext highlighter-rouge">calibrate_launch.py</code> in
<a href="https://github.com/mikeferguson/ubr_reloaded/tree/ros2/ubr1_calibration">ubr1_calibration</a>.</p>

<h3 id="capture-configuration">Capture Configuration</h3>

<p>The <code class="language-plaintext highlighter-rouge">capture.yaml</code> file specifies the details needed for data capture:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chains</code> - A parameter listing the names of the kinematic chains of the
robot which should be controlled.</li>
  <li>
<code class="language-plaintext highlighter-rouge">features</code> - A parameter listing the names of the various “feature finders”
that will be making our observations at each sample pose.</li>
</ul>

<p>Each of these chains and features is then defined by a parameter block of the
same name, for example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">robot_calibration</span><span class="pi">:</span>
  <span class="na">ros_parameters</span><span class="pi">:</span>
    <span class="c1"># List of chains</span>
    <span class="na">chains</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">arm</span>
    <span class="c1"># List of features</span>
    <span class="na">features</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">checkerboard_finder</span>
    <span class="c1"># Parameter block to define the arm chain</span>
    <span class="na">arm</span><span class="pi">:</span>
      <span class="na">topic</span><span class="pi">:</span> <span class="s">/arm_controller/follow_joint_trajectory</span>
      <span class="na">joints</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">first_joint</span>
      <span class="pi">-</span> <span class="s">second_joint</span>
    <span class="c1"># Parameter block to define the feature finder:</span>
    <span class="na">checkerboard_finder</span><span class="pi">:</span>
      <span class="na">type</span><span class="pi">:</span> <span class="s">robot_calibration::CheckerboardFinder</span>
      <span class="na">topic</span><span class="pi">:</span> <span class="s">/head_camera/depth_registered/points</span>
      <span class="na">camera_sensor_name</span><span class="pi">:</span> <span class="s">camera</span>
      <span class="na">chain_sensor_name</span><span class="pi">:</span> <span class="s">arm</span>

</code></pre></div></div>

<h4 id="chain-parameters">Chain Parameters</h4>

<p>For each chain, the following parameters can be defined:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">topic</code> - The namespace of the <code class="language-plaintext highlighter-rouge">control_msgs::FollowJointTrajectory</code>
server used to control this chain.</li>
  <li>
<code class="language-plaintext highlighter-rouge">planning_group</code> - Optional parameter, when set to a non-empty string
<code class="language-plaintext highlighter-rouge">robot_calibration</code> will call MoveIt to plan a collision free path from
the current robot pose to the next capture pose. When this parameter is
not set, the trajectory simply interpolates from the current pose to the
next capture pose without collision awareness - so you need to be careful
when defining your series of capture poses.</li>
  <li>
<code class="language-plaintext highlighter-rouge">joints</code> - A list of joints that this group comprises.</li>
</ul>

<h4 id="finder-parameters">Finder Parameters</h4>

<p>At a minimum, the following parameters must be set for all finders:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">type</code> - Name of the plugin to load.</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera_sensor_name</code> - Every finder outputs observations from some
sensor - this name must match the name used later in <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">chain_sensor_name</code> - Every finder outputs observations from some
chain - this name must match the name used later in <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">debug</code> - Most finders have a debug parameter which will insert the
raw image or point cloud into the observation. This makes the capture
bagfile larger but aids in debugging.</li>
</ul>

<p>The following types are currently included with <code class="language-plaintext highlighter-rouge">robot_calibration</code>
although you can create your own plugins. Each finder has it’s own
additional parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::CheckerboardFinder</code> - Detects checkerboards in
a point cloud.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_x</code> - Number of corners in the X direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_y</code> - Number of corners in the Y direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">size</code> - Size of checkerboard squares, in meters.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::CheckerboardFinder2d</code> - Detects checkerboards in
an image:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::Image</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_x</code> - Number of corners in the X direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_y</code> - Number of corners in the Y direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">size</code> - Size of checkerboard squares, in meters.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::LedFinder</code> - controls and detects a series of LEDs,
which can be a built-in alternative to having a robot hold the checkerboard.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">gripper_led_action</code> - Namespace of the gripper LED action server.</li>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_error</code> - Maximum distance detected LED can be from expected pose,
in meters.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_inconsistency</code> - Maximum relative difference between two LEDs in
the same capture pose, in meters.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_iterations</code> - Maximum number of times to toggle the LEDs for a given
capture pose.</li>
      <li>
<code class="language-plaintext highlighter-rouge">gripper_led_frame</code> - The robot link which the <code class="language-plaintext highlighter-rouge">leds</code> are defined in.</li>
      <li>
<code class="language-plaintext highlighter-rouge">leds</code> - Definition of the LED poses. For each LED, you need to specify
a <code class="language-plaintext highlighter-rouge">code</code> which is sent to the action server to turn that LED on, as well
as <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, and <code class="language-plaintext highlighter-rouge">z</code> offsets relative to <code class="language-plaintext highlighter-rouge">gripper_led_frame</code> for
the expected pose of that LED. These values will be used to generate
the chain observation.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::PlaneFinder</code> - Detects planes in a point cloud. This
will filter out points outside the limits, and then iteratively find the
largest plane until a desired one is found. This is commonly used to align
a sensor with the ground.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_max</code> - Maximum number of points to use in the observation</li>
      <li>The cloud can be pre-filtered using the <code class="language-plaintext highlighter-rouge">min_x</code>, <code class="language-plaintext highlighter-rouge">max_x</code>, <code class="language-plaintext highlighter-rouge">min_y</code>,
<code class="language-plaintext highlighter-rouge">max_y</code>, <code class="language-plaintext highlighter-rouge">min_z</code>, and <code class="language-plaintext highlighter-rouge">max_z</code> parameters.</li>
      <li>The desired orientation of the plane can be used by setting <code class="language-plaintext highlighter-rouge">normal_a</code>,
<code class="language-plaintext highlighter-rouge">normal_b</code>, <code class="language-plaintext highlighter-rouge">normal_c</code> parameters - if all are 0, the biggest plane
will be selected regardless of orientation. This is particularly useful
if the robot might be looking partially at the wall as well as the desired
floor surface.</li>
      <li>
<code class="language-plaintext highlighter-rouge">normal_angle</code> - If a desired orientation vector is set, the candidate
plane normal must be within this angle of the desired normal, in radians.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::ScanFinder</code> - Detects points in a laser scan, and then
repeats them vertically. This can be used to align a laser scanner against
a plane detected by a 3d camera.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::LaserScan</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">transform_frame</code> – Frame to transform the laser scan into, usually
<code class="language-plaintext highlighter-rouge">base_link</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">min_x</code>, <code class="language-plaintext highlighter-rouge">max_x</code>, <code class="language-plaintext highlighter-rouge">min_y</code>, and <code class="language-plaintext highlighter-rouge">max_y</code> are used to limit the
laser scan points that are used. They are defined in the <code class="language-plaintext highlighter-rouge">transform_frame</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">z_repeats</code> - How many times to copy the points vertically.</li>
      <li>
<code class="language-plaintext highlighter-rouge">z_offset</code> - Distance between repeated points.</li>
    </ul>
  </li>
</ul>

<p>Additionally, any finder that subscribes to a depth camera has the following parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">camera_info_topic</code>: The topic name for the camera info.</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera_driver</code>: Namespace of the camera driver, only used for Primesense-like
devices which have <code class="language-plaintext highlighter-rouge">z_offset_mm</code> and <code class="language-plaintext highlighter-rouge">z_scaling</code> parameters.</li>
</ul>

<h3 id="calibration-configuration">Calibration Configuration</h3>

<p>The <code class="language-plaintext highlighter-rouge">calibrate.yaml</code> configuration file specifies the configuration for
optimization. This specifies several items:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">base_link</code> - Frame used for internal calculations. Typically, the root of the
URDF is used. Often <code class="language-plaintext highlighter-rouge">base_link</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">calibration_steps</code> - In ROS 2, multistep calibration is fully supported. The
parameter <code class="language-plaintext highlighter-rouge">calibration_steps</code> should be a list of step names. A majority of
calibrations probably only use a single step, but the step name must still
be in a YAML list format.</li>
</ul>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">robot_calibration</span><span class="pi">:</span>
  <span class="na">ros__parameters</span><span class="pi">:</span>
    <span class="na">base_link</span><span class="pi">:</span> <span class="s">torso_lift_link</span>
    <span class="na">calibration_steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">single_calibration_step</span>
    <span class="na">single_calibration_step</span><span class="pi">:</span>
      <span class="na">models</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">first_model</span>
      <span class="na">first_model</span><span class="pi">:</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">first_model_type</span>

</code></pre></div></div>

<p>For each calibration step, there are several parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">models</code> - List of model names. Each model will then be defined in a
parameter block defined by the name. Models define how to reproject
observation points into the fixed frame. The basic model is a
kinematic chain. Additional models can reproject through a kinematic
chain and then a sensor, such as a 3d camera. Once loaded, models
will be used by the error blocks to compute the reprojection errors
between different sensor observations.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_params</code> - Defines the names of single-value free parameters. These
can be the names of a joint for which the joint offset should be calculated,
camera parameters such as focal lengths or the driver offsets for
Primesense devices. If attempting to calibrate the length of a robot
link, use <code class="language-plaintext highlighter-rouge">free_frames</code> to define the axis that is being calibrated.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_frames</code> - Defines the names of multi-valued free parameters that
are 6-d transforms. Also defines which axis are free. X, Y, and Z can all
be independently set to free parameters. Roll, pitch and yaw can also be
set free, however it is important to note that because calibration
internally uses an angle-axis representation, either all 3 should be set
free, or only one should be free. You should never set two out of three
to be free parameters.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_frames_initial_values</code> - Defines the initial offset values for
<code class="language-plaintext highlighter-rouge">free_frames</code>. X, Y, Z offsets are in meters. ROLL, PITCH, YAW are in
radians. This is most frequently used for setting the initial estimate
of the checkerboard position, see details below.</li>
  <li>
<code class="language-plaintext highlighter-rouge">error_blocks</code> - List of error block names, which are then defined
under their own namespaces.</li>
</ul>

<p>For each model, the <code class="language-plaintext highlighter-rouge">type</code> must be specified. The type should be one of:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d</code> - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter (which in MoveIt/KDL terms is usually referred to as the <code class="language-plaintext highlighter-rouge">tip</code>).</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera3d</code> - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter, and includes the pinhole camera model parameters (cx, cy, fx, fy)
when doing projection of the points. This model only works if your sensor
publishes CameraInfo. Further, the calibration obtained when this model is
used and any of the pinhole parameters are free parameters is only valid if
the physical sensor actually uses the CameraInfo for 3d projection (this
is generally true for the Primesense/Astra sensors).</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera2d</code> - Similar to <code class="language-plaintext highlighter-rouge">camera3d</code>, but for a 2d finder. Currently only
works with the output of the <code class="language-plaintext highlighter-rouge">CheckerboardFinder2d</code>.</li>
</ul>

<p>For each error block, the <code class="language-plaintext highlighter-rouge">type</code> must be specified. In addition to the
<code class="language-plaintext highlighter-rouge">type</code> parameter, each block will have additional parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_chain3d</code> - The most commonly used error block type.
This error block can compute the difference in reprojection
between two 3D “sensors” which tell us the position of
certain features of interest. Sensors might be a 3D camera or an arm
which is holding a checkerboard. Was previously called “camera3d_to_arm”:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_a</code> - First <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_b</code> - Second <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_camera2d</code>- Currently only used for the <code class="language-plaintext highlighter-rouge">CheckerboardFinder2d</code>:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_2d</code> - <code class="language-plaintext highlighter-rouge">camera2d</code> model to use in computing reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_3d</code> - <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">scale</code> - Scalar to multiply summed error by - note that error computed
in this block is in <em>pixel</em> space, rather than <em>metric</em> space like most
other error blocks.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_mesh</code> - This error block type can compute the closeness between
projected 3d points and a mesh. The mesh must be part of the robot body.
This is commonly used to align the robot sensor with the base of the robot,
using points that were found by the <code class="language-plaintext highlighter-rouge">RobotFinder</code> plugin:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model</code> - <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing reprojection
error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">link_name</code> -Name of the link in the URDF for which mesh to use.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_plane</code> - This error block can be used to compare projected
points to a plane. Each observation point is reprojected, then the sum
of distance to plane for each point is computed. The most common use case
is making sure that the ground plane a robot sees is really on the ground:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model</code> - The <code class="language-plaintext highlighter-rouge">camera3d</code> model for reprojection.</li>
      <li>
<code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">d</code> - Parameters for the desired plane equation, in the
form <code class="language-plaintext highlighter-rouge">ax + by + cz + d = 0</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">scale</code> - Since the error computed is a distance from the plane over
many points, scaling the error relative to other error blocks is often
required.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">plane_to_plane</code> - This error block is able to compute the difference
between two planes. For instance, 3d cameras may not have the resolution
to actually see a checkerboard, but we can align important axis by
making sure that a wall seen by both cameras is aligned. For each observation,
the points are assumed to form a plane:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_a</code> - First <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_b</code> - Second <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">normal_scale</code> - The normal error is computed as the difference between
the two plane normals and then multiplied by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">offset_scale</code> - The offset error is computed as the distance from
the centroid of the first plane to the second plane and then
multiplied by this scalar.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">outrageous</code> - Sometimes, the calibration is ill-defined in certain dimensions,
and we would like to avoid one of the free parameters from becoming
absurd. An outrageous error block can be used to limit a particular
parameter:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">param</code> - Free parameter to monitor.</li>
      <li>
<code class="language-plaintext highlighter-rouge">joint_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a joint name, multiply the free param value
by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">position_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a free frame, multiply the metric distance
in X, Y, Z by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">rotation_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a free frame, multiply the angular distance
of the free parameter value by this scalar.</li>
    </ul>
  </li>
</ul>

<h3 id="calibration-poses">Calibration Poses</h3>

<p>The final piece of configuration is the actual poses from which the robot should
capture data. This YAML file can be created by running the <code class="language-plaintext highlighter-rouge">capture_poses</code> script.
You will be prompted to move the robot to the desired pose and press ENTER, when
done collecting all of your poses, you can type EXIT.
This will create <code class="language-plaintext highlighter-rouge">calibration_poses.yaml</code> which is an array of capture poses:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-0.09211555123329163</span>
  <span class="pi">-</span> <span class="m">0.013307283632457256</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-1.747204065322876</span>
  <span class="pi">-</span> <span class="s">-0.07186950743198395</span>

</code></pre></div></div>

<p>By default, every finder is used for every capture pose. In some cases, you might
want to specify specific finders by editing the <code class="language-plaintext highlighter-rouge">features</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This sample pose uses only the `ground_plane_finder` feature finder</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">ground_plane_finder</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-0.09211555123329163</span>
  <span class="pi">-</span> <span class="m">0.013307283632457256</span>
<span class="c1"># This sample pose will use all features</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-1.747204065322876</span>
  <span class="pi">-</span> <span class="s">-0.07186950743198395</span>

</code></pre></div></div>

<h4 id="checkerboard-configuration">Checkerboard Configuration</h4>

<p>When using a checkerboard, we need to estimate the transformation from the
the tip of the kinematic chain to the virtual <code class="language-plaintext highlighter-rouge">checkerboard</code> frame.
Calibration will be faster and more accurate if the initial estimate of
this transformation is close to the actual
value, especially with regards to rotation.</p>

<p>The simplest way to check your initial estimate is to run the calibration with
only the six DOF of the checkerboard as free parameters. The output values will
be the X, Y, Z, and A, B, C of the transformation. It is important to note that
A, B, C are NOT roll, pitch, yaw – they are the axis-magnitude representation.
To get roll, pitch and yaw, run the <code class="language-plaintext highlighter-rouge">to_rpy</code> tool with your values of A, B,
and C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration to_rpy A B C

</code></pre></div></div>
<p>This will print the ROLL, PITCH, YAW values to put in for initial values. Then
insert the values in the calibration.yaml:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">free_frames_initial_values</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">checkerboard</span>
<span class="na">checkerboard_initial_values</span><span class="pi">:</span>
  <span class="na">x</span><span class="pi">:</span> <span class="m">0.0</span>
  <span class="na">y</span><span class="pi">:</span> <span class="m">0.225</span>
  <span class="na">z</span><span class="pi">:</span> <span class="m">0</span>
  <span class="na">roll</span><span class="pi">:</span> <span class="m">0.0</span>
  <span class="na">pitch</span><span class="pi">:</span> <span class="m">1.571</span>
  <span class="na">yaw</span><span class="pi">:</span> <span class="m">0.0</span>

</code></pre></div></div>

<p><a href="https://markhedleyjones.com/projects/calibration-checkerboard-collection">This tool</a>
can be helfpul for creating checkerboards.</p>

<h3 id="exported-results">Exported Results</h3>

<p>The exported results consist of an updated URDF file, and one or more updated
camera calibration YAML files. By default, these files will by exported into
the /tmp folder, with filenames that include a timestamp of generation. These
files need to be installed in the correct places to be properly loaded.</p>

<p>The <a href="https://github.com/fetchrobotics/fetch_ros/tree/indigo-devel/fetch_calibration">fetch_calibration</a>
package has an example python script for installing the updated files.</p>

<p>Within the updated URDF file, there are two types of exported results:</p>

<ul>
  <li>Changes to free_frames are applied as offsets in the joint origins.</li>
  <li>Changes to free_params (joint offsets) are applied as “calibration” tags
in the URDF. In particular, they are applied as “rising” tags. These
should be read by the robot drivers so that the offsets can be applied
before joint values are used for controllers. The offsets need to be added
to the joint position read from the device. The offset then typically
needs to be subtracted from the commanded position sent to the device.</li>
</ul>

<p>If your robot does not support the “calibration” tags, it might be possible
to use only free_frames, setting only the rotation in the joint axis to be
free.</p>

<h2 id="the-base_calibration_node">The <em>base_calibration_node</em>
</h2>

<p>To run the <em>base_calibration_node</em> node, you need a somewhat open space with a large
(~3 meters wide) wall that you can point the robot at.</p>

<p>Starting with the <code class="language-plaintext highlighter-rouge">0.10</code> release of <code class="language-plaintext highlighter-rouge">robot_calibration</code>, the actual movements the
robot does can be programmed via the <code class="language-plaintext highlighter-rouge">calibration_steps</code> parameter:</p>

<ul>
  <li>
<code>calibration_steps</code> - should be a list of string names of calibration
steps to run.</li>
  <li>
<code>step_name/type</code> - should be either <code class="language-plaintext highlighter-rouge">spin</code> or <code class="language-plaintext highlighter-rouge">rollout</code>.</li>
  <li>
<code>step_name/velocity</code> - velocity to move the robot. This will be
interpreted as angular velocity for <code class="language-plaintext highlighter-rouge">spin</code> steps and linear velocity for <code class="language-plaintext highlighter-rouge">rollout</code>
steps.</li>
  <li>
<code>step_name/rotations</code> - only valid for <code class="language-plaintext highlighter-rouge">spin</code> steps. Number of
rotations to complete at given <code class="language-plaintext highlighter-rouge">velocity</code>.</li>
  <li>
<code>step_name/distance</code> - only valid for <code class="language-plaintext highlighter-rouge">rollout</code> steps. Distance
in meters, to rollout the robot.</li>
</ul>

<p>Additional parameters:</p>

<ul>
  <li>
<code>accel_limit</code> - acceleration limit for <code class="language-plaintext highlighter-rouge">spin</code> steps (radians/second^2).</li>
  <li>
<code>linear_accel_limit</code> - acceleration limit for <code class="language-plaintext highlighter-rouge">rollout</code> steps (meters/second^2).</li>
  <li>
<code>min_angle/max_angle</code> how much of the laser scan to use when
measuring the wall angle (radians).</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/odom</code> - the node subscribes to this odom data. Message type
is <code>nav_msgs/Odometry</code>.</li>
  <li>
<code>/imu</code> - the node subscribes to this IMU data. Message type
is <code>sensor_msgs/IMU</code>.</li>
  <li>
<code>/base_scan</code> - the node subscribes to this laser data. Message type
is <code>sensor_msgs/LaserScan</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the node is a series of scalars to apply (where a value of 1.0 means
there is currently no error):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[base_calibration_node-1] track_width_scale: 0.986743
[base_calibration_node-1] imu_scale: 0.984465
[base_calibration_node-1] rollout_scale: 0.981911

</code></pre></div></div>

<p>The application of these values is largely dependent on the drivers being used
for the robot. For robots using <em>ros_control</em> or <em>robot_control</em> there is a
<code class="language-plaintext highlighter-rouge">track_width</code> parameter typically supplied as a ROS parameter in your launch file.</p>

<p>Note: in ROS 1, these scalars were pre-multiplied by the existing <code class="language-plaintext highlighter-rouge">track_width</code>
or <code class="language-plaintext highlighter-rouge">imu_scale</code> - however, with the lack of a unified parameter server in ROS 2,
this is no longer done.</p>

<h2 id="the-magnetometer_calibration-node">The <em>magnetometer_calibration</em> node</h2>

<p>The <em>magnetometer_calibration</em> node records magnetometer data and can compute
the <em>hard iron</em> offsets. After calibration, the magnetometer can be used as
a compass (typically by piping the data through <em>imu_filter_madgwick</em> and
then <em>robot_localization</em>).</p>

<p>Node parameters:</p>

<ul>
  <li>
<code>~rotation_manual</code> - if set to true, the node will not publish command
velocities and the user will have to manually rotate the magnetometer. Default: false.</li>
  <li>
<code>~rotation_duration</code> - how long to rotate the robot, in seconds.</li>
  <li>
<code>~rotation_velocity</code> - the yaw velocity to rotate the robot, in rad/s.</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/imu/mag</code> - the node subscribes to this magnetometer data. Message type
is <code>sensor_msgs/MagneticField</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the calibration is three parameters, <em>mag_bias_x</em>, <em>mag_bias_y</em>,
and <em>mag_bias_z</em>, which can be used with the <code>imu_filter_madgwick</code> package.</p>

<h3 id="migrating-from-ros1">Migrating from ROS1</h3>

<p>There are a number of changes in migrating from ROS1 to ROS2. Some of these are
due to differences in the ROS2 system, others are to finally cleanup mistakes
made in earlier version of robot_calibration.</p>

<p>The <code class="language-plaintext highlighter-rouge">chains</code>, <code class="language-plaintext highlighter-rouge">models</code>, <code class="language-plaintext highlighter-rouge">free_frames</code> and <code class="language-plaintext highlighter-rouge">features</code> parameters used to be lists of YAML
dictionaries. That format is not easily supported in ROS2 and so they are now
lists of string names and the actual dictionaries of information appear under
the associated name. For instance, in ROS1, you might have:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">models</span><span class="pi">:</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">arm</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">chain</span>
   <span class="na">frame</span><span class="pi">:</span> <span class="s">wrist_roll_link</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">camera</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">camera3d</span>
   <span class="na">frame</span><span class="pi">:</span> <span class="s">head_camera_rgb_optical_frame</span>

</code></pre></div></div>

<p>In ROS2, this becomes:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">models</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">arm</span>
<span class="pi">-</span> <span class="s">camera</span>
<span class="na">arm</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">chain3d</span>
  <span class="na">frame</span><span class="pi">:</span> <span class="s">wrist_roll_link</span>
<span class="na">camera</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">camera3d</span>
  <span class="na">frame</span><span class="pi">:</span> <span class="s">head_camera_rgb_optical_frame</span>

</code></pre></div></div>

<p>NOTE: the “chain” type has been renamed “chain3d” in ROS2 for consistency (and to allow
a future chain2d).</p>

<p>Multi-step calibration is now fully supported. A new parameter, <code class="language-plaintext highlighter-rouge">calibration_steps</code> must
be declared as a list of step names. The <code class="language-plaintext highlighter-rouge">models</code> and free parameters are then specified
for each step. As an example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">calibration_steps</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">first_calibration_step</span>
<span class="pi">-</span> <span class="s">second_calibration_step</span>
<span class="na">first_calibration_step</span><span class="pi">:</span>
  <span class="na">models</span><span class="pi">:</span> <span class="s">...</span>
  <span class="na">free_params</span><span class="pi">:</span> <span class="s">...</span>
<span class="na">second_calibration_step</span><span class="pi">:</span>
  <span class="na">models</span><span class="pi">:</span> <span class="s">...</span>
  <span class="na">free_params</span><span class="pi">:</span> <span class="s">...</span>

</code></pre></div></div>

<p>The capture poses can now be specified as YAML. The <code class="language-plaintext highlighter-rouge">convert_ros1_bag_to_yaml</code> script
can be run in ROS1 to export your ROS1 bagfile as a YAML file that can be loaded in ROS2.</p>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-github">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/robot_calibration">robot_calibration</a> <small>repository</small></h3>
        <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-mikeferguson-robot_calibration
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-mikeferguson-robot_calibration" role="menuitem" tabindex="-1" href="/r/robot_calibration/github-mikeferguson-robot_calibration" data="github-mikeferguson-robot_calibration">
                    <span class="glyphicon glyphicon-star"></span>
                    github-mikeferguson-robot_calibration
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>github</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>

  <div class="distro distro-noetic">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/robot_calibration">robot_calibration</a> <small>repository</small></h3>
        <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration">robot_calibration</a>
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration_msgs">robot_calibration_msgs</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-mikeferguson-robot_calibration
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-mikeferguson-robot_calibration" role="menuitem" tabindex="-1" href="/r/robot_calibration/github-mikeferguson-robot_calibration" data="github-mikeferguson-robot_calibration">
                    <span class="glyphicon glyphicon-star"></span>
                    github-mikeferguson-robot_calibration
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Generic calibration for robots</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/mikeferguson/robot_calibration.git">https://github.com/mikeferguson/robot_calibration.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">ros1</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2023-08-29
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/robot_calibration/#noetic-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#noetic-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#noetic-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/robot_calibration">robot_calibration</a></td>
                    <td>0.7.2</td>
                  </tr>
                
                  <tr>
                    <td><a href="/p/robot_calibration_msgs">robot_calibration_msgs</a></td>
                    <td>0.7.2</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="robot-calibration">Robot Calibration</h1>

<p>This package offers ROS nodes. The primary one is called <em>calibrate</em>, and
can be used to calibrate a number of parameters of a robot, such as:</p>

<ul>
  <li>3D Camera intrinsics and extrinsics</li>
  <li>Joint angle offsets</li>
  <li>Robot frame offsets</li>
</ul>

<p>These parameters are then inserted into an updated URDF, or updated camera
configuration YAML in the case of camera intrinsics.</p>

<p>Two additional ROS nodes are used for mobile-base related parameter tuning:</p>

<ul>
  <li>
<em>base_calibration_node</em> - can determine scaling factors for gyro and track
width parameters by rotating the robot in place and tracking the actual
rotation based on the laser scanner view of a wall.</li>
  <li>
<em>magnetometer_calibration</em> - can be used to do hard iron calibration
of a magnetometer.</li>
</ul>

<h2 id="the-calibrate-node">The <em>calibrate</em> node</h2>

<p>Calibration works in two steps. The first step involves the capture of data
samples from the robot. Each “sample” comprises the measured joint positions
of the robot and two or more “observations”. An observation is a collection
of points that have been detected by a “sensor”. For instance, a robot could
use a camera and an arm to “detect” the pose of corners on a checkerboard.
In the case of the camera sensor, the collection of points is simply the
detected positions of each corner of the checkerboard, relative to the pose
of the camera reference frame. For the arm, it is assumed that the checkerboard
is fixed relative to a virtual frame which is fixed relative to the end
effector of the arm. Within the virtual frame, we know the position of each
point of the checkerboard corners.</p>

<p>The second step of calibration involves optimization of the robot parameters
to minimize the errors. Errors are defined as the difference in the pose
of the points based on reprojection through each sensor. In the case of our
checkerboard above, the transform between the virtual frame and the end
effector becomes additional free parameters. By estimating these parameters
alongside the robot parameters, we can find a set of parameters such that
the reprojection of the checkerboard corners through the arm is as closely
aligned with the reprojection through the camera (and any associated
kinematic chain, for instance, a pan/tilt head).</p>

<h3 id="configuration">Configuration</h3>

<p>Configuration is typically handled through two sets of YAML files. The first
YAML file specifies the details needed for data capture:</p>

<ul>
  <li>chains - The kinematic chains of the robot which should be controlled,
and how to control them so that we can move the robot to each desired pose
for sampling.</li>
  <li>feature_finders - The configuration for the various “feature finders” that
will be making our observations at each sample pose. Current finders include
an LED detector, checkerboard finder, and plane finder. Feature finders
are plugin-based, so you can create your own.</li>
</ul>

<p>The second configuration file specifies the configuration for optimization.
This specifies several items:</p>

<ul>
  <li>base_link - Frame used for internal calculations. Typically, the root of the
URDF is used. Often <code class="language-plaintext highlighter-rouge">base_link</code>.</li>
  <li>models - Models define how to reproject points. The basic model is a
kinematic chain. Additional models can reproject through a kinematic
chain and then a sensor, such as a 3d camera. For IK chains, <code class="language-plaintext highlighter-rouge">frame</code> parameter
is the tip of the IK chain.
    <ul>
      <li>chain - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter (which in MoveIt/KDL terms is usually referred to as the <code class="language-plaintext highlighter-rouge">tip</code>).</li>
      <li>camera3d - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter, and includes the pinhole camera model parameters (cx, cy, fx, fy)
when doing projection of the points. This model only works if your sensor
publishes CameraInfo. Further, the calibration obtained when this model is
used and any of the pinhole parameters are free parameters is only valid if
the physical sensor actually uses the CameraInfo for 3d projection (this
is generally true for the Primesense/Astra sensors).</li>
    </ul>
  </li>
  <li>free_params - Defines the names of single-value free parameters. These
can be the names of a joint for which the joint offset should be calculated,
camera parameters such as focal lengths, or other parameters, such as
driver offsets for Primesense devices.</li>
  <li>free_frames - Defines the names of multi-valued free parameters that
are 6-d transforms. Also defines which axis are free. X, Y, and Z can all
be independently set to free parameters. Roll, pitch and yaw can also be
set free, however it is important to note that because calibration
internally uses an angle-axis representation, either all 3 should be set
free, or only one should be free. You should never set two out of three
to be free parameters.</li>
  <li>free_frames_initial_values - Defines the initial values for free_frames.
X, Y, Z offsets are in meters. ROLL, PITCH, YAW are in radians. This is most
frequently used for setting the initial estimate of the checkerboard position,
see details below.</li>
  <li>error_blocks - These define the actual errors to compare during optimization.
There are several error blocks available at this time:
    <ul>
      <li>chain3d_to_chain3d - This error block can compute the difference in
reprojection between two 3D “sensors” which tell us the position of
certain features of interest. Sensors might be a 3D camera or an arm
which is holding a checkerboard. Was previously called “camera3d_to_arm”.</li>
      <li>chain3d_to_plane - This error block can compute the difference between
projected 3d points and a desired plane. The most common use case is making
sure that the ground plane a robot sees is really on the ground.</li>
      <li>plane_to_plane - This error block is able to compute the difference
between two planes. For instance, 3d cameras may not have the resolution
to actually see a checkerboard, but we can align important axis by
making sure that a wall seen by both cameras is aligned.</li>
      <li>outrageous - Sometimes, the calibration is ill-defined in certain dimensions,
and we would like to avoid one of the free parameters from becoming
absurd. An outrageous error block can be used to limit a particular
parameter.</li>
    </ul>
  </li>
</ul>

<h4 id="checkerboard-configuration">Checkerboard Configuration</h4>
<p>When using a checkerboard, we need to estimate the transformation from the
the kinematic chain to the checkerboard. Calibration will be faster and more
accurate if the initial estimate of this transformation is close to the actual
value, especially with regards to rotation.</p>

<p>The simplest way to check your initial estimate is to run the calibration with
only the six DOF of the checkerboard as free parameters. The output values will
be the X, Y, Z, and A, B, C of the transformation. It is important to note that
A, B, C are NOT roll, pitch, yaw – they are the axis-magnitude representation.
To get roll, pitch and yaw, run the <code class="language-plaintext highlighter-rouge">to_rpy</code> tool with your values of A, B,
and C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun robot_calibration to_rpy A B C

</code></pre></div></div>
<p>This will print the ROLL, PITCH, YAW values to put in for initial values. Then
insert the values in the calibration.yaml:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>free_frames_initial_values:
 - name: checkerboard
   x: 0.0
   y: 0.225
   z: 0
   roll: 0.0
   pitch: 1.571
   yaw: 0.0

</code></pre></div></div>

<h3 id="exported-results">Exported Results</h3>

<p>The exported results consist of an updated URDF file, and one or more updated
camera calibration YAML files. By default, these files will by exported into
the /tmp folder, with filenames that include a timestamp of generation. These
files need to be installed in the correct places to be properly loaded.</p>

<p>The <a href="https://github.com/fetchrobotics/fetch_ros/tree/indigo-devel/fetch_calibration">fetch_calibration</a>
package has an example python script for installing the updated files.</p>

<p>Within the updated URDF file, there are two types of exported results:</p>

<ul>
  <li>Changes to free_frames are applied as offsets in the joint origins.</li>
  <li>Changes to free_params (joint offsets) are applied as “calibration” tags
in the URDF. In particular, they are applied as “rising” tags. These
should be read by the robot drivers so that the offsets can be applied
before joint values are used for controllers. The offsets need to be added
to the joint position read from the device. The offset then typically
needs to be subtracted from the commanded position sent to the device.</li>
</ul>

<p>If your robot does not support the “calibration” tags, it might be possible
to use only free_frames, setting only the rotation in the joint axis to be
free.</p>

<h2 id="the-base_calibration_node">The <em>base_calibration_node</em>
</h2>

<p>To run the <em>base_calibration_node</em> node, you need a somewhat open space with a large
(~3 meters wide) wall that you can point the robot at. The robot should be
pointed at the wall and it will then spin around at several different speeds.
On each rotation it will stop and capture the laser data. Afterwards, the
node uses the angle of the wall as measured by the laser scanner to determine
how far the robot has actually rotated versus the measurements from the gyro
and odometry. We then compute scalar corrections for both the gyro and the
odometry.</p>

<p>Node parameters:</p>

<ul>
  <li>
<code>/base_controller/track_width</code> - this is the default track width.</li>
  <li>
<code>/imu/gyro/scale</code> - this is the initial gyro scale.</li>
  <li>
<code>~min_angle/~max_angle</code> how much of the laser scan to use when
measuring the wall angle (radians).</li>
  <li>
<code>~accel_limit</code> - acceleration limit for rotation (radians/second^2).</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/odom</code> - the node subscribes to this odom data. Message type
is <code>nav_msgs/Odometry</code>.</li>
  <li>
<code>/imu</code> - the node subscribes to this IMU data. Message type
is <code>sensor_msgs/IMU</code>.</li>
  <li>
<code>/base_scan</code> - the node subscribes to this laser data. Message type
is <code>sensor_msgs/LaserScan</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the node is a new scale for the gyro and the odometry. The application
of these values is largely dependent on the drivers being used for the robot. For
robots using <em>ros_control</em> or <em>robot_control</em> there is a track_width parameter
typically supplied as a ROS parameter in your launch file.</p>

<h2 id="the-magnetometer_calibration-node">The <em>magnetometer_calibration</em> node</h2>

<p>The <em>magnetometer_calibration</em> node records magnetometer data and can compute
the <em>hard iron</em> offsets. After calibration, the magnetometer can be used as
a compass (typically by piping the data through <em>imu_filter_madgwick</em> and
then <em>robot_localization</em>).</p>

<p>Node parameters:</p>

<ul>
  <li>
<code>~rotation_manual</code> - if set to true, the node will not publish command
velocities and the user will have to manually rotate the magnetometer. Default: false.</li>
  <li>
<code>~rotation_duration</code> - how long to rotate the robot, in seconds.</li>
  <li>
<code>~rotation_velocity</code> - the yaw velocity to rotate the robot, in rad/s.</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/imu/mag</code> - the node subscribes to this magnetometer data. Message type
is <code>sensor_msgs/MagneticField</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the calibration is three parameters, <em>mag_bias_x</em>, <em>mag_bias_y</em>,
and <em>mag_bias_z</em>, which can be used with the <code>imu_filter_madgwick</code> package.</p>

<h1 id="status">Status</h1>

<ul>
  <li>Melodic Devel Job Status: <a href="http://build.ros.org/job/Mdev__robot_calibration__ubuntu_bionic_amd64/"><img src="http://build.ros.org/buildStatus/icon?job=Mdev__robot_calibration__ubuntu_bionic_amd64" alt="Build Status"></a>
</li>
  <li>Melodic Coverage: <a href="https://codecov.io/gh/mikeferguson/robot_calibration"><img src="https://codecov.io/gh/mikeferguson/robot_calibration/branch/master/graph/badge.svg" alt="codecov"></a>
</li>
</ul>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-galactic">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/robot_calibration">robot_calibration</a> <small>repository</small></h3>
        <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-mikeferguson-robot_calibration
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-mikeferguson-robot_calibration" role="menuitem" tabindex="-1" href="/r/robot_calibration/github-mikeferguson-robot_calibration" data="github-mikeferguson-robot_calibration">
                    <span class="glyphicon glyphicon-star"></span>
                    github-mikeferguson-robot_calibration
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>galactic</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>

  <div class="distro distro-iron">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/robot_calibration">robot_calibration</a> <small>repository</small></h3>
        <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration">robot_calibration</a>
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration_msgs">robot_calibration_msgs</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-mikeferguson-robot_calibration
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-mikeferguson-robot_calibration" role="menuitem" tabindex="-1" href="/r/robot_calibration/github-mikeferguson-robot_calibration" data="github-mikeferguson-robot_calibration">
                    <span class="glyphicon glyphicon-star"></span>
                    github-mikeferguson-robot_calibration
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Generic calibration for robots</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/mikeferguson/robot_calibration.git">https://github.com/mikeferguson/robot_calibration.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">ros2</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-03-17
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/robot_calibration/#iron-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#iron-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#iron-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/robot_calibration">robot_calibration</a></td>
                    <td>0.10.0</td>
                  </tr>
                
                  <tr>
                    <td><a href="/p/robot_calibration_msgs">robot_calibration_msgs</a></td>
                    <td>0.10.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="robot-calibration">Robot Calibration</h1>

<p>This package offers several ROS2 nodes. The primary one is called <em>calibrate</em>,
and can be used to calibrate a number of parameters of a robot, such as:</p>

<ul>
  <li>3D Camera intrinsics and extrinsics</li>
  <li>Joint angle offsets</li>
  <li>Robot frame offsets</li>
</ul>

<p>These parameters are then inserted into an updated URDF, or updated camera
configuration YAML in the case of camera intrinsics.</p>

<p>Two additional ROS nodes are used for mobile-base related parameter tuning:</p>

<ul>
  <li>
<em>base_calibration_node</em> - can determine scaling factors for wheel diameter,
track width and gyro gain by moving and rotating the robot while tracking
the actual movement based on the laser scanner view of a wall.</li>
  <li>
<em>magnetometer_calibration</em> - can be used to do hard iron calibration
of a magnetometer.</li>
</ul>

<h2 id="the-calibrate-node">The <em>calibrate</em> node</h2>

<p>Calibration works in two steps. The first step involves the capture of data
samples from the robot. Each “sample” comprises the measured joint positions
of the robot and two or more “observations”. An observation is a collection
of points that have been detected by a “sensor”. For instance, a robot could
use a camera and an arm to “detect” the pose of corners on a checkerboard.
In the case of the camera sensor, the collection of points is simply the
detected positions of each corner of the checkerboard, relative to the pose
of the camera reference frame. For the arm, it is assumed that the checkerboard
is fixed relative to a virtual <code class="language-plaintext highlighter-rouge">checkerboard</code> frame which is fixed relative
to the end effector of the arm. Within the virtual frame, we know the ideal
position of each point of the checkerboard corners since the checkerboard
is of known size.</p>

<p>The second step of calibration involves optimization of the robot parameters
to minimize the errors. Errors are defined as the difference in the pose
of the points based on reprojection throuhg each sensor. In the case of our
checkerboard above, the transform between the virtual frame and the end
effector becomes additional free parameters. By estimating these parameters
alongside the robot parameters, we can find a set of parameters such that
the reprojection of the checkerboard corners through the arm is as closely
aligned with the reprojection through the camera (and any associated
kinematic chain, for instance, a pan/tilt head).</p>

<p>Configuration is typically handled through two sets of YAML files: usually
called <code class="language-plaintext highlighter-rouge">capture.yaml</code> and <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</p>

<p>If you want to manually move the robot to poses and capture each time you
hit ENTER on the keyboard, you can run robot calibration with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration calibrate --manual --ros-args --params-file path-to-capture.yaml --params-file path-to-calibrate.yaml

</code></pre></div></div>

<p>More commonly, you will generate a third YAML file with the capture pose
configuration (as documented below in the section “Calibration Poses”):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration calibrate path-to-calibration-poses.yaml --ros-args --params-file path-to-capture.yaml --params-file path-to-calibrate.yaml

</code></pre></div></div>

<p>This is often wrapped into a ROS 2 launch file, which often records
a bagfile of the observations allowing to re-run just the calibration part
instead of needing to run capture each time. For an example, see the
UBR-1 example in the next section.</p>

<h3 id="example-configuration">Example Configuration</h3>

<p>All of the parameters that can be defined in the capture and calibrate steps
are documented below, but sometimes it is just nice to have a full example.
The UBR-1 robot uses this package to calibrate in ROS2. Start with
the <code class="language-plaintext highlighter-rouge">calibrate_launch.py</code> in
<a href="https://github.com/mikeferguson/ubr_reloaded/tree/ros2/ubr1_calibration">ubr1_calibration</a>.</p>

<h3 id="capture-configuration">Capture Configuration</h3>

<p>The <code class="language-plaintext highlighter-rouge">capture.yaml</code> file specifies the details needed for data capture:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chains</code> - A parameter listing the names of the kinematic chains of the
robot which should be controlled.</li>
  <li>
<code class="language-plaintext highlighter-rouge">features</code> - A parameter listing the names of the various “feature finders”
that will be making our observations at each sample pose.</li>
</ul>

<p>Each of these chains and features is then defined by a parameter block of the
same name, for example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">robot_calibration</span><span class="pi">:</span>
  <span class="na">ros_parameters</span><span class="pi">:</span>
    <span class="c1"># List of chains</span>
    <span class="na">chains</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">arm</span>
    <span class="c1"># List of features</span>
    <span class="na">features</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">checkerboard_finder</span>
    <span class="c1"># Parameter block to define the arm chain</span>
    <span class="na">arm</span><span class="pi">:</span>
      <span class="na">topic</span><span class="pi">:</span> <span class="s">/arm_controller/follow_joint_trajectory</span>
      <span class="na">joints</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">first_joint</span>
      <span class="pi">-</span> <span class="s">second_joint</span>
    <span class="c1"># Parameter block to define the feature finder:</span>
    <span class="na">checkerboard_finder</span><span class="pi">:</span>
      <span class="na">type</span><span class="pi">:</span> <span class="s">robot_calibration::CheckerboardFinder</span>
      <span class="na">topic</span><span class="pi">:</span> <span class="s">/head_camera/depth_registered/points</span>
      <span class="na">camera_sensor_name</span><span class="pi">:</span> <span class="s">camera</span>
      <span class="na">chain_sensor_name</span><span class="pi">:</span> <span class="s">arm</span>

</code></pre></div></div>

<h4 id="chain-parameters">Chain Parameters</h4>

<p>For each chain, the following parameters can be defined:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">topic</code> - The namespace of the <code class="language-plaintext highlighter-rouge">control_msgs::FollowJointTrajectory</code>
server used to control this chain.</li>
  <li>
<code class="language-plaintext highlighter-rouge">planning_group</code> - Optional parameter, when set to a non-empty string
<code class="language-plaintext highlighter-rouge">robot_calibration</code> will call MoveIt to plan a collision free path from
the current robot pose to the next capture pose. When this parameter is
not set, the trajectory simply interpolates from the current pose to the
next capture pose without collision awareness - so you need to be careful
when defining your series of capture poses.</li>
  <li>
<code class="language-plaintext highlighter-rouge">joints</code> - A list of joints that this group comprises.</li>
</ul>

<h4 id="finder-parameters">Finder Parameters</h4>

<p>At a minimum, the following parameters must be set for all finders:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">type</code> - Name of the plugin to load.</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera_sensor_name</code> - Every finder outputs observations from some
sensor - this name must match the name used later in <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">chain_sensor_name</code> - Every finder outputs observations from some
chain - this name must match the name used later in <code class="language-plaintext highlighter-rouge">calibrate.yaml</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">debug</code> - Most finders have a debug parameter which will insert the
raw image or point cloud into the observation. This makes the capture
bagfile larger but aids in debugging.</li>
</ul>

<p>The following types are currently included with <code class="language-plaintext highlighter-rouge">robot_calibration</code>
although you can create your own plugins. Each finder has it’s own
additional parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::CheckerboardFinder</code> - Detects checkerboards in
a point cloud.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_x</code> - Number of corners in the X direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_y</code> - Number of corners in the Y direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">size</code> - Size of checkerboard squares, in meters.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::CheckerboardFinder2d</code> - Detects checkerboards in
an image:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::Image</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_x</code> - Number of corners in the X direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_y</code> - Number of corners in the Y direction of the checkerboard.</li>
      <li>
<code class="language-plaintext highlighter-rouge">size</code> - Size of checkerboard squares, in meters.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::LedFinder</code> - controls and detects a series of LEDs,
which can be a built-in alternative to having a robot hold the checkerboard.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">gripper_led_action</code> - Namespace of the gripper LED action server.</li>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_error</code> - Maximum distance detected LED can be from expected pose,
in meters.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_inconsistency</code> - Maximum relative difference between two LEDs in
the same capture pose, in meters.</li>
      <li>
<code class="language-plaintext highlighter-rouge">max_iterations</code> - Maximum number of times to toggle the LEDs for a given
capture pose.</li>
      <li>
<code class="language-plaintext highlighter-rouge">gripper_led_frame</code> - The robot link which the <code class="language-plaintext highlighter-rouge">leds</code> are defined in.</li>
      <li>
<code class="language-plaintext highlighter-rouge">leds</code> - Definition of the LED poses. For each LED, you need to specify
a <code class="language-plaintext highlighter-rouge">code</code> which is sent to the action server to turn that LED on, as well
as <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, and <code class="language-plaintext highlighter-rouge">z</code> offsets relative to <code class="language-plaintext highlighter-rouge">gripper_led_frame</code> for
the expected pose of that LED. These values will be used to generate
the chain observation.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::PlaneFinder</code> - Detects planes in a point cloud. This
will filter out points outside the limits, and then iteratively find the
largest plane until a desired one is found. This is commonly used to align
a sensor with the ground.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::PointCloud2</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">points_max</code> - Maximum number of points to use in the observation</li>
      <li>The cloud can be pre-filtered using the <code class="language-plaintext highlighter-rouge">min_x</code>, <code class="language-plaintext highlighter-rouge">max_x</code>, <code class="language-plaintext highlighter-rouge">min_y</code>,
<code class="language-plaintext highlighter-rouge">max_y</code>, <code class="language-plaintext highlighter-rouge">min_z</code>, and <code class="language-plaintext highlighter-rouge">max_z</code> parameters.</li>
      <li>The desired orientation of the plane can be used by setting <code class="language-plaintext highlighter-rouge">normal_a</code>,
<code class="language-plaintext highlighter-rouge">normal_b</code>, <code class="language-plaintext highlighter-rouge">normal_c</code> parameters - if all are 0, the biggest plane
will be selected regardless of orientation. This is particularly useful
if the robot might be looking partially at the wall as well as the desired
floor surface.</li>
      <li>
<code class="language-plaintext highlighter-rouge">normal_angle</code> - If a desired orientation vector is set, the candidate
plane normal must be within this angle of the desired normal, in radians.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">robot_calibration::ScanFinder</code> - Detects points in a laser scan, and then
repeats them vertically. This can be used to align a laser scanner against
a plane detected by a 3d camera.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">topic</code> - Name of topic of type <code class="language-plaintext highlighter-rouge">sensor_msgs::LaserScan</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">transform_frame</code> – Frame to transform the laser scan into, usually
<code class="language-plaintext highlighter-rouge">base_link</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">min_x</code>, <code class="language-plaintext highlighter-rouge">max_x</code>, <code class="language-plaintext highlighter-rouge">min_y</code>, and <code class="language-plaintext highlighter-rouge">max_y</code> are used to limit the
laser scan points that are used. They are defined in the <code class="language-plaintext highlighter-rouge">transform_frame</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">z_repeats</code> - How many times to copy the points vertically.</li>
      <li>
<code class="language-plaintext highlighter-rouge">z_offset</code> - Distance between repeated points.</li>
    </ul>
  </li>
</ul>

<p>Additionally, any finder that subscribes to a depth camera has the following parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">camera_info_topic</code>: The topic name for the camera info.</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera_driver</code>: Namespace of the camera driver, only used for Primesense-like
devices which have <code class="language-plaintext highlighter-rouge">z_offset_mm</code> and <code class="language-plaintext highlighter-rouge">z_scaling</code> parameters.</li>
</ul>

<h3 id="calibration-configuration">Calibration Configuration</h3>

<p>The <code class="language-plaintext highlighter-rouge">calibrate.yaml</code> configuration file specifies the configuration for
optimization. This specifies several items:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">base_link</code> - Frame used for internal calculations. Typically, the root of the
URDF is used. Often <code class="language-plaintext highlighter-rouge">base_link</code>.</li>
  <li>
<code class="language-plaintext highlighter-rouge">calibration_steps</code> - In ROS 2, multistep calibration is fully supported. The
parameter <code class="language-plaintext highlighter-rouge">calibration_steps</code> should be a list of step names. A majority of
calibrations probably only use a single step, but the step name must still
be in a YAML list format.</li>
</ul>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">robot_calibration</span><span class="pi">:</span>
  <span class="na">ros__parameters</span><span class="pi">:</span>
    <span class="na">base_link</span><span class="pi">:</span> <span class="s">torso_lift_link</span>
    <span class="na">calibration_steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">single_calibration_step</span>
    <span class="na">single_calibration_step</span><span class="pi">:</span>
      <span class="na">models</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">first_model</span>
      <span class="na">first_model</span><span class="pi">:</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">first_model_type</span>

</code></pre></div></div>

<p>For each calibration step, there are several parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">models</code> - List of model names. Each model will then be defined in a
parameter block defined by the name. Models define how to reproject
observation points into the fixed frame. The basic model is a
kinematic chain. Additional models can reproject through a kinematic
chain and then a sensor, such as a 3d camera. Once loaded, models
will be used by the error blocks to compute the reprojection errors
between different sensor observations.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_params</code> - Defines the names of single-value free parameters. These
can be the names of a joint for which the joint offset should be calculated,
camera parameters such as focal lengths or the driver offsets for
Primesense devices. If attempting to calibrate the length of a robot
link, use <code class="language-plaintext highlighter-rouge">free_frames</code> to define the axis that is being calibrated.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_frames</code> - Defines the names of multi-valued free parameters that
are 6-d transforms. Also defines which axis are free. X, Y, and Z can all
be independently set to free parameters. Roll, pitch and yaw can also be
set free, however it is important to note that because calibration
internally uses an angle-axis representation, either all 3 should be set
free, or only one should be free. You should never set two out of three
to be free parameters.</li>
  <li>
<code class="language-plaintext highlighter-rouge">free_frames_initial_values</code> - Defines the initial offset values for
<code class="language-plaintext highlighter-rouge">free_frames</code>. X, Y, Z offsets are in meters. ROLL, PITCH, YAW are in
radians. This is most frequently used for setting the initial estimate
of the checkerboard position, see details below.</li>
  <li>
<code class="language-plaintext highlighter-rouge">error_blocks</code> - List of error block names, which are then defined
under their own namespaces.</li>
</ul>

<p>For each model, the <code class="language-plaintext highlighter-rouge">type</code> must be specified. The type should be one of:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d</code> - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter (which in MoveIt/KDL terms is usually referred to as the <code class="language-plaintext highlighter-rouge">tip</code>).</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera3d</code> - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter, and includes the pinhole camera model parameters (cx, cy, fx, fy)
when doing projection of the points. This model only works if your sensor
publishes CameraInfo. Further, the calibration obtained when this model is
used and any of the pinhole parameters are free parameters is only valid if
the physical sensor actually uses the CameraInfo for 3d projection (this
is generally true for the Primesense/Astra sensors).</li>
  <li>
<code class="language-plaintext highlighter-rouge">camera2d</code> - Similar to <code class="language-plaintext highlighter-rouge">camera3d</code>, but for a 2d finder. Currently only
works with the output of the <code class="language-plaintext highlighter-rouge">CheckerboardFinder2d</code>.</li>
</ul>

<p>For each error block, the <code class="language-plaintext highlighter-rouge">type</code> must be specified. In addition to the
<code class="language-plaintext highlighter-rouge">type</code> parameter, each block will have additional parameters:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_chain3d</code> - The most commonly used error block type.
This error block can compute the difference in reprojection
between two 3D “sensors” which tell us the position of
certain features of interest. Sensors might be a 3D camera or an arm
which is holding a checkerboard. Was previously called “camera3d_to_arm”:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_a</code> - First <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_b</code> - Second <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_camera2d</code>- Currently only used for the <code class="language-plaintext highlighter-rouge">CheckerboardFinder2d</code>:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_2d</code> - <code class="language-plaintext highlighter-rouge">camera2d</code> model to use in computing reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_3d</code> - <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">scale</code> - Scalar to multiply summed error by - note that error computed
in this block is in <em>pixel</em> space, rather than <em>metric</em> space like most
other error blocks.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_mesh</code> - This error block type can compute the closeness between
projected 3d points and a mesh. The mesh must be part of the robot body.
This is commonly used to align the robot sensor with the base of the robot,
using points that were found by the <code class="language-plaintext highlighter-rouge">RobotFinder</code> plugin:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model</code> - <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing reprojection
error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">link_name</code> -Name of the link in the URDF for which mesh to use.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">chain3d_to_plane</code> - This error block can be used to compare projected
points to a plane. Each observation point is reprojected, then the sum
of distance to plane for each point is computed. The most common use case
is making sure that the ground plane a robot sees is really on the ground:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model</code> - The <code class="language-plaintext highlighter-rouge">camera3d</code> model for reprojection.</li>
      <li>
<code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">d</code> - Parameters for the desired plane equation, in the
form <code class="language-plaintext highlighter-rouge">ax + by + cz + d = 0</code>.</li>
      <li>
<code class="language-plaintext highlighter-rouge">scale</code> - Since the error computed is a distance from the plane over
many points, scaling the error relative to other error blocks is often
required.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">plane_to_plane</code> - This error block is able to compute the difference
between two planes. For instance, 3d cameras may not have the resolution
to actually see a checkerboard, but we can align important axis by
making sure that a wall seen by both cameras is aligned. For each observation,
the points are assumed to form a plane:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">model_a</code> - First <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">model_b</code> - Second <code class="language-plaintext highlighter-rouge">chain3d</code> or <code class="language-plaintext highlighter-rouge">camera3d</code> model to use in computing
reprojection error.</li>
      <li>
<code class="language-plaintext highlighter-rouge">normal_scale</code> - The normal error is computed as the difference between
the two plane normals and then multiplied by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">offset_scale</code> - The offset error is computed as the distance from
the centroid of the first plane to the second plane and then
multiplied by this scalar.</li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">outrageous</code> - Sometimes, the calibration is ill-defined in certain dimensions,
and we would like to avoid one of the free parameters from becoming
absurd. An outrageous error block can be used to limit a particular
parameter:
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">param</code> - Free parameter to monitor.</li>
      <li>
<code class="language-plaintext highlighter-rouge">joint_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a joint name, multiply the free param value
by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">position_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a free frame, multiply the metric distance
in X, Y, Z by this scalar.</li>
      <li>
<code class="language-plaintext highlighter-rouge">rotation_scale</code> - If <code class="language-plaintext highlighter-rouge">param</code> is a free frame, multiply the angular distance
of the free parameter value by this scalar.</li>
    </ul>
  </li>
</ul>

<h3 id="calibration-poses">Calibration Poses</h3>

<p>The final piece of configuration is the actual poses from which the robot should
capture data. This YAML file can be created by running the <code class="language-plaintext highlighter-rouge">capture_poses</code> script.
You will be prompted to move the robot to the desired pose and press ENTER, when
done collecting all of your poses, you can type EXIT.
This will create <code class="language-plaintext highlighter-rouge">calibration_poses.yaml</code> which is an array of capture poses:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-0.09211555123329163</span>
  <span class="pi">-</span> <span class="m">0.013307283632457256</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-1.747204065322876</span>
  <span class="pi">-</span> <span class="s">-0.07186950743198395</span>

</code></pre></div></div>

<p>By default, every finder is used for every capture pose. In some cases, you might
want to specify specific finders by editing the <code class="language-plaintext highlighter-rouge">features</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This sample pose uses only the `ground_plane_finder` feature finder</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">ground_plane_finder</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-0.09211555123329163</span>
  <span class="pi">-</span> <span class="m">0.013307283632457256</span>
<span class="c1"># This sample pose will use all features</span>
<span class="pi">-</span> <span class="na">features</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">joints</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">first_joint</span>
  <span class="pi">-</span> <span class="s">second_joint</span>
  <span class="na">positions</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">-1.747204065322876</span>
  <span class="pi">-</span> <span class="s">-0.07186950743198395</span>

</code></pre></div></div>

<h4 id="checkerboard-configuration">Checkerboard Configuration</h4>

<p>When using a checkerboard, we need to estimate the transformation from the
the tip of the kinematic chain to the virtual <code class="language-plaintext highlighter-rouge">checkerboard</code> frame.
Calibration will be faster and more accurate if the initial estimate of
this transformation is close to the actual
value, especially with regards to rotation.</p>

<p>The simplest way to check your initial estimate is to run the calibration with
only the six DOF of the checkerboard as free parameters. The output values will
be the X, Y, Z, and A, B, C of the transformation. It is important to note that
A, B, C are NOT roll, pitch, yaw – they are the axis-magnitude representation.
To get roll, pitch and yaw, run the <code class="language-plaintext highlighter-rouge">to_rpy</code> tool with your values of A, B,
and C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run robot_calibration to_rpy A B C

</code></pre></div></div>
<p>This will print the ROLL, PITCH, YAW values to put in for initial values. Then
insert the values in the calibration.yaml:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">free_frames_initial_values</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">checkerboard</span>
<span class="na">checkerboard_initial_values</span><span class="pi">:</span>
  <span class="na">x</span><span class="pi">:</span> <span class="m">0.0</span>
  <span class="na">y</span><span class="pi">:</span> <span class="m">0.225</span>
  <span class="na">z</span><span class="pi">:</span> <span class="m">0</span>
  <span class="na">roll</span><span class="pi">:</span> <span class="m">0.0</span>
  <span class="na">pitch</span><span class="pi">:</span> <span class="m">1.571</span>
  <span class="na">yaw</span><span class="pi">:</span> <span class="m">0.0</span>

</code></pre></div></div>

<p><a href="https://markhedleyjones.com/projects/calibration-checkerboard-collection">This tool</a>
can be helfpul for creating checkerboards.</p>

<h3 id="exported-results">Exported Results</h3>

<p>The exported results consist of an updated URDF file, and one or more updated
camera calibration YAML files. By default, these files will by exported into
the /tmp folder, with filenames that include a timestamp of generation. These
files need to be installed in the correct places to be properly loaded.</p>

<p>The <a href="https://github.com/fetchrobotics/fetch_ros/tree/indigo-devel/fetch_calibration">fetch_calibration</a>
package has an example python script for installing the updated files.</p>

<p>Within the updated URDF file, there are two types of exported results:</p>

<ul>
  <li>Changes to free_frames are applied as offsets in the joint origins.</li>
  <li>Changes to free_params (joint offsets) are applied as “calibration” tags
in the URDF. In particular, they are applied as “rising” tags. These
should be read by the robot drivers so that the offsets can be applied
before joint values are used for controllers. The offsets need to be added
to the joint position read from the device. The offset then typically
needs to be subtracted from the commanded position sent to the device.</li>
</ul>

<p>If your robot does not support the “calibration” tags, it might be possible
to use only free_frames, setting only the rotation in the joint axis to be
free.</p>

<h2 id="the-base_calibration_node">The <em>base_calibration_node</em>
</h2>

<p>To run the <em>base_calibration_node</em> node, you need a somewhat open space with a large
(~3 meters wide) wall that you can point the robot at.</p>

<p>Starting with the <code class="language-plaintext highlighter-rouge">0.10</code> release of <code class="language-plaintext highlighter-rouge">robot_calibration</code>, the actual movements the
robot does can be programmed via the <code class="language-plaintext highlighter-rouge">calibration_steps</code> parameter:</p>

<ul>
  <li>
<code>calibration_steps</code> - should be a list of string names of calibration
steps to run.</li>
  <li>
<code>step_name/type</code> - should be either <code class="language-plaintext highlighter-rouge">spin</code> or <code class="language-plaintext highlighter-rouge">rollout</code>.</li>
  <li>
<code>step_name/velocity</code> - velocity to move the robot. This will be
interpreted as angular velocity for <code class="language-plaintext highlighter-rouge">spin</code> steps and linear velocity for <code class="language-plaintext highlighter-rouge">rollout</code>
steps.</li>
  <li>
<code>step_name/rotations</code> - only valid for <code class="language-plaintext highlighter-rouge">spin</code> steps. Number of
rotations to complete at given <code class="language-plaintext highlighter-rouge">velocity</code>.</li>
  <li>
<code>step_name/distance</code> - only valid for <code class="language-plaintext highlighter-rouge">rollout</code> steps. Distance
in meters, to rollout the robot.</li>
</ul>

<p>Additional parameters:</p>

<ul>
  <li>
<code>accel_limit</code> - acceleration limit for <code class="language-plaintext highlighter-rouge">spin</code> steps (radians/second^2).</li>
  <li>
<code>linear_accel_limit</code> - acceleration limit for <code class="language-plaintext highlighter-rouge">rollout</code> steps (meters/second^2).</li>
  <li>
<code>min_angle/max_angle</code> how much of the laser scan to use when
measuring the wall angle (radians).</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/odom</code> - the node subscribes to this odom data. Message type
is <code>nav_msgs/Odometry</code>.</li>
  <li>
<code>/imu</code> - the node subscribes to this IMU data. Message type
is <code>sensor_msgs/IMU</code>.</li>
  <li>
<code>/base_scan</code> - the node subscribes to this laser data. Message type
is <code>sensor_msgs/LaserScan</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the node is a series of scalars to apply (where a value of 1.0 means
there is currently no error):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[base_calibration_node-1] track_width_scale: 0.986743
[base_calibration_node-1] imu_scale: 0.984465
[base_calibration_node-1] rollout_scale: 0.981911

</code></pre></div></div>

<p>The application of these values is largely dependent on the drivers being used
for the robot. For robots using <em>ros_control</em> or <em>robot_control</em> there is a
<code class="language-plaintext highlighter-rouge">track_width</code> parameter typically supplied as a ROS parameter in your launch file.</p>

<p>Note: in ROS 1, these scalars were pre-multiplied by the existing <code class="language-plaintext highlighter-rouge">track_width</code>
or <code class="language-plaintext highlighter-rouge">imu_scale</code> - however, with the lack of a unified parameter server in ROS 2,
this is no longer done.</p>

<h2 id="the-magnetometer_calibration-node">The <em>magnetometer_calibration</em> node</h2>

<p>The <em>magnetometer_calibration</em> node records magnetometer data and can compute
the <em>hard iron</em> offsets. After calibration, the magnetometer can be used as
a compass (typically by piping the data through <em>imu_filter_madgwick</em> and
then <em>robot_localization</em>).</p>

<p>Node parameters:</p>

<ul>
  <li>
<code>~rotation_manual</code> - if set to true, the node will not publish command
velocities and the user will have to manually rotate the magnetometer. Default: false.</li>
  <li>
<code>~rotation_duration</code> - how long to rotate the robot, in seconds.</li>
  <li>
<code>~rotation_velocity</code> - the yaw velocity to rotate the robot, in rad/s.</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/imu/mag</code> - the node subscribes to this magnetometer data. Message type
is <code>sensor_msgs/MagneticField</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the calibration is three parameters, <em>mag_bias_x</em>, <em>mag_bias_y</em>,
and <em>mag_bias_z</em>, which can be used with the <code>imu_filter_madgwick</code> package.</p>

<h3 id="migrating-from-ros1">Migrating from ROS1</h3>

<p>There are a number of changes in migrating from ROS1 to ROS2. Some of these are
due to differences in the ROS2 system, others are to finally cleanup mistakes
made in earlier version of robot_calibration.</p>

<p>The <code class="language-plaintext highlighter-rouge">chains</code>, <code class="language-plaintext highlighter-rouge">models</code>, <code class="language-plaintext highlighter-rouge">free_frames</code> and <code class="language-plaintext highlighter-rouge">features</code> parameters used to be lists of YAML
dictionaries. That format is not easily supported in ROS2 and so they are now
lists of string names and the actual dictionaries of information appear under
the associated name. For instance, in ROS1, you might have:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">models</span><span class="pi">:</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">arm</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">chain</span>
   <span class="na">frame</span><span class="pi">:</span> <span class="s">wrist_roll_link</span>
 <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">camera</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">camera3d</span>
   <span class="na">frame</span><span class="pi">:</span> <span class="s">head_camera_rgb_optical_frame</span>

</code></pre></div></div>

<p>In ROS2, this becomes:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">models</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">arm</span>
<span class="pi">-</span> <span class="s">camera</span>
<span class="na">arm</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">chain3d</span>
  <span class="na">frame</span><span class="pi">:</span> <span class="s">wrist_roll_link</span>
<span class="na">camera</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">camera3d</span>
  <span class="na">frame</span><span class="pi">:</span> <span class="s">head_camera_rgb_optical_frame</span>

</code></pre></div></div>

<p>NOTE: the “chain” type has been renamed “chain3d” in ROS2 for consistency (and to allow
a future chain2d).</p>

<p>Multi-step calibration is now fully supported. A new parameter, <code class="language-plaintext highlighter-rouge">calibration_steps</code> must
be declared as a list of step names. The <code class="language-plaintext highlighter-rouge">models</code> and free parameters are then specified
for each step. As an example:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">calibration_steps</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">first_calibration_step</span>
<span class="pi">-</span> <span class="s">second_calibration_step</span>
<span class="na">first_calibration_step</span><span class="pi">:</span>
  <span class="na">models</span><span class="pi">:</span> <span class="s">...</span>
  <span class="na">free_params</span><span class="pi">:</span> <span class="s">...</span>
<span class="na">second_calibration_step</span><span class="pi">:</span>
  <span class="na">models</span><span class="pi">:</span> <span class="s">...</span>
  <span class="na">free_params</span><span class="pi">:</span> <span class="s">...</span>

</code></pre></div></div>

<p>The capture poses can now be specified as YAML. The <code class="language-plaintext highlighter-rouge">convert_ros1_bag_to_yaml</code> script
can be run in ROS1 to export your ROS1 bagfile as a YAML file that can be loaded in ROS2.</p>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-melodic">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/robot_calibration">robot_calibration</a> <small>repository</small></h3>
        <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration">robot_calibration</a>
        
        <a class="label label-primary pkg-label" href="/p/robot_calibration_msgs">robot_calibration_msgs</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-mikeferguson-robot_calibration
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-mikeferguson-robot_calibration" role="menuitem" tabindex="-1" href="/r/robot_calibration/github-mikeferguson-robot_calibration" data="github-mikeferguson-robot_calibration">
                    <span class="glyphicon glyphicon-star"></span>
                    github-mikeferguson-robot_calibration
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Generic calibration for robots</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/mikeferguson/robot_calibration.git">https://github.com/mikeferguson/robot_calibration.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">ros1</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2023-08-29
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robot</span> <span class="label label-default">ros</span> <span class="label label-default">calibration</span> <span class="label label-default">ros2</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/robot_calibration/#melodic-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#melodic-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/robot_calibration/#melodic-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/robot_calibration">robot_calibration</a></td>
                    <td>0.7.2</td>
                  </tr>
                
                  <tr>
                    <td><a href="/p/robot_calibration_msgs">robot_calibration_msgs</a></td>
                    <td>0.7.2</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="robot-calibration">Robot Calibration</h1>

<p>This package offers ROS nodes. The primary one is called <em>calibrate</em>, and
can be used to calibrate a number of parameters of a robot, such as:</p>

<ul>
  <li>3D Camera intrinsics and extrinsics</li>
  <li>Joint angle offsets</li>
  <li>Robot frame offsets</li>
</ul>

<p>These parameters are then inserted into an updated URDF, or updated camera
configuration YAML in the case of camera intrinsics.</p>

<p>Two additional ROS nodes are used for mobile-base related parameter tuning:</p>

<ul>
  <li>
<em>base_calibration_node</em> - can determine scaling factors for gyro and track
width parameters by rotating the robot in place and tracking the actual
rotation based on the laser scanner view of a wall.</li>
  <li>
<em>magnetometer_calibration</em> - can be used to do hard iron calibration
of a magnetometer.</li>
</ul>

<h2 id="the-calibrate-node">The <em>calibrate</em> node</h2>

<p>Calibration works in two steps. The first step involves the capture of data
samples from the robot. Each “sample” comprises the measured joint positions
of the robot and two or more “observations”. An observation is a collection
of points that have been detected by a “sensor”. For instance, a robot could
use a camera and an arm to “detect” the pose of corners on a checkerboard.
In the case of the camera sensor, the collection of points is simply the
detected positions of each corner of the checkerboard, relative to the pose
of the camera reference frame. For the arm, it is assumed that the checkerboard
is fixed relative to a virtual frame which is fixed relative to the end
effector of the arm. Within the virtual frame, we know the position of each
point of the checkerboard corners.</p>

<p>The second step of calibration involves optimization of the robot parameters
to minimize the errors. Errors are defined as the difference in the pose
of the points based on reprojection through each sensor. In the case of our
checkerboard above, the transform between the virtual frame and the end
effector becomes additional free parameters. By estimating these parameters
alongside the robot parameters, we can find a set of parameters such that
the reprojection of the checkerboard corners through the arm is as closely
aligned with the reprojection through the camera (and any associated
kinematic chain, for instance, a pan/tilt head).</p>

<h3 id="configuration">Configuration</h3>

<p>Configuration is typically handled through two sets of YAML files. The first
YAML file specifies the details needed for data capture:</p>

<ul>
  <li>chains - The kinematic chains of the robot which should be controlled,
and how to control them so that we can move the robot to each desired pose
for sampling.</li>
  <li>feature_finders - The configuration for the various “feature finders” that
will be making our observations at each sample pose. Current finders include
an LED detector, checkerboard finder, and plane finder. Feature finders
are plugin-based, so you can create your own.</li>
</ul>

<p>The second configuration file specifies the configuration for optimization.
This specifies several items:</p>

<ul>
  <li>base_link - Frame used for internal calculations. Typically, the root of the
URDF is used. Often <code class="language-plaintext highlighter-rouge">base_link</code>.</li>
  <li>models - Models define how to reproject points. The basic model is a
kinematic chain. Additional models can reproject through a kinematic
chain and then a sensor, such as a 3d camera. For IK chains, <code class="language-plaintext highlighter-rouge">frame</code> parameter
is the tip of the IK chain.
    <ul>
      <li>chain - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter (which in MoveIt/KDL terms is usually referred to as the <code class="language-plaintext highlighter-rouge">tip</code>).</li>
      <li>camera3d - Represents a kinematic chain from the <code class="language-plaintext highlighter-rouge">base_link</code> to the <code class="language-plaintext highlighter-rouge">frame</code>
parameter, and includes the pinhole camera model parameters (cx, cy, fx, fy)
when doing projection of the points. This model only works if your sensor
publishes CameraInfo. Further, the calibration obtained when this model is
used and any of the pinhole parameters are free parameters is only valid if
the physical sensor actually uses the CameraInfo for 3d projection (this
is generally true for the Primesense/Astra sensors).</li>
    </ul>
  </li>
  <li>free_params - Defines the names of single-value free parameters. These
can be the names of a joint for which the joint offset should be calculated,
camera parameters such as focal lengths, or other parameters, such as
driver offsets for Primesense devices.</li>
  <li>free_frames - Defines the names of multi-valued free parameters that
are 6-d transforms. Also defines which axis are free. X, Y, and Z can all
be independently set to free parameters. Roll, pitch and yaw can also be
set free, however it is important to note that because calibration
internally uses an angle-axis representation, either all 3 should be set
free, or only one should be free. You should never set two out of three
to be free parameters.</li>
  <li>free_frames_initial_values - Defines the initial values for free_frames.
X, Y, Z offsets are in meters. ROLL, PITCH, YAW are in radians. This is most
frequently used for setting the initial estimate of the checkerboard position,
see details below.</li>
  <li>error_blocks - These define the actual errors to compare during optimization.
There are several error blocks available at this time:
    <ul>
      <li>chain3d_to_chain3d - This error block can compute the difference in
reprojection between two 3D “sensors” which tell us the position of
certain features of interest. Sensors might be a 3D camera or an arm
which is holding a checkerboard. Was previously called “camera3d_to_arm”.</li>
      <li>chain3d_to_plane - This error block can compute the difference between
projected 3d points and a desired plane. The most common use case is making
sure that the ground plane a robot sees is really on the ground.</li>
      <li>plane_to_plane - This error block is able to compute the difference
between two planes. For instance, 3d cameras may not have the resolution
to actually see a checkerboard, but we can align important axis by
making sure that a wall seen by both cameras is aligned.</li>
      <li>outrageous - Sometimes, the calibration is ill-defined in certain dimensions,
and we would like to avoid one of the free parameters from becoming
absurd. An outrageous error block can be used to limit a particular
parameter.</li>
    </ul>
  </li>
</ul>

<h4 id="checkerboard-configuration">Checkerboard Configuration</h4>
<p>When using a checkerboard, we need to estimate the transformation from the
the kinematic chain to the checkerboard. Calibration will be faster and more
accurate if the initial estimate of this transformation is close to the actual
value, especially with regards to rotation.</p>

<p>The simplest way to check your initial estimate is to run the calibration with
only the six DOF of the checkerboard as free parameters. The output values will
be the X, Y, Z, and A, B, C of the transformation. It is important to note that
A, B, C are NOT roll, pitch, yaw – they are the axis-magnitude representation.
To get roll, pitch and yaw, run the <code class="language-plaintext highlighter-rouge">to_rpy</code> tool with your values of A, B,
and C:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun robot_calibration to_rpy A B C

</code></pre></div></div>
<p>This will print the ROLL, PITCH, YAW values to put in for initial values. Then
insert the values in the calibration.yaml:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>free_frames_initial_values:
 - name: checkerboard
   x: 0.0
   y: 0.225
   z: 0
   roll: 0.0
   pitch: 1.571
   yaw: 0.0

</code></pre></div></div>

<h3 id="exported-results">Exported Results</h3>

<p>The exported results consist of an updated URDF file, and one or more updated
camera calibration YAML files. By default, these files will by exported into
the /tmp folder, with filenames that include a timestamp of generation. These
files need to be installed in the correct places to be properly loaded.</p>

<p>The <a href="https://github.com/fetchrobotics/fetch_ros/tree/indigo-devel/fetch_calibration">fetch_calibration</a>
package has an example python script for installing the updated files.</p>

<p>Within the updated URDF file, there are two types of exported results:</p>

<ul>
  <li>Changes to free_frames are applied as offsets in the joint origins.</li>
  <li>Changes to free_params (joint offsets) are applied as “calibration” tags
in the URDF. In particular, they are applied as “rising” tags. These
should be read by the robot drivers so that the offsets can be applied
before joint values are used for controllers. The offsets need to be added
to the joint position read from the device. The offset then typically
needs to be subtracted from the commanded position sent to the device.</li>
</ul>

<p>If your robot does not support the “calibration” tags, it might be possible
to use only free_frames, setting only the rotation in the joint axis to be
free.</p>

<h2 id="the-base_calibration_node">The <em>base_calibration_node</em>
</h2>

<p>To run the <em>base_calibration_node</em> node, you need a somewhat open space with a large
(~3 meters wide) wall that you can point the robot at. The robot should be
pointed at the wall and it will then spin around at several different speeds.
On each rotation it will stop and capture the laser data. Afterwards, the
node uses the angle of the wall as measured by the laser scanner to determine
how far the robot has actually rotated versus the measurements from the gyro
and odometry. We then compute scalar corrections for both the gyro and the
odometry.</p>

<p>Node parameters:</p>

<ul>
  <li>
<code>/base_controller/track_width</code> - this is the default track width.</li>
  <li>
<code>/imu/gyro/scale</code> - this is the initial gyro scale.</li>
  <li>
<code>~min_angle/~max_angle</code> how much of the laser scan to use when
measuring the wall angle (radians).</li>
  <li>
<code>~accel_limit</code> - acceleration limit for rotation (radians/second^2).</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/odom</code> - the node subscribes to this odom data. Message type
is <code>nav_msgs/Odometry</code>.</li>
  <li>
<code>/imu</code> - the node subscribes to this IMU data. Message type
is <code>sensor_msgs/IMU</code>.</li>
  <li>
<code>/base_scan</code> - the node subscribes to this laser data. Message type
is <code>sensor_msgs/LaserScan</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the node is a new scale for the gyro and the odometry. The application
of these values is largely dependent on the drivers being used for the robot. For
robots using <em>ros_control</em> or <em>robot_control</em> there is a track_width parameter
typically supplied as a ROS parameter in your launch file.</p>

<h2 id="the-magnetometer_calibration-node">The <em>magnetometer_calibration</em> node</h2>

<p>The <em>magnetometer_calibration</em> node records magnetometer data and can compute
the <em>hard iron</em> offsets. After calibration, the magnetometer can be used as
a compass (typically by piping the data through <em>imu_filter_madgwick</em> and
then <em>robot_localization</em>).</p>

<p>Node parameters:</p>

<ul>
  <li>
<code>~rotation_manual</code> - if set to true, the node will not publish command
velocities and the user will have to manually rotate the magnetometer. Default: false.</li>
  <li>
<code>~rotation_duration</code> - how long to rotate the robot, in seconds.</li>
  <li>
<code>~rotation_velocity</code> - the yaw velocity to rotate the robot, in rad/s.</li>
</ul>

<p>Node topics:</p>

<ul>
  <li>
<code>/imu/mag</code> - the node subscribes to this magnetometer data. Message type
is <code>sensor_msgs/MagneticField</code>.</li>
  <li>
<code>/cmd_vel</code> - the node publishes rotation commands to this topic, unless
manual mode is enabled. Message type is <code>geometry_msgs/Twist</code>.</li>
</ul>

<p>The output of the calibration is three parameters, <em>mag_bias_x</em>, <em>mag_bias_y</em>,
and <em>mag_bias_z</em>, which can be used with the <code>imu_filter_madgwick</code> package.</p>

<h1 id="status">Status</h1>

<ul>
  <li>Melodic Devel Job Status: <a href="http://build.ros.org/job/Mdev__robot_calibration__ubuntu_bionic_amd64/"><img src="http://build.ros.org/buildStatus/icon?job=Mdev__robot_calibration__ubuntu_bionic_amd64" alt="Build Status"></a>
</li>
  <li>Melodic Coverage: <a href="https://codecov.io/gh/mikeferguson/robot_calibration"><img src="https://codecov.io/gh/mikeferguson/robot_calibration/branch/master/graph/badge.svg" alt="codecov"></a>
</li>
</ul>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>


<script src=/js/contribution_suggestions.js></script>
<script type="text/javascript">
  $(function() {
    setupContributeListTabLinks();
  });
  $(document).ready(function() {
    setupDistroSwitch("humble");
    setupContributeLists("https://github.com/mikeferguson/robot_calibration.git");
  });
</script>

      </div>
    </div>

    <footer class="site-footer">
  <div class="wrapper">
    <div class="container-fluid">
      <div style="float:left;">
        
          <a href="https://github.com/rkent/rosindex" title="Find rosindex in Github">
          <span class="icon  icon--github">
            <svg viewBox="0 0 16 16">
              <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
            </svg>
          </span>

          <span class="username">rkent/rosindex</span>
        </a>
        <em class="hidden-xs">| generated on 2025-05-05</em>
      
      </div>
      <div style="float:right;">
        <p class="text"><span class="hidden-xs">a community-maintained index of robotics software
 | </span><a href="/privacy.txt">privacy</a></p>
      </div>
    </div>
  </div>

</footer>


  </body>

</html>
