<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>ROS Index</title>
    <meta name="description" content="a community-maintained index of robotics software
">

    
    <link rel="canonical" href="http://index.rosdabbler.com/r/ruckig/">
    
    
    <link rel="icon" sizes="any" type="image/svg+xml" href="/assets/rosindex_logo.svg">

    

    <link rel="stylesheet" type="text/css" href="/bootstrap/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="/css/main.css">
    

    

    <script type="text/javascript" src=/js/jquery.js></script>
    <script src=/bootstrap/js/bootstrap.min.js type="text/javascript"></script>
    <script src=/js/jquery-cookie.js type="text/javascript"></script>
    
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EVD5Z6G6NH"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EVD5Z6G6NH');
</script>

    <script type="text/javascript" src=/js/toc.js></script>

    <script src=/js/distro_switch.js></script>
  </head>

  <body>

    <header class="site-header">

  <div class="wrapper">
    <div class="container-fluid" style="margin-bottom: 10px">
      <div class="row">
        <!-- title -->
        <div class="col-xs-3" style="white-space:nowrap">
          <a class="site-title" href="/">
            <img src="/assets/rosindex_logo.svg" width="26" height="26" alt="ROS index logo" style="padding-bottom: 3px"/>
            ROS Index</a>
        </div>
        <!-- main internal links -->
        <div class="col-xs-6 text-center" style="padding:0px">
          <div class="btn-group hidden-xs" role="group" aria-label="..." style="padding: 6px">
            <div class="btn-group" role="group">
              <a href="/?search_packages=true" class="btn btn-default" role="button">Package List</a>
            </div>
            <div class="btn-group" role="group">
              <a href="/?search_repos=true" class="btn btn-default" role="button">Repository List</a>
            </div>
            <div class="btn-group" role="group">
              <a href="/search_deps" class="btn btn-default" role="button">System Dependencies</a>
            </div>
          </div>
          <div class="hidden-lg hidden-md hidden-sm">
            <button id="hLabel" class="btn btn-link dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
              Lists <span class="caret"></span>
            </button>
            <ul class="dropdown-menu" aria-labelledby="hLabel">
              <li><a href="/?search_packages=true">Package List</a></li>
              <li><a href="/?search_repos=true">Repository List</a></li>
              <li><a href="/search_deps">System Dependencies</a></li>
            </ul>
          </div>
        </div>
        <!-- additional links -->
        <div class="col-xs-3 text-right" style="white-space:nowrap; padding:0px">
          <ul class="list-inline" style="margin-bottom:0px;">
            <li class="dropdown hidden-xs hidden-sm">
              <button id="rLabel" class="btn btn-link" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                ROS Resources <span class="caret"></span>
              </button>
              <ul class="dropdown-menu" role="menu" aria-labelledby="rLabel">
                <li><a href="http://docs.ros.org/">Documentation</a></li>
                <li><a href="http://wiki.ros.org/Support">Support</a></li>
                <li><a href="http://discourse.ros.org/">Discussion Forum</a></li>
                <li><a href="http://status.ros.org/">Service Status</a></li>
                <li><a href="https://robotics.stackexchange.com/questions/tagged/ros">ros @ Robotics Stack Exchange</a></li>
                <li><a href="https://docs.ros.org/en/ros2_packages/">Package API</a></li>
              </ul>
            </li>
            <li class="dropdown hidden-xs hidden-sm">
              <button id="aLabel" class="btn btn-link" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                About <span class="caret"></span>
              </button>
              <ul class="dropdown-menu dropdown-menu-right" role="menu" aria-labelledby="aLabel">
                <li><a href="/about">About </a></li>
                <li><a href="/contribute">Contribute</a></li>
                <li><a href="/help">Help</a></li>
                <li><a href="/stats">Stats</a></li>
              </ul>
            </li>
            <li class="dropdown hidden-md hidden-lg">
              <button id="qLabel" class="btn btn-link" type="button"
                      data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                Resources <span class="caret"></span>
              </button>
              <ul class="dropdown-menu dropdown-menu-right" role="menu" aria-labelledby="qLabel">
                <li><a href="/about">About </a></li>
                <li><a href="/contribute">Contribute</a></li>
                <li><a href="/help">Help</a></li>
                <li><a href="/stats">Stats</a></li>
                <hr style="margin:7px" />
                <li><a href="http://docs.ros.org/">Documentation</a></li>
                <li><a href="http://wiki.ros.org/Support">Support</a></li>
                <li><a href="http://discourse.ros.org/">Discussion Forum</a></li>
                <li><a href="http://status.ros.org/">Service Status</a></li>
                <li><a href="https://robotics.stackexchange.com/questions/tagged/ros">ros @ Robotics Stack Exchange</a></li>
                <li><a href="https://docs.ros.org/en/ros2_packages/">Package API</a></li>
              </ul>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="container-fluid" style="margin-top:20px">
  <div class="container-fluid">
    <div class="row">
      <ol class="breadcrumb">
        <li><a href="/">Home</a></li>
        <li><a href="/repos">Repos</a></li>
        <li class="active">ruckig</li>
        <!--<li class="active">ruckig</li>-->
      </ol>
    </div>
    <div class="row">
      

<div id="distro-switch" class="btn-group btn-group-justified" data-toggle="buttons">
  
    <label id="humble-option" class="distro-button btn btn-xs btn-primary" href="#humble" data="humble">
      <input type="radio" name="options" id="humble-radio" autocomplete="off"> humble
    </label>
  
    <label id="jazzy-option" class="distro-button btn btn-xs btn-primary" href="#jazzy" data="jazzy">
      <input type="radio" name="options" id="jazzy-radio" autocomplete="off"> jazzy
    </label>
  
    <label id="kilted-option" class="distro-button btn btn-xs btn-primary" href="#kilted" data="kilted">
      <input type="radio" name="options" id="kilted-radio" autocomplete="off"> kilted
    </label>
  
    <label id="rolling-option" class="distro-button btn btn-xs btn-primary" href="#rolling" data="rolling">
      <input type="radio" name="options" id="rolling-radio" autocomplete="off"> rolling
    </label>
  
    <label id="github-option" class="distro-button btn btn-xs btn-default" href="#github" data="github">
      <input type="radio" name="options" id="github-radio" autocomplete="off"> github
    </label>
  
    <label id="noetic-option" class="distro-button btn btn-xs btn-default" href="#noetic" data="noetic">
      <input type="radio" name="options" id="noetic-radio" autocomplete="off"> noetic
    </label>
  

  <!-- Older distros -->
  <div class="btn-group dropdown">
    <label type="button" class="btn btn-xs dropdown-toggle btn-primary" data-toggle="dropdown" id="older-distro-button">
        <input type="radio" name="options" autocomplete="off">
      <span id="older-label">Older</span>
      <span class="caret"></span>
    </label>
    <ul class="dropdown-menu" role="menu">
      
        <li data="galactic" id="galactic-option" class="disabled older-distro-option"  href="#galactic">
          <a href="#galactic" data="galactic" id="galactic-button">galactic</a>
        </li>
      
        <li data="iron" id="iron-option" class=" older-distro-option"  href="#iron">
          <a href="#iron" data="iron" id="iron-button">iron</a>
        </li>
      
        <li data="melodic" id="melodic-option" class="disabled older-distro-option"  href="#melodic">
          <a href="#melodic" data="melodic" id="melodic-button">melodic</a>
        </li>
      
    </ul>
  </div>
</div>

    </div>
    <div class="row">
      &nbsp;
    </div>
  </div>
</div>


  <div class="distro distro-humble">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/ruckig">ruckig</a> <small>repository</small></h3>
        <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        
        <a class="label label-primary pkg-label" href="/p/ruckig">ruckig</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-pantor-ruckig
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-pantor-ruckig" role="menuitem" tabindex="-1" href="/r/ruckig/github-pantor-ruckig" data="github-pantor-ruckig">
                    <span class="glyphicon glyphicon-star"></span>
                    github-pantor-ruckig
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Motion Generation for Robots and Machines. Real-time. Jerk-constrained. Time-optimal.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/pantor/ruckig.git">https://github.com/pantor/ruckig.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">main</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-04-19
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/ruckig/#humble-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/ruckig/#humble-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/ruckig/#humble-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/ruckig">ruckig</a></td>
                    <td>0.14.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<div align="center">
  <h1 align="center">Ruckig</h1>
  <h3 align="center">
    Instantaneous Motion Generation for Robots and Machines.
  </h3>
</div>
<p align="center">
  <a href="https://github.com/pantor/ruckig/actions">
    <img src="https://github.com/pantor/ruckig/workflows/CI/badge.svg" alt="CI">
  </a>
  <a href="https://github.com/pantor/ruckig/issues">
    <img src="https://img.shields.io/github/issues/pantor/ruckig.svg" alt="Issues">
  </a>
  <a href="https://github.com/pantor/ruckig/releases">
    <img src="https://img.shields.io/github/v/release/pantor/ruckig.svg?include_prereleases&amp;sort=semver" alt="Releases">
  </a>
  <a href="https://github.com/pantor/ruckig/blob/main/LICENSE">
    <img src="https://img.shields.io/badge/license-MIT-green.svg" alt="MIT">
  </a>
</p>

<p>Ruckig generates trajectories on-the-fly, allowing robots and machines to react instantaneously to sensor input. Ruckig calculates a trajectory to a <em>target</em> waypoint (with position, velocity, and acceleration) starting from <em>any</em> initial state limited by velocity, acceleration, and jerk constraints. Besides the target state, Ruckig allows to define intermediate positions for waypoint following. For state-to-state motions, Ruckig guarantees a time-optimal solution. With intermediate waypoints, Ruckig calculates the path and its time parametrization jointly, resulting in significantly faster trajectories compared to traditional methods.</p>

<p>More information can be found at <a href="https://ruckig.com">ruckig.com</a> and in the corresponding paper <a href="https://arxiv.org/abs/2105.04830">Jerk-limited Real-time Trajectory Generation with Arbitrary Target States</a>, accepted for the <em>Robotics: Science and Systems (RSS), 2021</em> conference.</p>

<h2 id="installation">Installation</h2>

<p>Ruckig has no dependencies (except for testing). To build Ruckig using CMake, just run</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> build
<span class="nb">cd </span>build
cmake <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Release ..
make

</code></pre></div></div>

<p>To install Ruckig in a system-wide directory, you can either use <code class="language-plaintext highlighter-rouge">(sudo) make install</code> or install it as debian package using cpack by running</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cpack
<span class="nb">sudo </span>dpkg <span class="nt">-i</span> ruckig<span class="k">*</span>.deb

</code></pre></div></div>

<p>An example of using Ruckig in your CMake project is given by <code class="language-plaintext highlighter-rouge">examples/CMakeLists.txt</code>. However, you can also include Ruckig as a directory within your project and call <code class="language-plaintext highlighter-rouge">add_subdirectory(ruckig)</code> in your parent <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>.</p>

<p>Ruckig is also available as a Python module, in particular for development or debugging purposes. The Ruckig <em>Community Version</em> can be installed from <a href="https://pypi.org/project/ruckig/">PyPI</a> via</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>ruckig

</code></pre></div></div>
<p>When using CMake, the Python module can be built using the <code class="language-plaintext highlighter-rouge">BUILD_PYTHON_MODULE</code> flag. If you’re only interested in the Python module (and not in the C++ library), you can build and install Ruckig via <code class="language-plaintext highlighter-rouge">pip install .</code>.</p>

<h2 id="tutorial">Tutorial</h2>

<p>Furthermore, we will explain the basics to get started with online generated trajectories within your application. There is also a <a href="https://docs.ruckig.com/pages.html">collection of examples</a> that guide you through the most important features of Ruckig. A time-optimal trajectory for a single degree of freedom is shown in the figure below. We also added plots of the resulting trajectories for all examples. Let’s get started!</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/example_profile.png?raw=true" alt="Trajectory Profile"></p>

<h3 id="waypoint-based-trajectory-generation">Waypoint-based Trajectory Generation</h3>

<p>Ruckig provides three main interface classes: the <em>Ruckig</em>, the <em>InputParameter</em>, and the <em>OutputParameter</em> class.</p>

<p>First, you’ll need to create a Ruckig instance with the number of DoFs as a template parameter, and the control cycle (e.g. in seconds) in the constructor.</p>

<pre><code class="language-.cpp">Ruckig&lt;6&gt; ruckig {0.001}; // Number DoFs; control cycle in [s]

</code></pre>

<p>The input type has 3 blocks of data: the <em>current</em> state, the <em>target</em> state and the corresponding kinematic <em>limits</em>.</p>

<pre><code class="language-.cpp">InputParameter&lt;6&gt; input; // Number DoFs
input.current_position = {0.2, ...};
input.current_velocity = {0.1, ...};
input.current_acceleration = {0.1, ...};
input.target_position = {0.5, ...};
input.target_velocity = {-0.1, ...};
input.target_acceleration = {0.2, ...};
input.max_velocity = {0.4, ...};
input.max_acceleration = {1.0, ...};
input.max_jerk = {4.0, ...};

OutputParameter&lt;6&gt; output; // Number DoFs

</code></pre>

<p>If you only want to have a acceleration-constrained trajectory, you can also omit the <code class="language-plaintext highlighter-rouge">max_jerk</code> as well as the <code class="language-plaintext highlighter-rouge">current</code> and <code class="language-plaintext highlighter-rouge">target_acceleration</code> value. Given all input and output resources, we can iterate over the trajectory at each discrete time step. For most applications, this loop must run within a real-time thread and controls the actual hardware.</p>

<pre><code class="language-.cpp">while (ruckig.update(input, output) == Result::Working) {
  // Make use of the new state here!
  // e.g. robot-&gt;setJointPositions(output.new_position);

  output.pass_to_input(input); // Don't forget this!
}

</code></pre>

<p>Within the control loop, you need to update the <em>current state</em> of the input parameter according to the calculated trajectory. Therefore, the <code class="language-plaintext highlighter-rouge">pass_to_input</code> method copies the new kinematic state of the output to the current kinematic state of the input parameter. If (in the next step) the current state is not the expected, pre-calculated trajectory, Ruckig will calculate a new trajectory based on the novel input. When the trajectory has reached the target state, the <code class="language-plaintext highlighter-rouge">update</code> function will return <code class="language-plaintext highlighter-rouge">Result::Finished</code>.</p>

<h3 id="intermediate-waypoints">Intermediate Waypoints</h3>

<p>The Ruckig Community Version includes built-in support for intermediate waypoints, using our cloud API for remote calculation. Of course, the Ruckig Pro version is fully local. To allocate the necessary memory for a variable number of waypoints beforehand, we need to pass the maximum number of waypoints to Ruckig via</p>

<pre><code class="language-.cpp">Ruckig&lt;6&gt; otg {0.001, 8};
InputParameter&lt;6&gt; input {8};
OutputParameter&lt;6&gt; output {8};

</code></pre>
<p>The <code class="language-plaintext highlighter-rouge">InputParameter</code> class takes the number of waypoints as an optional input, however usually you will fill in the values (and therefore reserve its memory) yourself. Then you’re ready to set intermediate via points by</p>

<pre><code class="language-.cpp">input.intermediate_positions = {
  {0.2, ...},
  {0.8, ...},
};

</code></pre>
<p>As soon as at least one intermediate positions is given, the Ruckig Community Version switches to the mentioned (of course, non real-time capable) cloud API. If you require real-time calculation on your own hardware, please contact us for the <em>Ruckig Pro Version</em>.</p>

<p>When using <em>intermediate positions</em>, both the underlying motion planning problem as well as its calculation changes significantly. In particular, there are some fundamental limitations for jerk-limited online trajectory generation regarding the usage of waypoints. Please find more information about these limitations <a href="https://docs.ruckig.com/md_pages_2__intermediate__waypoints.html">here</a>, and in general we recommend to use</p>

<pre><code class="language-.cpp">input.intermediate_positions = otg.filter_intermediate_positions(input.intermediate_positions, {0.1, ...});

</code></pre>
<p>to filter waypoints according to a (high) threshold distance. Setting <em>interrupt_calculation_duration</em> makes sure to be real-time capable by refining the solution in the next control invocation. Note that this is a soft interruption of the calculation. Currently, no minimum or discrete durations are supported when using intermediate positions.</p>

<h3 id="input-parameter">Input Parameter</h3>

<p>To go into more detail, the <em>InputParameter</em> type has following members:</p>

<pre><code class="language-.cpp">using Vector = std::array&lt;double, DOFs&gt;; // By default

Vector current_position;
Vector current_velocity; // Initialized to zero
Vector current_acceleration; // Initialized to zero

std::vector&lt;Vector&gt; intermediate_positions; // (only in Pro Version)

Vector target_position;
Vector target_velocity; // Initialized to zero
Vector target_acceleration; // Initialized to zero

Vector max_velocity;
Vector max_acceleration;
Vector max_jerk; // Initialized to infinity

std::optional&lt;Vector&gt; min_velocity; // If not given, the negative maximum velocity will be used.
std::optional&lt;Vector&gt; min_acceleration; // If not given, the negative maximum acceleration will be used.

std::optional&lt;Vector&gt; min_position; // (only in Pro Version)
std::optional&lt;Vector&gt; max_position; // (only in Pro Version)

std::array&lt;bool, DOFs&gt; enabled; // Initialized to true
std::optional&lt;double&gt; minimum_duration;
std::optional&lt;double&gt; interrupt_calculation_duration; // [µs], (only in Pro Version)

ControlInterface control_interface; // The default position interface controls the full kinematic state.
Synchronization synchronization; // Synchronization behavior of multiple DoFs
DurationDiscretization duration_discretization; // Whether the duration should be a discrete multiple of the control cycle (off by default)

std::optional&lt;Vector&lt;ControlInterface&gt;&gt; per_dof_control_interface; // Sets the control interface for each DoF individually, overwrites global control_interface
std::optional&lt;Vector&lt;Synchronization&gt;&gt; per_dof_synchronization; // Sets the synchronization for each DoF individually, overwrites global synchronization

</code></pre>

<p>On top of the current state, target state, and constraints, Ruckig allows for a few more advanced settings:</p>
<ul>
  <li>A <em>minimum</em> velocity and acceleration can be specified - these should be a negative number. If they are not given, the negative maximum velocity or acceleration will be used (similar to the jerk limit). For example, this might be useful in human robot collaboration settings with a different velocity limit towards a human. Or, when switching between different moving coordinate frames like picking from a conveyer belt.</li>
  <li>You can overwrite the global kinematic limits to specify limits for each section between two waypoints separately by using e.g. <code class="language-plaintext highlighter-rouge">per_section_max_velocity</code>.</li>
  <li>If a DoF is not <em>enabled</em>, it will be ignored in the calculation. Ruckig will output a trajectory with constant acceleration for those DoFs.</li>
  <li>A <em>minimum duration</em> can be optionally given. Note that Ruckig can not guarantee an exact, but only a minimum duration of the trajectory.</li>
  <li>The control interface (position or velocity control) can be switched easily. For example, a stop trajectory or visual servoing can be easily implemented with the velocity interface.</li>
  <li>Different synchronization behaviors (i.a. phase, time, or no synchonization) are implemented. Phase synchronization results in straight-line motions.</li>
  <li>The trajectory duration might be constrained to a multiple of the control cycle. This way, the <em>exact</em> state can be reached at a control loop execution.</li>
</ul>

<p>We refer to the <a href="https://docs.ruckig.com/namespaceruckig.html">API documentation</a> of the enumerations within the <code class="language-plaintext highlighter-rouge">ruckig</code> namespace for all available options.</p>

<h3 id="input-validation">Input Validation</h3>

<p>To check that Ruckig is able to generate a trajectory before the actual calculation step,</p>

<pre><code class="language-.cpp">ruckig.validate_input(input, check_current_state_within_limits=false, check_target_state_within_limits=true);
// returns true or throws

</code></pre>
<p>throws an error with a detailed reason if an input is not valid. You can also set the default template parameter to false via <code class="language-plaintext highlighter-rouge">ruckig.validate_input&lt;false&gt;(...)</code> to just return a boolean true or false. The two boolean arguments check that the current or target state are within the limits. The check includes a typical catch of jerk-limited trajectory generation: When the current state is at maximal velocity, any positive acceleration will inevitable lead to a velocity violation <em>at a future timestep</em>. In general, this condition is fulfilled when</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Abs(acceleration) &lt;= Sqrt(2 * max_jerk * (max_velocity - Abs(velocity))).

</code></pre></div></div>
<p>If both arguments are set to true, the calculated trajectory is guaranteed to be <em>within the kinematic limits throughout</em> its duration. Also, note that there are range constraints of the input due to numerical reasons, see below for more details.</p>

<h3 id="result-type">Result Type</h3>

<p>The <code class="language-plaintext highlighter-rouge">update</code> function of the Ruckig class returns a Result type that indicates the current state of the algorithm. This can either be <strong>working</strong>, <strong>finished</strong> if the trajectory has finished, or an <strong>error</strong> type if something went wrong during calculation. The result type can be compared as a standard integer.</p>

<table>
  <thead>
    <tr>
      <th>State</th>
      <th>Error Code</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Working</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Finished</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Error</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>ErrorInvalidInput</td>
      <td>-100</td>
    </tr>
    <tr>
      <td>ErrorTrajectoryDuration</td>
      <td>-101</td>
    </tr>
    <tr>
      <td>ErrorPositionalLimits</td>
      <td>-102</td>
    </tr>
    <tr>
      <td>ErrorExecutionTimeCalculation</td>
      <td>-110</td>
    </tr>
    <tr>
      <td>ErrorSynchronizationCalculation</td>
      <td>-111</td>
    </tr>
  </tbody>
</table>

<h3 id="output-parameter">Output Parameter</h3>

<p>The output class includes the new kinematic state and the overall trajectory.</p>

<pre><code class="language-.cpp">Vector new_position;
Vector new_velocity;
Vector new_acceleration;

Trajectory trajectory; // The current trajectory
double time; // The current, auto-incremented time. Reset to 0 at a new calculation.

size_t new_section; // Index of the section between two (possibly filtered) intermediate positions.
bool did_section_change; // Was a new section reached in the last cycle?

bool new_calculation; // Whether a new calculation was performed in the last cycle
bool was_calculation_interrupted; // Was the trajectory calculation interrupted? (only in Pro Version)
double calculation_duration; // Duration of the calculation in the last cycle [µs]

</code></pre>
<p>Moreover, the <strong>trajectory</strong> class has a range of useful parameters and methods.</p>

<pre><code class="language-.cpp">double duration; // Duration of the trajectory
std::array&lt;double, DOFs&gt; independent_min_durations; // Time-optimal profile for each independent DoF

&lt;...&gt; at_time(double time); // Get the kinematic state of the trajectory at a given time
&lt;...&gt; get_position_extrema(); // Returns information about the position extrema and their times

</code></pre>
<p>Again, we refer to the <a href="https://docs.ruckig.com">API documentation</a> for the exact signatures.</p>

<h3 id="offline-calculation">Offline Calculation</h3>

<p>Ruckig also supports an offline approach for calculating a trajectory:</p>

<pre><code class="language-.cpp">result = ruckig.calculate(input, trajectory);

</code></pre>
<p>When only using this method, the <code class="language-plaintext highlighter-rouge">Ruckig</code> constructor does not need a control cycle (<code class="language-plaintext highlighter-rouge">delta_time</code>) as an argument. However if given, Ruckig supports stepping through the trajectory with</p>

<pre><code class="language-.cpp">while (ruckig.update(trajectory, output) == Result::Working) {
  // Make use of the new state here!
  // e.g. robot-&gt;setJointPositions(output.new_position);
}

</code></pre>
<p>starting from the current <code class="language-plaintext highlighter-rouge">output.time</code> (currently Ruckig Pro only).</p>

<h3 id="tracking-interface">Tracking Interface</h3>

<p>When following an arbitrary signal with position, velocity, acceleration, and jerk-limitation, the straight forward way would be to pass the current state to Ruckig’s target state. However, as the resulting trajectory will take time to catch up, this approach will always lag behind the signal. The tracking interface solves this problem by predicting ahead (e.g. with constant acceleration by default) and is therefore able to follow signals very closely in a time-optimal way. This might be very helpful for (general) tracking, robot servoing, or trajectory post-processing applications.</p>

<p>To use the tracking interface, construct</p>

<pre><code class="language-.cpp">Trackig&lt;1&gt; otg {0.01};  // control cycle

</code></pre>
<p>and set the current state as well as the kinematic constraints via</p>

<pre><code class="language-.cpp">input.current_position = {0.0};
input.current_velocity = {0.0};
input.current_acceleration = {0.0};
input.max_velocity = {0.8};
input.max_acceleration = {2.0};
input.max_jerk = {5.0};

</code></pre>
<p>Then, we can track a signal in an online manner within the real-time control loop</p>

<pre><code class="language-.cpp">for (double t = 0; t &lt; 10.0; t += otg.delta_time) {
  auto target_state = signal(t); // signal returns position, velocity, and acceleration
  auto res = otg.update(target_state, input, output);
  // Make use of the smooth target motion here (e.g. output.new_position)

  output.pass_to_input(input);
}

</code></pre>
<p>Please find a complete example <a href="https://github.com/pantor/ruckig/blob/main/examples/13_tracking.cpp">here</a>. This functionality can also be used in an offline manner, e.g. when the entire signal is known beforehand. Here, we call the</p>

<pre><code class="language-.cpp">smooth_trajectory = otg.calculate_trajectory(target_states, input);

</code></pre>
<p>method with the trajectory given as a <code class="language-plaintext highlighter-rouge">std::vector</code> of target states. The Tracking interface is available in the Ruckig Pro version.</p>

<h3 id="dynamic-number-of-degrees-of-freedom">Dynamic Number of Degrees of Freedom</h3>

<p>So far, we have told Ruckig the number of DoFs as a template parameter. If you don’t know the number of DoFs at compile-time, you can set the template parameter to <code class="language-plaintext highlighter-rouge">ruckig::DynamicDOFs</code> and pass the DoFs to the constructor:</p>

<pre><code class="language-.cpp">Ruckig&lt;DynamicDOFs&gt; otg {6, 0.001};
InputParameter&lt;DynamicDOFs&gt; input {6};
OutputParameter&lt;DynamicDOFs&gt; output {6};

</code></pre>

<p>This switches the default Vector from the <code class="language-plaintext highlighter-rouge">std::array</code> to the dynamic <code class="language-plaintext highlighter-rouge">std::vector</code> type. However, we recommend to keep the template parameter when possible: First, it has a performance benefit of a few percent. Second, it is convenient for real-time programming due to its easier handling of memory allocations. When using dynamic degrees of freedom, make sure to allocate the memory of all vectors beforehand.</p>

<h3 id="custom-vector-types">Custom Vector Types</h3>

<p>Ruckig supports custom vector types to make interfacing with your code even easier and more flexible. Most importantly, you can switch to <a href="https://eigen.tuxfamily.org">Eigen Vectors</a> simply by including Eigen (3.4 or later) before Ruckig</p>

<pre><code class="language-.cpp">#include &lt;Eigen/Core&gt; // Version 3.4 or later
#include &lt;ruckig/ruckig.hpp&gt;

</code></pre>
<p>and then call the constructors with the <code class="language-plaintext highlighter-rouge">ruckig::EigenVector</code> parameter.</p>

<pre><code class="language-.cpp">Ruckig&lt;6, EigenVector&gt; otg {0.001};
InputParameter&lt;6, EigenVector&gt; input;
OutputParameter&lt;6, EigenVector&gt; output;

</code></pre>
<p>Now every in- and output of Ruckig’s API (such as <code class="language-plaintext highlighter-rouge">current_position</code>, <code class="language-plaintext highlighter-rouge">new_position</code> or <code class="language-plaintext highlighter-rouge">max_jerk</code>) are Eigen types! To define completely custom vector types, you can pass a C++ <a href="https://en.cppreference.com/w/cpp/language/template_parameters">template template parameter</a> to the constructor. This template template parameter needs to fulfill a range of template arguments and methods:</p>

<pre><code class="language-.cpp">template&lt;class Type, size_t DOFs&gt;
struct MinimalVector {
  Type operator[](size_t i) const; // Array [] getter
  Type&amp; operator[](size_t i); // Array [] setter
  size_t size() const; // Current size
  bool operator==(const MinimalVector&lt;T, DOFs&gt;&amp; rhs) const; // Equal comparison operator

  // Only required in combination with DynamicDOFs, e.g. to allocate memory
  void resize(size_t size);
};

</code></pre>
<p>Note that <code class="language-plaintext highlighter-rouge">DynamicDOFs</code> corresponds to <code class="language-plaintext highlighter-rouge">DOFs = 0</code>. We’ve included a range of examples for using Ruckig with <a href="https://github.com/pantor/ruckig/blob/main/examples/10_eigen_vector_type.cpp">(10) Eigen</a>, <a href="https://github.com/pantor/ruckig/blob/main/examples/11_custom_vector_type.cpp">(11) custom vector types</a>, and <a href="https://github.com/pantor/ruckig/blob/main/examples/12_custom_vector_type_dynamic_dofs.cpp">(12) custom types with a dynamic number of DoFs</a>.</p>

<h2 id="tests-and-numerical-stability">Tests and Numerical Stability</h2>

<p>The current test suite validates over 5.000.000.000 random trajectories as well as many additional edge cases. The numerical exactness is tested for the final position and final velocity to be within <code class="language-plaintext highlighter-rouge">1e-8</code>, for the final acceleration to be within <code class="language-plaintext highlighter-rouge">1e-10</code>, and for the velocity, acceleration and jerk limit to be within of a numerical error of <code class="language-plaintext highlighter-rouge">1e-12</code>. These are absolute values - we suggest to scale your input so that these correspond to your required precision of the system. For example, for most real-world systems we suggest to use input values in <code class="language-plaintext highlighter-rouge">[m]</code> (instead of e.g. <code class="language-plaintext highlighter-rouge">[mm]</code>), as <code class="language-plaintext highlighter-rouge">1e-8m</code> is sufficient precise for practical trajectory generation. Furthermore, all kinematic limits should be below <code class="language-plaintext highlighter-rouge">1e9</code>. The maximal supported trajectory duration is <code class="language-plaintext highlighter-rouge">7e3</code>. Note that Ruckig will also output values outside of this range, there is however no guarantee for correctness.</p>

<p>The Ruckig Pro version has additional tools to increase the numerical range and improve reliability. For example, the<code class="language-plaintext highlighter-rouge">position_scale</code> and <code class="language-plaintext highlighter-rouge">time_scale</code> parameter of the <code class="language-plaintext highlighter-rouge">Calculator</code> class change the internal representation of the input parameters.</p>

<pre><code class="language-.cpp">Ruckig&lt;1&gt; otg;
// Works also for Trackig&lt;1&gt; otg;

otg.calculator.position_scale = 1e2;  // Scales all positions in the input parameters
otg.calculator.time_scale = 1e3;  // Scale all times in the input parameters

</code></pre>
<p>This way, you can easily achieve the requirements above even for very high jerk limits or very long trajectories. Note that the scale parameters don’t effect the resulting trajectory - they are for internal calculation only.</p>

<h2 id="benchmark">Benchmark</h2>

<p>We find that Ruckig is more than twice as fast as Reflexxes Type IV for state-to-state motions and well-suited for control cycles as low as 250 microseconds. The Ruckig <em>Community Version</em> is in general a more powerful and open-source alternative to the <a href="http://reflexxes.ws/">Reflexxes Type IV</a> library. In fact, Ruckig is the first Type V trajectory generator for arbitrary target states and even supports directional velocity and acceleration limits, while also being faster on top.</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/benchmark.png?raw=true" alt="Benchmark"></p>

<p>For trajectories with intermediate waypoints, we compare Ruckig to <a href="https://github.com/hungpham2511/toppra">Toppra</a>, a state-of-the-art library for robotic motion planning. Ruckig is able to improve the trajectory duration on average by around 10%, as the path planning and time parametrization are calculated jointly. Moreover, Ruckig is real-time capable and supports jerk-constraints.</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/ruckig_toppra_example.png?raw=true" alt="Benchmark"></p>

<h2 id="development">Development</h2>

<p>Ruckig is written in C++17. It is continuously tested on <code class="language-plaintext highlighter-rouge">ubuntu-latest</code>, <code class="language-plaintext highlighter-rouge">macos-latest</code>, and <code class="language-plaintext highlighter-rouge">windows-latest</code> against following versions</p>

<ul>
  <li>Doctest v2.4 (only for testing)</li>
  <li>Nanobind v2.4 (only for Python wrapper)</li>
</ul>

<p>A C++11 and C++03 version of Ruckig is also available - please contact us if you’re interested.</p>

<h2 id="used-by">Used By</h2>

<p>Ruckig is used by over hundred research labs, companies, and open-source projects worldwide, including:</p>
<ul>
  <li>
<a href="https://moveit.ros.org">MoveIt 2</a> for trajectory generation.</li>
  <li>
<a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> starting from version 4.3.</li>
  <li><a href="https://flr.io">Fuzzy Logic Robotics</a></li>
  <li><a href="https://www.gestalt-robotics.com">Gestalt Robotics</a></li>
  <li>
<a href="https://github.com/stefanbesler/struckig">Struckig</a>, a port of Ruckig to Structered Text (ST - IEC61131-3) for usage on PLCs.</li>
  <li>
<a href="https://www.scanlab.de/de">Scanlab</a> for controlling lasers.</li>
  <li>
<a href="https://github.com/pantor/frankx">Frankx</a> for controlling the Franka Emika robot arm.</li>
  <li>
<a href="https://wiredworks.com">Wiredworks</a> made a simple Kivy <a href="https://github.com/wiredworks/ruckig-showcase">GUI application</a>
</li>
  <li>and many others!</li>
</ul>

<h2 id="citation">Citation</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@article{berscheid2021jerk,
  title={Jerk-limited Real-time Trajectory Generation with Arbitrary Target States},
  author={Berscheid, Lars and Kr{\"o}ger, Torsten},
  journal={Robotics: Science and Systems XVII},
  year={2021}
}

</code></pre></div></div>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-jazzy">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/ruckig">ruckig</a> <small>repository</small></h3>
        <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        
        <a class="label label-primary pkg-label" href="/p/ruckig">ruckig</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-pantor-ruckig
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-pantor-ruckig" role="menuitem" tabindex="-1" href="/r/ruckig/github-pantor-ruckig" data="github-pantor-ruckig">
                    <span class="glyphicon glyphicon-star"></span>
                    github-pantor-ruckig
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Motion Generation for Robots and Machines. Real-time. Jerk-constrained. Time-optimal.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/pantor/ruckig.git">https://github.com/pantor/ruckig.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">main</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-04-19
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/ruckig/#jazzy-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/ruckig/#jazzy-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/ruckig/#jazzy-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/ruckig">ruckig</a></td>
                    <td>0.14.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<div align="center">
  <h1 align="center">Ruckig</h1>
  <h3 align="center">
    Instantaneous Motion Generation for Robots and Machines.
  </h3>
</div>
<p align="center">
  <a href="https://github.com/pantor/ruckig/actions">
    <img src="https://github.com/pantor/ruckig/workflows/CI/badge.svg" alt="CI">
  </a>
  <a href="https://github.com/pantor/ruckig/issues">
    <img src="https://img.shields.io/github/issues/pantor/ruckig.svg" alt="Issues">
  </a>
  <a href="https://github.com/pantor/ruckig/releases">
    <img src="https://img.shields.io/github/v/release/pantor/ruckig.svg?include_prereleases&amp;sort=semver" alt="Releases">
  </a>
  <a href="https://github.com/pantor/ruckig/blob/main/LICENSE">
    <img src="https://img.shields.io/badge/license-MIT-green.svg" alt="MIT">
  </a>
</p>

<p>Ruckig generates trajectories on-the-fly, allowing robots and machines to react instantaneously to sensor input. Ruckig calculates a trajectory to a <em>target</em> waypoint (with position, velocity, and acceleration) starting from <em>any</em> initial state limited by velocity, acceleration, and jerk constraints. Besides the target state, Ruckig allows to define intermediate positions for waypoint following. For state-to-state motions, Ruckig guarantees a time-optimal solution. With intermediate waypoints, Ruckig calculates the path and its time parametrization jointly, resulting in significantly faster trajectories compared to traditional methods.</p>

<p>More information can be found at <a href="https://ruckig.com">ruckig.com</a> and in the corresponding paper <a href="https://arxiv.org/abs/2105.04830">Jerk-limited Real-time Trajectory Generation with Arbitrary Target States</a>, accepted for the <em>Robotics: Science and Systems (RSS), 2021</em> conference.</p>

<h2 id="installation">Installation</h2>

<p>Ruckig has no dependencies (except for testing). To build Ruckig using CMake, just run</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> build
<span class="nb">cd </span>build
cmake <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Release ..
make

</code></pre></div></div>

<p>To install Ruckig in a system-wide directory, you can either use <code class="language-plaintext highlighter-rouge">(sudo) make install</code> or install it as debian package using cpack by running</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cpack
<span class="nb">sudo </span>dpkg <span class="nt">-i</span> ruckig<span class="k">*</span>.deb

</code></pre></div></div>

<p>An example of using Ruckig in your CMake project is given by <code class="language-plaintext highlighter-rouge">examples/CMakeLists.txt</code>. However, you can also include Ruckig as a directory within your project and call <code class="language-plaintext highlighter-rouge">add_subdirectory(ruckig)</code> in your parent <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>.</p>

<p>Ruckig is also available as a Python module, in particular for development or debugging purposes. The Ruckig <em>Community Version</em> can be installed from <a href="https://pypi.org/project/ruckig/">PyPI</a> via</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>ruckig

</code></pre></div></div>
<p>When using CMake, the Python module can be built using the <code class="language-plaintext highlighter-rouge">BUILD_PYTHON_MODULE</code> flag. If you’re only interested in the Python module (and not in the C++ library), you can build and install Ruckig via <code class="language-plaintext highlighter-rouge">pip install .</code>.</p>

<h2 id="tutorial">Tutorial</h2>

<p>Furthermore, we will explain the basics to get started with online generated trajectories within your application. There is also a <a href="https://docs.ruckig.com/pages.html">collection of examples</a> that guide you through the most important features of Ruckig. A time-optimal trajectory for a single degree of freedom is shown in the figure below. We also added plots of the resulting trajectories for all examples. Let’s get started!</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/example_profile.png?raw=true" alt="Trajectory Profile"></p>

<h3 id="waypoint-based-trajectory-generation">Waypoint-based Trajectory Generation</h3>

<p>Ruckig provides three main interface classes: the <em>Ruckig</em>, the <em>InputParameter</em>, and the <em>OutputParameter</em> class.</p>

<p>First, you’ll need to create a Ruckig instance with the number of DoFs as a template parameter, and the control cycle (e.g. in seconds) in the constructor.</p>

<pre><code class="language-.cpp">Ruckig&lt;6&gt; ruckig {0.001}; // Number DoFs; control cycle in [s]

</code></pre>

<p>The input type has 3 blocks of data: the <em>current</em> state, the <em>target</em> state and the corresponding kinematic <em>limits</em>.</p>

<pre><code class="language-.cpp">InputParameter&lt;6&gt; input; // Number DoFs
input.current_position = {0.2, ...};
input.current_velocity = {0.1, ...};
input.current_acceleration = {0.1, ...};
input.target_position = {0.5, ...};
input.target_velocity = {-0.1, ...};
input.target_acceleration = {0.2, ...};
input.max_velocity = {0.4, ...};
input.max_acceleration = {1.0, ...};
input.max_jerk = {4.0, ...};

OutputParameter&lt;6&gt; output; // Number DoFs

</code></pre>

<p>If you only want to have a acceleration-constrained trajectory, you can also omit the <code class="language-plaintext highlighter-rouge">max_jerk</code> as well as the <code class="language-plaintext highlighter-rouge">current</code> and <code class="language-plaintext highlighter-rouge">target_acceleration</code> value. Given all input and output resources, we can iterate over the trajectory at each discrete time step. For most applications, this loop must run within a real-time thread and controls the actual hardware.</p>

<pre><code class="language-.cpp">while (ruckig.update(input, output) == Result::Working) {
  // Make use of the new state here!
  // e.g. robot-&gt;setJointPositions(output.new_position);

  output.pass_to_input(input); // Don't forget this!
}

</code></pre>

<p>Within the control loop, you need to update the <em>current state</em> of the input parameter according to the calculated trajectory. Therefore, the <code class="language-plaintext highlighter-rouge">pass_to_input</code> method copies the new kinematic state of the output to the current kinematic state of the input parameter. If (in the next step) the current state is not the expected, pre-calculated trajectory, Ruckig will calculate a new trajectory based on the novel input. When the trajectory has reached the target state, the <code class="language-plaintext highlighter-rouge">update</code> function will return <code class="language-plaintext highlighter-rouge">Result::Finished</code>.</p>

<h3 id="intermediate-waypoints">Intermediate Waypoints</h3>

<p>The Ruckig Community Version includes built-in support for intermediate waypoints, using our cloud API for remote calculation. Of course, the Ruckig Pro version is fully local. To allocate the necessary memory for a variable number of waypoints beforehand, we need to pass the maximum number of waypoints to Ruckig via</p>

<pre><code class="language-.cpp">Ruckig&lt;6&gt; otg {0.001, 8};
InputParameter&lt;6&gt; input {8};
OutputParameter&lt;6&gt; output {8};

</code></pre>
<p>The <code class="language-plaintext highlighter-rouge">InputParameter</code> class takes the number of waypoints as an optional input, however usually you will fill in the values (and therefore reserve its memory) yourself. Then you’re ready to set intermediate via points by</p>

<pre><code class="language-.cpp">input.intermediate_positions = {
  {0.2, ...},
  {0.8, ...},
};

</code></pre>
<p>As soon as at least one intermediate positions is given, the Ruckig Community Version switches to the mentioned (of course, non real-time capable) cloud API. If you require real-time calculation on your own hardware, please contact us for the <em>Ruckig Pro Version</em>.</p>

<p>When using <em>intermediate positions</em>, both the underlying motion planning problem as well as its calculation changes significantly. In particular, there are some fundamental limitations for jerk-limited online trajectory generation regarding the usage of waypoints. Please find more information about these limitations <a href="https://docs.ruckig.com/md_pages_2__intermediate__waypoints.html">here</a>, and in general we recommend to use</p>

<pre><code class="language-.cpp">input.intermediate_positions = otg.filter_intermediate_positions(input.intermediate_positions, {0.1, ...});

</code></pre>
<p>to filter waypoints according to a (high) threshold distance. Setting <em>interrupt_calculation_duration</em> makes sure to be real-time capable by refining the solution in the next control invocation. Note that this is a soft interruption of the calculation. Currently, no minimum or discrete durations are supported when using intermediate positions.</p>

<h3 id="input-parameter">Input Parameter</h3>

<p>To go into more detail, the <em>InputParameter</em> type has following members:</p>

<pre><code class="language-.cpp">using Vector = std::array&lt;double, DOFs&gt;; // By default

Vector current_position;
Vector current_velocity; // Initialized to zero
Vector current_acceleration; // Initialized to zero

std::vector&lt;Vector&gt; intermediate_positions; // (only in Pro Version)

Vector target_position;
Vector target_velocity; // Initialized to zero
Vector target_acceleration; // Initialized to zero

Vector max_velocity;
Vector max_acceleration;
Vector max_jerk; // Initialized to infinity

std::optional&lt;Vector&gt; min_velocity; // If not given, the negative maximum velocity will be used.
std::optional&lt;Vector&gt; min_acceleration; // If not given, the negative maximum acceleration will be used.

std::optional&lt;Vector&gt; min_position; // (only in Pro Version)
std::optional&lt;Vector&gt; max_position; // (only in Pro Version)

std::array&lt;bool, DOFs&gt; enabled; // Initialized to true
std::optional&lt;double&gt; minimum_duration;
std::optional&lt;double&gt; interrupt_calculation_duration; // [µs], (only in Pro Version)

ControlInterface control_interface; // The default position interface controls the full kinematic state.
Synchronization synchronization; // Synchronization behavior of multiple DoFs
DurationDiscretization duration_discretization; // Whether the duration should be a discrete multiple of the control cycle (off by default)

std::optional&lt;Vector&lt;ControlInterface&gt;&gt; per_dof_control_interface; // Sets the control interface for each DoF individually, overwrites global control_interface
std::optional&lt;Vector&lt;Synchronization&gt;&gt; per_dof_synchronization; // Sets the synchronization for each DoF individually, overwrites global synchronization

</code></pre>

<p>On top of the current state, target state, and constraints, Ruckig allows for a few more advanced settings:</p>
<ul>
  <li>A <em>minimum</em> velocity and acceleration can be specified - these should be a negative number. If they are not given, the negative maximum velocity or acceleration will be used (similar to the jerk limit). For example, this might be useful in human robot collaboration settings with a different velocity limit towards a human. Or, when switching between different moving coordinate frames like picking from a conveyer belt.</li>
  <li>You can overwrite the global kinematic limits to specify limits for each section between two waypoints separately by using e.g. <code class="language-plaintext highlighter-rouge">per_section_max_velocity</code>.</li>
  <li>If a DoF is not <em>enabled</em>, it will be ignored in the calculation. Ruckig will output a trajectory with constant acceleration for those DoFs.</li>
  <li>A <em>minimum duration</em> can be optionally given. Note that Ruckig can not guarantee an exact, but only a minimum duration of the trajectory.</li>
  <li>The control interface (position or velocity control) can be switched easily. For example, a stop trajectory or visual servoing can be easily implemented with the velocity interface.</li>
  <li>Different synchronization behaviors (i.a. phase, time, or no synchonization) are implemented. Phase synchronization results in straight-line motions.</li>
  <li>The trajectory duration might be constrained to a multiple of the control cycle. This way, the <em>exact</em> state can be reached at a control loop execution.</li>
</ul>

<p>We refer to the <a href="https://docs.ruckig.com/namespaceruckig.html">API documentation</a> of the enumerations within the <code class="language-plaintext highlighter-rouge">ruckig</code> namespace for all available options.</p>

<h3 id="input-validation">Input Validation</h3>

<p>To check that Ruckig is able to generate a trajectory before the actual calculation step,</p>

<pre><code class="language-.cpp">ruckig.validate_input(input, check_current_state_within_limits=false, check_target_state_within_limits=true);
// returns true or throws

</code></pre>
<p>throws an error with a detailed reason if an input is not valid. You can also set the default template parameter to false via <code class="language-plaintext highlighter-rouge">ruckig.validate_input&lt;false&gt;(...)</code> to just return a boolean true or false. The two boolean arguments check that the current or target state are within the limits. The check includes a typical catch of jerk-limited trajectory generation: When the current state is at maximal velocity, any positive acceleration will inevitable lead to a velocity violation <em>at a future timestep</em>. In general, this condition is fulfilled when</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Abs(acceleration) &lt;= Sqrt(2 * max_jerk * (max_velocity - Abs(velocity))).

</code></pre></div></div>
<p>If both arguments are set to true, the calculated trajectory is guaranteed to be <em>within the kinematic limits throughout</em> its duration. Also, note that there are range constraints of the input due to numerical reasons, see below for more details.</p>

<h3 id="result-type">Result Type</h3>

<p>The <code class="language-plaintext highlighter-rouge">update</code> function of the Ruckig class returns a Result type that indicates the current state of the algorithm. This can either be <strong>working</strong>, <strong>finished</strong> if the trajectory has finished, or an <strong>error</strong> type if something went wrong during calculation. The result type can be compared as a standard integer.</p>

<table>
  <thead>
    <tr>
      <th>State</th>
      <th>Error Code</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Working</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Finished</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Error</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>ErrorInvalidInput</td>
      <td>-100</td>
    </tr>
    <tr>
      <td>ErrorTrajectoryDuration</td>
      <td>-101</td>
    </tr>
    <tr>
      <td>ErrorPositionalLimits</td>
      <td>-102</td>
    </tr>
    <tr>
      <td>ErrorExecutionTimeCalculation</td>
      <td>-110</td>
    </tr>
    <tr>
      <td>ErrorSynchronizationCalculation</td>
      <td>-111</td>
    </tr>
  </tbody>
</table>

<h3 id="output-parameter">Output Parameter</h3>

<p>The output class includes the new kinematic state and the overall trajectory.</p>

<pre><code class="language-.cpp">Vector new_position;
Vector new_velocity;
Vector new_acceleration;

Trajectory trajectory; // The current trajectory
double time; // The current, auto-incremented time. Reset to 0 at a new calculation.

size_t new_section; // Index of the section between two (possibly filtered) intermediate positions.
bool did_section_change; // Was a new section reached in the last cycle?

bool new_calculation; // Whether a new calculation was performed in the last cycle
bool was_calculation_interrupted; // Was the trajectory calculation interrupted? (only in Pro Version)
double calculation_duration; // Duration of the calculation in the last cycle [µs]

</code></pre>
<p>Moreover, the <strong>trajectory</strong> class has a range of useful parameters and methods.</p>

<pre><code class="language-.cpp">double duration; // Duration of the trajectory
std::array&lt;double, DOFs&gt; independent_min_durations; // Time-optimal profile for each independent DoF

&lt;...&gt; at_time(double time); // Get the kinematic state of the trajectory at a given time
&lt;...&gt; get_position_extrema(); // Returns information about the position extrema and their times

</code></pre>
<p>Again, we refer to the <a href="https://docs.ruckig.com">API documentation</a> for the exact signatures.</p>

<h3 id="offline-calculation">Offline Calculation</h3>

<p>Ruckig also supports an offline approach for calculating a trajectory:</p>

<pre><code class="language-.cpp">result = ruckig.calculate(input, trajectory);

</code></pre>
<p>When only using this method, the <code class="language-plaintext highlighter-rouge">Ruckig</code> constructor does not need a control cycle (<code class="language-plaintext highlighter-rouge">delta_time</code>) as an argument. However if given, Ruckig supports stepping through the trajectory with</p>

<pre><code class="language-.cpp">while (ruckig.update(trajectory, output) == Result::Working) {
  // Make use of the new state here!
  // e.g. robot-&gt;setJointPositions(output.new_position);
}

</code></pre>
<p>starting from the current <code class="language-plaintext highlighter-rouge">output.time</code> (currently Ruckig Pro only).</p>

<h3 id="tracking-interface">Tracking Interface</h3>

<p>When following an arbitrary signal with position, velocity, acceleration, and jerk-limitation, the straight forward way would be to pass the current state to Ruckig’s target state. However, as the resulting trajectory will take time to catch up, this approach will always lag behind the signal. The tracking interface solves this problem by predicting ahead (e.g. with constant acceleration by default) and is therefore able to follow signals very closely in a time-optimal way. This might be very helpful for (general) tracking, robot servoing, or trajectory post-processing applications.</p>

<p>To use the tracking interface, construct</p>

<pre><code class="language-.cpp">Trackig&lt;1&gt; otg {0.01};  // control cycle

</code></pre>
<p>and set the current state as well as the kinematic constraints via</p>

<pre><code class="language-.cpp">input.current_position = {0.0};
input.current_velocity = {0.0};
input.current_acceleration = {0.0};
input.max_velocity = {0.8};
input.max_acceleration = {2.0};
input.max_jerk = {5.0};

</code></pre>
<p>Then, we can track a signal in an online manner within the real-time control loop</p>

<pre><code class="language-.cpp">for (double t = 0; t &lt; 10.0; t += otg.delta_time) {
  auto target_state = signal(t); // signal returns position, velocity, and acceleration
  auto res = otg.update(target_state, input, output);
  // Make use of the smooth target motion here (e.g. output.new_position)

  output.pass_to_input(input);
}

</code></pre>
<p>Please find a complete example <a href="https://github.com/pantor/ruckig/blob/main/examples/13_tracking.cpp">here</a>. This functionality can also be used in an offline manner, e.g. when the entire signal is known beforehand. Here, we call the</p>

<pre><code class="language-.cpp">smooth_trajectory = otg.calculate_trajectory(target_states, input);

</code></pre>
<p>method with the trajectory given as a <code class="language-plaintext highlighter-rouge">std::vector</code> of target states. The Tracking interface is available in the Ruckig Pro version.</p>

<h3 id="dynamic-number-of-degrees-of-freedom">Dynamic Number of Degrees of Freedom</h3>

<p>So far, we have told Ruckig the number of DoFs as a template parameter. If you don’t know the number of DoFs at compile-time, you can set the template parameter to <code class="language-plaintext highlighter-rouge">ruckig::DynamicDOFs</code> and pass the DoFs to the constructor:</p>

<pre><code class="language-.cpp">Ruckig&lt;DynamicDOFs&gt; otg {6, 0.001};
InputParameter&lt;DynamicDOFs&gt; input {6};
OutputParameter&lt;DynamicDOFs&gt; output {6};

</code></pre>

<p>This switches the default Vector from the <code class="language-plaintext highlighter-rouge">std::array</code> to the dynamic <code class="language-plaintext highlighter-rouge">std::vector</code> type. However, we recommend to keep the template parameter when possible: First, it has a performance benefit of a few percent. Second, it is convenient for real-time programming due to its easier handling of memory allocations. When using dynamic degrees of freedom, make sure to allocate the memory of all vectors beforehand.</p>

<h3 id="custom-vector-types">Custom Vector Types</h3>

<p>Ruckig supports custom vector types to make interfacing with your code even easier and more flexible. Most importantly, you can switch to <a href="https://eigen.tuxfamily.org">Eigen Vectors</a> simply by including Eigen (3.4 or later) before Ruckig</p>

<pre><code class="language-.cpp">#include &lt;Eigen/Core&gt; // Version 3.4 or later
#include &lt;ruckig/ruckig.hpp&gt;

</code></pre>
<p>and then call the constructors with the <code class="language-plaintext highlighter-rouge">ruckig::EigenVector</code> parameter.</p>

<pre><code class="language-.cpp">Ruckig&lt;6, EigenVector&gt; otg {0.001};
InputParameter&lt;6, EigenVector&gt; input;
OutputParameter&lt;6, EigenVector&gt; output;

</code></pre>
<p>Now every in- and output of Ruckig’s API (such as <code class="language-plaintext highlighter-rouge">current_position</code>, <code class="language-plaintext highlighter-rouge">new_position</code> or <code class="language-plaintext highlighter-rouge">max_jerk</code>) are Eigen types! To define completely custom vector types, you can pass a C++ <a href="https://en.cppreference.com/w/cpp/language/template_parameters">template template parameter</a> to the constructor. This template template parameter needs to fulfill a range of template arguments and methods:</p>

<pre><code class="language-.cpp">template&lt;class Type, size_t DOFs&gt;
struct MinimalVector {
  Type operator[](size_t i) const; // Array [] getter
  Type&amp; operator[](size_t i); // Array [] setter
  size_t size() const; // Current size
  bool operator==(const MinimalVector&lt;T, DOFs&gt;&amp; rhs) const; // Equal comparison operator

  // Only required in combination with DynamicDOFs, e.g. to allocate memory
  void resize(size_t size);
};

</code></pre>
<p>Note that <code class="language-plaintext highlighter-rouge">DynamicDOFs</code> corresponds to <code class="language-plaintext highlighter-rouge">DOFs = 0</code>. We’ve included a range of examples for using Ruckig with <a href="https://github.com/pantor/ruckig/blob/main/examples/10_eigen_vector_type.cpp">(10) Eigen</a>, <a href="https://github.com/pantor/ruckig/blob/main/examples/11_custom_vector_type.cpp">(11) custom vector types</a>, and <a href="https://github.com/pantor/ruckig/blob/main/examples/12_custom_vector_type_dynamic_dofs.cpp">(12) custom types with a dynamic number of DoFs</a>.</p>

<h2 id="tests-and-numerical-stability">Tests and Numerical Stability</h2>

<p>The current test suite validates over 5.000.000.000 random trajectories as well as many additional edge cases. The numerical exactness is tested for the final position and final velocity to be within <code class="language-plaintext highlighter-rouge">1e-8</code>, for the final acceleration to be within <code class="language-plaintext highlighter-rouge">1e-10</code>, and for the velocity, acceleration and jerk limit to be within of a numerical error of <code class="language-plaintext highlighter-rouge">1e-12</code>. These are absolute values - we suggest to scale your input so that these correspond to your required precision of the system. For example, for most real-world systems we suggest to use input values in <code class="language-plaintext highlighter-rouge">[m]</code> (instead of e.g. <code class="language-plaintext highlighter-rouge">[mm]</code>), as <code class="language-plaintext highlighter-rouge">1e-8m</code> is sufficient precise for practical trajectory generation. Furthermore, all kinematic limits should be below <code class="language-plaintext highlighter-rouge">1e9</code>. The maximal supported trajectory duration is <code class="language-plaintext highlighter-rouge">7e3</code>. Note that Ruckig will also output values outside of this range, there is however no guarantee for correctness.</p>

<p>The Ruckig Pro version has additional tools to increase the numerical range and improve reliability. For example, the<code class="language-plaintext highlighter-rouge">position_scale</code> and <code class="language-plaintext highlighter-rouge">time_scale</code> parameter of the <code class="language-plaintext highlighter-rouge">Calculator</code> class change the internal representation of the input parameters.</p>

<pre><code class="language-.cpp">Ruckig&lt;1&gt; otg;
// Works also for Trackig&lt;1&gt; otg;

otg.calculator.position_scale = 1e2;  // Scales all positions in the input parameters
otg.calculator.time_scale = 1e3;  // Scale all times in the input parameters

</code></pre>
<p>This way, you can easily achieve the requirements above even for very high jerk limits or very long trajectories. Note that the scale parameters don’t effect the resulting trajectory - they are for internal calculation only.</p>

<h2 id="benchmark">Benchmark</h2>

<p>We find that Ruckig is more than twice as fast as Reflexxes Type IV for state-to-state motions and well-suited for control cycles as low as 250 microseconds. The Ruckig <em>Community Version</em> is in general a more powerful and open-source alternative to the <a href="http://reflexxes.ws/">Reflexxes Type IV</a> library. In fact, Ruckig is the first Type V trajectory generator for arbitrary target states and even supports directional velocity and acceleration limits, while also being faster on top.</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/benchmark.png?raw=true" alt="Benchmark"></p>

<p>For trajectories with intermediate waypoints, we compare Ruckig to <a href="https://github.com/hungpham2511/toppra">Toppra</a>, a state-of-the-art library for robotic motion planning. Ruckig is able to improve the trajectory duration on average by around 10%, as the path planning and time parametrization are calculated jointly. Moreover, Ruckig is real-time capable and supports jerk-constraints.</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/ruckig_toppra_example.png?raw=true" alt="Benchmark"></p>

<h2 id="development">Development</h2>

<p>Ruckig is written in C++17. It is continuously tested on <code class="language-plaintext highlighter-rouge">ubuntu-latest</code>, <code class="language-plaintext highlighter-rouge">macos-latest</code>, and <code class="language-plaintext highlighter-rouge">windows-latest</code> against following versions</p>

<ul>
  <li>Doctest v2.4 (only for testing)</li>
  <li>Nanobind v2.4 (only for Python wrapper)</li>
</ul>

<p>A C++11 and C++03 version of Ruckig is also available - please contact us if you’re interested.</p>

<h2 id="used-by">Used By</h2>

<p>Ruckig is used by over hundred research labs, companies, and open-source projects worldwide, including:</p>
<ul>
  <li>
<a href="https://moveit.ros.org">MoveIt 2</a> for trajectory generation.</li>
  <li>
<a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> starting from version 4.3.</li>
  <li><a href="https://flr.io">Fuzzy Logic Robotics</a></li>
  <li><a href="https://www.gestalt-robotics.com">Gestalt Robotics</a></li>
  <li>
<a href="https://github.com/stefanbesler/struckig">Struckig</a>, a port of Ruckig to Structered Text (ST - IEC61131-3) for usage on PLCs.</li>
  <li>
<a href="https://www.scanlab.de/de">Scanlab</a> for controlling lasers.</li>
  <li>
<a href="https://github.com/pantor/frankx">Frankx</a> for controlling the Franka Emika robot arm.</li>
  <li>
<a href="https://wiredworks.com">Wiredworks</a> made a simple Kivy <a href="https://github.com/wiredworks/ruckig-showcase">GUI application</a>
</li>
  <li>and many others!</li>
</ul>

<h2 id="citation">Citation</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@article{berscheid2021jerk,
  title={Jerk-limited Real-time Trajectory Generation with Arbitrary Target States},
  author={Berscheid, Lars and Kr{\"o}ger, Torsten},
  journal={Robotics: Science and Systems XVII},
  year={2021}
}

</code></pre></div></div>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-kilted">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/ruckig">ruckig</a> <small>repository</small></h3>
        <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        
        <a class="label label-primary pkg-label" href="/p/ruckig">ruckig</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-pantor-ruckig
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-pantor-ruckig" role="menuitem" tabindex="-1" href="/r/ruckig/github-pantor-ruckig" data="github-pantor-ruckig">
                    <span class="glyphicon glyphicon-star"></span>
                    github-pantor-ruckig
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Motion Generation for Robots and Machines. Real-time. Jerk-constrained. Time-optimal.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/pantor/ruckig.git">https://github.com/pantor/ruckig.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">main</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-04-19
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/ruckig/#kilted-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/ruckig/#kilted-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/ruckig/#kilted-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/ruckig">ruckig</a></td>
                    <td>0.14.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<div align="center">
  <h1 align="center">Ruckig</h1>
  <h3 align="center">
    Instantaneous Motion Generation for Robots and Machines.
  </h3>
</div>
<p align="center">
  <a href="https://github.com/pantor/ruckig/actions">
    <img src="https://github.com/pantor/ruckig/workflows/CI/badge.svg" alt="CI">
  </a>
  <a href="https://github.com/pantor/ruckig/issues">
    <img src="https://img.shields.io/github/issues/pantor/ruckig.svg" alt="Issues">
  </a>
  <a href="https://github.com/pantor/ruckig/releases">
    <img src="https://img.shields.io/github/v/release/pantor/ruckig.svg?include_prereleases&amp;sort=semver" alt="Releases">
  </a>
  <a href="https://github.com/pantor/ruckig/blob/main/LICENSE">
    <img src="https://img.shields.io/badge/license-MIT-green.svg" alt="MIT">
  </a>
</p>

<p>Ruckig generates trajectories on-the-fly, allowing robots and machines to react instantaneously to sensor input. Ruckig calculates a trajectory to a <em>target</em> waypoint (with position, velocity, and acceleration) starting from <em>any</em> initial state limited by velocity, acceleration, and jerk constraints. Besides the target state, Ruckig allows to define intermediate positions for waypoint following. For state-to-state motions, Ruckig guarantees a time-optimal solution. With intermediate waypoints, Ruckig calculates the path and its time parametrization jointly, resulting in significantly faster trajectories compared to traditional methods.</p>

<p>More information can be found at <a href="https://ruckig.com">ruckig.com</a> and in the corresponding paper <a href="https://arxiv.org/abs/2105.04830">Jerk-limited Real-time Trajectory Generation with Arbitrary Target States</a>, accepted for the <em>Robotics: Science and Systems (RSS), 2021</em> conference.</p>

<h2 id="installation">Installation</h2>

<p>Ruckig has no dependencies (except for testing). To build Ruckig using CMake, just run</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> build
<span class="nb">cd </span>build
cmake <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Release ..
make

</code></pre></div></div>

<p>To install Ruckig in a system-wide directory, you can either use <code class="language-plaintext highlighter-rouge">(sudo) make install</code> or install it as debian package using cpack by running</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cpack
<span class="nb">sudo </span>dpkg <span class="nt">-i</span> ruckig<span class="k">*</span>.deb

</code></pre></div></div>

<p>An example of using Ruckig in your CMake project is given by <code class="language-plaintext highlighter-rouge">examples/CMakeLists.txt</code>. However, you can also include Ruckig as a directory within your project and call <code class="language-plaintext highlighter-rouge">add_subdirectory(ruckig)</code> in your parent <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>.</p>

<p>Ruckig is also available as a Python module, in particular for development or debugging purposes. The Ruckig <em>Community Version</em> can be installed from <a href="https://pypi.org/project/ruckig/">PyPI</a> via</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>ruckig

</code></pre></div></div>
<p>When using CMake, the Python module can be built using the <code class="language-plaintext highlighter-rouge">BUILD_PYTHON_MODULE</code> flag. If you’re only interested in the Python module (and not in the C++ library), you can build and install Ruckig via <code class="language-plaintext highlighter-rouge">pip install .</code>.</p>

<h2 id="tutorial">Tutorial</h2>

<p>Furthermore, we will explain the basics to get started with online generated trajectories within your application. There is also a <a href="https://docs.ruckig.com/pages.html">collection of examples</a> that guide you through the most important features of Ruckig. A time-optimal trajectory for a single degree of freedom is shown in the figure below. We also added plots of the resulting trajectories for all examples. Let’s get started!</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/example_profile.png?raw=true" alt="Trajectory Profile"></p>

<h3 id="waypoint-based-trajectory-generation">Waypoint-based Trajectory Generation</h3>

<p>Ruckig provides three main interface classes: the <em>Ruckig</em>, the <em>InputParameter</em>, and the <em>OutputParameter</em> class.</p>

<p>First, you’ll need to create a Ruckig instance with the number of DoFs as a template parameter, and the control cycle (e.g. in seconds) in the constructor.</p>

<pre><code class="language-.cpp">Ruckig&lt;6&gt; ruckig {0.001}; // Number DoFs; control cycle in [s]

</code></pre>

<p>The input type has 3 blocks of data: the <em>current</em> state, the <em>target</em> state and the corresponding kinematic <em>limits</em>.</p>

<pre><code class="language-.cpp">InputParameter&lt;6&gt; input; // Number DoFs
input.current_position = {0.2, ...};
input.current_velocity = {0.1, ...};
input.current_acceleration = {0.1, ...};
input.target_position = {0.5, ...};
input.target_velocity = {-0.1, ...};
input.target_acceleration = {0.2, ...};
input.max_velocity = {0.4, ...};
input.max_acceleration = {1.0, ...};
input.max_jerk = {4.0, ...};

OutputParameter&lt;6&gt; output; // Number DoFs

</code></pre>

<p>If you only want to have a acceleration-constrained trajectory, you can also omit the <code class="language-plaintext highlighter-rouge">max_jerk</code> as well as the <code class="language-plaintext highlighter-rouge">current</code> and <code class="language-plaintext highlighter-rouge">target_acceleration</code> value. Given all input and output resources, we can iterate over the trajectory at each discrete time step. For most applications, this loop must run within a real-time thread and controls the actual hardware.</p>

<pre><code class="language-.cpp">while (ruckig.update(input, output) == Result::Working) {
  // Make use of the new state here!
  // e.g. robot-&gt;setJointPositions(output.new_position);

  output.pass_to_input(input); // Don't forget this!
}

</code></pre>

<p>Within the control loop, you need to update the <em>current state</em> of the input parameter according to the calculated trajectory. Therefore, the <code class="language-plaintext highlighter-rouge">pass_to_input</code> method copies the new kinematic state of the output to the current kinematic state of the input parameter. If (in the next step) the current state is not the expected, pre-calculated trajectory, Ruckig will calculate a new trajectory based on the novel input. When the trajectory has reached the target state, the <code class="language-plaintext highlighter-rouge">update</code> function will return <code class="language-plaintext highlighter-rouge">Result::Finished</code>.</p>

<h3 id="intermediate-waypoints">Intermediate Waypoints</h3>

<p>The Ruckig Community Version includes built-in support for intermediate waypoints, using our cloud API for remote calculation. Of course, the Ruckig Pro version is fully local. To allocate the necessary memory for a variable number of waypoints beforehand, we need to pass the maximum number of waypoints to Ruckig via</p>

<pre><code class="language-.cpp">Ruckig&lt;6&gt; otg {0.001, 8};
InputParameter&lt;6&gt; input {8};
OutputParameter&lt;6&gt; output {8};

</code></pre>
<p>The <code class="language-plaintext highlighter-rouge">InputParameter</code> class takes the number of waypoints as an optional input, however usually you will fill in the values (and therefore reserve its memory) yourself. Then you’re ready to set intermediate via points by</p>

<pre><code class="language-.cpp">input.intermediate_positions = {
  {0.2, ...},
  {0.8, ...},
};

</code></pre>
<p>As soon as at least one intermediate positions is given, the Ruckig Community Version switches to the mentioned (of course, non real-time capable) cloud API. If you require real-time calculation on your own hardware, please contact us for the <em>Ruckig Pro Version</em>.</p>

<p>When using <em>intermediate positions</em>, both the underlying motion planning problem as well as its calculation changes significantly. In particular, there are some fundamental limitations for jerk-limited online trajectory generation regarding the usage of waypoints. Please find more information about these limitations <a href="https://docs.ruckig.com/md_pages_2__intermediate__waypoints.html">here</a>, and in general we recommend to use</p>

<pre><code class="language-.cpp">input.intermediate_positions = otg.filter_intermediate_positions(input.intermediate_positions, {0.1, ...});

</code></pre>
<p>to filter waypoints according to a (high) threshold distance. Setting <em>interrupt_calculation_duration</em> makes sure to be real-time capable by refining the solution in the next control invocation. Note that this is a soft interruption of the calculation. Currently, no minimum or discrete durations are supported when using intermediate positions.</p>

<h3 id="input-parameter">Input Parameter</h3>

<p>To go into more detail, the <em>InputParameter</em> type has following members:</p>

<pre><code class="language-.cpp">using Vector = std::array&lt;double, DOFs&gt;; // By default

Vector current_position;
Vector current_velocity; // Initialized to zero
Vector current_acceleration; // Initialized to zero

std::vector&lt;Vector&gt; intermediate_positions; // (only in Pro Version)

Vector target_position;
Vector target_velocity; // Initialized to zero
Vector target_acceleration; // Initialized to zero

Vector max_velocity;
Vector max_acceleration;
Vector max_jerk; // Initialized to infinity

std::optional&lt;Vector&gt; min_velocity; // If not given, the negative maximum velocity will be used.
std::optional&lt;Vector&gt; min_acceleration; // If not given, the negative maximum acceleration will be used.

std::optional&lt;Vector&gt; min_position; // (only in Pro Version)
std::optional&lt;Vector&gt; max_position; // (only in Pro Version)

std::array&lt;bool, DOFs&gt; enabled; // Initialized to true
std::optional&lt;double&gt; minimum_duration;
std::optional&lt;double&gt; interrupt_calculation_duration; // [µs], (only in Pro Version)

ControlInterface control_interface; // The default position interface controls the full kinematic state.
Synchronization synchronization; // Synchronization behavior of multiple DoFs
DurationDiscretization duration_discretization; // Whether the duration should be a discrete multiple of the control cycle (off by default)

std::optional&lt;Vector&lt;ControlInterface&gt;&gt; per_dof_control_interface; // Sets the control interface for each DoF individually, overwrites global control_interface
std::optional&lt;Vector&lt;Synchronization&gt;&gt; per_dof_synchronization; // Sets the synchronization for each DoF individually, overwrites global synchronization

</code></pre>

<p>On top of the current state, target state, and constraints, Ruckig allows for a few more advanced settings:</p>
<ul>
  <li>A <em>minimum</em> velocity and acceleration can be specified - these should be a negative number. If they are not given, the negative maximum velocity or acceleration will be used (similar to the jerk limit). For example, this might be useful in human robot collaboration settings with a different velocity limit towards a human. Or, when switching between different moving coordinate frames like picking from a conveyer belt.</li>
  <li>You can overwrite the global kinematic limits to specify limits for each section between two waypoints separately by using e.g. <code class="language-plaintext highlighter-rouge">per_section_max_velocity</code>.</li>
  <li>If a DoF is not <em>enabled</em>, it will be ignored in the calculation. Ruckig will output a trajectory with constant acceleration for those DoFs.</li>
  <li>A <em>minimum duration</em> can be optionally given. Note that Ruckig can not guarantee an exact, but only a minimum duration of the trajectory.</li>
  <li>The control interface (position or velocity control) can be switched easily. For example, a stop trajectory or visual servoing can be easily implemented with the velocity interface.</li>
  <li>Different synchronization behaviors (i.a. phase, time, or no synchonization) are implemented. Phase synchronization results in straight-line motions.</li>
  <li>The trajectory duration might be constrained to a multiple of the control cycle. This way, the <em>exact</em> state can be reached at a control loop execution.</li>
</ul>

<p>We refer to the <a href="https://docs.ruckig.com/namespaceruckig.html">API documentation</a> of the enumerations within the <code class="language-plaintext highlighter-rouge">ruckig</code> namespace for all available options.</p>

<h3 id="input-validation">Input Validation</h3>

<p>To check that Ruckig is able to generate a trajectory before the actual calculation step,</p>

<pre><code class="language-.cpp">ruckig.validate_input(input, check_current_state_within_limits=false, check_target_state_within_limits=true);
// returns true or throws

</code></pre>
<p>throws an error with a detailed reason if an input is not valid. You can also set the default template parameter to false via <code class="language-plaintext highlighter-rouge">ruckig.validate_input&lt;false&gt;(...)</code> to just return a boolean true or false. The two boolean arguments check that the current or target state are within the limits. The check includes a typical catch of jerk-limited trajectory generation: When the current state is at maximal velocity, any positive acceleration will inevitable lead to a velocity violation <em>at a future timestep</em>. In general, this condition is fulfilled when</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Abs(acceleration) &lt;= Sqrt(2 * max_jerk * (max_velocity - Abs(velocity))).

</code></pre></div></div>
<p>If both arguments are set to true, the calculated trajectory is guaranteed to be <em>within the kinematic limits throughout</em> its duration. Also, note that there are range constraints of the input due to numerical reasons, see below for more details.</p>

<h3 id="result-type">Result Type</h3>

<p>The <code class="language-plaintext highlighter-rouge">update</code> function of the Ruckig class returns a Result type that indicates the current state of the algorithm. This can either be <strong>working</strong>, <strong>finished</strong> if the trajectory has finished, or an <strong>error</strong> type if something went wrong during calculation. The result type can be compared as a standard integer.</p>

<table>
  <thead>
    <tr>
      <th>State</th>
      <th>Error Code</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Working</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Finished</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Error</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>ErrorInvalidInput</td>
      <td>-100</td>
    </tr>
    <tr>
      <td>ErrorTrajectoryDuration</td>
      <td>-101</td>
    </tr>
    <tr>
      <td>ErrorPositionalLimits</td>
      <td>-102</td>
    </tr>
    <tr>
      <td>ErrorExecutionTimeCalculation</td>
      <td>-110</td>
    </tr>
    <tr>
      <td>ErrorSynchronizationCalculation</td>
      <td>-111</td>
    </tr>
  </tbody>
</table>

<h3 id="output-parameter">Output Parameter</h3>

<p>The output class includes the new kinematic state and the overall trajectory.</p>

<pre><code class="language-.cpp">Vector new_position;
Vector new_velocity;
Vector new_acceleration;

Trajectory trajectory; // The current trajectory
double time; // The current, auto-incremented time. Reset to 0 at a new calculation.

size_t new_section; // Index of the section between two (possibly filtered) intermediate positions.
bool did_section_change; // Was a new section reached in the last cycle?

bool new_calculation; // Whether a new calculation was performed in the last cycle
bool was_calculation_interrupted; // Was the trajectory calculation interrupted? (only in Pro Version)
double calculation_duration; // Duration of the calculation in the last cycle [µs]

</code></pre>
<p>Moreover, the <strong>trajectory</strong> class has a range of useful parameters and methods.</p>

<pre><code class="language-.cpp">double duration; // Duration of the trajectory
std::array&lt;double, DOFs&gt; independent_min_durations; // Time-optimal profile for each independent DoF

&lt;...&gt; at_time(double time); // Get the kinematic state of the trajectory at a given time
&lt;...&gt; get_position_extrema(); // Returns information about the position extrema and their times

</code></pre>
<p>Again, we refer to the <a href="https://docs.ruckig.com">API documentation</a> for the exact signatures.</p>

<h3 id="offline-calculation">Offline Calculation</h3>

<p>Ruckig also supports an offline approach for calculating a trajectory:</p>

<pre><code class="language-.cpp">result = ruckig.calculate(input, trajectory);

</code></pre>
<p>When only using this method, the <code class="language-plaintext highlighter-rouge">Ruckig</code> constructor does not need a control cycle (<code class="language-plaintext highlighter-rouge">delta_time</code>) as an argument. However if given, Ruckig supports stepping through the trajectory with</p>

<pre><code class="language-.cpp">while (ruckig.update(trajectory, output) == Result::Working) {
  // Make use of the new state here!
  // e.g. robot-&gt;setJointPositions(output.new_position);
}

</code></pre>
<p>starting from the current <code class="language-plaintext highlighter-rouge">output.time</code> (currently Ruckig Pro only).</p>

<h3 id="tracking-interface">Tracking Interface</h3>

<p>When following an arbitrary signal with position, velocity, acceleration, and jerk-limitation, the straight forward way would be to pass the current state to Ruckig’s target state. However, as the resulting trajectory will take time to catch up, this approach will always lag behind the signal. The tracking interface solves this problem by predicting ahead (e.g. with constant acceleration by default) and is therefore able to follow signals very closely in a time-optimal way. This might be very helpful for (general) tracking, robot servoing, or trajectory post-processing applications.</p>

<p>To use the tracking interface, construct</p>

<pre><code class="language-.cpp">Trackig&lt;1&gt; otg {0.01};  // control cycle

</code></pre>
<p>and set the current state as well as the kinematic constraints via</p>

<pre><code class="language-.cpp">input.current_position = {0.0};
input.current_velocity = {0.0};
input.current_acceleration = {0.0};
input.max_velocity = {0.8};
input.max_acceleration = {2.0};
input.max_jerk = {5.0};

</code></pre>
<p>Then, we can track a signal in an online manner within the real-time control loop</p>

<pre><code class="language-.cpp">for (double t = 0; t &lt; 10.0; t += otg.delta_time) {
  auto target_state = signal(t); // signal returns position, velocity, and acceleration
  auto res = otg.update(target_state, input, output);
  // Make use of the smooth target motion here (e.g. output.new_position)

  output.pass_to_input(input);
}

</code></pre>
<p>Please find a complete example <a href="https://github.com/pantor/ruckig/blob/main/examples/13_tracking.cpp">here</a>. This functionality can also be used in an offline manner, e.g. when the entire signal is known beforehand. Here, we call the</p>

<pre><code class="language-.cpp">smooth_trajectory = otg.calculate_trajectory(target_states, input);

</code></pre>
<p>method with the trajectory given as a <code class="language-plaintext highlighter-rouge">std::vector</code> of target states. The Tracking interface is available in the Ruckig Pro version.</p>

<h3 id="dynamic-number-of-degrees-of-freedom">Dynamic Number of Degrees of Freedom</h3>

<p>So far, we have told Ruckig the number of DoFs as a template parameter. If you don’t know the number of DoFs at compile-time, you can set the template parameter to <code class="language-plaintext highlighter-rouge">ruckig::DynamicDOFs</code> and pass the DoFs to the constructor:</p>

<pre><code class="language-.cpp">Ruckig&lt;DynamicDOFs&gt; otg {6, 0.001};
InputParameter&lt;DynamicDOFs&gt; input {6};
OutputParameter&lt;DynamicDOFs&gt; output {6};

</code></pre>

<p>This switches the default Vector from the <code class="language-plaintext highlighter-rouge">std::array</code> to the dynamic <code class="language-plaintext highlighter-rouge">std::vector</code> type. However, we recommend to keep the template parameter when possible: First, it has a performance benefit of a few percent. Second, it is convenient for real-time programming due to its easier handling of memory allocations. When using dynamic degrees of freedom, make sure to allocate the memory of all vectors beforehand.</p>

<h3 id="custom-vector-types">Custom Vector Types</h3>

<p>Ruckig supports custom vector types to make interfacing with your code even easier and more flexible. Most importantly, you can switch to <a href="https://eigen.tuxfamily.org">Eigen Vectors</a> simply by including Eigen (3.4 or later) before Ruckig</p>

<pre><code class="language-.cpp">#include &lt;Eigen/Core&gt; // Version 3.4 or later
#include &lt;ruckig/ruckig.hpp&gt;

</code></pre>
<p>and then call the constructors with the <code class="language-plaintext highlighter-rouge">ruckig::EigenVector</code> parameter.</p>

<pre><code class="language-.cpp">Ruckig&lt;6, EigenVector&gt; otg {0.001};
InputParameter&lt;6, EigenVector&gt; input;
OutputParameter&lt;6, EigenVector&gt; output;

</code></pre>
<p>Now every in- and output of Ruckig’s API (such as <code class="language-plaintext highlighter-rouge">current_position</code>, <code class="language-plaintext highlighter-rouge">new_position</code> or <code class="language-plaintext highlighter-rouge">max_jerk</code>) are Eigen types! To define completely custom vector types, you can pass a C++ <a href="https://en.cppreference.com/w/cpp/language/template_parameters">template template parameter</a> to the constructor. This template template parameter needs to fulfill a range of template arguments and methods:</p>

<pre><code class="language-.cpp">template&lt;class Type, size_t DOFs&gt;
struct MinimalVector {
  Type operator[](size_t i) const; // Array [] getter
  Type&amp; operator[](size_t i); // Array [] setter
  size_t size() const; // Current size
  bool operator==(const MinimalVector&lt;T, DOFs&gt;&amp; rhs) const; // Equal comparison operator

  // Only required in combination with DynamicDOFs, e.g. to allocate memory
  void resize(size_t size);
};

</code></pre>
<p>Note that <code class="language-plaintext highlighter-rouge">DynamicDOFs</code> corresponds to <code class="language-plaintext highlighter-rouge">DOFs = 0</code>. We’ve included a range of examples for using Ruckig with <a href="https://github.com/pantor/ruckig/blob/main/examples/10_eigen_vector_type.cpp">(10) Eigen</a>, <a href="https://github.com/pantor/ruckig/blob/main/examples/11_custom_vector_type.cpp">(11) custom vector types</a>, and <a href="https://github.com/pantor/ruckig/blob/main/examples/12_custom_vector_type_dynamic_dofs.cpp">(12) custom types with a dynamic number of DoFs</a>.</p>

<h2 id="tests-and-numerical-stability">Tests and Numerical Stability</h2>

<p>The current test suite validates over 5.000.000.000 random trajectories as well as many additional edge cases. The numerical exactness is tested for the final position and final velocity to be within <code class="language-plaintext highlighter-rouge">1e-8</code>, for the final acceleration to be within <code class="language-plaintext highlighter-rouge">1e-10</code>, and for the velocity, acceleration and jerk limit to be within of a numerical error of <code class="language-plaintext highlighter-rouge">1e-12</code>. These are absolute values - we suggest to scale your input so that these correspond to your required precision of the system. For example, for most real-world systems we suggest to use input values in <code class="language-plaintext highlighter-rouge">[m]</code> (instead of e.g. <code class="language-plaintext highlighter-rouge">[mm]</code>), as <code class="language-plaintext highlighter-rouge">1e-8m</code> is sufficient precise for practical trajectory generation. Furthermore, all kinematic limits should be below <code class="language-plaintext highlighter-rouge">1e9</code>. The maximal supported trajectory duration is <code class="language-plaintext highlighter-rouge">7e3</code>. Note that Ruckig will also output values outside of this range, there is however no guarantee for correctness.</p>

<p>The Ruckig Pro version has additional tools to increase the numerical range and improve reliability. For example, the<code class="language-plaintext highlighter-rouge">position_scale</code> and <code class="language-plaintext highlighter-rouge">time_scale</code> parameter of the <code class="language-plaintext highlighter-rouge">Calculator</code> class change the internal representation of the input parameters.</p>

<pre><code class="language-.cpp">Ruckig&lt;1&gt; otg;
// Works also for Trackig&lt;1&gt; otg;

otg.calculator.position_scale = 1e2;  // Scales all positions in the input parameters
otg.calculator.time_scale = 1e3;  // Scale all times in the input parameters

</code></pre>
<p>This way, you can easily achieve the requirements above even for very high jerk limits or very long trajectories. Note that the scale parameters don’t effect the resulting trajectory - they are for internal calculation only.</p>

<h2 id="benchmark">Benchmark</h2>

<p>We find that Ruckig is more than twice as fast as Reflexxes Type IV for state-to-state motions and well-suited for control cycles as low as 250 microseconds. The Ruckig <em>Community Version</em> is in general a more powerful and open-source alternative to the <a href="http://reflexxes.ws/">Reflexxes Type IV</a> library. In fact, Ruckig is the first Type V trajectory generator for arbitrary target states and even supports directional velocity and acceleration limits, while also being faster on top.</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/benchmark.png?raw=true" alt="Benchmark"></p>

<p>For trajectories with intermediate waypoints, we compare Ruckig to <a href="https://github.com/hungpham2511/toppra">Toppra</a>, a state-of-the-art library for robotic motion planning. Ruckig is able to improve the trajectory duration on average by around 10%, as the path planning and time parametrization are calculated jointly. Moreover, Ruckig is real-time capable and supports jerk-constraints.</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/ruckig_toppra_example.png?raw=true" alt="Benchmark"></p>

<h2 id="development">Development</h2>

<p>Ruckig is written in C++17. It is continuously tested on <code class="language-plaintext highlighter-rouge">ubuntu-latest</code>, <code class="language-plaintext highlighter-rouge">macos-latest</code>, and <code class="language-plaintext highlighter-rouge">windows-latest</code> against following versions</p>

<ul>
  <li>Doctest v2.4 (only for testing)</li>
  <li>Nanobind v2.4 (only for Python wrapper)</li>
</ul>

<p>A C++11 and C++03 version of Ruckig is also available - please contact us if you’re interested.</p>

<h2 id="used-by">Used By</h2>

<p>Ruckig is used by over hundred research labs, companies, and open-source projects worldwide, including:</p>
<ul>
  <li>
<a href="https://moveit.ros.org">MoveIt 2</a> for trajectory generation.</li>
  <li>
<a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> starting from version 4.3.</li>
  <li><a href="https://flr.io">Fuzzy Logic Robotics</a></li>
  <li><a href="https://www.gestalt-robotics.com">Gestalt Robotics</a></li>
  <li>
<a href="https://github.com/stefanbesler/struckig">Struckig</a>, a port of Ruckig to Structered Text (ST - IEC61131-3) for usage on PLCs.</li>
  <li>
<a href="https://www.scanlab.de/de">Scanlab</a> for controlling lasers.</li>
  <li>
<a href="https://github.com/pantor/frankx">Frankx</a> for controlling the Franka Emika robot arm.</li>
  <li>
<a href="https://wiredworks.com">Wiredworks</a> made a simple Kivy <a href="https://github.com/wiredworks/ruckig-showcase">GUI application</a>
</li>
  <li>and many others!</li>
</ul>

<h2 id="citation">Citation</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@article{berscheid2021jerk,
  title={Jerk-limited Real-time Trajectory Generation with Arbitrary Target States},
  author={Berscheid, Lars and Kr{\"o}ger, Torsten},
  journal={Robotics: Science and Systems XVII},
  year={2021}
}

</code></pre></div></div>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-rolling">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/ruckig">ruckig</a> <small>repository</small></h3>
        <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        
        <a class="label label-primary pkg-label" href="/p/ruckig">ruckig</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-pantor-ruckig
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-pantor-ruckig" role="menuitem" tabindex="-1" href="/r/ruckig/github-pantor-ruckig" data="github-pantor-ruckig">
                    <span class="glyphicon glyphicon-star"></span>
                    github-pantor-ruckig
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Motion Generation for Robots and Machines. Real-time. Jerk-constrained. Time-optimal.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/pantor/ruckig.git">https://github.com/pantor/ruckig.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">main</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-04-19
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/ruckig/#rolling-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/ruckig/#rolling-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/ruckig/#rolling-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/ruckig">ruckig</a></td>
                    <td>0.14.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<div align="center">
  <h1 align="center">Ruckig</h1>
  <h3 align="center">
    Instantaneous Motion Generation for Robots and Machines.
  </h3>
</div>
<p align="center">
  <a href="https://github.com/pantor/ruckig/actions">
    <img src="https://github.com/pantor/ruckig/workflows/CI/badge.svg" alt="CI">
  </a>
  <a href="https://github.com/pantor/ruckig/issues">
    <img src="https://img.shields.io/github/issues/pantor/ruckig.svg" alt="Issues">
  </a>
  <a href="https://github.com/pantor/ruckig/releases">
    <img src="https://img.shields.io/github/v/release/pantor/ruckig.svg?include_prereleases&amp;sort=semver" alt="Releases">
  </a>
  <a href="https://github.com/pantor/ruckig/blob/main/LICENSE">
    <img src="https://img.shields.io/badge/license-MIT-green.svg" alt="MIT">
  </a>
</p>

<p>Ruckig generates trajectories on-the-fly, allowing robots and machines to react instantaneously to sensor input. Ruckig calculates a trajectory to a <em>target</em> waypoint (with position, velocity, and acceleration) starting from <em>any</em> initial state limited by velocity, acceleration, and jerk constraints. Besides the target state, Ruckig allows to define intermediate positions for waypoint following. For state-to-state motions, Ruckig guarantees a time-optimal solution. With intermediate waypoints, Ruckig calculates the path and its time parametrization jointly, resulting in significantly faster trajectories compared to traditional methods.</p>

<p>More information can be found at <a href="https://ruckig.com">ruckig.com</a> and in the corresponding paper <a href="https://arxiv.org/abs/2105.04830">Jerk-limited Real-time Trajectory Generation with Arbitrary Target States</a>, accepted for the <em>Robotics: Science and Systems (RSS), 2021</em> conference.</p>

<h2 id="installation">Installation</h2>

<p>Ruckig has no dependencies (except for testing). To build Ruckig using CMake, just run</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> build
<span class="nb">cd </span>build
cmake <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Release ..
make

</code></pre></div></div>

<p>To install Ruckig in a system-wide directory, you can either use <code class="language-plaintext highlighter-rouge">(sudo) make install</code> or install it as debian package using cpack by running</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cpack
<span class="nb">sudo </span>dpkg <span class="nt">-i</span> ruckig<span class="k">*</span>.deb

</code></pre></div></div>

<p>An example of using Ruckig in your CMake project is given by <code class="language-plaintext highlighter-rouge">examples/CMakeLists.txt</code>. However, you can also include Ruckig as a directory within your project and call <code class="language-plaintext highlighter-rouge">add_subdirectory(ruckig)</code> in your parent <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>.</p>

<p>Ruckig is also available as a Python module, in particular for development or debugging purposes. The Ruckig <em>Community Version</em> can be installed from <a href="https://pypi.org/project/ruckig/">PyPI</a> via</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>ruckig

</code></pre></div></div>
<p>When using CMake, the Python module can be built using the <code class="language-plaintext highlighter-rouge">BUILD_PYTHON_MODULE</code> flag. If you’re only interested in the Python module (and not in the C++ library), you can build and install Ruckig via <code class="language-plaintext highlighter-rouge">pip install .</code>.</p>

<h2 id="tutorial">Tutorial</h2>

<p>Furthermore, we will explain the basics to get started with online generated trajectories within your application. There is also a <a href="https://docs.ruckig.com/pages.html">collection of examples</a> that guide you through the most important features of Ruckig. A time-optimal trajectory for a single degree of freedom is shown in the figure below. We also added plots of the resulting trajectories for all examples. Let’s get started!</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/example_profile.png?raw=true" alt="Trajectory Profile"></p>

<h3 id="waypoint-based-trajectory-generation">Waypoint-based Trajectory Generation</h3>

<p>Ruckig provides three main interface classes: the <em>Ruckig</em>, the <em>InputParameter</em>, and the <em>OutputParameter</em> class.</p>

<p>First, you’ll need to create a Ruckig instance with the number of DoFs as a template parameter, and the control cycle (e.g. in seconds) in the constructor.</p>

<pre><code class="language-.cpp">Ruckig&lt;6&gt; ruckig {0.001}; // Number DoFs; control cycle in [s]

</code></pre>

<p>The input type has 3 blocks of data: the <em>current</em> state, the <em>target</em> state and the corresponding kinematic <em>limits</em>.</p>

<pre><code class="language-.cpp">InputParameter&lt;6&gt; input; // Number DoFs
input.current_position = {0.2, ...};
input.current_velocity = {0.1, ...};
input.current_acceleration = {0.1, ...};
input.target_position = {0.5, ...};
input.target_velocity = {-0.1, ...};
input.target_acceleration = {0.2, ...};
input.max_velocity = {0.4, ...};
input.max_acceleration = {1.0, ...};
input.max_jerk = {4.0, ...};

OutputParameter&lt;6&gt; output; // Number DoFs

</code></pre>

<p>If you only want to have a acceleration-constrained trajectory, you can also omit the <code class="language-plaintext highlighter-rouge">max_jerk</code> as well as the <code class="language-plaintext highlighter-rouge">current</code> and <code class="language-plaintext highlighter-rouge">target_acceleration</code> value. Given all input and output resources, we can iterate over the trajectory at each discrete time step. For most applications, this loop must run within a real-time thread and controls the actual hardware.</p>

<pre><code class="language-.cpp">while (ruckig.update(input, output) == Result::Working) {
  // Make use of the new state here!
  // e.g. robot-&gt;setJointPositions(output.new_position);

  output.pass_to_input(input); // Don't forget this!
}

</code></pre>

<p>Within the control loop, you need to update the <em>current state</em> of the input parameter according to the calculated trajectory. Therefore, the <code class="language-plaintext highlighter-rouge">pass_to_input</code> method copies the new kinematic state of the output to the current kinematic state of the input parameter. If (in the next step) the current state is not the expected, pre-calculated trajectory, Ruckig will calculate a new trajectory based on the novel input. When the trajectory has reached the target state, the <code class="language-plaintext highlighter-rouge">update</code> function will return <code class="language-plaintext highlighter-rouge">Result::Finished</code>.</p>

<h3 id="intermediate-waypoints">Intermediate Waypoints</h3>

<p>The Ruckig Community Version includes built-in support for intermediate waypoints, using our cloud API for remote calculation. Of course, the Ruckig Pro version is fully local. To allocate the necessary memory for a variable number of waypoints beforehand, we need to pass the maximum number of waypoints to Ruckig via</p>

<pre><code class="language-.cpp">Ruckig&lt;6&gt; otg {0.001, 8};
InputParameter&lt;6&gt; input {8};
OutputParameter&lt;6&gt; output {8};

</code></pre>
<p>The <code class="language-plaintext highlighter-rouge">InputParameter</code> class takes the number of waypoints as an optional input, however usually you will fill in the values (and therefore reserve its memory) yourself. Then you’re ready to set intermediate via points by</p>

<pre><code class="language-.cpp">input.intermediate_positions = {
  {0.2, ...},
  {0.8, ...},
};

</code></pre>
<p>As soon as at least one intermediate positions is given, the Ruckig Community Version switches to the mentioned (of course, non real-time capable) cloud API. If you require real-time calculation on your own hardware, please contact us for the <em>Ruckig Pro Version</em>.</p>

<p>When using <em>intermediate positions</em>, both the underlying motion planning problem as well as its calculation changes significantly. In particular, there are some fundamental limitations for jerk-limited online trajectory generation regarding the usage of waypoints. Please find more information about these limitations <a href="https://docs.ruckig.com/md_pages_2__intermediate__waypoints.html">here</a>, and in general we recommend to use</p>

<pre><code class="language-.cpp">input.intermediate_positions = otg.filter_intermediate_positions(input.intermediate_positions, {0.1, ...});

</code></pre>
<p>to filter waypoints according to a (high) threshold distance. Setting <em>interrupt_calculation_duration</em> makes sure to be real-time capable by refining the solution in the next control invocation. Note that this is a soft interruption of the calculation. Currently, no minimum or discrete durations are supported when using intermediate positions.</p>

<h3 id="input-parameter">Input Parameter</h3>

<p>To go into more detail, the <em>InputParameter</em> type has following members:</p>

<pre><code class="language-.cpp">using Vector = std::array&lt;double, DOFs&gt;; // By default

Vector current_position;
Vector current_velocity; // Initialized to zero
Vector current_acceleration; // Initialized to zero

std::vector&lt;Vector&gt; intermediate_positions; // (only in Pro Version)

Vector target_position;
Vector target_velocity; // Initialized to zero
Vector target_acceleration; // Initialized to zero

Vector max_velocity;
Vector max_acceleration;
Vector max_jerk; // Initialized to infinity

std::optional&lt;Vector&gt; min_velocity; // If not given, the negative maximum velocity will be used.
std::optional&lt;Vector&gt; min_acceleration; // If not given, the negative maximum acceleration will be used.

std::optional&lt;Vector&gt; min_position; // (only in Pro Version)
std::optional&lt;Vector&gt; max_position; // (only in Pro Version)

std::array&lt;bool, DOFs&gt; enabled; // Initialized to true
std::optional&lt;double&gt; minimum_duration;
std::optional&lt;double&gt; interrupt_calculation_duration; // [µs], (only in Pro Version)

ControlInterface control_interface; // The default position interface controls the full kinematic state.
Synchronization synchronization; // Synchronization behavior of multiple DoFs
DurationDiscretization duration_discretization; // Whether the duration should be a discrete multiple of the control cycle (off by default)

std::optional&lt;Vector&lt;ControlInterface&gt;&gt; per_dof_control_interface; // Sets the control interface for each DoF individually, overwrites global control_interface
std::optional&lt;Vector&lt;Synchronization&gt;&gt; per_dof_synchronization; // Sets the synchronization for each DoF individually, overwrites global synchronization

</code></pre>

<p>On top of the current state, target state, and constraints, Ruckig allows for a few more advanced settings:</p>
<ul>
  <li>A <em>minimum</em> velocity and acceleration can be specified - these should be a negative number. If they are not given, the negative maximum velocity or acceleration will be used (similar to the jerk limit). For example, this might be useful in human robot collaboration settings with a different velocity limit towards a human. Or, when switching between different moving coordinate frames like picking from a conveyer belt.</li>
  <li>You can overwrite the global kinematic limits to specify limits for each section between two waypoints separately by using e.g. <code class="language-plaintext highlighter-rouge">per_section_max_velocity</code>.</li>
  <li>If a DoF is not <em>enabled</em>, it will be ignored in the calculation. Ruckig will output a trajectory with constant acceleration for those DoFs.</li>
  <li>A <em>minimum duration</em> can be optionally given. Note that Ruckig can not guarantee an exact, but only a minimum duration of the trajectory.</li>
  <li>The control interface (position or velocity control) can be switched easily. For example, a stop trajectory or visual servoing can be easily implemented with the velocity interface.</li>
  <li>Different synchronization behaviors (i.a. phase, time, or no synchonization) are implemented. Phase synchronization results in straight-line motions.</li>
  <li>The trajectory duration might be constrained to a multiple of the control cycle. This way, the <em>exact</em> state can be reached at a control loop execution.</li>
</ul>

<p>We refer to the <a href="https://docs.ruckig.com/namespaceruckig.html">API documentation</a> of the enumerations within the <code class="language-plaintext highlighter-rouge">ruckig</code> namespace for all available options.</p>

<h3 id="input-validation">Input Validation</h3>

<p>To check that Ruckig is able to generate a trajectory before the actual calculation step,</p>

<pre><code class="language-.cpp">ruckig.validate_input(input, check_current_state_within_limits=false, check_target_state_within_limits=true);
// returns true or throws

</code></pre>
<p>throws an error with a detailed reason if an input is not valid. You can also set the default template parameter to false via <code class="language-plaintext highlighter-rouge">ruckig.validate_input&lt;false&gt;(...)</code> to just return a boolean true or false. The two boolean arguments check that the current or target state are within the limits. The check includes a typical catch of jerk-limited trajectory generation: When the current state is at maximal velocity, any positive acceleration will inevitable lead to a velocity violation <em>at a future timestep</em>. In general, this condition is fulfilled when</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Abs(acceleration) &lt;= Sqrt(2 * max_jerk * (max_velocity - Abs(velocity))).

</code></pre></div></div>
<p>If both arguments are set to true, the calculated trajectory is guaranteed to be <em>within the kinematic limits throughout</em> its duration. Also, note that there are range constraints of the input due to numerical reasons, see below for more details.</p>

<h3 id="result-type">Result Type</h3>

<p>The <code class="language-plaintext highlighter-rouge">update</code> function of the Ruckig class returns a Result type that indicates the current state of the algorithm. This can either be <strong>working</strong>, <strong>finished</strong> if the trajectory has finished, or an <strong>error</strong> type if something went wrong during calculation. The result type can be compared as a standard integer.</p>

<table>
  <thead>
    <tr>
      <th>State</th>
      <th>Error Code</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Working</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Finished</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Error</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>ErrorInvalidInput</td>
      <td>-100</td>
    </tr>
    <tr>
      <td>ErrorTrajectoryDuration</td>
      <td>-101</td>
    </tr>
    <tr>
      <td>ErrorPositionalLimits</td>
      <td>-102</td>
    </tr>
    <tr>
      <td>ErrorExecutionTimeCalculation</td>
      <td>-110</td>
    </tr>
    <tr>
      <td>ErrorSynchronizationCalculation</td>
      <td>-111</td>
    </tr>
  </tbody>
</table>

<h3 id="output-parameter">Output Parameter</h3>

<p>The output class includes the new kinematic state and the overall trajectory.</p>

<pre><code class="language-.cpp">Vector new_position;
Vector new_velocity;
Vector new_acceleration;

Trajectory trajectory; // The current trajectory
double time; // The current, auto-incremented time. Reset to 0 at a new calculation.

size_t new_section; // Index of the section between two (possibly filtered) intermediate positions.
bool did_section_change; // Was a new section reached in the last cycle?

bool new_calculation; // Whether a new calculation was performed in the last cycle
bool was_calculation_interrupted; // Was the trajectory calculation interrupted? (only in Pro Version)
double calculation_duration; // Duration of the calculation in the last cycle [µs]

</code></pre>
<p>Moreover, the <strong>trajectory</strong> class has a range of useful parameters and methods.</p>

<pre><code class="language-.cpp">double duration; // Duration of the trajectory
std::array&lt;double, DOFs&gt; independent_min_durations; // Time-optimal profile for each independent DoF

&lt;...&gt; at_time(double time); // Get the kinematic state of the trajectory at a given time
&lt;...&gt; get_position_extrema(); // Returns information about the position extrema and their times

</code></pre>
<p>Again, we refer to the <a href="https://docs.ruckig.com">API documentation</a> for the exact signatures.</p>

<h3 id="offline-calculation">Offline Calculation</h3>

<p>Ruckig also supports an offline approach for calculating a trajectory:</p>

<pre><code class="language-.cpp">result = ruckig.calculate(input, trajectory);

</code></pre>
<p>When only using this method, the <code class="language-plaintext highlighter-rouge">Ruckig</code> constructor does not need a control cycle (<code class="language-plaintext highlighter-rouge">delta_time</code>) as an argument. However if given, Ruckig supports stepping through the trajectory with</p>

<pre><code class="language-.cpp">while (ruckig.update(trajectory, output) == Result::Working) {
  // Make use of the new state here!
  // e.g. robot-&gt;setJointPositions(output.new_position);
}

</code></pre>
<p>starting from the current <code class="language-plaintext highlighter-rouge">output.time</code> (currently Ruckig Pro only).</p>

<h3 id="tracking-interface">Tracking Interface</h3>

<p>When following an arbitrary signal with position, velocity, acceleration, and jerk-limitation, the straight forward way would be to pass the current state to Ruckig’s target state. However, as the resulting trajectory will take time to catch up, this approach will always lag behind the signal. The tracking interface solves this problem by predicting ahead (e.g. with constant acceleration by default) and is therefore able to follow signals very closely in a time-optimal way. This might be very helpful for (general) tracking, robot servoing, or trajectory post-processing applications.</p>

<p>To use the tracking interface, construct</p>

<pre><code class="language-.cpp">Trackig&lt;1&gt; otg {0.01};  // control cycle

</code></pre>
<p>and set the current state as well as the kinematic constraints via</p>

<pre><code class="language-.cpp">input.current_position = {0.0};
input.current_velocity = {0.0};
input.current_acceleration = {0.0};
input.max_velocity = {0.8};
input.max_acceleration = {2.0};
input.max_jerk = {5.0};

</code></pre>
<p>Then, we can track a signal in an online manner within the real-time control loop</p>

<pre><code class="language-.cpp">for (double t = 0; t &lt; 10.0; t += otg.delta_time) {
  auto target_state = signal(t); // signal returns position, velocity, and acceleration
  auto res = otg.update(target_state, input, output);
  // Make use of the smooth target motion here (e.g. output.new_position)

  output.pass_to_input(input);
}

</code></pre>
<p>Please find a complete example <a href="https://github.com/pantor/ruckig/blob/main/examples/13_tracking.cpp">here</a>. This functionality can also be used in an offline manner, e.g. when the entire signal is known beforehand. Here, we call the</p>

<pre><code class="language-.cpp">smooth_trajectory = otg.calculate_trajectory(target_states, input);

</code></pre>
<p>method with the trajectory given as a <code class="language-plaintext highlighter-rouge">std::vector</code> of target states. The Tracking interface is available in the Ruckig Pro version.</p>

<h3 id="dynamic-number-of-degrees-of-freedom">Dynamic Number of Degrees of Freedom</h3>

<p>So far, we have told Ruckig the number of DoFs as a template parameter. If you don’t know the number of DoFs at compile-time, you can set the template parameter to <code class="language-plaintext highlighter-rouge">ruckig::DynamicDOFs</code> and pass the DoFs to the constructor:</p>

<pre><code class="language-.cpp">Ruckig&lt;DynamicDOFs&gt; otg {6, 0.001};
InputParameter&lt;DynamicDOFs&gt; input {6};
OutputParameter&lt;DynamicDOFs&gt; output {6};

</code></pre>

<p>This switches the default Vector from the <code class="language-plaintext highlighter-rouge">std::array</code> to the dynamic <code class="language-plaintext highlighter-rouge">std::vector</code> type. However, we recommend to keep the template parameter when possible: First, it has a performance benefit of a few percent. Second, it is convenient for real-time programming due to its easier handling of memory allocations. When using dynamic degrees of freedom, make sure to allocate the memory of all vectors beforehand.</p>

<h3 id="custom-vector-types">Custom Vector Types</h3>

<p>Ruckig supports custom vector types to make interfacing with your code even easier and more flexible. Most importantly, you can switch to <a href="https://eigen.tuxfamily.org">Eigen Vectors</a> simply by including Eigen (3.4 or later) before Ruckig</p>

<pre><code class="language-.cpp">#include &lt;Eigen/Core&gt; // Version 3.4 or later
#include &lt;ruckig/ruckig.hpp&gt;

</code></pre>
<p>and then call the constructors with the <code class="language-plaintext highlighter-rouge">ruckig::EigenVector</code> parameter.</p>

<pre><code class="language-.cpp">Ruckig&lt;6, EigenVector&gt; otg {0.001};
InputParameter&lt;6, EigenVector&gt; input;
OutputParameter&lt;6, EigenVector&gt; output;

</code></pre>
<p>Now every in- and output of Ruckig’s API (such as <code class="language-plaintext highlighter-rouge">current_position</code>, <code class="language-plaintext highlighter-rouge">new_position</code> or <code class="language-plaintext highlighter-rouge">max_jerk</code>) are Eigen types! To define completely custom vector types, you can pass a C++ <a href="https://en.cppreference.com/w/cpp/language/template_parameters">template template parameter</a> to the constructor. This template template parameter needs to fulfill a range of template arguments and methods:</p>

<pre><code class="language-.cpp">template&lt;class Type, size_t DOFs&gt;
struct MinimalVector {
  Type operator[](size_t i) const; // Array [] getter
  Type&amp; operator[](size_t i); // Array [] setter
  size_t size() const; // Current size
  bool operator==(const MinimalVector&lt;T, DOFs&gt;&amp; rhs) const; // Equal comparison operator

  // Only required in combination with DynamicDOFs, e.g. to allocate memory
  void resize(size_t size);
};

</code></pre>
<p>Note that <code class="language-plaintext highlighter-rouge">DynamicDOFs</code> corresponds to <code class="language-plaintext highlighter-rouge">DOFs = 0</code>. We’ve included a range of examples for using Ruckig with <a href="https://github.com/pantor/ruckig/blob/main/examples/10_eigen_vector_type.cpp">(10) Eigen</a>, <a href="https://github.com/pantor/ruckig/blob/main/examples/11_custom_vector_type.cpp">(11) custom vector types</a>, and <a href="https://github.com/pantor/ruckig/blob/main/examples/12_custom_vector_type_dynamic_dofs.cpp">(12) custom types with a dynamic number of DoFs</a>.</p>

<h2 id="tests-and-numerical-stability">Tests and Numerical Stability</h2>

<p>The current test suite validates over 5.000.000.000 random trajectories as well as many additional edge cases. The numerical exactness is tested for the final position and final velocity to be within <code class="language-plaintext highlighter-rouge">1e-8</code>, for the final acceleration to be within <code class="language-plaintext highlighter-rouge">1e-10</code>, and for the velocity, acceleration and jerk limit to be within of a numerical error of <code class="language-plaintext highlighter-rouge">1e-12</code>. These are absolute values - we suggest to scale your input so that these correspond to your required precision of the system. For example, for most real-world systems we suggest to use input values in <code class="language-plaintext highlighter-rouge">[m]</code> (instead of e.g. <code class="language-plaintext highlighter-rouge">[mm]</code>), as <code class="language-plaintext highlighter-rouge">1e-8m</code> is sufficient precise for practical trajectory generation. Furthermore, all kinematic limits should be below <code class="language-plaintext highlighter-rouge">1e9</code>. The maximal supported trajectory duration is <code class="language-plaintext highlighter-rouge">7e3</code>. Note that Ruckig will also output values outside of this range, there is however no guarantee for correctness.</p>

<p>The Ruckig Pro version has additional tools to increase the numerical range and improve reliability. For example, the<code class="language-plaintext highlighter-rouge">position_scale</code> and <code class="language-plaintext highlighter-rouge">time_scale</code> parameter of the <code class="language-plaintext highlighter-rouge">Calculator</code> class change the internal representation of the input parameters.</p>

<pre><code class="language-.cpp">Ruckig&lt;1&gt; otg;
// Works also for Trackig&lt;1&gt; otg;

otg.calculator.position_scale = 1e2;  // Scales all positions in the input parameters
otg.calculator.time_scale = 1e3;  // Scale all times in the input parameters

</code></pre>
<p>This way, you can easily achieve the requirements above even for very high jerk limits or very long trajectories. Note that the scale parameters don’t effect the resulting trajectory - they are for internal calculation only.</p>

<h2 id="benchmark">Benchmark</h2>

<p>We find that Ruckig is more than twice as fast as Reflexxes Type IV for state-to-state motions and well-suited for control cycles as low as 250 microseconds. The Ruckig <em>Community Version</em> is in general a more powerful and open-source alternative to the <a href="http://reflexxes.ws/">Reflexxes Type IV</a> library. In fact, Ruckig is the first Type V trajectory generator for arbitrary target states and even supports directional velocity and acceleration limits, while also being faster on top.</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/benchmark.png?raw=true" alt="Benchmark"></p>

<p>For trajectories with intermediate waypoints, we compare Ruckig to <a href="https://github.com/hungpham2511/toppra">Toppra</a>, a state-of-the-art library for robotic motion planning. Ruckig is able to improve the trajectory duration on average by around 10%, as the path planning and time parametrization are calculated jointly. Moreover, Ruckig is real-time capable and supports jerk-constraints.</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/ruckig_toppra_example.png?raw=true" alt="Benchmark"></p>

<h2 id="development">Development</h2>

<p>Ruckig is written in C++17. It is continuously tested on <code class="language-plaintext highlighter-rouge">ubuntu-latest</code>, <code class="language-plaintext highlighter-rouge">macos-latest</code>, and <code class="language-plaintext highlighter-rouge">windows-latest</code> against following versions</p>

<ul>
  <li>Doctest v2.4 (only for testing)</li>
  <li>Nanobind v2.4 (only for Python wrapper)</li>
</ul>

<p>A C++11 and C++03 version of Ruckig is also available - please contact us if you’re interested.</p>

<h2 id="used-by">Used By</h2>

<p>Ruckig is used by over hundred research labs, companies, and open-source projects worldwide, including:</p>
<ul>
  <li>
<a href="https://moveit.ros.org">MoveIt 2</a> for trajectory generation.</li>
  <li>
<a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> starting from version 4.3.</li>
  <li><a href="https://flr.io">Fuzzy Logic Robotics</a></li>
  <li><a href="https://www.gestalt-robotics.com">Gestalt Robotics</a></li>
  <li>
<a href="https://github.com/stefanbesler/struckig">Struckig</a>, a port of Ruckig to Structered Text (ST - IEC61131-3) for usage on PLCs.</li>
  <li>
<a href="https://www.scanlab.de/de">Scanlab</a> for controlling lasers.</li>
  <li>
<a href="https://github.com/pantor/frankx">Frankx</a> for controlling the Franka Emika robot arm.</li>
  <li>
<a href="https://wiredworks.com">Wiredworks</a> made a simple Kivy <a href="https://github.com/wiredworks/ruckig-showcase">GUI application</a>
</li>
  <li>and many others!</li>
</ul>

<h2 id="citation">Citation</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@article{berscheid2021jerk,
  title={Jerk-limited Real-time Trajectory Generation with Arbitrary Target States},
  author={Berscheid, Lars and Kr{\"o}ger, Torsten},
  journal={Robotics: Science and Systems XVII},
  year={2021}
}

</code></pre></div></div>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-github">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/ruckig">ruckig</a> <small>repository</small></h3>
        <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-pantor-ruckig
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-pantor-ruckig" role="menuitem" tabindex="-1" href="/r/ruckig/github-pantor-ruckig" data="github-pantor-ruckig">
                    <span class="glyphicon glyphicon-star"></span>
                    github-pantor-ruckig
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>github</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>

  <div class="distro distro-noetic">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/ruckig">ruckig</a> <small>repository</small></h3>
        <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-pantor-ruckig
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-pantor-ruckig" role="menuitem" tabindex="-1" href="/r/ruckig/github-pantor-ruckig" data="github-pantor-ruckig">
                    <span class="glyphicon glyphicon-star"></span>
                    github-pantor-ruckig
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>noetic</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>

  <div class="distro distro-galactic">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/ruckig">ruckig</a> <small>repository</small></h3>
        <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-pantor-ruckig
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-pantor-ruckig" role="menuitem" tabindex="-1" href="/r/ruckig/github-pantor-ruckig" data="github-pantor-ruckig">
                    <span class="glyphicon glyphicon-star"></span>
                    github-pantor-ruckig
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>galactic</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>

  <div class="distro distro-iron">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/ruckig">ruckig</a> <small>repository</small></h3>
        <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        
        <a class="label label-primary pkg-label" href="/p/ruckig">ruckig</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-pantor-ruckig
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-pantor-ruckig" role="menuitem" tabindex="-1" href="/r/ruckig/github-pantor-ruckig" data="github-pantor-ruckig">
                    <span class="glyphicon glyphicon-star"></span>
                    github-pantor-ruckig
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Motion Generation for Robots and Machines. Real-time. Jerk-constrained. Time-optimal.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/pantor/ruckig.git">https://github.com/pantor/ruckig.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">main</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-04-19
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/ruckig/#iron-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/ruckig/#iron-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/ruckig/#iron-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/ruckig">ruckig</a></td>
                    <td>0.14.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<div align="center">
  <h1 align="center">Ruckig</h1>
  <h3 align="center">
    Instantaneous Motion Generation for Robots and Machines.
  </h3>
</div>
<p align="center">
  <a href="https://github.com/pantor/ruckig/actions">
    <img src="https://github.com/pantor/ruckig/workflows/CI/badge.svg" alt="CI">
  </a>
  <a href="https://github.com/pantor/ruckig/issues">
    <img src="https://img.shields.io/github/issues/pantor/ruckig.svg" alt="Issues">
  </a>
  <a href="https://github.com/pantor/ruckig/releases">
    <img src="https://img.shields.io/github/v/release/pantor/ruckig.svg?include_prereleases&amp;sort=semver" alt="Releases">
  </a>
  <a href="https://github.com/pantor/ruckig/blob/main/LICENSE">
    <img src="https://img.shields.io/badge/license-MIT-green.svg" alt="MIT">
  </a>
</p>

<p>Ruckig generates trajectories on-the-fly, allowing robots and machines to react instantaneously to sensor input. Ruckig calculates a trajectory to a <em>target</em> waypoint (with position, velocity, and acceleration) starting from <em>any</em> initial state limited by velocity, acceleration, and jerk constraints. Besides the target state, Ruckig allows to define intermediate positions for waypoint following. For state-to-state motions, Ruckig guarantees a time-optimal solution. With intermediate waypoints, Ruckig calculates the path and its time parametrization jointly, resulting in significantly faster trajectories compared to traditional methods.</p>

<p>More information can be found at <a href="https://ruckig.com">ruckig.com</a> and in the corresponding paper <a href="https://arxiv.org/abs/2105.04830">Jerk-limited Real-time Trajectory Generation with Arbitrary Target States</a>, accepted for the <em>Robotics: Science and Systems (RSS), 2021</em> conference.</p>

<h2 id="installation">Installation</h2>

<p>Ruckig has no dependencies (except for testing). To build Ruckig using CMake, just run</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> build
<span class="nb">cd </span>build
cmake <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Release ..
make

</code></pre></div></div>

<p>To install Ruckig in a system-wide directory, you can either use <code class="language-plaintext highlighter-rouge">(sudo) make install</code> or install it as debian package using cpack by running</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cpack
<span class="nb">sudo </span>dpkg <span class="nt">-i</span> ruckig<span class="k">*</span>.deb

</code></pre></div></div>

<p>An example of using Ruckig in your CMake project is given by <code class="language-plaintext highlighter-rouge">examples/CMakeLists.txt</code>. However, you can also include Ruckig as a directory within your project and call <code class="language-plaintext highlighter-rouge">add_subdirectory(ruckig)</code> in your parent <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>.</p>

<p>Ruckig is also available as a Python module, in particular for development or debugging purposes. The Ruckig <em>Community Version</em> can be installed from <a href="https://pypi.org/project/ruckig/">PyPI</a> via</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>ruckig

</code></pre></div></div>
<p>When using CMake, the Python module can be built using the <code class="language-plaintext highlighter-rouge">BUILD_PYTHON_MODULE</code> flag. If you’re only interested in the Python module (and not in the C++ library), you can build and install Ruckig via <code class="language-plaintext highlighter-rouge">pip install .</code>.</p>

<h2 id="tutorial">Tutorial</h2>

<p>Furthermore, we will explain the basics to get started with online generated trajectories within your application. There is also a <a href="https://docs.ruckig.com/pages.html">collection of examples</a> that guide you through the most important features of Ruckig. A time-optimal trajectory for a single degree of freedom is shown in the figure below. We also added plots of the resulting trajectories for all examples. Let’s get started!</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/example_profile.png?raw=true" alt="Trajectory Profile"></p>

<h3 id="waypoint-based-trajectory-generation">Waypoint-based Trajectory Generation</h3>

<p>Ruckig provides three main interface classes: the <em>Ruckig</em>, the <em>InputParameter</em>, and the <em>OutputParameter</em> class.</p>

<p>First, you’ll need to create a Ruckig instance with the number of DoFs as a template parameter, and the control cycle (e.g. in seconds) in the constructor.</p>

<pre><code class="language-.cpp">Ruckig&lt;6&gt; ruckig {0.001}; // Number DoFs; control cycle in [s]

</code></pre>

<p>The input type has 3 blocks of data: the <em>current</em> state, the <em>target</em> state and the corresponding kinematic <em>limits</em>.</p>

<pre><code class="language-.cpp">InputParameter&lt;6&gt; input; // Number DoFs
input.current_position = {0.2, ...};
input.current_velocity = {0.1, ...};
input.current_acceleration = {0.1, ...};
input.target_position = {0.5, ...};
input.target_velocity = {-0.1, ...};
input.target_acceleration = {0.2, ...};
input.max_velocity = {0.4, ...};
input.max_acceleration = {1.0, ...};
input.max_jerk = {4.0, ...};

OutputParameter&lt;6&gt; output; // Number DoFs

</code></pre>

<p>If you only want to have a acceleration-constrained trajectory, you can also omit the <code class="language-plaintext highlighter-rouge">max_jerk</code> as well as the <code class="language-plaintext highlighter-rouge">current</code> and <code class="language-plaintext highlighter-rouge">target_acceleration</code> value. Given all input and output resources, we can iterate over the trajectory at each discrete time step. For most applications, this loop must run within a real-time thread and controls the actual hardware.</p>

<pre><code class="language-.cpp">while (ruckig.update(input, output) == Result::Working) {
  // Make use of the new state here!
  // e.g. robot-&gt;setJointPositions(output.new_position);

  output.pass_to_input(input); // Don't forget this!
}

</code></pre>

<p>Within the control loop, you need to update the <em>current state</em> of the input parameter according to the calculated trajectory. Therefore, the <code class="language-plaintext highlighter-rouge">pass_to_input</code> method copies the new kinematic state of the output to the current kinematic state of the input parameter. If (in the next step) the current state is not the expected, pre-calculated trajectory, Ruckig will calculate a new trajectory based on the novel input. When the trajectory has reached the target state, the <code class="language-plaintext highlighter-rouge">update</code> function will return <code class="language-plaintext highlighter-rouge">Result::Finished</code>.</p>

<h3 id="intermediate-waypoints">Intermediate Waypoints</h3>

<p>The Ruckig Community Version includes built-in support for intermediate waypoints, using our cloud API for remote calculation. Of course, the Ruckig Pro version is fully local. To allocate the necessary memory for a variable number of waypoints beforehand, we need to pass the maximum number of waypoints to Ruckig via</p>

<pre><code class="language-.cpp">Ruckig&lt;6&gt; otg {0.001, 8};
InputParameter&lt;6&gt; input {8};
OutputParameter&lt;6&gt; output {8};

</code></pre>
<p>The <code class="language-plaintext highlighter-rouge">InputParameter</code> class takes the number of waypoints as an optional input, however usually you will fill in the values (and therefore reserve its memory) yourself. Then you’re ready to set intermediate via points by</p>

<pre><code class="language-.cpp">input.intermediate_positions = {
  {0.2, ...},
  {0.8, ...},
};

</code></pre>
<p>As soon as at least one intermediate positions is given, the Ruckig Community Version switches to the mentioned (of course, non real-time capable) cloud API. If you require real-time calculation on your own hardware, please contact us for the <em>Ruckig Pro Version</em>.</p>

<p>When using <em>intermediate positions</em>, both the underlying motion planning problem as well as its calculation changes significantly. In particular, there are some fundamental limitations for jerk-limited online trajectory generation regarding the usage of waypoints. Please find more information about these limitations <a href="https://docs.ruckig.com/md_pages_2__intermediate__waypoints.html">here</a>, and in general we recommend to use</p>

<pre><code class="language-.cpp">input.intermediate_positions = otg.filter_intermediate_positions(input.intermediate_positions, {0.1, ...});

</code></pre>
<p>to filter waypoints according to a (high) threshold distance. Setting <em>interrupt_calculation_duration</em> makes sure to be real-time capable by refining the solution in the next control invocation. Note that this is a soft interruption of the calculation. Currently, no minimum or discrete durations are supported when using intermediate positions.</p>

<h3 id="input-parameter">Input Parameter</h3>

<p>To go into more detail, the <em>InputParameter</em> type has following members:</p>

<pre><code class="language-.cpp">using Vector = std::array&lt;double, DOFs&gt;; // By default

Vector current_position;
Vector current_velocity; // Initialized to zero
Vector current_acceleration; // Initialized to zero

std::vector&lt;Vector&gt; intermediate_positions; // (only in Pro Version)

Vector target_position;
Vector target_velocity; // Initialized to zero
Vector target_acceleration; // Initialized to zero

Vector max_velocity;
Vector max_acceleration;
Vector max_jerk; // Initialized to infinity

std::optional&lt;Vector&gt; min_velocity; // If not given, the negative maximum velocity will be used.
std::optional&lt;Vector&gt; min_acceleration; // If not given, the negative maximum acceleration will be used.

std::optional&lt;Vector&gt; min_position; // (only in Pro Version)
std::optional&lt;Vector&gt; max_position; // (only in Pro Version)

std::array&lt;bool, DOFs&gt; enabled; // Initialized to true
std::optional&lt;double&gt; minimum_duration;
std::optional&lt;double&gt; interrupt_calculation_duration; // [µs], (only in Pro Version)

ControlInterface control_interface; // The default position interface controls the full kinematic state.
Synchronization synchronization; // Synchronization behavior of multiple DoFs
DurationDiscretization duration_discretization; // Whether the duration should be a discrete multiple of the control cycle (off by default)

std::optional&lt;Vector&lt;ControlInterface&gt;&gt; per_dof_control_interface; // Sets the control interface for each DoF individually, overwrites global control_interface
std::optional&lt;Vector&lt;Synchronization&gt;&gt; per_dof_synchronization; // Sets the synchronization for each DoF individually, overwrites global synchronization

</code></pre>

<p>On top of the current state, target state, and constraints, Ruckig allows for a few more advanced settings:</p>
<ul>
  <li>A <em>minimum</em> velocity and acceleration can be specified - these should be a negative number. If they are not given, the negative maximum velocity or acceleration will be used (similar to the jerk limit). For example, this might be useful in human robot collaboration settings with a different velocity limit towards a human. Or, when switching between different moving coordinate frames like picking from a conveyer belt.</li>
  <li>You can overwrite the global kinematic limits to specify limits for each section between two waypoints separately by using e.g. <code class="language-plaintext highlighter-rouge">per_section_max_velocity</code>.</li>
  <li>If a DoF is not <em>enabled</em>, it will be ignored in the calculation. Ruckig will output a trajectory with constant acceleration for those DoFs.</li>
  <li>A <em>minimum duration</em> can be optionally given. Note that Ruckig can not guarantee an exact, but only a minimum duration of the trajectory.</li>
  <li>The control interface (position or velocity control) can be switched easily. For example, a stop trajectory or visual servoing can be easily implemented with the velocity interface.</li>
  <li>Different synchronization behaviors (i.a. phase, time, or no synchonization) are implemented. Phase synchronization results in straight-line motions.</li>
  <li>The trajectory duration might be constrained to a multiple of the control cycle. This way, the <em>exact</em> state can be reached at a control loop execution.</li>
</ul>

<p>We refer to the <a href="https://docs.ruckig.com/namespaceruckig.html">API documentation</a> of the enumerations within the <code class="language-plaintext highlighter-rouge">ruckig</code> namespace for all available options.</p>

<h3 id="input-validation">Input Validation</h3>

<p>To check that Ruckig is able to generate a trajectory before the actual calculation step,</p>

<pre><code class="language-.cpp">ruckig.validate_input(input, check_current_state_within_limits=false, check_target_state_within_limits=true);
// returns true or throws

</code></pre>
<p>throws an error with a detailed reason if an input is not valid. You can also set the default template parameter to false via <code class="language-plaintext highlighter-rouge">ruckig.validate_input&lt;false&gt;(...)</code> to just return a boolean true or false. The two boolean arguments check that the current or target state are within the limits. The check includes a typical catch of jerk-limited trajectory generation: When the current state is at maximal velocity, any positive acceleration will inevitable lead to a velocity violation <em>at a future timestep</em>. In general, this condition is fulfilled when</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Abs(acceleration) &lt;= Sqrt(2 * max_jerk * (max_velocity - Abs(velocity))).

</code></pre></div></div>
<p>If both arguments are set to true, the calculated trajectory is guaranteed to be <em>within the kinematic limits throughout</em> its duration. Also, note that there are range constraints of the input due to numerical reasons, see below for more details.</p>

<h3 id="result-type">Result Type</h3>

<p>The <code class="language-plaintext highlighter-rouge">update</code> function of the Ruckig class returns a Result type that indicates the current state of the algorithm. This can either be <strong>working</strong>, <strong>finished</strong> if the trajectory has finished, or an <strong>error</strong> type if something went wrong during calculation. The result type can be compared as a standard integer.</p>

<table>
  <thead>
    <tr>
      <th>State</th>
      <th>Error Code</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Working</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Finished</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Error</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>ErrorInvalidInput</td>
      <td>-100</td>
    </tr>
    <tr>
      <td>ErrorTrajectoryDuration</td>
      <td>-101</td>
    </tr>
    <tr>
      <td>ErrorPositionalLimits</td>
      <td>-102</td>
    </tr>
    <tr>
      <td>ErrorExecutionTimeCalculation</td>
      <td>-110</td>
    </tr>
    <tr>
      <td>ErrorSynchronizationCalculation</td>
      <td>-111</td>
    </tr>
  </tbody>
</table>

<h3 id="output-parameter">Output Parameter</h3>

<p>The output class includes the new kinematic state and the overall trajectory.</p>

<pre><code class="language-.cpp">Vector new_position;
Vector new_velocity;
Vector new_acceleration;

Trajectory trajectory; // The current trajectory
double time; // The current, auto-incremented time. Reset to 0 at a new calculation.

size_t new_section; // Index of the section between two (possibly filtered) intermediate positions.
bool did_section_change; // Was a new section reached in the last cycle?

bool new_calculation; // Whether a new calculation was performed in the last cycle
bool was_calculation_interrupted; // Was the trajectory calculation interrupted? (only in Pro Version)
double calculation_duration; // Duration of the calculation in the last cycle [µs]

</code></pre>
<p>Moreover, the <strong>trajectory</strong> class has a range of useful parameters and methods.</p>

<pre><code class="language-.cpp">double duration; // Duration of the trajectory
std::array&lt;double, DOFs&gt; independent_min_durations; // Time-optimal profile for each independent DoF

&lt;...&gt; at_time(double time); // Get the kinematic state of the trajectory at a given time
&lt;...&gt; get_position_extrema(); // Returns information about the position extrema and their times

</code></pre>
<p>Again, we refer to the <a href="https://docs.ruckig.com">API documentation</a> for the exact signatures.</p>

<h3 id="offline-calculation">Offline Calculation</h3>

<p>Ruckig also supports an offline approach for calculating a trajectory:</p>

<pre><code class="language-.cpp">result = ruckig.calculate(input, trajectory);

</code></pre>
<p>When only using this method, the <code class="language-plaintext highlighter-rouge">Ruckig</code> constructor does not need a control cycle (<code class="language-plaintext highlighter-rouge">delta_time</code>) as an argument. However if given, Ruckig supports stepping through the trajectory with</p>

<pre><code class="language-.cpp">while (ruckig.update(trajectory, output) == Result::Working) {
  // Make use of the new state here!
  // e.g. robot-&gt;setJointPositions(output.new_position);
}

</code></pre>
<p>starting from the current <code class="language-plaintext highlighter-rouge">output.time</code> (currently Ruckig Pro only).</p>

<h3 id="tracking-interface">Tracking Interface</h3>

<p>When following an arbitrary signal with position, velocity, acceleration, and jerk-limitation, the straight forward way would be to pass the current state to Ruckig’s target state. However, as the resulting trajectory will take time to catch up, this approach will always lag behind the signal. The tracking interface solves this problem by predicting ahead (e.g. with constant acceleration by default) and is therefore able to follow signals very closely in a time-optimal way. This might be very helpful for (general) tracking, robot servoing, or trajectory post-processing applications.</p>

<p>To use the tracking interface, construct</p>

<pre><code class="language-.cpp">Trackig&lt;1&gt; otg {0.01};  // control cycle

</code></pre>
<p>and set the current state as well as the kinematic constraints via</p>

<pre><code class="language-.cpp">input.current_position = {0.0};
input.current_velocity = {0.0};
input.current_acceleration = {0.0};
input.max_velocity = {0.8};
input.max_acceleration = {2.0};
input.max_jerk = {5.0};

</code></pre>
<p>Then, we can track a signal in an online manner within the real-time control loop</p>

<pre><code class="language-.cpp">for (double t = 0; t &lt; 10.0; t += otg.delta_time) {
  auto target_state = signal(t); // signal returns position, velocity, and acceleration
  auto res = otg.update(target_state, input, output);
  // Make use of the smooth target motion here (e.g. output.new_position)

  output.pass_to_input(input);
}

</code></pre>
<p>Please find a complete example <a href="https://github.com/pantor/ruckig/blob/main/examples/13_tracking.cpp">here</a>. This functionality can also be used in an offline manner, e.g. when the entire signal is known beforehand. Here, we call the</p>

<pre><code class="language-.cpp">smooth_trajectory = otg.calculate_trajectory(target_states, input);

</code></pre>
<p>method with the trajectory given as a <code class="language-plaintext highlighter-rouge">std::vector</code> of target states. The Tracking interface is available in the Ruckig Pro version.</p>

<h3 id="dynamic-number-of-degrees-of-freedom">Dynamic Number of Degrees of Freedom</h3>

<p>So far, we have told Ruckig the number of DoFs as a template parameter. If you don’t know the number of DoFs at compile-time, you can set the template parameter to <code class="language-plaintext highlighter-rouge">ruckig::DynamicDOFs</code> and pass the DoFs to the constructor:</p>

<pre><code class="language-.cpp">Ruckig&lt;DynamicDOFs&gt; otg {6, 0.001};
InputParameter&lt;DynamicDOFs&gt; input {6};
OutputParameter&lt;DynamicDOFs&gt; output {6};

</code></pre>

<p>This switches the default Vector from the <code class="language-plaintext highlighter-rouge">std::array</code> to the dynamic <code class="language-plaintext highlighter-rouge">std::vector</code> type. However, we recommend to keep the template parameter when possible: First, it has a performance benefit of a few percent. Second, it is convenient for real-time programming due to its easier handling of memory allocations. When using dynamic degrees of freedom, make sure to allocate the memory of all vectors beforehand.</p>

<h3 id="custom-vector-types">Custom Vector Types</h3>

<p>Ruckig supports custom vector types to make interfacing with your code even easier and more flexible. Most importantly, you can switch to <a href="https://eigen.tuxfamily.org">Eigen Vectors</a> simply by including Eigen (3.4 or later) before Ruckig</p>

<pre><code class="language-.cpp">#include &lt;Eigen/Core&gt; // Version 3.4 or later
#include &lt;ruckig/ruckig.hpp&gt;

</code></pre>
<p>and then call the constructors with the <code class="language-plaintext highlighter-rouge">ruckig::EigenVector</code> parameter.</p>

<pre><code class="language-.cpp">Ruckig&lt;6, EigenVector&gt; otg {0.001};
InputParameter&lt;6, EigenVector&gt; input;
OutputParameter&lt;6, EigenVector&gt; output;

</code></pre>
<p>Now every in- and output of Ruckig’s API (such as <code class="language-plaintext highlighter-rouge">current_position</code>, <code class="language-plaintext highlighter-rouge">new_position</code> or <code class="language-plaintext highlighter-rouge">max_jerk</code>) are Eigen types! To define completely custom vector types, you can pass a C++ <a href="https://en.cppreference.com/w/cpp/language/template_parameters">template template parameter</a> to the constructor. This template template parameter needs to fulfill a range of template arguments and methods:</p>

<pre><code class="language-.cpp">template&lt;class Type, size_t DOFs&gt;
struct MinimalVector {
  Type operator[](size_t i) const; // Array [] getter
  Type&amp; operator[](size_t i); // Array [] setter
  size_t size() const; // Current size
  bool operator==(const MinimalVector&lt;T, DOFs&gt;&amp; rhs) const; // Equal comparison operator

  // Only required in combination with DynamicDOFs, e.g. to allocate memory
  void resize(size_t size);
};

</code></pre>
<p>Note that <code class="language-plaintext highlighter-rouge">DynamicDOFs</code> corresponds to <code class="language-plaintext highlighter-rouge">DOFs = 0</code>. We’ve included a range of examples for using Ruckig with <a href="https://github.com/pantor/ruckig/blob/main/examples/10_eigen_vector_type.cpp">(10) Eigen</a>, <a href="https://github.com/pantor/ruckig/blob/main/examples/11_custom_vector_type.cpp">(11) custom vector types</a>, and <a href="https://github.com/pantor/ruckig/blob/main/examples/12_custom_vector_type_dynamic_dofs.cpp">(12) custom types with a dynamic number of DoFs</a>.</p>

<h2 id="tests-and-numerical-stability">Tests and Numerical Stability</h2>

<p>The current test suite validates over 5.000.000.000 random trajectories as well as many additional edge cases. The numerical exactness is tested for the final position and final velocity to be within <code class="language-plaintext highlighter-rouge">1e-8</code>, for the final acceleration to be within <code class="language-plaintext highlighter-rouge">1e-10</code>, and for the velocity, acceleration and jerk limit to be within of a numerical error of <code class="language-plaintext highlighter-rouge">1e-12</code>. These are absolute values - we suggest to scale your input so that these correspond to your required precision of the system. For example, for most real-world systems we suggest to use input values in <code class="language-plaintext highlighter-rouge">[m]</code> (instead of e.g. <code class="language-plaintext highlighter-rouge">[mm]</code>), as <code class="language-plaintext highlighter-rouge">1e-8m</code> is sufficient precise for practical trajectory generation. Furthermore, all kinematic limits should be below <code class="language-plaintext highlighter-rouge">1e9</code>. The maximal supported trajectory duration is <code class="language-plaintext highlighter-rouge">7e3</code>. Note that Ruckig will also output values outside of this range, there is however no guarantee for correctness.</p>

<p>The Ruckig Pro version has additional tools to increase the numerical range and improve reliability. For example, the<code class="language-plaintext highlighter-rouge">position_scale</code> and <code class="language-plaintext highlighter-rouge">time_scale</code> parameter of the <code class="language-plaintext highlighter-rouge">Calculator</code> class change the internal representation of the input parameters.</p>

<pre><code class="language-.cpp">Ruckig&lt;1&gt; otg;
// Works also for Trackig&lt;1&gt; otg;

otg.calculator.position_scale = 1e2;  // Scales all positions in the input parameters
otg.calculator.time_scale = 1e3;  // Scale all times in the input parameters

</code></pre>
<p>This way, you can easily achieve the requirements above even for very high jerk limits or very long trajectories. Note that the scale parameters don’t effect the resulting trajectory - they are for internal calculation only.</p>

<h2 id="benchmark">Benchmark</h2>

<p>We find that Ruckig is more than twice as fast as Reflexxes Type IV for state-to-state motions and well-suited for control cycles as low as 250 microseconds. The Ruckig <em>Community Version</em> is in general a more powerful and open-source alternative to the <a href="http://reflexxes.ws/">Reflexxes Type IV</a> library. In fact, Ruckig is the first Type V trajectory generator for arbitrary target states and even supports directional velocity and acceleration limits, while also being faster on top.</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/benchmark.png?raw=true" alt="Benchmark"></p>

<p>For trajectories with intermediate waypoints, we compare Ruckig to <a href="https://github.com/hungpham2511/toppra">Toppra</a>, a state-of-the-art library for robotic motion planning. Ruckig is able to improve the trajectory duration on average by around 10%, as the path planning and time parametrization are calculated jointly. Moreover, Ruckig is real-time capable and supports jerk-constraints.</p>

<p><img src="https://github.com/pantor/ruckig/raw/main/doc/ruckig_toppra_example.png?raw=true" alt="Benchmark"></p>

<h2 id="development">Development</h2>

<p>Ruckig is written in C++17. It is continuously tested on <code class="language-plaintext highlighter-rouge">ubuntu-latest</code>, <code class="language-plaintext highlighter-rouge">macos-latest</code>, and <code class="language-plaintext highlighter-rouge">windows-latest</code> against following versions</p>

<ul>
  <li>Doctest v2.4 (only for testing)</li>
  <li>Nanobind v2.4 (only for Python wrapper)</li>
</ul>

<p>A C++11 and C++03 version of Ruckig is also available - please contact us if you’re interested.</p>

<h2 id="used-by">Used By</h2>

<p>Ruckig is used by over hundred research labs, companies, and open-source projects worldwide, including:</p>
<ul>
  <li>
<a href="https://moveit.ros.org">MoveIt 2</a> for trajectory generation.</li>
  <li>
<a href="https://www.coppeliarobotics.com/">CoppeliaSim</a> starting from version 4.3.</li>
  <li><a href="https://flr.io">Fuzzy Logic Robotics</a></li>
  <li><a href="https://www.gestalt-robotics.com">Gestalt Robotics</a></li>
  <li>
<a href="https://github.com/stefanbesler/struckig">Struckig</a>, a port of Ruckig to Structered Text (ST - IEC61131-3) for usage on PLCs.</li>
  <li>
<a href="https://www.scanlab.de/de">Scanlab</a> for controlling lasers.</li>
  <li>
<a href="https://github.com/pantor/frankx">Frankx</a> for controlling the Franka Emika robot arm.</li>
  <li>
<a href="https://wiredworks.com">Wiredworks</a> made a simple Kivy <a href="https://github.com/wiredworks/ruckig-showcase">GUI application</a>
</li>
  <li>and many others!</li>
</ul>

<h2 id="citation">Citation</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@article{berscheid2021jerk,
  title={Jerk-limited Real-time Trajectory Generation with Arbitrary Target States},
  author={Berscheid, Lars and Kr{\"o}ger, Torsten},
  journal={Robotics: Science and Systems XVII},
  year={2021}
}

</code></pre></div></div>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <em>No CONTRIBUTING.md found.</em>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-melodic">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/ruckig">ruckig</a> <small>repository</small></h3>
        <span class="label label-default">robotics</span> <span class="label label-default">motion-planning</span> <span class="label label-default">trajectory-generation</span> <span class="label label-default">optimal-control</span> <span class="label label-default">robot-arm</span> <span class="label label-default">jerk-constrained</span> <span class="label label-default">time-optimal</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-pantor-ruckig
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-pantor-ruckig" role="menuitem" tabindex="-1" href="/r/ruckig/github-pantor-ruckig" data="github-pantor-ruckig">
                    <span class="glyphicon glyphicon-star"></span>
                    github-pantor-ruckig
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>melodic</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>


<script src=/js/contribution_suggestions.js></script>
<script type="text/javascript">
  $(function() {
    setupContributeListTabLinks();
  });
  $(document).ready(function() {
    setupDistroSwitch("humble");
    setupContributeLists("https://github.com/pantor/ruckig.git");
  });
</script>

      </div>
    </div>

    <footer class="site-footer">
  <div class="wrapper">
    <div class="container-fluid">
      <div style="float:left;">
        
          <a href="https://github.com/rkent/rosindex" title="Find rosindex in Github">
          <span class="icon  icon--github">
            <svg viewBox="0 0 16 16">
              <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
            </svg>
          </span>

          <span class="username">rkent/rosindex</span>
        </a>
        <em class="hidden-xs">| generated on 2025-05-05</em>
      
      </div>
      <div style="float:right;">
        <p class="text"><span class="hidden-xs">a community-maintained index of robotics software
 | </span><a href="/privacy.txt">privacy</a></p>
      </div>
    </div>
  </div>

</footer>


  </body>

</html>
