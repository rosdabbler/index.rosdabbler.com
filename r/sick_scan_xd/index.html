<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>ROS Index</title>
    <meta name="description" content="a community-maintained index of robotics software
">

    
    <link rel="canonical" href="http://index.rosdabbler.com/r/sick_scan_xd/">
    
    
    <link rel="icon" sizes="any" type="image/svg+xml" href="/assets/rosindex_logo.svg">

    

    <link rel="stylesheet" type="text/css" href="/bootstrap/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="/css/main.css">
    

    

    <script type="text/javascript" src=/js/jquery.js></script>
    <script src=/bootstrap/js/bootstrap.min.js type="text/javascript"></script>
    <script src=/js/jquery-cookie.js type="text/javascript"></script>
    
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EVD5Z6G6NH"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EVD5Z6G6NH');
</script>

    <script type="text/javascript" src=/js/toc.js></script>

    <script src=/js/distro_switch.js></script>
  </head>

  <body>

    <header class="site-header">

  <div class="wrapper">
    <div class="container-fluid" style="margin-bottom: 10px">
      <div class="row">
        <!-- title -->
        <div class="col-xs-3" style="white-space:nowrap">
          <a class="site-title" href="/">
            <img src="/assets/rosindex_logo.svg" width="26" height="26" alt="ROS index logo" style="padding-bottom: 3px"/>
            ROS Index</a>
        </div>
        <!-- main internal links -->
        <div class="col-xs-6 text-center" style="padding:0px">
          <div class="btn-group hidden-xs" role="group" aria-label="..." style="padding: 6px">
            <div class="btn-group" role="group">
              <a href="/?search_packages=true" class="btn btn-default" role="button">Package List</a>
            </div>
            <div class="btn-group" role="group">
              <a href="/?search_repos=true" class="btn btn-default" role="button">Repository List</a>
            </div>
            <div class="btn-group" role="group">
              <a href="/search_deps" class="btn btn-default" role="button">System Dependencies</a>
            </div>
          </div>
          <div class="hidden-lg hidden-md hidden-sm">
            <button id="hLabel" class="btn btn-link dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
              Lists <span class="caret"></span>
            </button>
            <ul class="dropdown-menu" aria-labelledby="hLabel">
              <li><a href="/?search_packages=true">Package List</a></li>
              <li><a href="/?search_repos=true">Repository List</a></li>
              <li><a href="/search_deps">System Dependencies</a></li>
            </ul>
          </div>
        </div>
        <!-- additional links -->
        <div class="col-xs-3 text-right" style="white-space:nowrap; padding:0px">
          <ul class="list-inline" style="margin-bottom:0px;">
            <li class="dropdown hidden-xs hidden-sm">
              <button id="rLabel" class="btn btn-link" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                ROS Resources <span class="caret"></span>
              </button>
              <ul class="dropdown-menu" role="menu" aria-labelledby="rLabel">
                <li><a href="http://docs.ros.org/">Documentation</a></li>
                <li><a href="http://wiki.ros.org/Support">Support</a></li>
                <li><a href="http://discourse.ros.org/">Discussion Forum</a></li>
                <li><a href="http://status.ros.org/">Service Status</a></li>
                <li><a href="https://robotics.stackexchange.com/questions/tagged/ros">ros @ Robotics Stack Exchange</a></li>
                <li><a href="https://docs.ros.org/en/ros2_packages/">Package API</a></li>
              </ul>
            </li>
            <li class="dropdown hidden-xs hidden-sm">
              <button id="aLabel" class="btn btn-link" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                About <span class="caret"></span>
              </button>
              <ul class="dropdown-menu dropdown-menu-right" role="menu" aria-labelledby="aLabel">
                <li><a href="/about">About </a></li>
                <li><a href="/contribute">Contribute</a></li>
                <li><a href="/help">Help</a></li>
                <li><a href="/stats">Stats</a></li>
              </ul>
            </li>
            <li class="dropdown hidden-md hidden-lg">
              <button id="qLabel" class="btn btn-link" type="button"
                      data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                Resources <span class="caret"></span>
              </button>
              <ul class="dropdown-menu dropdown-menu-right" role="menu" aria-labelledby="qLabel">
                <li><a href="/about">About </a></li>
                <li><a href="/contribute">Contribute</a></li>
                <li><a href="/help">Help</a></li>
                <li><a href="/stats">Stats</a></li>
                <hr style="margin:7px" />
                <li><a href="http://docs.ros.org/">Documentation</a></li>
                <li><a href="http://wiki.ros.org/Support">Support</a></li>
                <li><a href="http://discourse.ros.org/">Discussion Forum</a></li>
                <li><a href="http://status.ros.org/">Service Status</a></li>
                <li><a href="https://robotics.stackexchange.com/questions/tagged/ros">ros @ Robotics Stack Exchange</a></li>
                <li><a href="https://docs.ros.org/en/ros2_packages/">Package API</a></li>
              </ul>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="container-fluid" style="margin-top:20px">
  <div class="container-fluid">
    <div class="row">
      <ol class="breadcrumb">
        <li><a href="/">Home</a></li>
        <li><a href="/repos">Repos</a></li>
        <li class="active">sick_scan_xd</li>
        <!--<li class="active">sick_scan_xd</li>-->
      </ol>
    </div>
    <div class="row">
      

<div id="distro-switch" class="btn-group btn-group-justified" data-toggle="buttons">
  
    <label id="humble-option" class="distro-button btn btn-xs btn-primary" href="#humble" data="humble">
      <input type="radio" name="options" id="humble-radio" autocomplete="off"> humble
    </label>
  
    <label id="jazzy-option" class="distro-button btn btn-xs btn-primary" href="#jazzy" data="jazzy">
      <input type="radio" name="options" id="jazzy-radio" autocomplete="off"> jazzy
    </label>
  
    <label id="kilted-option" class="distro-button btn btn-xs btn-default" href="#kilted" data="kilted">
      <input type="radio" name="options" id="kilted-radio" autocomplete="off"> kilted
    </label>
  
    <label id="rolling-option" class="distro-button btn btn-xs btn-default" href="#rolling" data="rolling">
      <input type="radio" name="options" id="rolling-radio" autocomplete="off"> rolling
    </label>
  
    <label id="github-option" class="distro-button btn btn-xs btn-default" href="#github" data="github">
      <input type="radio" name="options" id="github-radio" autocomplete="off"> github
    </label>
  
    <label id="noetic-option" class="distro-button btn btn-xs btn-primary" href="#noetic" data="noetic">
      <input type="radio" name="options" id="noetic-radio" autocomplete="off"> noetic
    </label>
  

  <!-- Older distros -->
  <div class="btn-group dropdown">
    <label type="button" class="btn btn-xs dropdown-toggle btn-primary" data-toggle="dropdown" id="older-distro-button">
        <input type="radio" name="options" autocomplete="off">
      <span id="older-label">Older</span>
      <span class="caret"></span>
    </label>
    <ul class="dropdown-menu" role="menu">
      
        <li data="galactic" id="galactic-option" class="disabled older-distro-option"  href="#galactic">
          <a href="#galactic" data="galactic" id="galactic-button">galactic</a>
        </li>
      
        <li data="iron" id="iron-option" class=" older-distro-option"  href="#iron">
          <a href="#iron" data="iron" id="iron-button">iron</a>
        </li>
      
        <li data="melodic" id="melodic-option" class="disabled older-distro-option"  href="#melodic">
          <a href="#melodic" data="melodic" id="melodic-button">melodic</a>
        </li>
      
    </ul>
  </div>
</div>

    </div>
    <div class="row">
      &nbsp;
    </div>
  </div>
</div>


  <div class="distro distro-humble">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/sick_scan_xd">sick_scan_xd</a> <small>repository</small></h3>
        <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        
        <a class="label label-primary pkg-label" href="/p/sick_scan_xd">sick_scan_xd</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-SICKAG-sick_scan_xd
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-SICKAG-sick_scan_xd" role="menuitem" tabindex="-1" href="/r/sick_scan_xd/github-SICKAG-sick_scan_xd" data="github-SICKAG-sick_scan_xd">
                    <span class="glyphicon glyphicon-star"></span>
                    github-SICKAG-sick_scan_xd
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">A versatile driver for a wide range of SICK LiDAR and RADAR devices, providing support for both Linux (native, ROS 1, ROS 2) and Windows (native, ROS 2) platforms.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/SICKAG/sick_scan_xd.git">https://github.com/SICKAG/sick_scan_xd.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">master</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2024-10-23
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/sick_scan_xd/#humble-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/sick_scan_xd/#humble-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/sick_scan_xd/#humble-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/sick_scan_xd">sick_scan_xd</a></td>
                    <td>3.6.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<p><img align="right" width="200" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Logo_SICK_AG_2009.svg/1200px-Logo_SICK_AG_2009.svg.png"></p>

<h2 id="executive-summary">Executive Summary</h2>

<p>This project provides a driver for the SICK LiDARs and Radar sensors mentioned <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#supported-sick-devices">here</a>. The driver supports both Linux (native, ROS 1, ROS 2) and Windows (native and ROS 2). See the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/CHANGELOG.md">CHANGELOG.md</a> for the latest updates.</p>

<p><strong>Main features and characteristics</strong></p>
<ul>
  <li>Support of ROS 1 (Linux), ROS 2 (Linux and Windows)</li>
  <li>Generic C/C++ and python API for usage without ROS (Linux and Windows)</li>
  <li>SLAM support</li>
  <li>Compatible with x64 and ARM64 architecture (incl. Raspberry Pi)</li>
  <li>No dependencies to 3rd party libraries like boost</li>
</ul>

<h2 id="table-of-contents">Table of Contents</h2>

<details>
  <summary>Expand to full table of contents </summary>

- [Repository organization](#repository-organization)
- [Supported SICK Devices](#supported-sick-devices)
- [Getting started](#getting-started)
  - [Detecting SICK devices in the network](#detecting-sick-devices-in-the-network)
  - [Change IP address](#change-ip-address)
  - [Starting with a new lidar](#starting-with-a-new-lidar)
  - [Test connection (Linux)](#test-connection-linux)
- [Building the driver](#building-the-driver)
  - [Build on Linux ROS 1](#build-on-linux-ros-1)
    - [Install prebuilt binaries](#install-prebuilt-binaries)
    - [Build from sources](#build-from-sources)
  - [Build on Linux ROS 2](#build-on-linux-ros-2)
    - [Install prebuilt binaries](#install-prebuilt-binaries-1)
    - [Build from sources](#build-from-sources-1)
  - [Build on Windows ROS 2](#build-on-windows-ros-2)
  - [Build on Linux generic without ROS](#build-on-linux-generic-without-ros)
  - [Build on Windows generic without ROS](#build-on-windows-generic-without-ros)
- [Running the driver](#running-the-driver)
  - [Starting Scanner with Specific IP Address](#starting-scanner-with-specific-ip-address)
  - [Start Multiple Nodes](#start-multiple-nodes)
  - [Common parameters](#common-parameters)
  - [Further useful parameters and features](#further-useful-parameters-and-features)
  - [ROS services](#ros-services)
  - [Driver states, timeouts](#driver-states-timeouts)
  - [SOPAS Mode](#sopas-mode)
  - [Example Startup Sequence](#example-startup-sequence)
- [Driver features and additional information](#driver-features-and-additional-information)
  - [Software Overview](#software-overview)
    - [Software structure](#software-structure)
    - [Message receiving and message handling](#message-receiving-and-message-handling)
    - [sick\_scansegment\_xd](#sick_scansegment_xd)
    - [Files and folders](#files-and-folders)
  - [Generic Driver API](#generic-driver-api)
    - [Overview](#overview)
    - [Build and test shared library](#build-and-test-shared-library)
    - [Usage example](#usage-example)
    - [C-API](#c-api)
    - [Useful links](#useful-links)
  - [Timestamps and synchronization (Software PLL)](#timestamps-and-synchronization-software-pll)
  - [Coordinate transforms](#coordinate-transforms)
  - [IMU Support](#imu-support)
  - [Encoders](#encoders)
    - [Connecting encoders](#connecting-encoders)
    - [Example circuit to trigger encoder counts](#example-circuit-to-trigger-encoder-counts)
    - [Activation of encoder information](#activation-of-encoder-information)
  - [Field Evaluation Information](#field-evaluation-information)
    - [Field monitoring messages](#field-monitoring-messages)
    - [Visualization with rviz](#visualization-with-rviz)
    - [Cola commands](#cola-commands)
    - [Tools, emulation and unittests](#tools-emulation-and-unittests)
  - [SLAM Support](#slam-support)
    - [Introduction](#introduction)
    - [Measuring Principle](#measuring-principle)
    - [NAV350 ROS 1 SLAM example](#nav350-ros-1-slam-example)
    - [NAV350 ROS 2 SLAM example](#nav350-ros-2-slam-example)
    - [picoScan100 ROS 1 SLAM example](#picoscan100-ros-1-slam-example)
    - [MRS1104 SLAM support](#mrs1104-slam-support)
    - [Google Cartographer](#google-cartographer)
    - [OctoMap](#octomap)
    - [RTAB-Map](#rtab-map)
  - [Raspberry Pi Support](#raspberry-pi-support)
    - [multiScan100 example](#multiscan100-example)
    - [Performance](#performance)
    - [Troubleshooting](#troubleshooting)
  - [More Tools](#more-tools)
- [Device specific information](#device-specific-information)
  - [picoScan100/multiScan100](#picoscan100multiscan100)
    - [Configuration](#configuration)
    - [IMU support](#imu-support-1)
    - [SOPAS support](#sopas-support)
    - [Run multiScan100 and picoScan100 simultaneously](#run-multiscan100-and-picoscan100-simultaneously)
    - [Visualization](#visualization)
    - [PointCloud memory layout](#pointcloud-memory-layout)
    - [Customized point clouds](#customized-point-clouds)
    - [Customized point clouds on a Raspberry Pi](#customized-point-clouds-on-a-raspberry-pi)
    - [MSGPACK validation](#msgpack-validation)
    - [Firewall configuration](#firewall-configuration)
    - [SOPAS support for sick\_scan\_segment\_xd](#sopas-support-for-sick_scan_segment_xd)
  - [TiM781 and TiM781S](#tim781-and-tim781s)
  - [TiM240](#tim240)
  - [NAV350](#nav350)
    - [Process loop](#process-loop)
    - [Initialization and setup](#initialization-and-setup)
    - [Messages](#messages)
    - [Odometry messages](#odometry-messages)
    - [Angle compensation](#angle-compensation)
  - [MRS6124](#mrs6124)
    - [Timing between Layers](#timing-between-layers)
    - [MRS600 with RMS1000](#mrs600-with-rms1000)
  - [RMS1000](#rms1000)
    - [Raw Targets](#raw-targets)
    - [Tracking Objects](#tracking-objects)
    - [ROS message for Radar](#ros-message-for-radar)
    - [Launch Files](#launch-files)
    - [Parameter for Radar Usage](#parameter-for-radar-usage)
    - [Radar Datagram](#radar-datagram)
  - [RMS1000 and LMS1000 combination](#rms1000-and-lms1000-combination)
  - [LMS1000 and MRS1000 interlacing](#lms1000-and-mrs1000-interlacing)
- [FAQ](#faq)
  - [General](#general)
  - [Networking](#networking)
  - [multiScan100 / picoScan100](#multiscan100--picoscan100)
- [Troubleshooting and technical support](#troubleshooting-and-technical-support)
- [Creators and contribution](#creators-and-contribution)
- [Keywords](#keywords)


</details>

<h1 id="repository-organization">Repository organization</h1>

<p>The repository supports two main branches. The <strong>“master”</strong> branch is the branch that contains official releases that are tagged and versioned and also included in the ROS distribution. If you want to work with this official branch, you must explicitly specify this branch in the ‘git clone’ command by adding “-b master”. The “develop” branch is the default branch and contains the latest development status.</p>

<p>Example:</p>

<p>Checking out the latest revision (usually older than the develop version, but officially released):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone -b master https://github.com/SICKAG/sick_scan_xd.git

</code></pre></div></div>

<p>Checking out the latest development status:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/SICKAG/sick_scan_xd.git

</code></pre></div></div>

<h1 id="supported-sick-devices">Supported SICK Devices</h1>

<p>The driver supports Ethernet-IPv4-based communication with all of the following SICK products.</p>

<table>
  <thead>
    <tr>
      <th>2D LiDAR sensors</th>
      <th>Part no.</th>
      <th>3D LiDAR sensors</th>
      <th>Part no.</th>
      <th>RADAR sensors</th>
      <th>Part no.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>picoScan100 <a href="https://support.sick.com/sick-knowledgebase/article/?code=KA-09438">(supports native ROS 2 as well)</a>
</td>
      <td><a href="https://www.sick.com/de/en/search?text=1134610">e.g. 1134610</a></td>
      <td>multiScan100</td>
      <td><a href="https://www.sick.com/de/en/search?text=1131164">e.g. 1131164</a></td>
      <td>RMS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1107598">e.g. 1107598</a></td>
    </tr>
    <tr>
      <td>LRS4000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1098855">e.g. 1098855</a></td>
      <td>MRS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1081208">e.g. 1081208</a></td>
      <td>RMS2000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1129088">e.g. 1129088</a></td>
    </tr>
    <tr>
      <td>TiM2xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1104981">1104981</a></td>
      <td>MRS6124</td>
      <td><a href="https://www.sick.com/de/en/search?text=6065086">6065086</a></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM5xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060445">e.g. 1060445</a></td>
      <td>LD-MRS</td>
      <td><a href="https://www.sick.com/de/de/p/p662073">e.g. 1115128</a></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM7xxS</td>
      <td><a href="https://www.sick.com/de/en/search?text=1105052">e.g. 1105052</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM7xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1096807">e.g 1096807</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS5xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1046135">e.g. 1046135</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1092445">1092445</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS1xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1041114">e.g. 1041114</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS4000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1091423">e.g. 1091423</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LD-LRS</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060831">e.g. 1060831</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LD-OEM</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060828">e.g. 1060828</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV3xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060834">e.g. 1060834</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV2xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1074308">e.g. 1074308</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS family is currently not supported on Windows.</li>
    <li>ROS services require installation of ROS 1 or ROS 2.</li>
    <li>ROS services are currently not available for LD-MRS.</li>
    <li>Publishing point cloud data requires ROS 1 or ROS 2. On native Linux and native Windows, point cloud data are exported via API</li>
    <li>The driver is not tested on MAC</li>
  </ul>
</blockquote>

<h1 id="getting-started">Getting started</h1>

<p>Run the following steps for a quick start:</p>

<ol>
  <li>
    <p>Create a workspace (e.g. folder <code class="language-plaintext highlighter-rouge">sick_scan_ws</code>), clone the sick_scan_xd repository and build sick_generic_caller and shared library:</p>

    <ul>
      <li>For <strong>Linux without ROS</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-generic-without-ros">build instructions for Linux generic without ROS</a>
</li>
      <li>For <strong>Linux with ROS 1</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-ros-1">build instructions for Linux ROS 1</a>
</li>
      <li>For <strong>Linux with ROS 2</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-ros-2">build instructions for Linux ROS 2</a>
</li>
      <li>For <strong>Windows without ROS</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-windows-generic-without-ros">build instructions for Windows without ROS</a>
</li>
      <li>For <strong>Windows with ROS 2</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-windows-ros-2">build instructions for Windows with ROS 2</a>
</li>
    </ul>
  </li>
  <li>
    <p>Connect your lidar. Check the network connection by <code class="language-plaintext highlighter-rouge">ping &lt;lidar-ip-address&gt;</code>.</p>
  </li>
  <li>
    <p>Run the sick_scan_xd driver:</p>

    <p>For <strong>Linux without ROS</strong>: Use the sick_scan_xd API and run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to the build folder
      ./build/sick_scan_xd_api_test ./sick_scan_xd/launch/sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Linux with ROS 1</strong>: Launch sick_scan_xd: <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      source ./devel_isolated/setup.bash
      roslaunch sick_scan_xd sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Linux with ROS 2</strong>: Run <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      source ./install/setup.bash
      ros2 launch sick_scan_xd sick_tim_7xx.launch.py hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Windows without ROS</strong>: Use the sick_scan_xd API and run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd .\sick_scan_ws\sick_scan_xd
      set PATH=.;.\build;..\build\Debug;%PATH%
      .\build\Debug\sick_scan_xd_api_test.exe launch/sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Windows with ROS 2</strong>: Run <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd .\sick_scan_ws
      call .\install\setup.bat
      ros2 launch sick_scan_xd sick_tim_7xx.launch.py hostname:=192.168.0.1
      
</code></pre></div></div>

<h2 id="detecting-sick-devices-in-the-network">Detecting SICK devices in the network</h2>

<p>The Python script</p>

<pre><code class="language-sick_scan_xd/tools/sick_generic_device_finder/sick_generic_device_finder.py">
</code></pre>
<p>sends a UDP broadcast to which all available scanners respond with a device description.
The variable
<code class="language-plaintext highlighter-rouge">UDP_IP = "192.168.0.255"
</code> defines the broadcast address used by the script.
If you are using a different IP address configuration on your host pc you have to change this variable according to the broadcast address of your network card.</p>

<pre><code class="language-ifconfig">``` shows the broadcast address for every network adapter.

## Change IP address

The IP address of the device can be changed with a customized launch file. The following launch sequence is an example:

```roslaunch sick_scan_xd sick_new_ip.launch hostname:=192.168.0.1 new_IP:=192.168.0.100
</code></pre>

<p>The launch file restarts the lidar after the address change and stops the sick_scan_xd node. After a few seconds of booting time the scanner is reachable under the new IP address. The Python script is experimental. It is known that some ethernet adapter are not fully supported. As a fallback solution you can always use the SOPAS ET software under windows.</p>

<h2 id="starting-with-a-new-lidar">Starting with a new lidar</h2>

<p>The lidar is delivered with a standard IP address, to read or change it the <a href="https://www.sick.com/de/de/sopas-engineering-tool-2018/p/p367244">SICK SOPAS ET</a> for windows can be used.
When the tool is started, a search is performed which lists all scanners available in the network.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/scanner_found.PNG" alt="SOPAS start" title="SOPAS start"></p>

<p>Double-click to select the scanner for the project</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/scanner_added.PNG" alt="SOPAS select" title="SOPAS select"></p>

<p>Double click on the lidar icon to open the configuration menu of the scanner. Select here the network configuration menu and set the parameters by clicking on the save icon (red arrow)</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/set_config.PNG" alt="SOPAS save network" title="SOPAS save network"></p>

<p>To ensure that the settings are stored even after a power cycle, they must be stored in the eeprom. To do this, click on the eeprom icon and confirm the save.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/save_permanent.PNG" alt="SOPAS save eeprom" title="SOPAS save eeprom"></p>

<p>To test the settings under Windows use the commands</p>
<pre><code class="language-ipconfig">``` and 
```ping
``` in the 
```cmd.exe
```. Make sure that the lidar and host pc have different IP addresses e.g. 192.168.0.1 for the pc and 192.168.0.2 for the scanner.

## Test connection (Linux)

to test the settings under the Linux target system you can use netcat to check if a TCP connection to the scanner can be established

```nc -z -v -w5 $SCANNERIPADDRESS 2112
</code></pre>
<p>the connection can be successfully established</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/nc_scanner.PNG" alt="Linux netcat scanner" title="linux netcat scanner"></p>

<p>unlike a ping, the connection attempt to the host PC is not successful</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/nc_win_host.PNG" alt="Linux netcat host" title="linux netcat host"></p>

<h1 id="building-the-driver">Building the driver</h1>

<p>sick_scan_xd can be build on 64-bit Linux and Windows, with and without ROS, with and without LDMRS. The following table shows the allowed combinations and how to build. sick_scan_xd supports 64 bit Linux and Windows, 32 bit systems are not supported.</p>

<table>
  <thead>
    <tr>
      <th><strong>target</strong></th>
      <th><strong>cmake settings</strong></th>
      <th><strong>build script</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linux, native, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_linux.bash</td>
    </tr>
    <tr>
      <td>Linux, native, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_linux_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 1, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros1.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 1, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros1_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 2, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros2.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 2, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros2_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Windows, native, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test\scripts &amp;&amp; make_win64.cmd</td>
    </tr>
    <tr>
      <td>Windows, ROS 2, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test\scripts &amp;&amp; make_ros2.cmd</td>
    </tr>
  </tbody>
</table>

<p>If you’re using ROS, set your ROS-environment before running one of these scripts, f.e.
<code class="language-plaintext highlighter-rouge">source /opt/ros/noetic/setup.bash</code> for ROS 1 noetic, or
<code class="language-plaintext highlighter-rouge">source /opt/ros/foxy/setup.bash</code> for ROS 2 foxy, or
<code class="language-plaintext highlighter-rouge">source /opt/ros/humble/setup.bash</code> for ROS 2 humble.
See the build descriptions for more details.</p>

<h2 id="build-on-linux-ros-1">Build on Linux ROS 1</h2>

<p>To build resp. install sick_scan_xd on Linux with ROS 1, you can build sick_scan_xd from sources or install prebuilt binaries.</p>

<h3 id="install-prebuilt-binaries">Install prebuilt binaries</h3>

<p>Run the following steps to install sick_scan_xd on Linux with ROS 1 noetic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-noetic-sick-scan-xd

</code></pre></div></div>

<p>After successful installation, you can run sick_scan_xd using <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd &lt;launchfile&gt;</code>, e.g. <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_picoscan.launch</code> for picoScan. sick_scan_xd can be removed by <code class="language-plaintext highlighter-rouge">sudo apt-get remove ros-noetic-sick-scan-xd</code>.</p>

<h3 id="build-from-sources">Build from sources</h3>

<p>Run the following steps to build sick_scan_xd on Linux with ROS 1:</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir ./src
   pushd ./src
   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   rm -rf ./build ./build_isolated/ ./devel ./devel_isolated/ ./install ./install_isolated/ ./log/ # remove any files from a previous build
   
</code></pre></div></div>
<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   source /opt/ros/noetic/setup.bash # replace noetic by your ros distro
   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
   source ./devel_isolated/setup.bash
   # source ./install_isolated/setup.bash
   
</code></pre></div></div>
<p>For ROS versions other than noetic, please replace <code class="language-plaintext highlighter-rouge">source /opt/ros/noetic/setup.bash</code> with your ros distribution.</p>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DRASPBERRY=1 -Wno-dev
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call catkin_make_isolated with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -Wno-dev
   
</code></pre></div></div>

<p>To build sick_generic_caller without multiScan136/sick_scansegment_xd/picoScan150 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DSCANSEGMENT_XD=0 -Wno-dev
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build <strong>without LDMRS</strong> and <strong>without multiScan100/picoScan100 support</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DSCANSEGMENT_XD=0 -Wno-dev
   
</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<p><strong>Build options</strong></p>

<p><strong>Without LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DSCANSEGMENT_XD=0 -Wno-dev

</code></pre></div></div>
<p><strong>Without LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -Wno-dev

</code></pre></div></div>
<p><strong>with LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DSCANSEGMENT_XD=0 -Wno-dev

</code></pre></div></div>
<p><strong>with LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev

</code></pre></div></div>

<p>To create source code documentation by doxygen, run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-linux-ros-2">Build on Linux ROS 2</h2>

<p>To build resp. install sick_scan_xd on Linux with ROS 2, you can build sick_scan_xd from sources or install prebuilt binaries.</p>

<h3 id="install-prebuilt-binaries-1">Install prebuilt binaries</h3>

<p>Run the following steps to install sick_scan_xd on Linux with ROS 2 humble:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-humble-sick-scan-xd

</code></pre></div></div>

<p>After successful installation, you can run sick_scan_xd using <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt;.py</code>, e.g. <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py</code> for multiScan. sick_scan_xd can be removed by <code class="language-plaintext highlighter-rouge">sudo apt-get remove ros-humble-sick-scan-xd</code>.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> ROS 2 humble Debian packages require Ubuntu 22 or newer, see https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html for system requirements.</p>
</blockquote>

<h3 id="build-from-sources-1">Build from sources</h3>

<p>Run the following steps to build sick_scan_xd on Linux with ROS 2:</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir ./src
   pushd ./src
   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   rm -rf ./build ./build_isolated/ ./devel ./devel_isolated/ ./install ./install_isolated/ ./log/ # remove any files from a previous build
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   source /opt/ros/foxy/setup.bash # replace foxy by your ros distro
   colcon build --packages-select libsick_ldmrs --event-handlers console_direct+
   source ./install/setup.bash
   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" --event-handlers console_direct+
   source ./install/setup.bash
   
</code></pre></div></div>
<p>For ROS versions other than foxy, please replace <code class="language-plaintext highlighter-rouge">source /opt/ros/foxy/setup.bash</code> with your ros distribution.</p>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DRASPBERRY=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call colcon with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" --event-handlers console_direct+
   
</code></pre></div></div>
<p>To build sick_generic_caller without multiScan136/sick_scansegment_xd/picoScan150 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build <strong>without LDMRS</strong> and <strong>without multiScan100/picoScan100 support</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>Depending on the ROS 2 distribution, package diagnostic_updater might not be found (compiler error: <code class="language-plaintext highlighter-rouge">diagnostic_updater.hpp not found</code>). In this case package diagnostic_updater has to be installed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install ros-${ROS_DISTRO}-diagnostic-updater
sudo apt install ros-${ROS_DISTRO}-diagnostic-msgs
# E.g. to install diagnostic_updater on foxy, run
# sudo apt-get install ros-foxy-diagnostic-updater
# sudo apt install ros-foxy-diagnostic-msgs

</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<p><strong>Build options</strong></p>

<p><strong>Without LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>Without LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>with LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>with LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " --event-handlers console_direct+

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong> To create source code documentation by doxygen, run</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-windows-ros-2">Build on Windows ROS 2</h2>

<p>To install sick_scan_xd on Windows with ROS 2, follow the steps below:</p>

<ol>
  <li>
    <p>If not yet done, install Visual Studio. Visual Studio 2019 Community or Professional Edition is recommended.</p>
  </li>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir sick_scan_ws
   cd sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repository https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir .\src
   pushd .\src
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   
</code></pre></div></div>

<ol>
  <li>Set the ROS 2 and Visual-Studio environment:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   call "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\Common7\Tools\VsDevCmd.bat" -arch=amd64 -host_arch=amd64
   call C:\opt\ros\foxy\x64\setup.bat
   
</code></pre></div></div>
<p>This step depends on your local ROS 2 and Visual-Studio installation. Please replace <code class="language-plaintext highlighter-rouge">C:\opt\ros\foxy\x64\setup.bat</code> with your ROS 2 version and adapt the path to the Visual Studio folder if your installation is different.</p>

<ol>
  <li>Cleanup to insure a complete rebuild:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   rmdir /s/q .\build
   rmdir /s/q .\install
   rmdir /s/q .\log
   del /f/q .\src\CMakeLists.txt
   
</code></pre></div></div>
<p>This step is only required for a complete rebuild. A complete rebuild is recommended e.g. after an update of the sick_scan_xd sources.</p>

<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" --event-handlers console_direct+
   call .\install\setup.bat
   
</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS sensors are currently not supported on Windows.</li>
    <li>To build sick_generic_caller without multiScan136/sick_scansegment_xd support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<h2 id="build-on-linux-generic-without-ros">Build on Linux generic without ROS</h2>

<p>Run the following steps to build sick_scan_xd on Linux (no ROS required):</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   
</code></pre></div></div>

<ol>
  <li>Build libsick_ldmrs (required only once for LD-MRS sensors):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   pushd libsick_ldmrs
   mkdir -p ./build
   cd ./build
   cmake -G "Unix Makefiles" ..
   make -j4
   sudo make -j4 install
   popd
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller and libsick_scan_xd_shared_lib.so:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./build
   pushd ./build
   rm -rf ./*
   export ROS_VERSION=0
   cmake -DROS_VERSION=0 -G "Unix Makefiles" ../sick_scan_xd
   make -j4
   sudo make -j4 install
   popd
   
</code></pre></div></div>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -DRASPBERRY=1 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>To build sick_generic_caller without multiScan100/picoScan100 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DSCANSEGMENT_XD=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build without LD-MRS and scansegment_xd support:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -DSCANSEGMENT_XD=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> To create source code documentation by doxygen, run</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-windows-generic-without-ros">Build on Windows generic without ROS</h2>

<p>To install sick_scan_xd on Windows, follow the steps below:</p>

<ol>
  <li>
    <p>If not yet done, install Visual Studio. Visual Studio 2019 Community or Professional Edition is recommended.</p>
  </li>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir sick_scan_ws
   cd sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repository https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller and sick_scan_xd_shared_lib.dll with cmake and Visual Studio 2019:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cd sick_scan_xd
   set _os=x64
   set _cmake_string=Visual Studio 16 2019
   set _msvc=Visual Studio 2019
   set _cmake_build_dir=build
   if not exist %_cmake_build_dir% mkdir %_cmake_build_dir%
   pushd %_cmake_build_dir%
   cmake -DROS_VERSION=0 -G "%_cmake_string%" ..
   cmake --build . --clean-first --config Debug
   cmake --build . --clean-first --config Release
   REM open sick_scan_xd.sln in Visual Studio 2019 for development and debugging
   popd
   
</code></pre></div></div>
<p>For development or debugging, open file <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\sick_scan_xd.sln</code> in Visual Studio. To install the library and header in the system folder, run <code class="language-plaintext highlighter-rouge">cmake --build . --target install</code> with admin privileges.</p>

<p>After successful build, binary files <code class="language-plaintext highlighter-rouge">sick_generic_caller.exe</code> and <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> are created in folders <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\Debug</code> and <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\Release</code>.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS sensors are currently not supported on Windows.</li>
    <li>To build sick_generic_caller without multiScan100/picoScan100 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DSCANSEGMENT_XD=0 -G "%_cmake_string%" ..
   
</code></pre></div></div>

<h1 id="running-the-driver">Running the driver</h1>

<p>The sick_scan_xd driver can be started on the command line by <code class="language-plaintext highlighter-rouge">sick_generic_caller &lt;launchfile&gt; [hostname:=&lt;ip-address&gt;]</code>. The start process varies slightly depending on the target OS:</p>

<p>On native Linux without ROS, call</p>

<p>```sick_generic_caller <launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On Linux with ROS 1, call

    
```./devel_isolated/setup.bash
</code></pre></div></div>

<p>```roslaunch sick_scan_xd <launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On Linux with ROS 2, call

    
```source ./install/setup.bash
</code></pre></div></div>

<p>```ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/<launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On native Windows without ROS, call

    
```sick_generic_caller &lt;launchfile&gt;
</code></pre></div></div>

<p>On Windows with ROS 2, call</p>

<p>```call .\install\setup.bat</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    
```ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/&lt;launchfile&gt;
</code></pre></div></div>

<p>Use the following commands to run the sick_scan_xd driver for a specific scanner type:</p>

<ul>
  <li>For MRS6124:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_6xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_mrs_6xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_6xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_6xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_6xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For MRS1104:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_1xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_mrs_1xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_1xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_1xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_1xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1104 with firmware 1.x:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1104 with firmware 2.x:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx_v2.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xxx_v2.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx_v2.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx_v2.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx_v2.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM240-prototype:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_240.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_240.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_240.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_240.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_240.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM5xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_5xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_5xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_5xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_5xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_5xx.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM7xx-family (no safety scanner):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM7xxS-family (safety scanner):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xxS.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xxS.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xxS.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xxS.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xxS.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS5xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_5xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_5xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_5xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS4xxx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_4xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_4xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_4xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_4xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_4xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS4000:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_4xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_4xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_4xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_4xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_4xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LDMRS-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_ldmrs.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_ldmrs.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_ldmrs.launch</code>
</li>
      <li>Note that LD-MRS are currently not supported on Windows</li>
    </ul>
  </li>
  <li>For LRS36x0:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x0.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS36x0 mounted upside down:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0_upside_down.launch</code>
  <br>For upside down mounted devices, the point cloud is rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>.</li>
    </ul>
  </li>
  <li>For LRS36x1:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x1.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS36x1 mounted upside down:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1_upside_down.launch</code>
</li>
    </ul>

    <p><br>For upside down mounted devices, the point cloud is rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>.</p>
  </li>
  <li>For LD-OEM15xx:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_oem_15xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_oem_15xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_oem_15xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_oem_15xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_oem_15xx.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV210 and NAV245:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_2xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_2xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_2xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_2xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_2xx.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV310:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_31x.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_31x.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_31x.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_31x.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_31x.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV350:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_350.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_350.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_350.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_350.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_350.launch</code>
</li>
    </ul>
  </li>
  <li>For RMS-family (RMS1xxx, RMS2xxx):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_rms_xxxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_rms_xxxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_rms_xxxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_rms_xxxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_rms_xxxx.launch</code>
</li>
    </ul>
  </li>
  <li>For multiScan136 (sick_scansegement_xd):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">hostname</code> is the ip-address of the lidar, <code class="language-plaintext highlighter-rouge">udp_receiver_ip</code> is the ip-address of the receiver (i.e. the ip of the computer running sick_generic_caller).</li>
    </ul>
  </li>
  <li>For picoScan150:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_picoscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_picoscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">hostname</code> is the ip-address of the lidar, <code class="language-plaintext highlighter-rouge">udp_receiver_ip</code> is the ip-address of the receiver (i.e. the ip of the computer running sick_generic_caller).</li>
    </ul>
  </li>
</ul>

<p>Common command line options are</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">hostname:=&lt;ip-address&gt;</code> to connect to a sensor with a given IP address. Default value is always the factory default IP address of the scanner.</li>
</ul>

<p>Further (common and scanner specific) options can be set via launch file, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#common-parameters">Common parameters</a> and configure the settings in the launch file corresponding to the scanner type.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> After modifying a launch-file, it has to be installed by running <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev</code>
to be located and used by <code class="language-plaintext highlighter-rouge">roslaunch</code>.</p>
</blockquote>

<p>On ROS 2 you can launch sick_generic_caller by python launch files, too. Use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 launch sick_scan_xd &lt;name&gt;.launch.py &lt;param&gt;:=&lt;value&gt;

</code></pre></div></div>
<p>E.g. for LMS-5xx: <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_lms_5xx.launch.py hostname:=192.168.0.1</code></p>

<p>The launch.py-files on ROS 2 passes the corresponding launch-file to the driver: <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lms_5xx.launch.py">sick_lms_5xx.launch.py</a> gives an example for LMS-5xx. Parameter can be overwritten</p>
<ul>
  <li>either by command line, e.g. <br> <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_lms_5xx.launch.py hostname:=192.168.0.1</code>,</li>
  <li>or by passing additional arguments in the launch.py-file, e.g. <br> <code class="language-plaintext highlighter-rouge">node = Node(package='sick_scan_xd', executable='sick_generic_caller', arguments=[launch_file_path, 'hostname:=192.168.0.1'])</code>
</li>
</ul>

<h2 id="starting-scanner-with-specific-ip-address">Starting Scanner with Specific IP Address</h2>

<p>To start the scanner with a specific IP address, option <code class="language-plaintext highlighter-rouge">hostname:=&lt;ip-address&gt;</code> can be used.
The hostname is the ip-address of the scanner, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71                         # Linux native
roslaunch sick_scan_xd sick_tim_5xx.launch hostname:=192.168.0.71                      # Linux ROS 1
ros2 run sick_scan_xd sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71   # Linux ROS 2
sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71                         # Windows native
ros2 run sick_scan_xd sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71   # Windows ROS 2

</code></pre></div></div>

<h2 id="start-multiple-nodes">Start Multiple Nodes</h2>

<p>Multiple nodes can be started to support multiple sensors. In this case, multiple instances of sick_scan_xd have to be started, each node with different name and topic. ROS 1 example to run two TiM 7xx devices with ip address <code class="language-plaintext highlighter-rouge">192.168.0.1</code> and <code class="language-plaintext highlighter-rouge">192.168.0.2</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1 &amp;
roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2 &amp;

</code></pre></div></div>

<p>On Linux with ROS 1, multiple nodes to support multiple sensors can be started by one launch file, too.
Take the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_tim_5xx_twin.launch">sick_tim_5xx_twin.launch</a> as an example.
Remapping the scan and cloud topics is essential to distinguish the scandata and provide TF information.</p>

<p>ROS 2 example to run two TiM 7xx devices with IP address <code class="language-plaintext highlighter-rouge">192.168.0.1</code> and <code class="language-plaintext highlighter-rouge">192.168.0.2</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1 &amp;
ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2 &amp;

</code></pre></div></div>

<p>To support multiple sensors, sick_scan_xd has to be started multiple times, with one sick_scan_xd-node for each sensor. By default, each sick_scan_xd-node connects to “192.168.0.1” and publishes its point cloud on topic “cloud”. Therefore both the node name, the ip-address of the sensor and the point cloud topic have to be configured differently for each node.</p>

<p>Node name, ip-address and point cloud topic can be configured in the launch-file or by command line argument:</p>

<p>Topic, nodename and ip configuration in a launch-file (example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;launch&gt;
        &lt;arg name="nodename" default="sick_tim_7xx"/&gt;
        &lt;arg name="hostname" default="192.168.0.1"/&gt;
        &lt;arg name="cloud_topic" default="cloud"/&gt;
        &lt;node name="$(arg nodename)" pkg="sick_scan_xd" type="sick_generic_caller" respawn="false" output="screen"&gt;
            &lt;param name="scanner_type" type="string" value="sick_tim_7xx"/&gt;
            &lt;param name="nodename" type="string" value="$(arg nodename)"/&gt;
            &lt;param name="hostname" type="string" value="$(arg hostname)"/&gt;
            &lt;param name="cloud_topic" type="string" value="$(arg cloud_topic)"/&gt;
    
</code></pre></div></div>

<p>Topic, node name and ip configuration by command line (ROS 1 example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1
    roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2
    
</code></pre></div></div>

<p>Topic, node name and IP configuration by command line (ROS 2 example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1
    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2
    
</code></pre></div></div>

<p>Scripts <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/scripts/run_linux_ros1_simu_tim7xx_twin.bash">run_linux_ros1_simu_tim7xx_twin.bash</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/scripts/run_linux_ros2_simu_tim7xx_twin.bash">run_linux_ros2_simu_tim7xx_twin.bash</a> show a complete example with emulation of two TiM7xx sensors and two sick_scan_xd nodes running concurrently using different nodenames and topics.</p>

<p>To run two multiScan100 or picoScan100 devices simultanously, each sick_scan_xd node must be configured with different lidar ip addresses and udp ports, different node names, different ros topics and frame ids for each point cloud. Therefore the following launch file parameter should be overwritten by individual settings for each lidar:</p>
<ul>
  <li>“hostname”: e.g. “192.168.0.190” and “192.168.0.98”</li>
  <li>“nodename”: e.g. sick_picoscan0” and “sick_picoscan1”</li>
  <li>“publish_frame_id”: e.g. “world0” and “world1”</li>
  <li>“publish_laserscan_segment_topic”: e.g. “scan0_segment” and “scan1_segment”</li>
  <li>“publish_laserscan_fullframe_topic”: e.g. “scan0_fullframe” and “scan1_fullframe”</li>
  <li>“imu_topic”: e.g. “imu0” and “imu1”</li>
  <li>“udp_port”: e.g. “56661” and “56662”</li>
  <li>“imu_udp_port”: e.g. “7503” and “7504”</li>
  <li>individual topics and frame ids for each customized point cloud, e.g.
    <ul>
      <li>replace all “topic=/cloud_” by “topic=/cloud0<em>” resp. “topic=/cloud1</em>”</li>
      <li>replace all “frameid=world” by “frameid=world0” resp. “frameid=world1”
It is recommend to first verify the launch file configurations separately for each picoScan100 before running them simultanously.</li>
    </ul>
  </li>
</ul>

<p>For picoScan100 and multiScan, parameter udp_receiver_ip must be set to the ip address of the PC running sick_scan_xd. It is recommend to use ip addresses in the same subnet.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The sick_scan_xd API does not support running multiple lidars simultaneously in a single process.** Currently the sick_scan_xd API does not support the single or multi-threaded use of 2 or more lidars in one process, since the sick_scan_xd library is not guaranteed to be thread-safe. To run multiple lidars simultaneously, we recommend using ROS or running sick_scan_xd in multiple and separate processes, so that each process serves one sensor.</p>
</blockquote>

<h2 id="common-parameters">Common parameters</h2>

<p>For the launch-file settings and the tag/values pairs the following keywords are supported:</p>

<table>
  <thead>
    <tr>
      <th>Keyword</th>
      <th>Meaning</th>
      <th>Default value</th>
      <th>Hint</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>scanner_type</td>
      <td>Scanner family</td>
      <td>???</td>
      <td>see list above</td>
    </tr>
    <tr>
      <td>min_ang</td>
      <td>Start scan angle in [rad]</td>
      <td>-2.3998277</td>
      <td> </td>
    </tr>
    <tr>
      <td>max_ang</td>
      <td>End scan angle in [rad]</td>
      <td>+2.3998277</td>
      <td> </td>
    </tr>
    <tr>
      <td>intensity_resolution_16bit</td>
      <td>Switch between 8Bit/16Bit</td>
      <td>“false”</td>
      <td>do not change</td>
    </tr>
    <tr>
      <td>hostname</td>
      <td>Ip address of scanner</td>
      <td>192.168.0.1</td>
      <td>change to scanner ip address in your network (see faq)</td>
    </tr>
    <tr>
      <td>port</td>
      <td>port number</td>
      <td>2112</td>
      <td>do not change, check firewall rules if there is blocking traffic</td>
    </tr>
    <tr>
      <td>timelimit</td>
      <td>Timelimit in [sec]</td>
      <td>5</td>
      <td>do not change</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">scanner_type</code>
Name of the used scanner. Usually this is also the name of the launch file. This entry is used to differentiate
between the various scanner properties within the software code.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">hostname</code>
IP-address of the scanner (default: 192.168.0.1)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">port</code>
IP-port of the scanner (default: 2112)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">min_ang</code>
Start angle in [rad]</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">max_ang</code>
End angle in [rad]</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">use_binary_protocol</code>
Switch between SOPAS Binary and SOPAS ASCII protocol</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">intensity</code>
Enable or disable transport of intensity values</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">intensity_resolution_16bit</code>
If true, the intensity values is transferred as 16 bit value. If false, as 8 bit value.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">min_intensity</code>
If min_intensity &gt; 0, all range values in a LaserScan message are set to infinity, if their intensity value is below min_intensity</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cloud_topic</code>
Topic name of the published pointcloud2 data</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">frame_id</code>
Frame id used for the published data</p>
  </li>
</ul>

<p>Tag/value pairs of the command line overwrite settings in the launch file.
The use of the parameters can be looked up in the launch files. This is also recommended as a starting point.</p>

<h2 id="further-useful-parameters-and-features">Further useful parameters and features</h2>

<ul>
  <li>
    <p><strong>Timestamps</strong>: If parameter<code class="language-plaintext highlighter-rouge">sw_pll_only_publish</code> is true (default), an internal Software PLL is used to sync the scan generation timestamps to system timestamps. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#timestamps-and-synchronization-software-pll">Timestamps and synchronization (Software PLL)</a> for details.</p>
  </li>
  <li>
    <p><strong>Angle compensation</strong>: For highest angle accuracy the NAV-Lidar series supports an <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#angle-compensation">angle compensation mechanism</a>.</p>
  </li>
  <li>
    <p><strong>Angle correction</strong>: MRS1000 lidars transmit accurate azimuth angles for each scan point. Therefore, the stride (angle increment) of the MRS1000 azimuth angles in polar and cartesian point clouds is not exactly constant. Since laserscan messages assume a constant angle increment, scan points in point cloud and laserscan messages have slightly different azimuth angles.</p>
  </li>
  <li>
    <p><strong>Field monitoring</strong>: The <strong>LMS1xx</strong>, <strong>LMS5xx</strong>, <strong>TiM7xx</strong> and <strong>TiM7xxS</strong> families have <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#field-evaluation-information">extended settings for field monitoring</a>.</p>
  </li>
  <li>
    <p><strong>Radar devices</strong>: For radar devices (RMS1000/RMS2000), radar raw targets or radar objects or both can be tracked and transmitted. You can activate parameter transmit_raw_targets, transmit_objects or both in the launch file:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   &lt;param name="transmit_raw_targets" type="bool" value="false"/&gt;
   &lt;param name="transmit_objects" type="bool" value="true"/&gt;
   
</code></pre></div></div>
<p>By default, radar objects are tracked.</p>

<ul>
  <li>
<strong>Coordinate transform</strong>: An optional coordinate transform can be applied to the point cloud. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#coordinate-transforms">coordinate transforms</a>) for details.</li>
</ul>

<h2 id="ros-services">ROS services</h2>

<p>On ROS 1 and ROS 2, services can be used to send COLA commands to the sensor. This can be very helpful for diagnosis, e.g. by querying the device status or its id.</p>

<p>Use the following examples to run a cola command on ROS 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_lms_5xx/ColaMsg "{request: 'sMN IsSystemReady'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sRN SCdevicestate'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sEN LIDinputstate 1'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sEN LIDoutputstate 1'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sMN LMCstartmeas'}"
rosservice call /sick_lms_5xx/SCdevicestate "{}" # query device state
rosservice call /sick_lms_5xx/SCreboot "{}"      # execute a software reset on the device
rosservice call /sick_lms_5xx/SCsoftreset "{}"   # save current parameter and shut down device

</code></pre></div></div>

<p>Use the following examples to run a cola command on ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN IsSystemReady'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN SCdevicestate'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sEN LIDinputstate 1'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sEN LIDoutputstate 1'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN LMCstartmeas'}"
ros2 service call /SCdevicestate sick_scan_xd/srv/SCdevicestateSrv "{}" # query device state
ros2 service call /SCreboot sick_scan_xd/srv/SCrebootSrv "{}"           # execute a software reset on the device
ros2 service call /SCsoftreset sick_scan_xd/srv/SCsoftresetSrv "{}"     # save current parameter and shut down device

</code></pre></div></div>

<p>Use ros service <code class="language-plaintext highlighter-rouge">SickScanExit</code> to stop the scanner and driver:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_nav_31x/SickScanExit "{}" # stop scanner and driver on ROS 1
ros2 service call /SickScanExit sick_scan_xd/srv/SickScanExitSrv "{}" # stop scanner and driver on ROS 2

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>The COLA commands are sensor specific. See the user manual and telegram listing for further details.</li>
    <li>ROS services require installation of ROS 1 or ROS 2, i.e. services for Cola commands are currently not supported on native Linux or native Windows.</li>
    <li>ROS services are currently not available for the LDMRS.</li>
    <li>ROS service “ColaMsg” should only be used for diagnosis. It is not recommended to change the lidar settings while the driver is running. Otherwise the driver settings can become different or inconsistant to the lidar settings. Restart the driver after changing lidar settings by SOAPS ET or SOPAS commands.</li>
    <li>Some SOPAS commands like <code class="language-plaintext highlighter-rouge">sMN SetAccessMode 3 F4724744</code> stop the current measurement. In this case, the driver restarts after a timeout (5 seconds by default). To process those SOPAS commands without restart, you can
      <ul>
        <li>send <code class="language-plaintext highlighter-rouge">sMN LMCstartmeas</code> and <code class="language-plaintext highlighter-rouge">sMN Run</code> to switch again into measurement mode within the timeout, or</li>
        <li>increase the driver timeout <code class="language-plaintext highlighter-rouge">read_timeout_millisec_default</code> in the launch-file.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Additional services can be available for specific lidars. Service “GetContaminationResult” is e.g. available for MRS1xxx, LMS1000 and multiScan:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ROS 1 example for service GetContaminationResult (LMS 1xxx)
rosservice call /sick_lms_1xxx/GetContaminationResult "{}"
# ROS 2 example for service GetContaminationResult (LMS 1xxx)
ros2 service call /GetContaminationResult sick_scan_xd/srv/GetContaminationResultSrv "{}"

</code></pre></div></div>

<p>Example sequence with stop and start measurement to set a particle filter (TiM-7xxx on ROS 1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LFPparticle'}" # response: "sRA LFPparticle \\x00\\x01\\xf4"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sWN LFPparticle 0101F4'}" # response: "sWA LFPparticle"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN LMCstartmeas'}"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN Run'}"

</code></pre></div></div>

<h2 id="driver-states-timeouts">Driver states, timeouts</h2>

<p>The driver runs in two different states:</p>

<ol>
  <li>
    <p>Initialization: The scanner is initialized and configured by a list of sopas commands</p>
  </li>
  <li>
    <p>Measurement: The scanner is operational, scandata are transmitted and the point cloud is published.
After start, the driver enters initialization mode. After successful initialization, the driver switches automatically into measurement mode.</p>
  </li>
</ol>

<p>The communication between driver and scanner is monitored. In case of communication timeouts, e.g. due to network problems, the TCP connection is reset and the scanner is re-initialized. The driver uses 3 different timeouts (i.e time since last message received from lidar):</p>

<ol>
  <li>
    <p>In measurement mode: If no messages arrive for 5 seconds [timeout 0], the TCP/IP connection is closed. After a short delay, the tcp connection is reopened and the driver switches to initialization mode and reinitializes the Lidar.</p>
  </li>
  <li>
    <p>In initialization mode: If no messages received after 120 sec [Timeout 1] the TCP/IP connection is closed. After a short delay, the tcp connection is reopened and the driver switches to initialization mode and reinitializes the Lidar.</p>
  </li>
  <li>
    <p>In any mode: If no messages received after 150 sec [Timeout 2] the driver terminates.</p>
  </li>
</ol>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The internal timer is reset on successful communication. i.e. the timeout refers to the time of the last message from the Lidar. If there was no message yet, then the time of programme start is used.</p>
</blockquote>

<p>All timeouts can be configured in the launchfile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="message_monitoring_enabled" type="bool" value="True" /&gt;      &lt;!-- Enable message monitoring with reconnect+reinit in case of timeouts, default: true --&gt;
&lt;param name="read_timeout_millisec_default" type="int" value="5000"/&gt;     &lt;!-- 5 sec read timeout in operational mode (measurement mode), default: 5000 milliseconds --&gt;
&lt;param name="read_timeout_millisec_startup" type="int" value="120000"/&gt;   &lt;!-- 120 sec read timeout during startup (sensor may be starting up, which can take up to 120 sec.), default: 120000 milliseconds --&gt;
&lt;param name="read_timeout_millisec_kill_node" type="int" value="150000"/&gt; &lt;!-- 150 sec point cloud timeout, ros node will be killed if no point cloud published within the last 150 sec., default: 150000 milliseconds --&gt;

</code></pre></div></div>

<p>The following diagram shows the transition between the driver states:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/./doc/driverStatesDiagram1.png" alt="driverStatesDiagram"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Timeout 2 (i.e. no lidar message after 150 seconds) terminates the driver. By default, the driver does not restart automatically. It is therefor recommended to run the driver within an endless loop, e.g. in bash:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while(true) ; do roslaunch sick_scan_xd &lt;launchfile&gt; [&lt;arguments&gt;] ; done

</code></pre></div></div>

<p>The following table summarizes the timeout parameter:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/./doc/timeout_parameter.png" alt="timeout_parameter"></p>

<p>Details of timeout settings:</p>

<ul>
  <li>
    <p>message_monitoring_enabled: Enable or disable timeouts and monitoring. Disabling deactivates any error handling in case of network problems. Recommended default value: True</p>
  </li>
  <li>
    <p>read_timeout_millisec_default: Read timeout in milliseconds in operational (measurement) mode. If no datagrams are received from lidar within 5 seconds (default), the TCP socket is closed and the lidar is reinitialized.</p>
  </li>
  <li>
    <p>read_timeout_millisec_startup: Read timeout in milliseconds during initialization after startup. If SOPAS commands are not responded within 120 seconds (default), the TCP socket is closed and lidar is reinitialized.</p>
  </li>
  <li>
    <p>read_timeout_millisec_kill_node: Pointcloud timeout in milliseconds in operational (measurement) mode. If the sick_scan_xd does not publish a point cloud within the last 150 seconds, the sick_scan_xd process is killed. Should never happen, but is the �last resort� to exit after any kind of error (e.g. socket hangs up and blocks after network trouble).</p>
  </li>
  <li>
    <p>All timeouts configured in milliseconds</p>
  </li>
  <li>To disable timeouts (not recommended):
    <ul>
      <li>Set message_monitoring_enabled = false, or</li>
      <li>Set timeouts to “infinite” values, i.e MAX_INT = 2147483647 milliseconds (24.9 days)</li>
    </ul>
  </li>
  <li>To disable point cloud monitoring (not recommended):
    <ul>
      <li>read_timeout_millisec_kill_node &lt;= 0 deactivates pointcloud monitoring</li>
    </ul>
  </li>
  <li>Parameter read_timeout_millisec_default and read_timeout_millisec_startup: value 0 and negative values are currently NOT mapped to other values, i.e. will cause an immediately timeout error. Use value 2147483647 or message_monitoring_enabled = false to deactivate read timeouts (not recommended)</li>
</ul>

<h2 id="sopas-mode">SOPAS Mode</h2>

<p>This driver supports both COLA-B (binary) and COLA-A (ASCII) communication with the laser scanner. Binary mode is activated by default, since this mode generates less network traffic and enables more compatibility to all scanners.
If the communication mode set in the scanner memory is different from that used by the driver, the scanner’s communication mode is changed. This requires a restart of the TCP-IP connection, which can extend the start time by up to 30 seconds.
There are two ways to prevent this:</p>
<ol>
  <li>Recommended:
    <ul>
      <li>Set the communication mode with the SOPAS ET software to binary and save this setting in the scanner’s EEPROM.</li>
      <li>Set “use_binary_protocol” to default value “true”.</li>
    </ul>
  </li>
  <li>Use the parameter “use_binary_protocol” to overwrite the default settings of the driver.</li>
</ol>

<h2 id="example-startup-sequence">Example Startup Sequence</h2>

<p>The following ROS boot protocol shows the typical start sequence when starting a SICK laser scanner. The MRS6124 is shown here as an example. However, the startup sequence is generally similar for all scanners.</p>

<p>After a firmware update, the following Quickcheck is performed:</p>
<ol>
  <li>Is the device accessible via ping?</li>
  <li>Can the device be started with the corresponding generic launch file?</li>
  <li>At the end of the launch process, the device switches to receive mode
 for scan data? Typically the last command sent is
<code class="language-plaintext highlighter-rouge">&lt;STX&gt;sEA LMDscandata \x01&lt;ETX&gt;
</code>.</li>
  <li>Check with rviz: Is it possible to see the Pointcloud2 data or similar? Is the shown data reasonable?</li>
  <li>Check the scan rate with the command</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic hz /cloud

</code></pre></div></div>
<ol>
  <li>Further inspection, if any, by dumping Pointcloud2 data.
The header is of particular interest here. A typical call can therefore look as follows:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic echo /cloud|grep frame -B 7 -A 26

</code></pre></div></div>
<p><strong>Example Sequence</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_mrs_6xxx.launch hostname:=192.168.0.25
... logging to /home/rosuser/.ros/log/75631922-6109-11e9-b76f-54e1ad2921b6/roslaunch-ROS-NB-10680.log
Checking log directory for disk usage. This may take awhile.
Press Ctrl-C to interrupt
Done checking log file disk usage. Usage is &lt;1GB.
started roslaunch server http://ROS-NB:40757/
SUMMARY
========
PARAMETERS
 * /rosdistro: melodic
 * /rosversion: 1.14.3
 * /sick_mrs_6xxx/filter_echos: 0
 * /sick_mrs_6xxx/hostname: 192.168.0.25
 * /sick_mrs_6xxx/max_ang: 1.047197333
 * /sick_mrs_6xxx/min_ang: -1.040216
 * /sick_mrs_6xxx/port: 2112
 * /sick_mrs_6xxx/range_max: 250.0
 * /sick_mrs_6xxx/range_min: 0.1
 * /sick_mrs_6xxx/scanner_type: sick_mrs_6xxx
 * /sick_mrs_6xxx/timelimit: 5
 * /sick_mrs_6xxx/use_binary_protocol: True
NODES
  /
    sick_mrs_6xxx (sick_scan_xd/sick_generic_caller)
auto-starting new master
process[master]: started with pid [10690]
ROS_MASTER_URI=http://localhost:11311
setting /run_id to 75631922-6109-11e9-b76f-54e1ad2921b6
process[rosout-1]: started with pid [10701]
started core service [/rosout]
process[sick_mrs_6xxx-2]: started with pid [10708]
[ INFO] [1555502887.036684738]: sick_generic_caller V. 001.003.016
[ INFO] [1555502887.036717573]: Program arguments: /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller
[ INFO] [1555502887.036725741]: Program arguments: __name:=sick_mrs_6xxx
[ INFO] [1555502887.036731933]: Program arguments: __log:=/home/rosuser/.ros/log/75631922-6109-11e9-b76f-54e1ad2921b6/sick_mrs_6xxx-2.log
[ INFO] [1555502887.048425000]: Found sopas_protocol_type param overwriting default protocol:
[ INFO] [1555502887.048956468]: Binary protocol activated
[ INFO] [1555502887.048984179]: Start initialising scanner [Ip: 192.168.0.25] [Port: 2112]
[ INFO] [1555502887.067528995]: Publishing laserscan-pointcloud2 to cloud
[ INFO] [1555502887.071035827]: Parameter setting for &lt;active_echo: 0&gt;
[ INFO] [1555502887.271739084]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0023&gt;sMN SetAccessMode 0x03 0xf4 0x72 0x47 0x44 CRC:&lt;0xb3&gt;
[ INFO] [1555502887.273290840]: Receiving: &lt;STX&gt;sAN SetAccessMode \x01&lt;ETX&gt;
[ INFO] [1555502887.473927858]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sWN EIHstCola 0x01 CRC:&lt;0x09&gt;
[ INFO] [1555502887.475365983]: Receiving: &lt;STX&gt;sWA EIHstCola &lt;ETX&gt;
[ INFO] [1555502887.675864993]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sMN LMCstopmeas CRC:&lt;0x10&gt;
[ INFO] [1555502888.199590269]: Receiving: &lt;STX&gt;sAN LMCstopmeas \x00&lt;ETX&gt;
[ INFO] [1555502888.400030148]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sRN DeviceIdent CRC:&lt;0x25&gt;
[ INFO] [1555502888.401393378]: Receiving: &lt;STX&gt;sRA DeviceIdent \x00\x08\x4d\x52\x53\x36\x31\x32\x34\x52\x00\x0a\x31\x2e\x31\x2e\x30\x2e\x35\x36\x35\x43&lt;ETX&gt;
[ INFO] [1555502888.401653485]: Deviceinfo MRS6124R V1.1.0.565C found and supported by this driver.
[ INFO] [1555502888.602062286]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0019&gt;sRN FirmwareVersion CRC:&lt;0x24&gt;
[ INFO] [1555502888.603444526]: Receiving: &lt;STX&gt;sRA FirmwareVersion \x00\x0a\x31\x2e\x31\x2e\x30\x2e\x35\x36\x35\x43&lt;ETX&gt;
[ INFO] [1555502888.804094446]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0017&gt;sRN SCdevicestate CRC:&lt;0x30&gt;
[ INFO] [1555502888.805521867]: Receiving: &lt;STX&gt;sRA SCdevicestate \x01&lt;ETX&gt;
[ INFO] [1555502889.006161400]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0010&gt;sRN ODoprh CRC:&lt;0x41&gt;
[ INFO] [1555502889.007613972]: Receiving: &lt;STX&gt;sRA ODoprh \x00\x00\x19\xf1&lt;ETX&gt;
[ INFO] [1555502889.209949897]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0010&gt;sRN ODpwrc CRC:&lt;0x52&gt;
[ INFO] [1555502889.211413041]: Receiving: &lt;STX&gt;sRA ODpwrc \x00\x00\x02\x55&lt;ETX&gt;
[ INFO] [1555502889.413742132]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0016&gt;sRN LocationName CRC:&lt;0x55&gt;
[ INFO] [1555502889.415205992]: Receiving: &lt;STX&gt;sRA LocationName \x00\x0b\x6e\x6f\x74\x20\x64\x65\x66\x69\x6e\x65\x64&lt;ETX&gt;
[ INFO] [1555502889.417205292]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMPoutputRange CRC:&lt;0x5e&gt;
[ INFO] [1555502889.418631134]: Receiving: &lt;STX&gt;sRA LMPoutputRange \x00\x01\x00\x00\x05\x15\x00\x04\xa3\x80\x00\x16\xe3\x60&lt;ETX&gt;
[ INFO] [1555502889.418830949]: Angle resolution of scanner is 0.13010 [deg]  (in 1/10000th deg: 0x515)
[ INFO] [1555502889.418907556]: MIN_ANG:   -1.040 [rad]  -59.600 [deg]
[ INFO] [1555502889.418975818]: MAX_ANG:    1.047 [rad]   60.000 [deg]
[ INFO] [1555502889.419156102]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0033&gt;sWN LMPoutputRange 0x00 0x01 0x00 0x00 0x05 0x15 0x00 0x04 0xa3 0x80 0x00 0x16 0xe3 0x60 CRC:&lt;0xd8&gt;
[ INFO] [1555502889.420488646]: Receiving: &lt;STX&gt;sWA LMPoutputRange &lt;ETX&gt;
[ INFO] [1555502889.420719836]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMPoutputRange CRC:&lt;0x5e&gt;
[ INFO] [1555502889.421994443]: Receiving: &lt;STX&gt;sRA LMPoutputRange \x00\x01\x00\x00\x05\x15\x00\x04\xa3\x80\x00\x16\xe3\x60&lt;ETX&gt;
[ INFO] [1555502889.422165198]: Angle resolution of scanner is 0.13010 [deg]  (in 1/10000th deg: 0x515)
[ INFO] [1555502889.424815945]: MIN_ANG (after command verification):   -1.040 [rad]  -59.600 [deg]
[ INFO] [1555502889.424901901]: MAX_ANG (after command verification):    1.047 [rad]   60.000 [deg]
[ INFO] [1555502889.425102725]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0032&gt;sWN LMDscandatacfg 0x1f 0x00 0x01 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01 CRC:&lt;0x5c&gt;
[ INFO] [1555502889.426373088]: Receiving: &lt;STX&gt;sWA LMDscandatacfg &lt;ETX&gt;
[ INFO] [1555502889.426606493]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMDscandatacfg CRC:&lt;0x67&gt;
[ INFO] [1555502889.427933309]: Receiving: &lt;STX&gt;sRA LMDscandatacfg \x1f\x00\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01&lt;ETX&gt;
[ INFO] [1555502889.430654546]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sWN FREchoFilter 0x00 CRC:&lt;0x7f&gt;
[ INFO] [1555502889.431952374]: Receiving: &lt;STX&gt;sWA FREchoFilter &lt;ETX&gt;
[ INFO] [1555502889.432180430]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0016&gt;sMN LMCstartmeas CRC:&lt;0x68&gt;
[ INFO] [1555502889.963840302]: Receiving: &lt;STX&gt;sAN LMCstartmeas \x00&lt;ETX&gt;
[ INFO] [1555502889.964083670]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0007&gt;sMN Run CRC:&lt;0x19&gt;
[ INFO] [1555502889.965558914]: Receiving: &lt;STX&gt;sAN Run \x01&lt;ETX&gt;
[ INFO] [1555502889.965813465]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0017&gt;sEN LMDscandata 0x01 CRC:&lt;0x33&gt;
[ INFO] [1555502889.967297195]: Receiving: &lt;STX&gt;sEA LMDscandata \x01&lt;ETX&gt;

</code></pre></div></div>

<h1 id="driver-features-and-additional-information">Driver features and additional information</h1>

<h2 id="software-overview">Software Overview</h2>

<p>The sick_scan_xd software is essentially affected by its use cases:</p>

<ul>
  <li>Implement the common tasks for different lidars:
    <ul>
      <li>Provide driver software on Linux and Windows, generic, ROS 1 and ROS 2</li>
      <li>Receive and convert scan data, publish point cloud</li>
      <li>Run startup, configuration and setup</li>
    </ul>
  </li>
  <li>Use cases:
    <ul>
      <li>Provide a point cloud to the customer/application</li>
      <li>Provide a common high level interface for all supported lidars</li>
      <li>Hide datagram details, encodings and parsing knowhow</li>
      <li>The most common use case is to run lidar + sick_scan_xd to get a point cloud.</li>
    </ul>
  </li>
  <li>Software requirements:
    <ul>
      <li>Support different lidars (LMS, LRS, LDMRS, MRS, NAV, TiM, RMS, multiScan, etc.)</li>
      <li>Support different OS (Linux, Windows)</li>
      <li>Support different targets (ROS 1, ROS 2, generic)</li>
      <li>Support different protocols (Cola-A, Cola-B, TCP, UDP, msgpack)</li>
      <li>Implement parser for different telegrams (scandata, scancfg, fields, etc.)</li>
    </ul>
  </li>
</ul>

<p>This overview describes the most important modules and their relationship.</p>

<h3 id="software-structure">Software structure</h3>

<p>The following figures show the most important software blocks:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/software_overview_01.png" alt="software_overview_01"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/software_overview_02.png" alt="software_overview_02"></p>

<p>sick_scan_xd contains 6 main functional blocks:</p>

<ul>
  <li>sick_generic_caller and sick_generic_laser for initialization and setup:
    <ul>
      <li>Read configuration from launchfile:
        <ul>
          <li>ROS 1: <code class="language-plaintext highlighter-rouge">ros::NodeHandle::getParam</code>
</li>
          <li>ROS 2 and generic: <code class="language-plaintext highlighter-rouge">LaunchParser</code> (ros-wrapper)</li>
        </ul>
      </li>
      <li>Lidar specific setup:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickGenericParser</code>: lidar specific properties and messages parsing</li>
          <li>Set and get lidar specific properties: number of layers, angular resolution, etc.</li>
          <li>Parse and convert scan data, input: scan data (ascii or binary datagram), output: <code class="language-plaintext highlighter-rouge">ros::sensor_msgs::LaserScan</code>
</li>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanCommonTcp</code>: receive TCP messages, convert and publish point cloud</li>
        </ul>
      </li>
      <li>Start ros services:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanServices</code>: register ros services, convert from/to SOPAS</li>
        </ul>
      </li>
      <li>Start monitoring:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanMonitor</code>: monitor scan data, reinit on timeout</li>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::PointCloudMonitor</code>: monitor point cloud, reinit on timeout</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>sick_scan_common for the most common lidar devices (LMS, LRS, MRS, NAV, TiM, RMS, etc.):
    <ul>
      <li>Implemention by SickScanCommon and SickScanCommonTcp</li>
      <li>Uses SickGenericParser for lidar specific properties and parsing</li>
      <li>Runs common tasks for LMS/LRS/MRS/NAV/TiM/RMS:</li>
      <li>Run SOPAS startup sequence</li>
      <li>Run TCP receiver thread</li>
      <li>Process telegrams: parse and convert to point cloud</li>
      <li>Publish point cloud</li>
    </ul>
  </li>
  <li>sick_ldmrs for LD-MRS support using the ldmrs-library from https://github.com/SICKAG/libsick_ldmrs.git</li>
  <li>sick_scansegment_xd for multiScan136 and picoScan150 lidars using SOPAS, msgpack and UDP-communication</li>
  <li>sick_scan_services for ros services</li>
  <li>sick_generic_monitoring for monitoring and re-initialization in case of errors (e.g. network errors).</li>
</ul>

<p>The following figures show these 6 functional blocks:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/software_overview_03.png" alt="software_overview_03"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/software_overview_04.png" alt="software_overview_04"></p>

<p>The function blocks depend on and use the underlying system (ROS, TCP, etc.):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/driverComponentsDiagram1.png" alt="driver_components_01"></p>

<h3 id="message-receiving-and-message-handling">Message receiving and message handling</h3>

<p>Message receiving and message handling are decoupled, i.e. both tasks run in separate thread and exchange messages via a FIFO-buffer. This way, message handling cannot block tcp recv and vice versa. The following figure shows the message handling:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/software_overview_05.png" alt="software_overview_05"></p>

<p>The following figure shows the sequence diagram for a LMDscandata telegram:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/messageSequenceDiagram1.png" alt="messageSequenceDiagram1"></p>

<p>Incoming TCP messages and exported point cloud messages are monitored. sick_scan_xd reinitialises the lidar and the tcp connection in case of timeouts.</p>

<h3 id="sick_scansegment_xd">sick_scansegment_xd</h3>

<p>sick_scansegment_xd implements support for multiScan136 and picoScan150 lidars using SOPAS, msgpack and UDP-communication. It has 5 functional blocks:</p>

<ul>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackThreads</code>:
    <ul>
      <li>Init and run all sick_scansegment_xd components</li>
      <li>SOPAS startup (multiScan136, picoScan150)</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::UdpReceiver</code>:
    <ul>
      <li>Run UDP receiver thread</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackConverter</code>:
    <ul>
      <li>Parse and convert msgpacks</li>
      <li>Collect scan segments</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackValidator</code>:
    <ul>
      <li>Validate msgpacks and scansegments</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::RosMsgpackPublisher</code>:
    <ul>
      <li>Publish point cloud (single segments)</li>
      <li>Publish cloud_fullframe (fullframe pointcloud, 360 deg for Multiscan136 resp. 270 deg for picoscan)</li>
    </ul>
  </li>
</ul>

<p>The following figure shows the compoenent diagram for sick_scansegment_xd:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/driverComponentsDiagram2.png" alt="driverComponentsDiagram2"></p>

<p>Message receiving, converting and publishing run in 3 separate threads and exchange their messages via a FIFO-buffer.</p>

<p>The following figure shows the sequence diagram for a multiScan136 msgpack:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/messageSequenceDiagram2.png" alt="messageSequenceDiagram2"></p>

<p>The following figure shows the sequence diagram for a picoScan and compact format:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/messageSequenceDiagram3.png" alt="messageSequenceDiagram3"></p>

<h3 id="files-and-folders">Files and folders</h3>

<p>The source files for the sick_scan_xd core can be found in the following folders:</p>
<ul>
  <li>driver/src: source files</li>
  <li>include: header files</li>
  <li>launch: configuration</li>
  <li>msg: ros messages definitions</li>
  <li>srv: ros services definitions</li>
  <li>roswrap: ros wrapper (ROS 2 and generic)</li>
</ul>

<p>These folders are required to build sick_generic_caller.</p>

<p>Additional folders for sick_scan_xd support, development and test are:</p>
<ul>
  <li>test: test scripts and emulator</li>
  <li>tools: additional development tools</li>
</ul>

<h2 id="generic-driver-api">Generic Driver API</h2>

<h3 id="overview">Overview</h3>

<p>A generic API for sick_scan_xd has the following goals:</p>
<ul>
  <li>Easy integration of sick_scan_xd into customer systems with and without ROS</li>
  <li>Integrate SICK lidars with one API, independent of lidar types or underlying operating system</li>
  <li>Provide the same sick_scan_xd functionality on systems without ROS</li>
  <li>In particular: make the sick_scan_xd functionality available on non-ROS-systems without need to customize sources or configuration files.</li>
</ul>

<p>The generic sick_scan_xd API provides an interface to all lidars supported by sick_scan_xd. This API can be used in C, C++, Python, or any other language with support of C-bindings.</p>

<p>The generic sick_scan_xd API ships with the API-header, the library (binary or sources) and usage examples for C, C++ and Python. The following component diagram shows the relationship between API, library, lidar and a customized application:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_api/apiComponentsDiagram1.png" alt="apiComponentsDiagram1.png"></p>

<p>Running multiple lidars simultaneously in a single process is not supported.** Currently the sick_scan_xd API does not support the single or multi-threaded use of 2 or more lidars in one process, since the sick_scan_xd library is not guaranteed to be thread-safe. To run multiple lidars simultaneously, we recommend using ROS or running sick_scan_xd in multiple and separate processes, so that each process serves one sensor. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#start-multiple-nodes">start multiple lidars</a> for further information.</p>

<h3 id="build-and-test-shared-library">Build and test shared library</h3>

<p>The shared library, which implements the C-API, is built native on Linux or Windows (i.e. without ROS). Follow the instructions on <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-generic-without-ros">Build on Linux generic without ROS</a> for Linux resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-windows-generic-without-ros">Build on Windows</a> for Windows.</p>

<h4 id="build-the-shared-library-on-linux">Build the shared library on Linux</h4>

<p>Run the following commands to build the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Clone repositories
git clone https://github.com/SICKAG/libsick_ldmrs.git
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
# Build libsick_ldmrs library
mkdir -p ./build
mkdir -p ./libsick_ldmrs/build
pushd libsick_ldmrs/build
cmake -G "Unix Makefiles" ..
make -j4
sudo make -j4 install
popd
# Build libsick_scan_xd_shared_lib.so
pushd ./build
export ROS_VERSION=0
cmake -DROS_VERSION=0 -G "Unix Makefiles" ../sick_scan_xd
make -j4
sudo make -j4 install
# Check build and library dependencies
ls -al ./sick_generic_caller
ls -al ./libsick_scan_xd_shared_lib.so
ls -al ./sick_scan_xd_api_test
ldd -r ./libsick_scan_xd_shared_lib.so
popd

</code></pre></div></div>
<p>After successful build, the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> and a tiny test executable <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> are created.</p>

<h4 id="build-the-shared-library-on-windows">Build the shared library on Windows</h4>

<p>Run the following commands to build the shared library <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> with Visual Studio 2019 on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Clone repository sick_scan_xd
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
# Build libraries sick_scan_xd_shared_lib.dll
call "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\Common7\Tools\VsDevCmd.bat" -arch=amd64 -host_arch=amd64
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
cd sick_scan_xd
if not exist %_cmake_build_dir% mkdir %_cmake_build_dir%
pushd %_cmake_build_dir%
cmake -DROS_VERSION=0 -G "%_cmake_string%" ..
if %ERRORLEVEL% neq 0 ( @echo ERROR building %_cmake_string% sick_scan_xd with cmake &amp; @pause )
cmake --build . --clean-first --config Debug

</code></pre></div></div>
<p>After successful build, the shared library <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> and a tiny test executable <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test.exe</code> are created. To install the library and header in the system folder, run <code class="language-plaintext highlighter-rouge">cmake --build . --target install</code> with admin privileges. Note that LD-MRS is not supported on Windows.
privileges</p>
<blockquote>
  <p><strong><em>NOTE:</em></strong> sick_scan_xd builds and runs with both Visual Studio 2019 and 2022. Visual Studio 2019 is recommended, since ROS on Windows requires VS 2019.</p>
</blockquote>

<p>Replace <code class="language-plaintext highlighter-rouge">cmake -DROS_VERSION=0 -G "%_cmake_string%" ..</code> by  <code class="language-plaintext highlighter-rouge">cmake -DROS_VERSION=0 -DCMAKE_ENABLE_EMULATOR=1 -G "%_cmake_string%" ..</code> to build emulators for unit tests without lidar hardware, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CONTRIBUTING.md">Simulation</a>.</p>

<h4 id="test-the-shared-library">Test the shared library</h4>

<p>The executable file <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> provides a minimalistic API test. Run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;ip-address&gt;</code> to test the API against a lidar, e.g. on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH # append relative path to build folder
export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to build folder
./build/sick_scan_xd_api_test ./sick_scan_xd/launch/sick_tim_7xx.launch hostname:=192.168.0.1

</code></pre></div></div>
<p>On Windows, run e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;..\build\Debug;%PATH%
.\build\Debug\sick_scan_xd_api_test.exe launch/sick_lms_5xx.launch hostname:=192.168.0.1

</code></pre></div></div>

<p>The executable binary <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> will just load library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code>, start the lidar and print a message when receiving lidar messages, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test: pointcloud callback</code>. Replace <code class="language-plaintext highlighter-rouge">sick_lms_1xx.launch</code> in the example by the launch file corresponding to your type of lidar.</p>

<p>To load the library, the build folder has to be included in <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code> (Linux) resp. <code class="language-plaintext highlighter-rouge">PATH</code> (Windows). Set this environment variable to your build folder, e.g. on Linux using</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH # append relative path to build folder
export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to build folder

</code></pre></div></div>
<p>resp. on Windows</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;.\build\Debug;%PATH%

</code></pre></div></div>

<h3 id="usage-example">Usage example</h3>

<p>The sick_scan_xd API can be used on Linux or Windows in any language with support of C-bindings. There are 3 steps required to use the API:</p>

<ol>
  <li>API- and lidar-initialization by
    <ul>
      <li>SickScanApiLoadLibrary</li>
      <li>SickScanApiCreate</li>
      <li>SickScanApiInitByLaunchfile or SickScanApiInitByCli</li>
    </ul>
  </li>
  <li>
    <p>Receive messages by registration of callbacks using <code class="language-plaintext highlighter-rouge">SickScanApiRegister&lt;MsgType&gt;Msg</code>-functions (recommended) or by polling using <code class="language-plaintext highlighter-rouge">SickScanApiWaitNext&lt;MsgType&gt;Msg</code>-functions.</p>

    <p>Alternative examples to receive lidar scan data as a point cloud:</p>
    <ul>
      <li>Register a callback for cartesian point cloud data using SickScanApiRegisterCartesianPointCloudMsg, or</li>
      <li>register a callback for polar point cloud data using SickScanApiRegisterPolarPointCloudMsg.</li>
    </ul>

    <p>The registered callback will be executed whenever the lidar has sent new scan data and receives the (cartesian or polar) point cloud by a parameter of type SickScanPointCloudMsg. The SickScanPointCloudMsg in sick_scan_xd API corresponds to ROS pointcloud: The cartesian point cloud  (registered by SickScanApiRegisterCartesianPointCloudMsg) contains the fields (x, y, z, intensity). The polar point cloud (registered by SickScanApiRegisterPolarPointCloudMsg) contains the fields (range, azimuth, elevation, intensity). Each field contains its name (i.e. x, y, z, range, azimuth, elevation, or intensity) and offset. The scan data is a flat buffer of size width x height fields:</p>

    <p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_api/apiPointCloudMsg.png" alt="apiPointCloudMsg"></p>

    <p>The following python code shows how to convert a cartesian point cloud to 3D points (x, y, z):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Convert a SickScanCartesianPointCloudMsg to points
    def pySickScanCartesianPointCloudMsgToXYZ(pointcloud_msg):
        # get point cloud fields
        num_fields = pointcloud_msg.fields.size
        msg_fields_buffer = pointcloud_msg.fields.buffer
        field_offset_x = -1
        field_offset_y = -1
        field_offset_z = -1
        for n in range(num_fields):
            field_name = ctypesCharArrayToString(msg_fields_buffer[n].name)
            field_offset = msg_fields_buffer[n].offset
            if field_name == "x":
                field_offset_x = msg_fields_buffer[n].offset
            elif field_name == "y":
                field_offset_y = msg_fields_buffer[n].offset
            elif field_name == "z":
                field_offset_z = msg_fields_buffer[n].offset
        # Extract x,y,z
        cloud_data_buffer_len = (pointcloud_msg.row_step * pointcloud_msg.height) # length of polar cloud data in byte
        assert(pointcloud_msg.data.size == cloud_data_buffer_len and field_offset_x &gt;= 0 and field_offset_y &gt;= 0 and field_offset_z &gt;= 0)
        cloud_data_buffer = bytearray(cloud_data_buffer_len)
        for n in range(cloud_data_buffer_len):
            cloud_data_buffer[n] = pointcloud_msg.data.buffer[n]
        points_x = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        points_y = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        points_z = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        point_idx = 0
        for row_idx in range(pointcloud_msg.height):
            for col_idx in range(pointcloud_msg.width):
                # Get lidar point in polar coordinates (range, azimuth and elevation)
                pointcloud_offset = row_idx * pointcloud_msg.row_step + col_idx * pointcloud_msg.point_step
                points_x[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_x)[0]
                points_y[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_y)[0]
                points_z[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_z)[0]
                point_idx = point_idx + 1
        return points_x, points_y, points_z
   
</code></pre></div></div>
<p>Exchange field names (“x”, “y”, “z”) by (“range”, “azimuth”, “elevation”) to get 3D polar points (range, azimuth, elevation).</p>

<p>For further details, see minimalistic usage examples in C and Python.</p>

<p>Note for multiScan100 and picoScan100 lidars:</p>

<ul>
  <li>
    <p>The WaitNext-functions of the API return the next received message. For multiScan100 and picoScan, this can be a scan segment (i.e. a part of the full scan) or a fullframe point cloud (i.e. all scan points of a 360 degree scan). Depending on the timing, you may not receive all messages, i.e. you may e.g. receive scan points of different segments. We therefore recommend to register a message callback instead of a WaitNext-function. With a registered message callback, you will get all fullframe and segment point cloud messages.</p>
  </li>
  <li>
    <p>For multiScan100 and picoScan, point cloud messages can contain a scan segment (i.e. a part of the full scan) or a fullframe point cloud  (i.e. all scan points of a 360 degree scan). The type can be determined by the topic (default: “/cloud_unstructured_segments” for segments, “/cloud_unstructured_fullframe” for fullframe point clouds) or by segment index (-1 for fullframe, 0 up to 11 for segment point clouds).</p>
  </li>
</ul>

<ol>
  <li>Close lidar and API by
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">SickScanApiDeregister&lt;MsgType&gt;Msg</code>-functions</li>
      <li>SickScanApiClose</li>
      <li>SickScanApiRelease</li>
    </ul>
  </li>
</ol>

<p>It is recommended to store a deep copy of the point cloud data in a fifo buffer (first in, first out) for further data processing. After the registered callback is executed, the point cloud memory will be released. Make sure to store a deep copy of the point cloud, not a shallow copy.</p>

<p>All functions named <code class="language-plaintext highlighter-rouge">SickScanApi</code> are implemented within the library file (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux). A small wrapper is provided (<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/src/sick_scan_xd_api/sick_scan_xd_api_wrapper.c">sick_scan_xd_api_wrapper.c</a> for C/C++, <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a> for python), which loads and unloads the library (functions <code class="language-plaintext highlighter-rouge">SickScanApiLoadLibrary</code> and <code class="language-plaintext highlighter-rouge">SickScanApiUnloadLibrary</code>) and delegates the function calls to the binary.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). Otherwise, please install numpy with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> if numpy is not yet installed.</p>
</blockquote>

<h4 id="minimalistic-usage-example-in-c">Minimalistic usage example in C</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/examples/c/minimum_sick_scan_api_client.c">minimum_sick_scan_api_client.c</a> shows a minimalistic example of a C client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the build and run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd examples/c
mkdir -p ./build
cd ./build
cmake -G "Unix Makefiles" ..
make -j4
cd ../..
export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH
./examples/c/build/minimum_sick_scan_api_client &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the build and run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REM Set environment for Visual Studio 2019 (VS 16)
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
REM Build the minimalistic C usage example
cd examples\c
mkdir %_cmake_build_dir%
cd %_cmake_build_dir%
cmake -G "%_cmake_string%" ..
cmake --build . --clean-first --config Debug
REM Set environment: add build folder to LD_LIBRARY_PATH, add python/api to PYTHONPATH
cd ..\..
set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
REM Run minimalistic C api example
.\examples\c\build\Debug\minimum_sick_scan_api_client.exe &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<h4 id="minimalistic-usage-example-in-c-1">Minimalistic usage example in C++</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/examples/cpp/minimum_sick_scan_api_client.cpp">minimum_sick_scan_api_client.cpp</a> shows a minimalistic example of a C++ client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the build and run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd examples/cpp
mkdir -p ./build
cd ./build
cmake -G "Unix Makefiles" ..
make -j4
cd ../..
export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH
./examples/cpp/build/minimum_sick_scan_api_client &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the build and run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REM Set environment for Visual Studio 2019 (VS 16)
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
REM Build the minimalistic C++ usage example
cd examples\cpp
mkdir %_cmake_build_dir%
cd %_cmake_build_dir%
cmake -G "%_cmake_string%" ..
cmake --build . --clean-first --config Debug
REM Set environment: add build folder to LD_LIBRARY_PATH, add python/api to PYTHONPATH
cd ..\..
set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
REM Run minimalistic C++ api example
.\examples\cpp\build\Debug\minimum_sick_scan_api_client.exe &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<h4 id="minimalistic-usage-example-in-python">Minimalistic usage example in Python</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/examples/python/minimum_sick_scan_api_client.py">minimum_sick_scan_api_client.py</a> shows a minimalistic example of a python client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export LD_LIBRARY_PATH=`pwd`:`pwd`/build:$LD_LIBRARY_PATH
export PYTHONPATH=`pwd`:`pwd`/python/api:$PYTHONPATH
python3 ./examples/python/minimum_sick_scan_api_client.py &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
set PYTHONPATH=.;.\python\api;%PATH%
python ./examples/python/minimum_sick_scan_api_client.py &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). Otherwise, please install numpy with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> if numpy is not yet installed.</p>
</blockquote>

<h4 id="complete-usage-example-in-c">Complete usage example in C++</h4>

<p>A complete C/C++ usage example is implemented in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a>. Note that the shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) has no dependencies to ROS. The usage example on the other hand supports both ROS 1, ROS 2 and native Linux or Windows. When build on ROS, it converts the SickScanApi-messages into ROS-messages. On ROS, they can be visualized by rviz. The following screenshot shows a point cloud published by <code class="language-plaintext highlighter-rouge">rosrun sick_scan_xd sick_scan_xd_api_test _sick_scan_args:="./src/sick_scan_xd/launch/sick_tim_7xx.launch"</code>:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_api/api_test_linux_ros1_tim7xx.png" alt="api_test_linux_ros1_tim7xx.png"></p>

<p>Without ROS, sick_scan_xd_api_test plots a jpeg-file to enable a simple visualization of a point cloud. E.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>firefox ./demo/image_viewer_api_test.html &amp;
./build_linux/sick_scan_xd_api_test ./launch/sick_tim_7xx.launch

</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_api/api_test_linux_tim7xx.png" alt="api_test_linux_tim7xx.png"></p>

<h4 id="complete-usage-example-in-python">Complete usage example in Python</h4>

<p>A complete python usage example is implemented in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a>. It is handy to test the sick_scan_xd library. Like its C++ counterpart <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a>, it just loads library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code>, starts a lidar and receives the lidar point cloud and messages via API. On ROS 1, the lidar point cloud and messages are converted to ROS and published. The lidar point cloud can be visualized by rviz using topic “/sick_scan_xd_api_test/api_cloud”.</p>

<p>Run <code class="language-plaintext highlighter-rouge">python3 sick_scan_xd_api_test.py &lt;launchfile&gt; hostname:=&lt;ip-address&gt;</code> to test the API against a lidar.
On Linux e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PYTHONPATH=`pwd`:`pwd`/src/sick_scan_xd/python/api:$PYTHONPATH
source /opt/ros/noetic/setup.bash # replace by noetic by your ros version
python3 ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_lms_1xx.launch hostname:=192.168.0.1

</code></pre></div></div>
<p>On Windows e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PYTHONPATH=.;.\src\sick_scan_xd\python\api;%PYTHONPATH%
python ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_lms_1xx.launch hostname:=192.168.0.1

</code></pre></div></div>

<p>The pthon usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> imports <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a>, which contains the python definitions of the sick_scan_xd API. Make sure that sick_scan_api.py can be imported, e.g. by including folder <code class="language-plaintext highlighter-rouge">python/api</code> in PYTHONPATH by:</p>

<p><code class="language-plaintext highlighter-rouge">export PYTHONPATH=</code>pwd<code class="language-plaintext highlighter-rouge">:</code>pwd<code class="language-plaintext highlighter-rouge">/src/sick_scan_xd/python/api:$PYTHONPATH</code> on Linux, resp. <br>
<code class="language-plaintext highlighter-rouge">set PYTHONPATH=.;.\src\sick_scan_xd\python\api;%PYTHONPATH%</code> on Windows</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  The shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) works standalone and does not have any ROS dependencies. The usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> converts API- to ROS-messages for visualization and is therefore dependent on ROS, if ROS is installed.</p>
</blockquote>

<p>If ROS is not installed, <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> uses matplotlib to visualize the pointcloud. The following screenshot shows a TiM-7xx point cloud on Linux without ROS:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_api/api_test_python_tim7xx.png" alt="api_test_python_tim7xx.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows without ROS, <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> requires numpy and matplotlib. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). These python distributions provide the necessary packages and tools. Otherwise, please install numpy and matplotlib with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> and <code class="language-plaintext highlighter-rouge">python -m pip install matplotlib</code> if not yet done.</p>
</blockquote>

<h4 id="diagnostic">Diagnostic</h4>

<p>The API provides the following functions for diagnostics:</p>

<ul>
  <li>SickScanApiRegisterDiagnosticMsg and SickScanApiDeregisterDiagnosticMsg: Register resp. deregister a callback to receive diagnostic messages. Diagnostic messages contain a status code and status message. The status code is one of the following numbers:
    <ul>
      <li>OK=0 (normal operation)</li>
      <li>WARN=1 (warning)</li>
      <li>ERROR=2 (error, should not occur)</li>
      <li>INIT=3 (initialization after startup or reconnection)</li>
      <li>EXIT=4 (sick_scan_xd exiting)</li>
    </ul>

    <p>The status message is descriptional C-string.</p>

    <p>A typical sequence of the status code is:</p>
    <ul>
      <li>INIT at startup, then</li>
      <li>after lidar initialization is completed: change to OK (normal operation) and run, and</li>
      <li>EXIT at shutdown.
 Diagnostic messages are generated whenever the status changed or an ERROR occured. Status code 2 (i.e. error) should not occur under normal operation.</li>
    </ul>
  </li>
  <li>
    <p>SickScanApiRegisterLogMsg and SickScanApiDeregisterLogMsg: Register resp. deregister a callback to receive log messages. This callback will receive all informational or error messages printed on console. The log messages contain a log level (Info=1, Warn=2, Error=3, Fatal=4) and the log message.</p>
  </li>
  <li>
    <p>SickScanApiGetStatus queries the current status. This function returns the current status code (OK=0 i.e. normal operation, WARN=1, ERROR=2, INIT=3 i.e. initialization after startup or reconnection or EXIT=4) and the descriptional status message.</p>
  </li>
  <li>SickScanApiSendSOPAS sends a SOPAS command (Cola-A) to the lidar and returns the response from the device.
    <ul>
      <li>C++ example:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     char sopas_response_buffer[1024] = { 0 };
     SickScanApiSendSOPAS(apiHandle, "sRN SCdevicestate", &amp;sopas_response_buffer[0], (int32_t)sizeof(sopas_response_buffer); // returns "sRA SCdevicestate \x00" in sopas_response_buffer
     
</code></pre></div></div>

<ul>
  <li>Python example:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     sopas_response = SickScanApiSendSOPAS(sick_scan_library, api_handle, "sRN SCdevicestate")` # returns "sRA SCdevicestate \x00".
      
</code></pre></div></div>
<p>See the telegram listing for valid SOPAS commands.</p>

<ul>
  <li>SickScanApiSetVerboseLevel and SickScanApiGetVerboseLevel sets resp. returns the verbose level. The verbose level can be 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR, 4=FATAL or 5=QUIET (equivalent to ros::console::levels). Default verbose level is 1 (INFO), i.e. sick_scan_xd prints informational, warnings and error messages on the console. Logging callbacks registered with SickScanApiRegisterLogMsg will receive all informational, warnings and error messages independent of the verbose level.</li>
</ul>

<p>To monitor sick_scan_xd resp. the lidar, it is recommended to register a callback for diagnostic messages using SickScanApiRegisterDiagnosticMsg and to display the error message in case for status code 2 (error). See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> for an example.</p>

<h4 id="simulation-and-unit-test">Simulation and unit test</h4>

<p>sick_scan_xd provides a tiny server for offline tests which simulates a basic lidar. It just accepts TCP connections, responds to sopas requests with predefined responses and sends lidar data from file. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CONTRIBUTING.md">Simulation</a> for further details. Note that the simulation does not emulate or replace a lidar, it just supports basic unit tests.</p>

<p>Open a new terminal and run the following steps to test the api against a TiM7xx simulation using the python example mentioned above:</p>

<ol>
  <li>Build library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> incl. emulator with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code>:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./src/build
   pushd ./src/build
   rm -rf ./*
   cmake -DROS_VERSION=0 -DCMAKE_ENABLE_EMULATOR=1 -G "Unix Makefiles" ../sick_scan_xd
   make -j4
   ls -al libsick_scan_xd_shared_lib.so sick_scan_xd_api_test sick_generic_caller sick_scan_emulator # list size and date of the binaries
   popd
   
</code></pre></div></div>
<p>Building sick_scan_xd with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code> requires jsoncpp. Install libjsoncpp by running “sudo apt-get install libjsoncpp-dev” on Linux resp. “vcpkg install jsoncpp:x64-windows” on Windows (vcpkg required). Run the following steps to install Visual Studios package manager vcpkg on Windows:
      * Download vcpkg-master.zip from https://github.com/microsoft/vcpkg/archive/master.zip and unzip to <code class="language-plaintext highlighter-rouge">c:\vcpkg</code>. Alternatively, run “git clone https://github.com/microsoft/vcpkg”
      * Install vcpkg by running the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        cd c:/vcpkg
        bootstrap-vcpkg.bat
        vcpkg integrate install
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  * Include vcpkg in your path:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        set PATH=c:\vcpkg\installed\x64-windows\bin;%PATH%
        
</code></pre></div></div>

<ol>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
  <li>
    <p>Build sick_scan_xd for ROS 1 on Linux, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-ros1">Build on Linux ROS 1</a></p>
  </li>
  <li>
    <p>Start the TiM7xx simulator:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cp -f ./src/sick_scan_xd/test/emulator/scandata/sopas_et_field_test_1_2_both_010.pcapng.json /tmp/lmd_scandata.pcapng.json
   ./src/build/sick_scan_emulator ./src/sick_scan_xd/test/emulator/launch/emulator_01_default.launch &amp;
   sleep 1
   
</code></pre></div></div>

<ol>
  <li>Run sick_scan_xd_api_test.py against the TiM7xx simulator on localhost:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   export PYTHONPATH=.:./src/sick_scan_xd/python/api:$PYTHONPATH
   python3 ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_tim_7xx.launch hostname:=127.0.0.1 port:=2111 sw_pll_only_publish:=False
   
</code></pre></div></div>

<ol>
  <li>Start rviz and visualize the point cloud on topic “/sick_scan_xd_api_test/api_cloud”.</li>
</ol>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) works standalone and does not have any ROS dependencies. The usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> uses ROS for visualization.</p>
</blockquote>

<h3 id="c-api">C-API</h3>

<p>The header file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/include/sick_scan_xd_api/sick_scan_api.h">sick_scan_api.h</a> defines the C-interface. It defines all datatypes, messages and functions of the generic sick_scan_xd API. To allow equal operations on all systems, the definition of datatypes and messages is as close as possible to their equivalents currently used on ROS.</p>

<p>Python file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a> defines the same interface in python.</p>

<h3 id="useful-links">Useful links</h3>

<p><a href="https://docs.python.org/3/library/ctypes.html">ctypes</a> is used for data exchange and function calls between Python and C-libraries:</p>
<ul>
  <li>https://docs.python.org/3/library/ctypes.html</li>
  <li>https://docs.python.org/3/library/ctypes.html#structures-and-unions</li>
  <li>https://docs.python.org/3/library/ctypes.html#callback-functions</li>
</ul>

<h2 id="timestamps-and-synchronization-software-pll">Timestamps and synchronization (Software PLL)</h2>

<p>Often there is a requirement that the time stamp of the measurements should be calculated for each individual shot. This article explains some background information about the determination of these time stamps. Here the statements refer to the LMS511. However, they can be transferred to other lidars using the same logic.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/lms511_scan.png" alt="lms511_scan.png"></p>

<p>The lidar sends a pulsed beam onto a rotating mirror. Since the speed of rotation is relatively low, this mirror serves as transmitter and receiver. The direction of rotation can be seen in the drawing.</p>

<p>25 scans per second means that the mirror makes 25 360° rounds per second. The actual laser unit is only active during the 190°. Therefore the so-called duty cycle is 190/360. The rotation is unaccelerated, so that the lidar arrives at the same angular direction again after 40 ms (1/25). From the angular distance from shot to shot you can calculate the pulse rate of the laser. For example, if the angular difference from shot to shot is 0.1 degree, the so-called shot rate would be: 360/0.1 * 25 shots/second.</p>

<p>A scan means the group of all shots during one revolution. Just imagine the lidar as a lighthouse that rotates evenly and measures the distance values over time of flight in a certain sector (here 190°) with the above mentioned shot rate. Also you find some background material in the documentation of SICK.</p>

<p>In the transmission protocol of the lidar two points in time are given in so-called ticks (resolution in microseconds):
a) Start of the scans in ticks
b) Start of IP data transfer from lidar to PC in ticks</p>

<p>It is assumed that the transfer between lidar and PC is near latency-free.
The software PLL generates an assignment between the tick of the IP data transmission and the system time of the PC via an estimated line mapping. On the basis of this straight line equation, the start of the scan is then calculated relative to the system time. This generation time stamp is the time of the first shot of the scan. This timestamp is assigned to the point cloud timestamp. From there, the rotation speed and the angular distance from shot to shot can be used to approximately calculate the time for each shot.</p>

<p>A software pll is used to convert LiDAR timestamps in ticks to the ros system time.</p>

<p>Many sensor devices, e.g. lidar devices, provide sensor data with timestamps. These timestamps can be synchronized with the current system time by additional hardware, e.g. by GPS. But without specialized hardware, sensor timestamps and system time is normally unsynchronized. Sensor timestamps are often quite accurate, but have a different time base and a bias to the system time or to other sensor clocks. This difference is estimated and compensated by this Software PLL.</p>

<p>The scanner has an internal time base of microseconds since system startup. Against this “tick” time base all time stamps are made in the scanner. When sending messages from the scanner, two time stamps are added:</p>

<ol>
  <li>scan generation ticks–&gt; timestamp at the time of the first shot</li>
  <li>scan transmission ticks–&gt; time stamp for the transmission of the data</li>
</ol>

<p>When data packets are received, they are timestamped by the driver against the systemtime in ros::time format. See following Fig.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/timing_sync.png" alt="timing_syn.png"></p>

<p>The relationship between system time and ticks is then derived from the time stamps and kept synchronous.The time required for the transmission of data over the network is assumed to be short and constant and is therefore neglected. The function of the algorithms is shown in the following Fig.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sequence_time_pll.png" alt="sequence_time_pll.png"></p>

<p>To compensate the different time base and bias between sensor and system clock, the system time when receiving sensor data is gathered together with the sensor timestamp. While the system time is often measured in seconds resp. nanoseconds, the sensor timestamp is normally received in clock ticks. SoftwarePLL estimates the correlation between system time in secondsnanoseconds and sensor ticks, and computes a corrected time from ticks. This way you know at which time stamp the data
have been measured by your sensor.</p>

<p>SoftwarePLL is a generic module and independant from specific sensor types. It just uses the system timestamps and ticks, estimates their correlation and predicts the time from sensor ticks.SoftwarePLL computes a linear regression between ticks and system timestamps. The system time is measured immediately after receiving new sensor data, while sensor ticks represent the sensor clock at the time of measurement. Thus we have three different times for each measurement</p>

<ul>
  <li>The time when the system receives the sensor data (receive time t_rec), measured in seconds resp. nanoseconds.</li>
  <li>The sensor ticks (or just ticks) at the time of the measurement. These ticks are contained in the sensor data and
received later by the system.</li>
  <li>The time of the measurement (measurement time t_mea). We don’t know this time yet, but we estimate it from both the ticks
and their receive time t_rec using the SoftwarePLL.</li>
</ul>

<p>During initialization, ticks and system timestamps are stored in fifo buffer (first-in, first-out). After initialization,
typically after N=7 measurements, a regression line is computed, i.e. the slope <code class="language-plaintext highlighter-rouge">m</code> (gradient) of a function
<code class="language-plaintext highlighter-rouge">f(ticks) = m  ticks + c</code> is estimated from ticks <code class="language-plaintext highlighter-rouge">x(i)</code> and timestamps <code class="language-plaintext highlighter-rouge">y(i)</code> by a linear regression
<code class="language-plaintext highlighter-rouge">m = (N  sum(x(i)  y(i)) - sum(x(i))  sum(y(i)))  (N  sum(x(i)  x(i)) - sum(x(i))sum(x(i)))</code> with <code class="language-plaintext highlighter-rouge">0 = i  N</code> and
unbiased values <code class="language-plaintext highlighter-rouge">x(i) = tick(i) - tick(0)</code>, <code class="language-plaintext highlighter-rouge">y(i) = t_rec(i) - t_rec(0)</code>.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/pll_regression.png" alt="pll_regression.png"></p>

<p>The estimated system time <code class="language-plaintext highlighter-rouge">t_esti(i)</code> of a measurement can be computed from its sensor tick by <code class="language-plaintext highlighter-rouge">t_esti(i) = m  (ticks(i) - ticks(0)) + t_rec(0)</code>.
If the difference between estimated times <code class="language-plaintext highlighter-rouge">t_esti(i)</code> and the measured system timestamps <code class="language-plaintext highlighter-rouge">t_rec(i)</code> is small (typically
less than 100 milliseconds), the estimation can be considered to be valid. With a valid estimation of <code class="language-plaintext highlighter-rouge">m</code>, we can
get a corrected timestamp for new measurements by applying function <code class="language-plaintext highlighter-rouge">SoftwarePLLGetCorrectedTimeStamp</code>, which returns
the estimated system time of a measurement <code class="language-plaintext highlighter-rouge">t_esti  = m  (ticks - ticks(0)) + t_rec(0)</code>.</p>

<p>If the estimation is not valid (i.e. the difference between estimated times and measured system timestamps in the buffer is
significant), we can’t estimate system timestamps from sensor ticks. If this happens more than a given number of times
after initialization (typically 20 times), the fifo is reset and a new initialization is done.</p>

<p>Use the following code snippet as an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include softwarePLL.h

 Create an instance of SoftwarePLL
SoftwarePLL&amp; software_pll = SoftwarePLLInstance(Sensor1);

 Get system time t_rec in seconds and nanoseconds when receiving sensor data
rosTime t_rec = rosTimenow();
uint32_t sec = t_rec.nsec;
uint32_t nanosec = t_rec.nsec;

 Get sensor ticks from sensor data
uint32_t ticks = scanner_msg.ticks;

 Update SoftwarePLL
software_pll.UpdatePLL(sec, nanosec, ticks);

 Get corrected timestamp (time of measurement from ticks)
software_pll.GetCorrectedTimeStamp(sec, nanosec, ticks);

</code></pre></div></div>

<p><strong>Data buffering in MRS1000</strong></p>

<p>Due to their construction the MRS1000 scanners generate different layers at the same time which are output sequentially by the scanner firmware. In order to ensure that only point cloud messages that follow one another in time are sent, buffering can be activated in the driver.
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/scannbuffering.png" alt="scannbuffering.png"></p>

<h2 id="coordinate-transforms">Coordinate transforms</h2>

<p>Different lidars use different coordinate systems. sick_scan_xd transforms all points of the published pointclouds to the ROS coordinate system, independant of the lidar. The following figure shows the commonly used coordinate systems:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/3d_coordinate_system_comp.png" alt="3d_coordinate_system_comp.png"></p>

<p>An additional coordinate transform can be applied to the pointcloud. This optional transform can be used to transform the pointclouds into a user defined coordinate system. If the lidar is e.g. mounted on a vehicle, the pointclouds can be transformed into a vehicle coordinates.</p>

<p>An additional coordinate transform can be configured by a 6D pose (x, y, z, roll, pitch, yaw) with a translational part (x, y, z) in [m] and a rotational part (roll, pitch, yaw) in [rad].</p>

<p>If configured, it will transform the point cloud from its “cloud” coordinates into user defined “world” coordinate system:</p>

<p><code class="language-plaintext highlighter-rouge">T[world,cloud] with P_world = T[world,cloud] * P_cloud</code> (parent: world, child: cloud)</p>

<p>The final rotation is defined by: Rotation = Rot[yaw] * Rot[pitch] * Rot[roll] with roll = rotation about x-axis, pitch = rotation about y-axis and yaw = rotation about z-axis.</p>

<p>An additional transform can be configured in the launchfile, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- Apply an additional transform to the cartesian pointcloud, default: "0,0,0,0,0,0" (i.e. no transform) --&gt;
&lt;!-- &gt; **_NOTE:_** add_transform_xyz_rpy is specified by 6D pose x, y, z, roll, pitch, yaw in [m] resp. [rad] --&gt;
&lt;!-- It transforms a 3D point in cloud coordinates to 3D point in user defined world coordinates: --&gt;
&lt;!-- add_transform_xyz_rpy := T[world,cloud] with parent "world" and child "cloud", i.e. P_world = T[world,cloud] * P_cloud --&gt;
&lt;param name="add_transform_xyz_rpy" type="string" value="0,0,0,0,0,0" /&gt;

</code></pre></div></div>

<p>Default value is <code class="language-plaintext highlighter-rouge">"0,0,0,0,0,0"</code>, i.e. no additional transform will be applied.</p>

<p>The additional transform applies to cartesian lidar pointclouds and visualization marker (fields).
It is <strong>NOT</strong> applied to polar point clouds, radarscans, LD-MRS objects or other messages.</p>

<p>Note that sick_scan_xd configures an additional transform using (x, y, z, roll, pitch, yaw). In contrast, the ROS static_transform_publisher uses commandline arguments in order x, y, z, yaw, pitch, roll.</p>

<p>Example using ROS static_transform_publisher with x=0, y=0, z=0, roll=15, pitch=-10, yaw=5 [deg]:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source /opt/ros/noetic/setup.bash
# static_transform_publisher x y z yaw pitch roll frame_id child_frame_id period_in_ms
# tf_echo &lt;source_frame&gt; &lt;target_frame&gt;
# rot_x = 5 deg: 0.0872665, rot_y = -10 deg: -0.1745329, rot_z = 15 deg: 0.2617994
rosrun tf static_transform_publisher 0 0 0 0.2617994 -0.1745329 0.0872665 parent_frame child_frame 100
rosrun tf tf_echo parent_frame child_frame

</code></pre></div></div>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/doc/sick_scan_api/trafo_example.py">trafo_example.py</a> demonstrates how a transform can be computed.</p>

<p>For upside down mounted devices, the point cloud can be rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lrs_36x0_upside_down.launch">sick_lrs_36x0_upside_down.launch</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lrs_36x1_upside_down.launch">sick_lrs_36x1_upside_down.launch</a> show examples for compensating the point cloud of an upside down mounted device by a 180 deg rotation about the x axis.</p>

<h2 id="imu-support">IMU Support</h2>

<p>Devices of the MRS6xxx and MRS1xxx series are available with an optionally built-in IMU.</p>

<p>For the IMU support of multiScan100 and picoScan100 refer to the device specific section.</p>

<p>By setting the following config parameter in the launch file, the output of <a href="http://docs.ros.org/melodic/api/sensor_msgs/html/msg/Imu.html">imu messages</a> can be enabled with a compatible scanner. Currently the messages are published in the /imu Topic.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_enable"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">value=</span><span class="s">"True"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_topic"</span> <span class="na">type=</span><span class="s">"string"</span> <span class="na">value=</span><span class="s">"imu"</span><span class="nt">/&gt;</span>

</code></pre></div></div>
<p>The imu Messages contain covariance matrices, these are currently determined from empirical values and are not measured specifically for each scanner.
The laser scanner provides additional information (tick timestamp and confidence) to the Imu messages these can be activated by activating the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/msg/SickImu.msg">SickImu messages</a>.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_enable_additional_info"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">value=</span><span class="s">"True"</span> <span class="nt">/&gt;</span>

</code></pre></div></div>

<p>IMU messages are only supported in SOPAS binary mode. Due to the high data rate of the IMU messages (100 Hz and more) while sending the standard laser scanner messages at the same time, the ASCII mode is not supported. Please set the scanner to binary mode if you are using the IMU.</p>

<h2 id="encoders">Encoders</h2>

<p>If the device is mounted for mobile use or if the objects to be measured are in motion,the application will usually also need position data to further process the measured val‐ues.Encoders can be connected for this purpose. The encoder data is then available withthe other measured values in a single scan and at the same interface. A volume,for example, can be calculated by evaluating the measurement data. The input fre‐quency of the encoder signal must not exceed 50 kHz.The following encoders with push-pull output stage can be used:</p>
<ol>
  <li>Single-channel, only connected at encoder A, no direction detection.</li>
  <li>Dual-channel (phase), connected at encoder A and encoder B; the pulses have aphase shift of 90°, making direction detection possible. By definition, during for‐ward motion (CW = clockwise) phase A precedes phase B; conversely, duringreverse motion (CCW = counterclockwise) edge A rises before edge B.</li>
  <li>Dual-channel (level), connected at encoder A and encoder B; the pulses are atencoder A; at encoder B, the direction is indicated by level 0 or level 1 (rarely).</li>
</ol>

<h3 id="connecting-encoders">Connecting encoders</h3>
<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/lms4xxx_encoder_connection.png" alt="LMS4000 encoder connection" title="LMS4000 encoder connection">
See also <a href="https://cdn.sick.com/media/docs/0/90/790/Operating_instructions_LMS4000_2D_LiDAR_sensors_en_IM0079790.PDF">LMS4000 Manual</a></p>

<h3 id="example-circuit-to-trigger-encoder-counts">Example circuit to trigger encoder counts</h3>
<p>Whenever the switch is closed a potential of 24 V is applied to the encoder input A in mode (01 single-channel) this leads to an increase of the count by 1.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/circuit.png" alt="encoder trigger" title="encoder trigger"></p>

<h3 id="activation-of-encoder-information">Activation of encoder information</h3>
<p>If the parameter</p>
<pre><code class="language-encoder_mode">``` is set to 1-4 in the launch file, the encoder is activated in the laser scanner in the corresponding mode (see list above).

The following encoder modes can be configured in the launch file or by commandline parameter:
* `encoder_mode:=-1`: Default value, i.e. encoder configuration not set
* `encoder_mode:=0`: Encoder off (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=1`: Single increment (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=2`: Direction recognition phase (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=3`: Direction recognition level (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=4`: Fixed increment speed/ticks (supported by LMS4000 only)

Encoder messages are published on topic `/encoder` synchronously to the point cloud messages. They contain a timestamp and the encoder value, e.g.:

```console
foo@bar:~$rostopic echo /encoder
header:
  seq: 20700
  stamp:
    secs: 1570722972
    nsecs:  28866142
  frame_id: "Encoder"
enc_count: 836
---
header:
  seq: 20701
  stamp:
    secs: 1570722972
    nsecs:  30598181
  frame_id: "Encoder"
enc_count: 836
---
header:
  seq: 20702
  stamp:
    secs: 1570722972
    nsecs:  32138020
  frame_id: "Encoder"
enc_count: 836

</code></pre>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/Encoder_data.png" alt="Encoderdata in Sopas datagramm" title="Encoderdata in Sopas datagramm"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/set_encoder_settings.png" alt="Set encoder config" title="Set encoder config"></p>

<h2 id="field-evaluation-information">Field Evaluation Information</h2>

<p>The LMS1xx, LMS5xx, TiM7xx and TiM7xxS families support extensions for field monitoring.</p>

<h3 id="field-monitoring-messages">Field monitoring messages</h3>

<p>LMS1xx, LMS5xx, TiM7xx and TiM7xxS scanner support field monitoring. Fields can be configured by Sopas ET. Once they are configured, sick_scan_xd publishes ros messages containing the monitoring information from the lidar.</p>

<p>By default, field monitoring is enabled in the launch files <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lms_1xx.launch">sick_lms_1xx.launch</a>,  <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lms_5xx.launch">sick_lms_5xx.launch</a>,
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_tim_7xx.launch">sick_tim_7xx.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_tim_7xxS.launch">sick_tim_7xxS.launch</a> by following settings:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="activate_lferec" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lferec messages --&gt;
&lt;param name="activate_lidoutputstate" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lidoutputstate messages --&gt;
&lt;param name="activate_lidinputstate" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lidinputstate messages --&gt;

</code></pre></div></div>

<p>The driver queries the field configuration from the lidar and activates field monitoring by sending cola commands <code class="language-plaintext highlighter-rouge">"sEN LFErec 1"</code> and <code class="language-plaintext highlighter-rouge">"sEN LIDoutputstate 1"</code> at startup. Field monitoring is deactivated when driver exits. During runtime, it’s possible to query, activate or deactivate monitoring using ros service ColaMsg with the following command (see section <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#cola-commands">Cola commands</a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LFErec 1'}" # activate LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LFErec 0'}" # deactivate LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LFErec'}"   # query activation status of LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDoutputstate 1'}" # activate LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDoutputstate 0'}" # deactivate LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LIDoutputstate'}"   # query activation status of LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDinputstate 1'}"  # activate LIDinputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDinputstate 0'}"  # deactivate LIDinputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LIDinputstate'}"    # query activation status of LIDinputstate messages

</code></pre></div></div>

<p>LFErec and LIDoutputstate messages are defined in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/msg/LFErecMsg.msg">LFErecMsg.msg</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/msg/LFErecFieldMsg.msg">LFErecFieldMsg.msg</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/msg/LIDoutputstateMsg.msg">LIDoutputstateMsg.msg</a> and published on the following topics: <code class="language-plaintext highlighter-rouge">"/sick_tim_7xxS/lferec"</code> resp. <code class="language-plaintext highlighter-rouge">"/sick_tim_7xxS/lidoutputstate"</code>.</p>

<table>
  <thead>
    <tr>
      <th>** Lidar **</th>
      <th>** lferec topic **</th>
      <th>** lidoutputstate topic **</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>lms_1xx</td>
      <td>/sick_lms_1xx/lferec</td>
      <td>/sick_lms_1xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_5xx</td>
      <td>/sick_lms_5xx/lferec</td>
      <td>/sick_lms_5xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_7xx</td>
      <td>/sick_tim_7xx/lferec</td>
      <td>/sick_tim_7xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_7xxS</td>
      <td>/sick_tim_7xxS/lferec</td>
      <td>/sick_tim_7xxS/lidoutputstate</td>
    </tr>
  </tbody>
</table>

<p>To view the field monitoring messages, run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic echo "/sick_lms_1xx/lferec"
rostopic echo "/sick_lms_1xx/lidoutputstate"
rostopic echo "/sick_lms_5xx/lferec"
rostopic echo "/sick_lms_5xx/lidoutputstate"
rostopic echo "/sick_tim_7xx/lferec"
rostopic echo "/sick_tim_7xx/lidoutputstate"
rostopic echo "/sick_tim_7xxS/lferec"
rostopic echo "/sick_tim_7xxS/lidoutputstate"

</code></pre></div></div>
<p>or use rviz to visualize monitored fields and their status (see section <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#visualization-with-rviz">Visualization with rviz</a>)</p>

<p>The most important values of the field monitoring messages are</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">field_index</code> (uint8) and <code class="language-plaintext highlighter-rouge">field_result_mrs</code> (uint8) for each field of a LFErec message with result status<br>&lt;ul&gt;
    </li>
<li>0: invalid / incorrect,</li>
    <li>1: free / clear, or</li>
    <li>2: infringed.</li>
    <p>&lt;/ul&gt;</p>
  
  <li>
<code class="language-plaintext highlighter-rouge">output_state</code> (uint8) for each LIDoutputstate message with status 0 (not active), 1 (active) or 2 (not used).</li>
</ul>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Field monitoring currently supports binary cola messages only, which is the default. If cola ascii is activated, please switch back to cola binary for field monitoring.</p>
</blockquote>

<h3 id="visualization-with-rviz">Visualization with rviz</h3>

<p>The point cloud, the monitored fields and their status can be visualized using rviz. Use the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/emulator/config/rviz_emulator_cfg.rviz">rviz configuration file</a>
and run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz

</code></pre></div></div>

<p>Otherwise you can just add visualizations of type <code class="language-plaintext highlighter-rouge">/cloud/PointCloud2</code> and <code class="language-plaintext highlighter-rouge">/sick_tim_7xxS/marker</code> (resp. <code class="language-plaintext highlighter-rouge">/sick_tim_1xx/marker</code> for lms_1xx,  <code class="language-plaintext highlighter-rouge">/sick_tim_5xx/marker</code> for lms_5xx and  <code class="language-plaintext highlighter-rouge">/sick_tim_7xx/marker</code> for tim_7xx):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/tim7xxs_screenshot01.png" alt="tim7xxs_screenshot01.png"></p>

<p>The following screenshot shows a TiM781S example with 2 fields (the 3. field is not configured), the first field with status “Clear”, the second with status “Infringed”:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/tim7xxs_screenshot02.png" alt="tim7xxs_screenshot02.png"></p>

<p>The following screenshot shows a LMS511 example with a segmented field, two rectangular fields and a dynamic fields:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/lms511_screenshot01.png" alt="lms511_screenshot01.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Some combinations of rviz, OpenGL 3, VMware and graphic card drivers may cause visualization issues. In case of missing markers, try rviz with Open GL 2 using the command</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz --opengl 210

</code></pre></div></div>

<h3 id="cola-commands">Cola commands</h3>

<p>Cola commands can be sent for diagnosis and development using the ros service ColaMsg. This service is implemented in sick_scan_xd and started by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="start_services" type="bool" value="True"/&gt;

</code></pre></div></div>
<p>in the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_tim_7xxS.launch">sick_tim_7xxS.launch</a> (resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lms_1xx.launch">sick_lms_1xx.launch</a>, <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lms_5xx.launch">sick_lms_5xx.launch</a>, <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_tim_7xx.launch">sick_tim_7xx.launch</a> ). The ros service sends the given cola command to the lidar and returns its response.</p>

<p>Example for cola command <code class="language-plaintext highlighter-rouge">"sRN SCdevicestate"</code> and response <code class="language-plaintext highlighter-rouge">"sRA SCdevicestate \\x00"</code> with error status 0 (no error):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN SCdevicestate'}"
response: "sRA SCdevicestate \\x00"

</code></pre></div></div>

<h3 id="tools-emulation-and-unittests">Tools, emulation and unittests</h3>

<p>Package sick_scan_xd implements some tools to support unittests, development and emulation of Tim781S devices:</p>

<ul>
  <li>sick_scan_emulator to emulate lidar devices and enable unittests (currently for Tim781S only)</li>
  <li>pcap_json_converter to convert pcapng-files to json.</li>
</ul>

<h4 id="lms-and-tim-emulation">LMS and TiM emulation</h4>

<p>sick_scan_emulator implements a simple test server for cola commands. It rececives Cola-commands, returns Tim781S-like responses and sends Scandata from a json-file. Run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_01_default.launch

</code></pre></div></div>
<p>to emulate a local Tim781S device. Then start and connect the sick_scan_xd driver by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>Note that sick_scan_emulator just implements a simple server for offline tests. It does not emulate a lidar device completely and should only be used for development and testing.</p>

<p>Scandata messages are parsed from json-file(s). These json-files are configured in the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/emulator/launch/emulator_01_default.launch">emulator.launch</a> and converted form wireshark-records (pcapng-files) using pcap_json_converter.py (see section Pcapng converter tool](#pcapng-converter-tool)).</p>

<p>A LMS111 device can be emulated by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_lms1xx.launch &amp;
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms1xx.rviz &amp;
roslaunch sick_scan_xd sick_lms_1xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>A LMS511 device can be emulated by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_lms5xx.launch &amp;
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms5xx.rviz &amp;
roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<h4 id="unittests">Unittests</h4>

<p>Folder <code class="language-plaintext highlighter-rouge">test/emulator/scandata</code> contains scandata examples for unittests. To run an offline unittest for LMS111, LMS511, TiM781, TiM781S enter the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd test/scripts
./run_simu_lms1xx.bash
./run_simu_lms5xx.bash
./run_simu_tim7xx_tim7xxS.bash

</code></pre></div></div>
<p>or start emulator, driver and rviz by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1
# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz --opengl 210 &amp;
sleep 1
# Start sick_scan_xd driver for TiM871S
roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<h4 id="pcapng-converter-tool">Pcapng converter tool</h4>

<p>The pcapng converter tool <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/pcap_json_converter/pcap_json_converter.py">pcap_json_converter.py</a> converts pcapng-files to json-files. Run the following steps to create a json-file with scandata for the emulator:</p>

<ol>
  <li>Start wireshark and filter the tcp traffic on port 2112 with the filter expression <code class="language-plaintext highlighter-rouge">tcp and tcp.port==2112</code>.</li>
  <li>Start TiM781S and run the sick_scan_xd driver.</li>
  <li>Capture the network traffic for some time.</li>
  <li>Stop capturing and save the network traffic in a pcapng-file.</li>
  <li>Convert the pcapng-file to json by <code class="language-plaintext highlighter-rouge">python pcap_json_converter.py --pcap_filename=&lt;filepath&gt;.pcapng</code>. Result is a jsonfile <code class="language-plaintext highlighter-rouge">&lt;filepath&gt;.pcapng.json</code>
</li>
  <li>Set the resulting json-file in the emulator configuration <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/emulator/launch/emulator_01_default.launch">emulator.launch</a> by <code class="language-plaintext highlighter-rouge">&lt;arg name="scandatafiles" default="&lt;filepath&gt;.pcapng.json"/&gt;</code>
</li>
</ol>

<h2 id="slam-support">SLAM Support</h2>

<h3 id="introduction">Introduction</h3>

<p>In robotic mapping and navigation, simultaneous localization and mapping (SLAM) is the computational problem of constructing or updating a map of an unknown environment while simultaneously keeping track of an agent’s location within it. For further details please refer to https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping .</p>

<h3 id="measuring-principle">Measuring Principle</h3>

<p>The following assumes that the SLAM algorithm works with a laser scanner mounted on a mobile base. The mobile base (e.g. a robot) records the environment while driving and creates the map from it. The mobile base usually has a so-called intertial measurement unit (IMU). In principle, however, it is also possible to estimate the direction of movement from the chronological sequence of the laser scans by means of correlation observations. The laser scanner then virtually takes over the task of the IMU and other components (e.g. counting the wheel revolutions). The method of estimating the position and orientation (position estimation) of a mobile system based on data from its driving system is called odometry (cf. https://en.wikipedia.org/wiki/Odometry).</p>

<p>The SLAM algorithm hector_slam (http://wiki.ros.org/hector_slam) supports odometry estimation directly from the laser scans and is therefore used as a reference implementation in the following.</p>

<p>Other widely used SLAM algorithms such as gmapping (cf. http://wiki.ros.org/gmapping ) do not have this option. They depend on the data of an IMU. One possibility to use Gmapping nevertheless is the integration of the project laser_scan_matcher (https://answers.ros.org/question/63457/gmapping-without-odom/ and http://wiki.ros.org/laser_scan_matcher ).  Here, however, the pose must still be converted into an odometry message (see https://answers.ros.org/question/12489/obtaining-nav_msgsodometry-from-a-laser_scan-eg-with-laser_scan_matcher/ ).</p>

<h3 id="nav350-ros-1-slam-example">NAV350 ROS 1 SLAM example</h3>

<p>Build hector_slam and sick_scan_xd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd src
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
git clone https://github.com/tu-darmstadt-ros-pkg/hector_slam.git
cd ..
catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DCMAKE_ENABLE_EMULATOR=1 -Wno-dev

</code></pre></div></div>

<p>Run rviz, sick_scan_xd with NAV350 and hector_slam:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./devel_isolated/setup.bash
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_slam_nav350.rviz &amp;
roslaunch sick_scan sick_nav_350.launch hostname:=192.168.0.1 tf_publish_rate:=0 &amp;
roslaunch sick_scan test_200_slam_ros1_hector.launch scan_topic:=/scan scan_layer_0_frame_id:=cloud_POS_000_DIST1 cloud_frame_id:=cloud &amp;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  By default, sick_scan_xd publishes transform (TF) messages, which map frame id “map” to the point cloud frame id. To avoid conflicts with hector SLAM, it is recommended to disable these TF messages by commandline parameter <strong><code class="language-plaintext highlighter-rouge">tf_publish_rate:=0</code></strong> or by setting <code class="language-plaintext highlighter-rouge">&lt;param name="tf_publish_rate" type="double" value="0"/&gt;</code> in the launchfile.</p>
</blockquote>

<p>The following rviz screenshot shows an example of a NAV350 pointcloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/slam_example_ros1_nav350.png" alt="slam_example_ros1_nav350.png"></p>

<h3 id="nav350-ros-2-slam-example">NAV350 ROS 2 SLAM example</h3>

<p>Install ths ROS 2 slam-toolbox with <code class="language-plaintext highlighter-rouge">sudo apt install ros-foxy-navigation2 ros-foxy-nav2-bringup ros-foxy-slam-toolbox</code> (replace <code class="language-plaintext highlighter-rouge">foxy</code> by your ros distribution).</p>

<p>Build sick_scan_xd for ROS 2 as described in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#install-on-ros-2">INSTALL ROS 2</a></p>

<p>Run rviz2, sick_scan_xd, slam_toolbox and static transforms:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
ros2 run rviz2 rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_slam_nav350.rviz &amp;
ros2 launch sick_scan sick_nav_350.launch.py hostname:=192.168.0.1 tf_publish_rate:=0 &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 base_link cloud  &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 base_footprint base_link  &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 odom base_footprint  &amp;
ros2 launch nav2_bringup navigation_launch.py &amp;
ros2 launch slam_toolbox online_async_launch.py &amp;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Laserscan messages need to be remapped to topic <code class="language-plaintext highlighter-rouge">/scan</code> (default is <code class="language-plaintext highlighter-rouge">/sick_nav_350/scan</code>). Use <code class="language-plaintext highlighter-rouge">remappings=[ ('/sick_nav_350/scan', '/scan'), ]</code> in the launchfile, e.g.:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node = Node(
    package='sick_scan',
    executable='sick_generic_caller',
    output='screen',
    remappings=[ ('/sick_nav_350/scan', '/scan'), ], # remap laserscan messages to topic /scan
)

</code></pre></div></div>

<p>The following rviz2 screenshot shows an example of a NAV350 laserscan created by sick_scan_xd and its map generated by slam_toolbox on ROS 2:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/slam_example_ros2_nav350.png" alt="slam_example_ros2_nav350.png"></p>

<h3 id="picoscan100-ros-1-slam-example">picoScan100 ROS 1 SLAM example</h3>

<p>Run rviz, sick_scan_xd with picoScan100 and hector_slam:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./devel_isolated/setup.bash
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_slam_multiscan.rviz &amp;
roslaunch sick_scan sick_nav_350.launch hostname:=192.168.0.1 hostname:=127.0.0.1 udp_receiver_ip:=192.168.0.100 tf_publish_rate:=0 &amp;
roslaunch sick_scan test_200_slam_ros1_hector.launch scan_topic:=/sick_picoscan/scan_fullframe scan_layer_0_frame_id:=world_1 cloud_frame_id:=world &amp;

</code></pre></div></div>
<p>Replace ip address <code class="language-plaintext highlighter-rouge">192.168.0.100</code> with the ip address of your local machine running sick_scan_xd.</p>

<p>The following rviz screenshot shows an example of a picoScan100 point cloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/slam_example_ros1_picoscan.png" alt="slam_example_ros1_picoscan.png"></p>

<h3 id="mrs1104-slam-support">MRS1104 SLAM support</h3>

<p>MRS1104 provides 4 layers covering elevation angles at -2.5°, 0.0°, 2.5° and 5.0°. The layer with 0.0° is used for SLAM by default. The following rviz screenshot shows an example of a MRS1104 point cloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/slam_example_ros1_mrs1104.png" alt="slam_example_ros1_mrs1104.png"></p>

<p>Since Hector-Slam expects only one laser scan frame with a unique identifier for the laser scans, the following parameters were added to the driver.</p>

<p>slam_echo: The name of the echo is entered here, which is filtered out of all possible 12 echoes. This should be “laser_POS_000_DIST1”. This exports the first hit in the position with an elevation angle of 0°. If you want to use the layers with elevation angles -2.5°, 2.5° and 5.0°, you can set another flag with the name slam_bundle to True. If this flag is set, the oblique distances are multiplied by the cosine in this direction to obtain the projection onto the XY plane. This quadruples the number of points and increases the scan rate from 12.5 Hz to 50 Hz. However, for oblique impact surfaces (i.e. no vertical walls) this method can lead to larger estimation errors. In this case slam_bundle should be set to false.</p>

<h3 id="google-cartographer">Google Cartographer</h3>

<p>The support of Google Cartographer was made possible by a number of extensions to the driver. On the driver side, the MRS1104 is prepared to support the Google Cartographer. The Google Cartographer expects data packets at a high recording density (several hundred packets per second) to perform the SLAM algorithm. For this reason, an option has been introduced that allows the scans to be chopped into small angular ranges. The time stamps for these small ranges were converted accordingly.</p>

<p>Setup Google Cartographer (these steps are for illustration only, you must adapt these lines to your local directory names)</p>

<ol>
  <li>Login to Ubuntu.</li>
  <li>Open multiple terminals.</li>
  <li>Terminal 1:
. ros1_start.sh
roscore</li>
  <li>Terminal 2:
  . ros1_start.sh
cd ~/ros_catkin_ws
source ./devel/setup.bash</li>
  <li>Terminal 3:
roslaunch sick_scan_xd sick_mrs_1xxx_cartographer.launch cloud_topic:=horizontal_laser_3d frame_id:=horizontal_vlp16_link</li>
  <li>Terminal 4:
roslaunch sick_scan_xd sick_tim_5xx.launch cloud_topic:=vertical_laser_3d frame_id:=vertical_vlp16_link hostname:=192.168.0.71</li>
  <li>
    <p>Terminal 5:</p>

    <ul>
      <li>. ros1_start.sh</li>
      <li>cd ~/ros_cartographer_ws</li>
      <li>source ./install_isolated/setup.bash</li>
      <li>catkin_make_isolated</li>
      <li>roslaunch cartographer_ros live_demo_backpack_3d.launch</li>
    </ul>
  </li>
</ol>

<p><strong>Example output</strong></p>

<p>The following figure shows an example of an outdoor slam result using a MRS1104:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/slam_example.png" alt="slam_example"></p>

<h3 id="octomap">OctoMap</h3>

<p><a href="https://github.com/OctoMap">OctoMap</a> models a 3D occupancy map. The octomap_server builds and distributes volumetric 3D occupancy maps from a 3D point cloud. Tutorials and examples can be found e.g. in <a href="https://www.arminhornung.de/Research/pub/hornung13roscon.pdf">3D Mapping with OctoMap</a>, <a href="https://github.com/tejalbarnwal/octomap_tutorial">octomap_tutorial</a> and <a href="https://www.youtube.com/watch?v=dF2mlKJqkUg">Basic usage of octomap_mapping</a>. Note that OctoMap is not a fully SLAM algorithm, but it can create 2D and 3D maps from point clouds.</p>

<p>Run the following steps to build and run OctoMap and sick_scan_xd with a multiScan100 lidar on ROS 1:</p>
<ol>
  <li>Clone OctoMap + sick_scan_xd:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone https://github.com/SICKAG/sick_scan_xd.git
    git clone https://github.com/OctoMap/octomap_ros.git
    git clone https://github.com/OctoMap/octomap_msgs.git
    git clone https://github.com/OctoMap/octomap_mapping.git
    popd
    
</code></pre></div></div>
<ol>
  <li>Set topic and frame_id for multiScan100 in octomap_mapping.launch:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="frame_id" type="string" value="world" /&gt;
    &lt;remap from="cloud_in" to="/cloud_unstructured_fullframe" /&gt;
    
</code></pre></div></div>
<ol>
  <li>Build:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
    
</code></pre></div></div>
<ol>
  <li>Run OctoMap + sick_scan_xd:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Run sick_scan_xd + multiScan100
    roslaunch sick_scan_xd sick_multiscan.launch hostname:="192.168.0.1" udp_receiver_ip:=" 192.168.0.100"
    # Run octomap_server
    roslaunch octomap_server octomap_mapping.launch
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Replace parameter "hostname" with the ip address of the multiScan100 lidar and "udp_receiver_ip" with the ip address of the PC running sick_scan_xd. 5. Visualize OctoMap with rviz:
* Add MarkerArray topic "/occupied_cells_vis_array“ (colored voxels)
* Add Map topic "/projected_map“ (gray 2D Projection) 6. Save the OctoMap:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rosrun octomap_server octomap_saver -f ./octomap_multiscan.bt
    
</code></pre></div></div>
<ol>
  <li>Publish the saved OctoMap:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rosrun octomap_server octomap_server_node ./octomap_multiscan.bt
    
</code></pre></div></div>
<p>The following screenshot shows an example of an octomap created from a multiScan100 point cloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/octomap_example_ros1_multiscan.png" alt="octomap_example_ros1_multiscan"></p>

<h3 id="rtab-map">RTAB-Map</h3>

<p><a href="https://introlab.github.io/rtabmap/">RTAB-Map</a> (Real-Time Appearance-Based Mapping) is a RGB-D, Stereo and Lidar Graph-Based SLAM approach, which can be used for 3D-SLAM in combination with multiScan100 or other SICK lidars. sick_scan_xd provides a 3D-SLAM example using RTAB-Map with the multiScan100 lidar. The following section describes how to install and run RTAB-Map with sick_scan_xd and a multiScan.</p>

<h4 id="install-on-ros-1">Install on ROS 1</h4>

<p>Run the following steps to build rtabmap and sick_scan_xd with on ROS 1:</p>

<ol>
  <li>Build the prerequisites for RTAB-Map:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo apt-get install libboost-all-dev
    sudo apt-get install libeigen3-dev
    sudo apt-get install libsdl-image1.2-dev
    sudo apt-get install libsdl-dev
    sudo apt-get install ros-noetic-nav-msgs
    sudo apt-get install ros-noetic-tf2-sensor-msgs
    sudo apt-get install ros-noetic-imu-filter-madgwick
    sudo apt-get install python3-wstool
    sudo apt-get install ros-noetic-scan-tools
    pushd /tmp
    mkdir -p libnabo/build &amp;&amp; pushd libnabo/build
    cmake ..
    cmake --build .
    sudo cmake --build . --target install
    popd
    mkdir -p libpointmatcher/build &amp;&amp; pushd libpointmatcher/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    mkdir -p rtabmap/build &amp;&amp; pushd rtabmap/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    popd
    
</code></pre></div></div>
<ol>
  <li>Build RTAB-Map and sick_scan_xd in your workspace:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone https://github.com/ros-planning/navigation.git
    git clone https://github.com/ros-planning/navigation_msgs.git
    git clone https://github.com/introlab/rtabmap_ros.git
    git clone https://github.com/SICKAG/sick_scan_xd.git
    popd
    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
    sudo ldconfig
    
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">sudo ldconfig</code> if you encounter errors while loading shared libraries.</p>

<p>Note that building rtabmap with libpointermatch is highly recommended.</p>

<h4 id="run-rtab-map-and-multiscan100-on-ros-1">Run RTAB-MAP and multiScan100 on ROS 1</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan_rtabmap.launch">sick_multiscan_rtabmap.launch</a> provides a launch file to run 3D-SLAM using rtabmap and sick_scan_xd with a multiScan100 lidar. The SLAM parameters are just examples taken from <a href="https://github.com/introlab/rtabmap_ros/blob/master/rtabmap_examples/launch/test_ouster.launch">rtabmap_examples/launch/test_ouster.launch</a>. Run <code class="language-plaintext highlighter-rouge">rosrun rtabmap_slam rtabmap --params</code> to see all RTAB-Map options, parameters and their meaning and adopt launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan_rtabmap.launch">sick_multiscan_rtabmap.launch</a> if required.</p>

<p>Run the following command to start rtabmap and sick_scan_xd with a multiScan100 lidar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install_isolated/setup.bash
roslaunch sick_scan_xd sick_multiscan_rtabmap.launch hostname:="191.168.0.1" udp_receiver_ip:=" 191.168.0.100"

</code></pre></div></div>
<p>Replace parameter “hostname” with the ip address of the multiScan100 lidar and “udp_receiver_ip” with the ip address of the PC running sick_scan_xd. The following screenshot shows an example of RTAB-MAP and a multiScan100 point cloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/rtabmap_example_ros1_multiscan.png" alt="rtabmap_example_ros1_multiscan"></p>

<p>To visualize SLAM results, add e.g. topics <code class="language-plaintext highlighter-rouge">/rtabmap/grid_map</code>, <code class="language-plaintext highlighter-rouge">/rtabmap/localization_pose</code> and <code class="language-plaintext highlighter-rouge">/rtabmap/odom</code> in rviz.</p>

<p>rtabmap provides services to switch to mapping or localization mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /rtabmap/resume                # resume after pause
rosservice call /rtabmap/trigger_new_map       # start a new map
rosservice call /rtabmap/set_mode_mapping      # set mapping mode
rosservice call /rtabmap/set_mode_localization # set localization mode

</code></pre></div></div>

<p>Alternatively, you can use the options in rtabmap-viz:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/rtabmap_viz_options.png" alt="rtabmap_viz_options"></p>

<h4 id="install-on-ros-2">Install on ROS 2</h4>

<p>Building rtabmap and sick_scan_xd on ROS 2 is similar to ROS 1. Run the following steps to build rtabmap and sick_scan_xd with on ROS 2:</p>

<ol>
  <li>Build the prerequisites for RTAB-Map:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo apt-get install libboost-all-dev
    sudo apt-get install libeigen3-dev
    sudo apt-get install libsdl-image1.2-dev
    sudo apt-get install libsdl1.2-dev
    sudo apt-get install ros-humble-nav-msgs
    sudo apt-get install ros-humble-tf2-sensor-msgs
    sudo apt-get install ros-humble-imu-filter-madgwick
    sudo apt-get install python3-wstool
    sudo apt-get install ros-humble-scan-tools
    sudo apt install ros-humble-pcl-ros
    pushd /tmp
    git clone https://github.com/introlab/rtabmap.git rtabmap
    git clone https://github.com/ethz-asl/libnabo.git libnabo
    git clone https://github.com/ethz-asl/libpointmatcher.git libpointmatcher
    mkdir -p libnabo/build &amp;&amp; pushd libnabo/build
    cmake ..
    cmake --build .
    sudo cmake --build . --target install
    popd
    mkdir -p libpointmatcher/build &amp;&amp; pushd libpointmatcher/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    mkdir -p rtabmap/build &amp;&amp; pushd rtabmap/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    popd
    
</code></pre></div></div>
<ol>
  <li>Build RTAB-Map and sick_scan_xd in your workspace:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone --branch ros2 https://github.com/introlab/rtabmap_ros.git rtabmap_ros
    git clone https://github.com/SICKAG/sick_scan_xd.git
    popd
    rosdep update &amp;&amp; rosdep install --from-paths src --ignore-src -r -y
    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    colcon build --symlink-install --cmake-args " -DROS_VERSION=2" " -DCMAKE_ENABLE_EMULATOR=1" "-DCMAKE_BUILD_TYPE=Release" --event-handlers console_direct+
    sudo ldconfig
    
</code></pre></div></div>

<h4 id="run-rtab-map-and-multiscan100-on-ros-2">Run RTAB-MAP and multiScan100 on ROS 2</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan_rtabmap.launch.py">sick_multiscan_rtabmap.launch.py</a> provides a launch file to run 3D-SLAM using rtabmap and sick_scan_xd with a multiScan100 lidar. The SLAM parameters are examples taken from <a href="https://github.com/introlab/rtabmap_ros/blob/master/rtabmap_examples/launch/test_ouster.launch">rtabmap_examples/launch/test_ouster.launch</a>.</p>

<p>Run the following command to start rtabmap and sick_scan_xd with a multiScan100 lidar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
ros2 launch sick_scan_xd sick_multiscan_rtabmap.launch.py hostname:="191.168.0.1" udp_receiver_ip:=" 191.168.0.100"

</code></pre></div></div>
<p>Replace parameter “hostname” with the ip address of the multiScan100 lidar and “udp_receiver_ip” with the ip address of the PC running sick_scan_xd.</p>

<p>rtabmap provides services to switch to mapping or localization mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /rtabmap/resume std_srvs/srv/Empty                # resume after pause
ros2 service call /rtabmap/trigger_new_map std_srvs/srv/Empty       # start a new map
ros2 service call /rtabmap/set_mode_mapping std_srvs/srv/Empty      # set mapping mode
ros2 service call /rtabmap/set_mode_localization std_srvs/srv/Empty # set localization mode

</code></pre></div></div>

<h2 id="raspberry-pi-support">Raspberry Pi Support</h2>

<p>sick_scan_xd supports Linux on Raspberry Pi 4. Follow the build instructions for Linux to run sick_scan_xd on a Raspberry:</p>
<ul>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-generic-without-ros">Build on Linux generic without ROS</a></li>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-ros-1">Build on Linux ROS 1</a></li>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-ros-2">Build on Linux ROS 2</a></li>
</ul>

<p>Cmake option “ -DRASPBERRY=1” activates compiler settings for the Raspberry. Laserscan messages and polar pointclouds are not published on the Raspberry due to performance reasons.</p>

<h3 id="multiscan100-example">multiScan100 example</h3>

<p>The following screenshot shows sick_scan_xd running under ROS 1 on a Raspberry Pi 4 connected to a multiScan100 lidar. A Linux-PC uses rviz to display the fullframe point cloud generated on the Raspberry. The ssh-terminal shows the sick_scan_xd log messages on the Raspberry:
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/raspberry-perftest-04.png" alt="screenshot raspberry performance test"></p>

<p>On a Raspberry Pi 4, sick_scan_xd processes 240 messages/second with a mean latency of 2.7 milliseconds/message.</p>

<h3 id="performance">Performance</h3>

<p>Due to the low power consumption of a Raspberry Pi, performance is critical for applications using sick_scan_xd, especially for multiScan100 lidars.</p>

<p>Symptoms for performance problems can be e.g.:</p>
<ul>
  <li>sick_scan_xd reports the loss of UDP packets or message drops</li>
  <li>sick_scan_xd does not publish the fullframe pointcloud</li>
  <li>rviz shows flickering segment pointclouds even with increased decay time</li>
  <li>low frequency of segment or fullframe pointcloud messages</li>
  <li>generally high system load</li>
</ul>

<p>Performance problems can have very different reasons. Notes to help with the elimination of performance issues:</p>

<ol>
  <li>
    <p>Use the latest Raspberry Pi 4. Previous Raspberry Pi models may work with sick_scan_xd, but are not supported officially.</p>
  </li>
  <li>
    <p>Eliminate multiple echos. For most lidars, the echo filter is activated by default and only the last echo is transmitted. Check the launch file configuration and set parameter <code class="language-plaintext highlighter-rouge">filter_echos</code> if not yet done:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="filter_echos" type="int" value="2"/&gt; &lt;!-- FREchoFilter settings: 0: first echo, 1: all echos, 2: last echo --&gt;
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For multican lidars, the echo filter is activated in the launch file by parameter `host_FREchoFilter`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="host_FREchoFilter" type="int" value="2" /&gt;          &lt;!-- Optionally set FREchoFilter with 0 for FIRST_ECHO (default, EchoCount=1), 1 for ALL_ECHOS (EchoCount=3), or 2 for LAST_ECHO (EchoCount=1) --&gt;
    &lt;param name="host_set_FREchoFilter" type="bool" value="True" /&gt;  &lt;!-- If true, FREchoFilter is set at startup (default: false) --&gt;
    
</code></pre></div></div>

<ol>
  <li>Run a basic performance test on ROS 2 using a tiny sopas test server and a udp player to emulate a multiscan:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Start multiScan100 emulator (sopas test server)
    python3 ./src/sick_scan_xd/test/python/multiscan_sopas_test_server.py --tcp_port=2111 --cola_binary=0 &amp;
    # Start rviz
    ros2 run rviz2 rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_cfg_multiscan_emu_360_perftest.rviz &amp;
    sleep 1
    # Start sick_generic_caller with sick_scansegment_xd
    ros2 launch sick_scan sick_multiscan.launch.py hostname:=127.0.0.1 udp_receiver_ip:="127.0.0.1" &amp;
    sleep 3
    # Play udp packets to emulate multiScan
    python3 ./src/sick_scan_xd/test/python/multiscan_perftest_player.py --udp_port=2115 --repeat=100 --send_rate=100 --verbose=0 --prompt=0
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The result should look like the follwing screenshot:
![screenshot raspberry performance test](doc/screenshots/raspberry-perftest-01.png)
If you otherwise observe the loss of UDP packets, message drops, missing pointclouds or mean latency times significantly higher than 6 milliseconds/message, check the system load of your Raspberry and try to eliminate cpu or network intensive processes.
</code></pre></div></div>

<ol>
  <li>Start sick_scan and the sopas test server on the Raspberry as above, but run the udp player <code class="language-plaintext highlighter-rouge">multiscan_perftest_player.py</code> on another PC in your local subnet, e.g.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    python3 multiscan_perftest_player.py --dst_ip=192.168.1.27 --udp_port=2115 --repeat=1000 --send_rate=0 --force_delay=3.0e-3 --verbose=0 --prompt=0
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Replace the example ip adress `192.168.1.27` by the ip adress of your Raspberry. The result should look like the follwing screenshot:
![screenshot raspberry performance test](doc/screenshots/raspberry-perftest-02.png)
If you otherwise observe the loss of UDP packets, message drops, missing pointclouds or mean latency times significantly higher than 6 milliseconds/message, check the system load of your Raspberry and try to eliminate cpu or network intensive processes. sick_scan_xd (i.e. process sick_generic_caller) should consume ca. 80% of one core resp. cause ca. 20% of the total cpu load.
</code></pre></div></div>

<h3 id="troubleshooting">Troubleshooting</h3>

<h4 id="endianess">Endianess</h4>

<p>ARM processors support both little and big endian mode. sick_scan_xd has been tested on Raspberry Pi 4 using ROS 1 and ROS 2 on Linux in little endian mode. You can check the endianess of your system with <code class="language-plaintext highlighter-rouge">lscpu</code>.</p>

<h4 id="build-sick_scan_xd-on-a-raspberry-without-internet-or-github-access">Build sick_scan_xd on a Raspberry without internet or github access</h4>

<p>Checkout sick_scan_xd and use <code class="language-plaintext highlighter-rouge">scp -rp</code> to copy files and directories recursively from local host to a Raspberry, e.g.:</p>

<p>On your local Linux PC (Raspberry IP-address is 192.168.178.52 in this example):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p ./sick_scan_xd_raspberry_pi_pretest/src
pushd ./sick_scan_xd_raspberry_pi_pretest/src
git clone https://github.com/SICKAG/libsick_ldmrs.git
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
popd
scp -rp ./sick_scan_xd_raspberry_pi_pretest 192.168.178.52:/home/rostest/sick_scan_xd_raspberry_pi_pretest

</code></pre></div></div>

<p>On your Raspberry Pi (ROS 1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /home/rostest/sick_scan_xd_raspberry_pi_pretest
pushd ./src/sick_scan_xd/test/scripts
chmod a+x ./*.bash
./makeall_ros1.bash
popd
source ./devel_isolated/setup.bash

</code></pre></div></div>

<p>To view the pointcloud on your local Linux PC (with Raspberry IP-address is 192.168.178.52 in this example):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export ROS_MASTER_URI=http://192.168.178.52:11311/
rviz

</code></pre></div></div>

<h2 id="more-tools">More Tools</h2>

<p>Various tools exist in the repository to improve the operation of the scanners. It is also recommended to read the section <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#Troubleshooting">Troubleshooting</a>.
Overview of the tools:</p>

<ul>
  <li>Search for scanner in the network:
Use the Python3 tool “sick_generic_device_finder.py” in the tools/sick_generic_device_finder directory.
The tools will output the IP addresses of the connected scanners and some more information about the scanner.
Call it with python3, i.e.
<code class="language-plaintext highlighter-rouge">
python3 sick_generic_device_finder.py
</code>
</li>
  <li>Setting new IP address: With the help of the parameter “new_IP” a new IP address can be assigned when calling the node sick_scan_xd.
The launch file sick_new_ip.launch in the launch directory shows an example of how to use this parameter.</li>
  <li>Converting of pointclouds to images: With the tool pcl_converter.cpp one can convert pointcloud2-data
to image. That is especial convenient for 24-layers scanners like the MRS6124.</li>
  <li>Setting up a brand new scanner: To set up a brand new scanner,
it is recommended to use the two tools “sick_generic_device_finder.py” to find the scanner in the network
and the launch file sick_new_ip.launch to set a new IP address. If further settings are to be saved that cannot be made via ROS   parameters, we recommend using the Windows tool “Sopas ET” from SICK.</li>
  <li>Unit tests: For a quick unit test after installation without the sensor hardware, a test server is provided to simulate a scanner. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CONTRIBUTING.md">Simulation</a> for further details.</li>
  <li>Testing: The sick_scan_test program was developed for testing the driver. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CONTRIBUTING.md">Testing</a> for details.</li>
</ul>

<h1 id="device-specific-information">Device specific information</h1>

<h2 id="picoscan100multiscan100">picoScan100/multiScan100</h2>

<p>The multiScan100 and picoScan100 are new lidars from Sick. multiScan100 has a total of 16 lidar units rotating around a vertical axis. The rotation speed is 20 rounds per second.</p>

<p>Scan data are transmitted in msgpack or compact format over UDP.</p>

<p>multiScan100/picoScan100 lidars are supported by sick_scan_xd.
The following describes the configuration, validation and test in more detail.</p>

<h3 id="configuration">Configuration</h3>

<p>multiScan100 is configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan.launch">sick_multiscan.launch</a>.
picoScan100 is configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_picoscan.launch">sick_picoscan.launch</a>.</p>

<p>Modify file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan.launch">sick_multiscan.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_picoscan.launch">sick_picoscan.launch</a> to change configuration. Note that the ip address of the udp receiver <strong>must</strong> be configured on each system. This is the ip address of the computer running sick_scan_xd.</p>

<p>The ip address of the lidar and the udp receiver can be configured in the launch file by e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;arg name="hostname" default="192.168.0.1"/&gt;
&lt;arg name="udp_receiver_ip" default="192.168.0.100"/&gt;

</code></pre></div></div>
<p>or by command line by e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Run sick_scansegment_xd generic without ROS:
sick_generic_caller ./launch/sick_multiscan.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100
# Run sick_scansegment_xd on ROS 1:
roslaunch sick_scan_xd sick_multiscan.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100
# Run sick_scansegment_xd on ROS 2:
ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100

</code></pre></div></div>

<h3 id="imu-support-1">IMU support</h3>

<p>IMU support for multiScan100 and picoScan100 is enabled by default and can be configured in the launchfile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="imu_enable" type="bool" value="True"/&gt;  &lt;!-- Enable inertial measurement unit IMU, compact format only --&gt;
&lt;param name="imu_udp_port" type="int" value="7503"/&gt; &lt;!-- udp port for multiScan100 imu data (if imu_enable is true) --&gt;
&lt;param name="imu_topic" type="string" value="imu"/&gt;  &lt;!-- topic of ros IMU messages --&gt;

</code></pre></div></div>

<p>sick_scan_xd receives IMU data by UDP and publishes <a href="https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/Imu.html">ROS 1 sensor_msgs/Imu</a> resp. <a href="https://docs.ros2.org/latest/api/sensor_msgs/msg/Imu.html">ROS 2 sensor_msgs/msg/Imu</a> messages.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> IMU support requires compact format, which is the default. If msgpack communication is configured, imu support is automatically disabled.</p>
</blockquote>

<p>IMU support for picoScan100 requires firmware version 1.1 or newer, see https://www.sick.com/de/en/downloads/media/swp680096 for firmware downloads.</p>

<h3 id="sopas-support">SOPAS support</h3>

<p>On ROS 1 and ROS 2, service <code class="language-plaintext highlighter-rouge">ColaMsg</code> is provided to send CoLa commands to the lidar. Using this service, filters can be applied during runtime.</p>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#sopas-support-for-sick_scan_segment_xd">See</a> here for examples.</p>

<p>See the manual for further information of filter settings and parameter.</p>

<p>The driver sends the following SOPAS start and stop sequence at program start resp. exit (example with default ip address 192.168.0.1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Prerequirement: measurement is active, but no UDP data is sent
// Start sending scan data output
sMN SetAccessMode 3 F4724744  // set authorization level for writing settings
sWN ScanDataEthSettings 1 +192 +168 +0 +1 +2115  // configure destination scan data output destination to 192.168.0.52 port 2115
sWN ScanDataFormat 1   // set scan data output format to MSGPACK
sWN ScanDataPreformatting 1 // for multiscan136 only
sWN ScanDataEnable 1   // enable scan data ouput
sMN LMCstartmeas       // start measurement
sMN Run                // apply the settings and logout
// ...
// UDP data is sent
// ...
// Stop sending scan data output
sMN SetAccessMode   3 F4724744   // set authorization level for writing settings
sWN ScanDataEnable 0   // disable scan data output
sMN Run   // apply the settings and logout
// No UDP data is sent anymore

</code></pre></div></div>

<h3 id="run-multiscan100-and-picoscan100-simultaneously">Run multiScan100 and picoScan100 simultaneously</h3>

<p>The following example shows a multiScan100 and a picoScan100 device running simultaneously on ROS 1. The ip address of the multiScan100 is <code class="language-plaintext highlighter-rouge">192.168.0.1</code> (default), the ip address of the picoScan100 has been set to <code class="language-plaintext highlighter-rouge">192.168.0.2</code>. The Linux-PC running sick_scan_xd uses ip address <code class="language-plaintext highlighter-rouge">192.168.0.100</code>. <code class="language-plaintext highlighter-rouge">fping -a -q -g 192.168.0.0/24</code> shows all available devices in subnet <code class="language-plaintext highlighter-rouge">192.168.0.x</code>:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_01.png" alt="multiple_lidars_01.png"></p>

<table>
  <thead>
    <tr>
      <th>device</th>
      <th>ip</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>192.168.0.1</td>
      <td>multiScan100</td>
    </tr>
    <tr>
      <td>192.168.0.2</td>
      <td>picoScan100</td>
    </tr>
    <tr>
      <td>192.168.0.100</td>
      <td>Linux-PC</td>
    </tr>
  </tbody>
</table>

<p>Open 192.168.0.1 and 192.168.0.2 in a browser to view the network settings with SOPAS Air:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_02.png" alt="multiple_lidars_02.png"></p>

<p>The frame ids and ros topics of both lidars should be configured differently. Copy both launchfiles (sick_multiscan.launch and sick_piocscan.launch in this example) e.g. to lidar1.launch and lidar2.launch and replace ros topics and frame ids, e.g.
    * replace all “topic=/cloud_” by “topic=/cloud1<em>” in lidar1.launch
    * replace all “topic=/cloud</em>” by “topic=/cloud2_” in lidar2.launch
    * replace all “frameid=world” by “frameid=world1” in lidar1.launch
    * replace all “frameid=world” by “frameid=world2” in lidar2.launch</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_03.png" alt="multiple_lidars_03.png"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_04.png" alt="multiple_lidars_04.png"></p>

<p>Provide the launchfiles with <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1</code>.</p>

<p>Then launch sick_scan_xd twice with two different launchfiles, ip addresses, node names, udp ports, topic and frame ids.</p>

<p>Example:</p>

<p>`
roslaunch sick_scan_xd lidar1.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100 nodename:=lidar1 udp_port:=2115 imu_udp_port:=7503 publish_frame_id:=world1 publish_laserscan_segment_topic:=scan1_segment publish_laserscan_fullframe_topic:=scan1_fullframe imu_topic:=imu1 &amp;
`</p>

<p>`
roslaunch sick_scan_xd lidar2.launch hostname:=192.168.0.2 udp_receiver_ip:=192.168.0.100 nodename:=lidar2 udp_port:=2116 imu_udp_port:=7504 publish_frame_id:=world2 publish_laserscan_segment_topic:=scan2_segment publish_laserscan_fullframe_topic:=scan2_fullframe imu_topic:=imu2 &amp;
`</p>

<p>Rviz shows the point clouds of both lidars running simultaneously, with frame id <code class="language-plaintext highlighter-rouge">world1</code> for lidar1 (multiScan) and frame id <code class="language-plaintext highlighter-rouge">world2</code> for lidar2 (picoScan):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_05.png" alt="multiple_lidars_05.png"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_06.png" alt="multiple_lidars_06.png"></p>

<p>If the 6D poses of the lidars are known, their coordinates can be transformed to a common frame by a static_transform_publisher. Example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun tf static_transform_publisher 0 0 0 0 0 0 world world1 100 &amp;
rosrun tf static_transform_publisher 0 0 0 0 0 0 world world2 100 &amp;

</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_07.png" alt="multiple_lidars_07.png"></p>

<p>The big purple dots show the picoScan100 pointcloud, the other points are the multiScan100 point clouds. Both are transformed to the common frame id <code class="language-plaintext highlighter-rouge">world</code>. Note that both point clouds do not match exactly, because the 6D poses are just assumed to be (x=0, y=0, z=0, yaw=0, pitch=0, roll=0) in this example.</p>

<h3 id="visualization">Visualization</h3>

<p>The multiScan100 and picoScan100 scans can be visualized by rviz. The following screenshots show two examples of a multiScan100 pointcloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/20210929-tokenized-msgpacks-emulator-rviz.png" alt="msgpacks-emulator-rviz">
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/20210929-tokenized-msgpacks-multiScan-rviz.png" alt="msgpacks-emulator-rviz"></p>

<p>Note that sick_scan_xd publishes 2 pointclouds:</p>
<ul>
  <li>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud</code> is published for each scan segment.</li>
  <li>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_fullframe</code> collects all segments for a complete 360 degree full scan (360 degree for multiScan100, 276 degree for picoscan100).</li>
</ul>

<p>Pointcloud callbacks defined in the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#generic-driver-api">API</a> are called the same way: A callback registered with SickScanApiRegisterPolarPointCloudMsg is called</p>
<ul>
  <li>with a segment_idx &gt;= 0 for each scan segment, and</li>
  <li>with segment_idx := -1 for the complete 360 degree full scan.</li>
</ul>

<h3 id="pointcloud-memory-layout">PointCloud memory layout</h3>

<p>The Multiscan136 scans with 12 segments and 16 layer. For test, development and debugging, knowledge the internal memory layout of the pointclouds can be helpful.</p>

<p>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_unstructured_segments</code> (topic <code class="language-plaintext highlighter-rouge">/cloud</code> for sick_scan_xd version 2.10 or earlier) is published for each scan segment. Each pointcloud concatenates the layer of that segment. Each layer concatenates the points of that layer and segment. Each point concatenates the cartesian position (x, y, z) and the intensity i of a scan point. Each value of a point (x, y, z, i) is represented by a 4 byte float value. The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_unstructured_fullframe</code> (topic <code class="language-plaintext highlighter-rouge">/cloud_fullframe</code> for sick_scan_xd version 2.10 or earlier) collects all segments of a complete 360 degree full scan. Therefore, a total of 13 cartesian pointclouds are published for a 360 degree full scan:</p>

<ul>
  <li>
    <p>12 segment pointclouds. Each segment pointcloud concatenates the points of each layer in this segment in a flat memory layout:<br>
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_segment_xd_01.png" alt="sick_scan_segment_xd_01.png"></p>
  </li>
  <li>
    <p>1 full scan pointcloud concatenating all 12 segments:<br>
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_segment_xd_02.png" alt="sick_scan_segment_xd_02.png"></p>
  </li>
</ul>

<p>Note that segments and layer are not sorted in ascending order. They are published in the same order as they are received from the lidar.</p>

<h3 id="customized-point-clouds">Customized point clouds</h3>

<p>Pointclouds can be customized, i.e. the fields and points can be configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan.launch">sick_multiscan.launch</a>.</p>

<p>Parameter “custom_pointclouds” lists all customized pointclouds to be published. Each pointcloud is given by its name, e.g:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="custom_pointclouds" type="string" value="cloud_unstructured_segments cloud_unstructured_fullframe cloud_polar_unstructured_segments cloud_polar_unstructured_fullframe cloud_all_fields_fullframe"/&gt;

</code></pre></div></div>
<p>This example publishes 5 types of pointclouds:</p>
<ul>
  <li>Pointcloud for each segment in cartesian coordinates (x,y,z,i), named “cloud_unstructured_segments”</li>
  <li>Pointcloud for each fullframe in cartesian coordinates (x,y,z,i), named “cloud_unstructured_fullframe”</li>
  <li>Pointcloud for each segment in polar coordinates (azimuth,elevation,range,i), named “cloud_polar_unstructured_segments”</li>
  <li>Pointcloud for each fullframe in polar coordinates (azimuth,elevation,range,i), named “cloud_polar_unstructured_fullframe”</li>
  <li>Pointcloud for each fullframe with all available fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), named “cloud_all_fields_fullframe”</li>
</ul>

<p>These 5 pointclouds are published by default.</p>

<p>The properties of the pointcloud, i.e. their fields and points, are configured by the pointcloud name, e.g. pointcloud “cloud_unstructured_segments” (i.e. the segment pointcloud in cartesian coordinates):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_unstructured_segments: cartesian coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_unstructured_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_segments frameid=world publish=1"/&gt;

</code></pre></div></div>
<p>The cloud property configuration is a list of key-value-pairs, where each key-value-pair specifies a property and its value. E.g. <code class="language-plaintext highlighter-rouge">topic=/cloud_unstructured_segments frameid=world</code> defines ros topic “/cloud_unstructured_segments” and frame id “world” for the pointcloud named “cloud_unstructured_segments”.</p>

<p>The following key-value-pairs of a customized pointcloud are currently supported:</p>

<ul>
  <li>Parameter “coordinateNotation” is an enum to configure pointcloud coordinates:
    <ul>
      <li>coordinateNotation=0: cartesian (default, pointcloud has fields x,y,z,i), identical to customized with fields=x,y,z,i</li>
      <li>coordinateNotation=1: polar (pointcloud has fields azimuth,elevation,r,i), identical to customized with fields=azimuth,elevation,range,i</li>
      <li>coordinateNotation=2: both cartesian and polar (pointcloud has fields x,y,z,azimuth,elevation,r,i), identical to customized with fields=x,y,z,azimuth,elevation,range,i</li>
      <li>coordinateNotation=3: customized pointcloud fields, i.e. the pointcloud has fields configured by parameter “fields”</li>
    </ul>
  </li>
  <li>Parameter “updateMethod” is an enum to configure fullframe pointclouds versus segmented pointcloud:
    <ul>
      <li>updateMethod=0: fullframe pointcloud (default)</li>
      <li>updateMethod=1: segmented pointcloud</li>
    </ul>
  </li>
  <li>Parameter “fields” defines the fields of the pointcloud for coordinateNotation == 3 (customized pointcloud fields), e.g.
    <ul>
      <li>fields=x,y,z,i: cartesian pointcloud</li>
      <li>fields=range,azimuth,elevation: polar pointcloud</li>
      <li>or any other combination of x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector</li>
    </ul>

    <p>These fields have the following meaning:</p>
    <ul>
      <li>field “x”: cartesian x coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “y”: cartesian y coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “z”: cartesian z coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “i”: intensity  (4 byte, float32)</li>
      <li>field “range”: polar coordinate range in meter (4 byte, float32)</li>
      <li>field “azimuth”: polar coordinate azimuth in radians  (4 byte, float32)</li>
      <li>field “elevation”: polar coordinate elevation in radians  (4 byte, float32)</li>
      <li>field “t”:  time offset in nano seconds relative to the header timestamp in the point cloud (4 byte, uint32), used by rtabmap for deskewing</li>
      <li>field “ts”: time offset in seconds relative to the header timestamp (4 byte, float32)</li>
      <li>field “lidar_sec”: uint32 seconds part of the lidar timestamp in microseconds (lidar time), lidar_sec = (uint32_t)(lidar_timestamp_microsec / 1000000)</li>
      <li>field “lidar_nsec”: uint32nano seconds part of the lidar timestamp in microseconds (lidar time), lidar_nsec = (uint32_t)(1000 * (lidar_timestamp_microsec % 1000000))</li>
      <li>field “ring”:  layer id (1 byte, int8), identical to field “layer”</li>
      <li>field “layer”: layer (group) index (4 byte, int32), 0 &lt;= layer &lt; 16 for multiScan100 (16 layer), 0 for picoScan100 (1 layer)</li>
      <li>field “echo”: echo index (4 byte, int32)</li>
      <li>field “reflector”: optional reflector bit (1 byte, uint8), 0 or 1, default: 0</li>
    </ul>
  </li>
  <li>Parameter “echos” defines which echos are included in the pointcloud, e.g.
    <ul>
      <li>echos=0,1,2: all echos</li>
      <li>echos=2: last echo
 or any other combination of 0,1,2</li>
    </ul>
  </li>
  <li>Parameter “layers” defines which echos are included in the pointcloud, e.g
    <ul>
      <li>layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 for all layers</li>
      <li>layers=5 for the 0 degree layer
 or any other combination of 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</li>
    </ul>
  </li>
  <li>Parameter “reflectors” filters the points by the reflector bit, i.e.
    <ul>
      <li>reflectors=0,1 for points with reflector bit set or not set</li>
      <li>reflectors=0 for points with reflector bit not set</li>
      <li>reflectors=1 for points with reflector bit set</li>
    </ul>
  </li>
  <li>Parameter “infringed” defines filters the points by infringement, i.e.
    <ul>
      <li>infringed=0,1 for points with infringement bit set or not set</li>
      <li>infringed=0 for points with infringement bit not set</li>
      <li>infringed=1 for points with infringement bit set
 Parameter “infringed” is currently not supported (reserved for future use)</li>
    </ul>
  </li>
  <li>
    <p>Parameter “topic” defines the ros topic, e.g. topic=/cloud_fullframe for cartesian fullframe pointclouds</p>
  </li>
  <li>
    <p>Parameter “frameid” defines the ros frame of the pointcloud, e.g. frameid=world, frameid=map or frameid=base_link</p>
  </li>
  <li>Parameter “publish” activates or deactivates the pointcloud, e.g. publish=1 to generate and publish, or publish=0 to deactivate that pointcloud</li>
</ul>

<p>To add a new pointcloud, define a pointcloud name (e.g. “cloud_layer7_cartesian”), add “cloud_layer7_cartesian” in parameter “custom_pointclouds” and specify a new parameter “cloud_layer7_cartesian” with the new cloud properties, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_layer7_cartesian: cartesian coordinates, fullframe, first echo, layer7 --&gt;
&lt;param name="cloud_layer7_cartesian" type="string" value="coordinateNotation=0 updateMethod=0 echos=0 layers=7 reflectors=0,1 infringed=0,1 topic=/cloud_layer7_cartesian frameid=world publish=1"/&gt;

</code></pre></div></div>

<p>The following pointclouds are currently predefined in launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan.launch">sick_multiscan.launch</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_unstructured_segments: cartesian coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_unstructured_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_fullframe: cartesian coordinates, fullframe, all echos, all layers, max. 32400 points, mean ca. 10000 points per cloud --&gt;
&lt;param name="cloud_unstructured_fullframe" type="string" value="coordinateNotation=0 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_fullframe frameid=world publish=1"/&gt;

&lt;!-- cloud_polar_unstructured_segments: polar coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_polar_unstructured_segments" type="string" value="coordinateNotation=1 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_polar_unstructured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_polar_unstructured_fullframe: polar coordinates, fullframe, all echos, all layers --&gt;
&lt;param name="cloud_polar_unstructured_fullframe" type="string" value="coordinateNotation=1 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_polar_unstructured_fullframe frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo1: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo1" type="string" value="coordinateNotation=0 updateMethod=0 echos=0 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo1 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo1_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo1_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo1_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo2: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo2" type="string" value="coordinateNotation=0 updateMethod=0 echos=1 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo2 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo2_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo2_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=1 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo2_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo3: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo3" type="string" value="coordinateNotation=0 updateMethod=0 echos=2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo3 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo3_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo3_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_echo3_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_reflector: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_reflector" type="string" value="coordinateNotation=0 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_reflector frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_reflector_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_reflector_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_reflector_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires0: cartesian and polar coordinates, fullframe, all echos, high resolution layer 5, fields=x,y,z,i,range,azimuth,elevation, 12*2880x3=103680 points per cloud --&gt;
&lt;param name="cloud_structured_hires0" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=5 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires0 frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires0_segments: cartesian and polar coordinates, segments, all echos, high resolution layer 5, fields=x,y,z,i,range,azimuth,elevation, 2880x3=8640 points per cloud --&gt;
&lt;param name="cloud_structured_hires0_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=5 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires0_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires1: cartesian and polar coordinates, fullframe, all echos, high resolution layer 13, fields=x,y,z,i,range,azimuth,elevation, 12*2880x3=103680 points per cloud --&gt;
&lt;param name="cloud_structured_hires1" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=13 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires1 frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires1_segments: cartesian and polar coordinates, segments, all echos, high resolution layer 13, fields=x,y,z,i,range,azimuth,elevation, 2880x3=8640 points per cloud --&gt;
&lt;param name="cloud_structured_hires1_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=13 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires1_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured: cartesian and polar coordinates, fullframe, all echos, low resolution layers 0,1,2,3,4,6,7,8,9,10,11,12,14,15, fields=x,y,z,i,range,azimuth,elevation, 12*360*14*3=181440 points per cloud --&gt;
&lt;param name="cloud_structured" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=0,1,2,3,4,6,7,8,9,10,11,12,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_structured frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_segments: cartesian and polar coordinates, segments, all echos, low resolution layers 0,1,2,3,4,6,7,8,9,10,11,12,14,15, fields=x,y,z,i,range,azimuth,elevation, 360*14*3=15120 points per cloud --&gt;
&lt;param name="cloud_structured_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=0,1,2,3,4,6,7,8,9,10,11,12,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_structured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_all_fields_segments: all fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), segments, all echos, all layers --&gt;
&lt;param name="cloud_all_fields_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_all_fields_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_all_fields_fullframe: all fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), fullframe, all echos, all layers --&gt;
&lt;param name="cloud_all_fields_fullframe" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_all_fields_fullframe frameid=world publish=1"/&gt;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  The sick_scan_xd API callback functions <code class="language-plaintext highlighter-rouge">SickScanApiRegisterCartesianPointCloudMsg</code> and <code class="language-plaintext highlighter-rouge">SickScanApiRegisterPolarPointCloudMsg</code> provide cartesian and polar pointclouds, i.e. pointclouds configured with <code class="language-plaintext highlighter-rouge">coordinateNotation=0</code> (cartesian) or <code class="language-plaintext highlighter-rouge">coordinateNotation=1</code> (polar). Pointclouds with <code class="language-plaintext highlighter-rouge">coordinateNotation=2</code> (cartesian + polar) or <code class="language-plaintext highlighter-rouge">coordinateNotation=3</code> (customized fields) are currently not supported by the generic API.</p>
</blockquote>

<h3 id="customized-point-clouds-on-a-raspberry-pi">Customized point clouds on a Raspberry Pi</h3>

<p>Performance is critical on a Raspberry. To reduce the cpu load, you may restrict the number of pointclouds to the minimum required for your application. E.g. if you just need the cartesian fullframe pointcloud, you can use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="custom_pointclouds" type="string" value="cloud_unstructured_fullframe"/&gt;

</code></pre></div></div>
<p>to decrease the cpu usage.</p>

<h3 id="msgpack-validation">MSGPACK validation</h3>

<p>A msgpack validation can be activated. This validation checks</p>
<ol>
  <li>each incoming msgpack for scan data out of the expected values, and</li>
  <li>missing scandata after collecting the msgpack data for a full scan (360 degree for multiScan100, 276 degree for picoScan100)</li>
</ol>

<p>If a msgpack contains scan data out of expected values, the msgpack is discarded and an error message is printed. This should not happen in normal operation mode. If scan data are missing after a full 360 degree scan, an error message is printed. This might happen in case of udp packet drops.</p>

<p>By default, the full range of scan data is expected, i.e. all echos, all segments, all layers and azimuth values covering -180 up to +180 degree. If filters are activated (echo-, layer- or angle-range-filter to reduce network traffic), the msgpack validation should currently be deactivated or configured thoroughly to avoid error messages. In the next release, the filter configuration is queried from  multiScan136 Beta and validation settings are adopted to the multiScan136 Beta filter settings.</p>

<p>The msgpack validation is configured in file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan.launch">sick_multiscan.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_picoscan.launch">sick_picoscan.launch</a>. To activate or deactivate msgpack validation, set <code class="language-plaintext highlighter-rouge">msgpack_validator_enabled</code> to True (activated) resp. False (deactivated).</p>

<p>Msgpack validation leads to error messages in case of udp packet drops. Increase the value <code class="language-plaintext highlighter-rouge">msgpack_validator_check_missing_scandata_interval</code> to tolerate udp packet drops. Higher values increase the number of msgpacks collected for verification.</p>

<h3 id="firewall-configuration">Firewall configuration</h3>

<p>By default, UDP communication is allowed on localhosts. To enable udp communication between 2 different machines, firewalls have to be configured.</p>

<p>On Windows: Setup the windows firewall to allow sick_scan_xd to receive udp packages on port 2115.
To pass udp packages from a remote sender, the default rule for incoming udp packages has to be configured in the windows firewall:</p>
<ol>
  <li>Run “wf.msc” as admin,</li>
  <li>Click Inbound Rules and locate the rule(s) for lidar3d_msr100_recv (resp. python to allow python test scripts), and</li>
  <li>Deactivate the UDP-rule for this process(es) or configure exceptions for remote computers.</li>
  <li>Alternatively, you can create a new rule allowing udp communication on port 2115.</li>
</ol>

<p>On Linux: Run the following commands to allow any udp communication on port 2115:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo iptables -A INPUT -p udp -m udp --dport 2115 -j ACCEPT
sudo iptables -A OUTPUT -p udp -m udp --sport 2115 -j ACCEPT
sudo iptables-save

</code></pre></div></div>
<p>Alternatively, you can also use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ufw allow from any to any port 2115 proto udp

</code></pre></div></div>
<p>to allow all udp traffic on port 2115.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  If Linux or Windows is running in a virtual machine, make sure UDP port 2115 is forwarded. With VMware Workstation Pro, you can configure port forwarding
using the Virtual Network Editor. Udp echos, delays, drops and other unexpected errors might occur when more than one network card is configured in VMware.
Make sure you have only one network adapter activated with custom NAT:</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/vmware_network_settings.png" alt="vmware_network_settings"></p>

<h3 id="sopas-support-for-sick_scan_segment_xd">SOPAS support for sick_scan_segment_xd</h3>

<p>On ROS 1 and ROS 2, sick_scan_segment_xd provides ros service <code class="language-plaintext highlighter-rouge">ColaMsg</code> to send CoLa commands to the lidar. Using this service, filters can be applied to multiScan136 and picoScan150 lidars during runtime.</p>

<p>Examples on ROS 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice list
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN IsSystemReady'}"                             # response: "sAN IsSystemReady 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"                  # response: "sAN SetAccessMode 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataEthSettings 1 +127 +0 +0 +1 +2115'}" # response: "sWA ScanDataEthSettings"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataFormat 1'}"                          # response: "sWA ScanDataFormat"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataPreformatting 1'}"                   # response: "sWA ScanDataPreformatting"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataEnable 1'}"                          # response: "sWA ScanDataEnable"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN LMCstartmeas'}"                              # response: "sAN LMCstartmeas"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN Run'}"                                       # response: "sAN Run 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"                                    # response: "sAN SetAccessMode 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN FREchoFilter 1'}"                                              # response: "sWA FREchoFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1'}" # response: "sWA LFPangleRangeFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'}"            # response: "sWA LFPlayerFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN Run'}"                                                         # response: "sAN Run 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LFPlayerFilter is not supported by picoscan150.</p>
</blockquote>

<p>Examples on ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service list
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN IsSystemReady'}"                             # response: "sAN IsSystemReady 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN SetAccessMode 3 F4724744'}"                  # response: "sAN SetAccessMode 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataEthSettings 1 +127 +0 +0 +1 +2115'}" # response: "sWA ScanDataEthSettings"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataFormat 1'}"                          # response: "sWA ScanDataFormat"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataPreformatting 1'}"                   # response: "sWA ScanDataPreformatting"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataEnable 1'}"                          # response: "sWA ScanDataEnable"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN LMCstartmeas'}"                              # response: "sAN LMCstartmeas"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN Run'}"                                       # response: "sAN Run 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN SetAccessMode 3 F4724744'}"                                    # response: "sAN SetAccessMode 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN FREchoFilter 1'}"                                              # response: "sWA FREchoFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1'}" # response: "sWA LFPangleRangeFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'}"            # response: "sWA LFPlayerFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN Run'}"                                                         # response: "sAN Run 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LFPlayerFilter is not supported by picoscan150.</p>
</blockquote>

<h2 id="tim781-and-tim781s">TiM781 and TiM781S</h2>

<p>For TiM781S lidars, the initial lidar configuration can be deactivated using optional argument initialize_scanner:=0.
Note that this mode does not initialize the lidar. The mode assumes that the scanner is in an appropriate state corresponding to the properties configured in the launchfile. It is not recommended to use this option unless for specific tasks in a controlled environment.</p>

<p><strong>Do not use this mode except the lidar has been configured properly and initialized successfully and is in the same state as after initialization by the launchfile! This option is for advanced users only!</strong></p>

<p>Example: <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=192.168.0.1 initialize_scanner:=0</code></p>

<h3 id="field-evaluation-tim7xx">Field evaluation TiM7xx</h3>

<p>The field evaluation for TiM7xx lidars support two additional options to configure the active field set: FieldSetSelectionMethod and ActiveFieldSet. These options allow to set the active field set during runtime, see the operation manual for details.</p>

<p>Options FieldSetSelectionMethod and ActiveFieldSet can be configured in the launch file and by ros services “FieldSetRead” and “FieldSetWrite”.</p>

<p>Initial values for FieldSetSelectionMethod and ActiveFieldSet can be configured in the launch file, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="active_field_set" type="int" value="-1"/&gt; &lt;!-- set ActiveFieldSet at startup: -1 = do not set (default), index of active field otherwise --&gt;
&lt;param name="field_set_selection_method" type="int" value="-1"/&gt; &lt;!-- set FieldSetSelectionMethod at startup: -1 = do not set (default), 0 = active field selection by digital inputs, 1 = active field selection by telegram --&gt;

</code></pre></div></div>
<p>By default, options FieldSetSelectionMethod and ActiveFieldSet are not written by the driver, i.e. the default values apply (factory defaults or settings by SOPAS ET).</p>

<p>Example service call for ROS1 to read resp. write options FieldSetSelectionMethod and ActiveFieldSet:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/FieldSetRead "{}" # returns field_set_selection_method and active_field_set
rosservice call /sick_tim_7xx/FieldSetWrite "{field_set_selection_method_in: -1, active_field_set_in: 1}" # write active_field_set

</code></pre></div></div>
<p>Example service call for ROS1 to read resp. write options FieldSetSelectionMethod and ActiveFieldSet:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /FieldSetRead sick_scan_xd/srv/FieldSetReadSrv "{}" # returns field_set_selection_method and active_field_set
ros2 service call /FieldSetWrite sick_scan_xd/srv/FieldSetWriteSrv "{field_set_selection_method_in: -1, active_field_set_in: 1}" # write active_field_set

</code></pre></div></div>

<p>Parameter active_field_set &lt; 0: do not set (default), active_field_set &gt; 0: index of active field otherwise (see operation manual for details about ActiveFieldSet telegram)</p>

<p>Parameter field_set_selection_method &lt; 0: do not set (default), field_set_selection_method = 0: active field selection by digital inputs, field_set_selection_method = 1: active field selection by telegram</p>

<p>Note that FieldSetSelectionMethod (parameter field_set_selection_method) requires a higher authorization level and should be configured in the launch file. It is therefore recommended to set <code class="language-plaintext highlighter-rouge">field_set_selection_method_in: -1</code> when using ros service FieldSetWrite.</p>

<h2 id="tim240">TiM240</h2>

<p>The TiM240 is a new scanner that fits seamlessly into the family of other TiM devices. The TiM240 has an opening angle of 240 degrees. In contrast to the previous scanners from SICK, the coordinate system used corresponds directly to the ROS convention. For this reason, this scanner does not require a coordinate conversion of 90 degrees around the Z-axis. However, this is taken into account in the driver code, so that the user will not notice any difference in the setting of the angular ranges during use.
The angular position according to the data sheet can be taken from the drawings below.</p>

<p>The following figures show the difference between the TiM5xx family and the TiM240 device.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/tim240/tim_5xx_scanarea.jpg" alt="TiM5xx scan area"></p>

<p>TiM5xx scanning area</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/tim240/tim_240_scanarea.jpg" alt="TiM240 scan area"></p>

<p>TiM240 scanning area</p>

<h2 id="nav350">NAV350</h2>

<p>NAV350 devices are supported by sick_scan_xd since 2023. Since they support navigation and use a different communication mode, this chapter gives an overview of the NAV350 support in sick_scan_xd. Please refer to the manuals for further information.</p>

<h3 id="process-loop">Process loop</h3>

<p>Scan data, landmarks and poses of NAV350 devices are queried by SOPAS commands with polling. Therefore the sick_scan_xd process loop runs as followed:</p>

<ol>
  <li>Initialization and setup</li>
  <li>Main loop (polling):
1 . Send data request “sMN mNPOSGetData 1 2”
2 . Receive and parse response
3 . Convert and publish pointcloud, laserscan, landmarks, pose and transform
4 . API: notify listeners and run their callback functions
5 . Repeat from step 1</li>
  <li>In case of incoming odometry messages (asynchron):
1 . Convert to SOPAS command
2 . Send “sMN mNPOSSetSpeed <odom_data>" to NAV350</odom_data>
</li>
</ol>

<h3 id="initialization-and-setup">Initialization and setup</h3>

<p>After initialization, sick_scan_xd switches to navigation mode by default. Navigation requires mapping (i.e. a valid landmark layout), which can be done by</p>
<ul>
  <li>SOPAS ET (recommended), or</li>
  <li>optional mapping with parameter <code class="language-plaintext highlighter-rouge">nav_do_initial_mapping:=True</code> using the landmarks detected at start, or</li>
  <li>using an optional imk-file.</li>
</ul>

<p>Configuration and setup using SOPAS ET is most powerful and recommended.</p>

<p>The default sopas initialization sequence runs as followed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"sMN SetAccessMode 3 F4724744"     # switch to access level authorized client
"sMN mNEVAChangeState 1"           # switch to operation mode standby
"sWN NEVACurrLayer &lt;layer&gt;"        # set layer configured by launchfile
"sWN NLMDLandmarkDataFormat 0 1 1" # set result format (landmark data)
"sWN NAVScanDataFormat 1 1"        # set result format (scan data)
"sWN NPOSPoseDataFormat 1 1"       # set result format (pose data)
"sMN mNEVAChangeState 4"           # switch to navigation mode
"sMN mNPOSGetData 1 2"             # query pose, landmark and scan data

</code></pre></div></div>

<p>If optional parameter <code class="language-plaintext highlighter-rouge">nav_do_initial_mapping</code> is true, a landmark layout is initialized using the reflectors detected at startup (sopas command “sMN mNMAPDoMapping”). The sopas initialization sequence for an initial mapping runs as followed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"sMN SetAccessMode 3 F4724744"     # switch to access level authorized client
"sMN mNEVAChangeState 1"           # switch to operation mode standby
"sWN NEVACurrLayer &lt;layer&gt;"        # set layer configured by launchfile
"sWN NLMDLandmarkDataFormat 0 1 1" # set result format (landmark data)
"sWN NAVScanDataFormat 1 1"        # set result format (scan data)
"sWN NPOSPoseDataFormat 1 1"       # set result format (pose data)
"sMN mNEVAChangeState 2"           # switch to mapping mode
"sMN mNLAYEraseLayout 1"           # clear landmark layout
"sWN NMAPMapCfg ..."               # configure mapping parameter
"sWN NLMDReflSize &lt;size&gt;"          # set reflector size configured by launchfile
"sMN mNMAPDoMapping"               # detect landmarks and run mapping
"sMN mNLAYAddLandmark ..."         # add all detected landmarks to the layout
"sMN mNLAYStoreLayout"             # store landmark layout
"sMN mNEVAChangeState 4"           # switch to navigation mode
"sMN mNPOSGetData 1 2"             # query pose, landmark and scan data

</code></pre></div></div>

<p>The landmark layout stored in an imk-file can optionally loaded at startup with optional parameter. See the NAV350 manual for details about imk-files.</p>

<p>The settings are configured in launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_nav_350.launch">sick_nav_350.launch</a>.</p>

<h3 id="messages">Messages</h3>

<p>sick_scan_xd polls the NAV350 scan data, reflectors and poses in its main loop. Scan data are published by pointcloud messages (in topic “cloud” by default). Reflectors are published by type <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVLandmarkData</code> on topic “/sick_nav_350/nav_landmark” and as MarkerArray on topic “/sick_nav_350/nav_reflectors” for easy visualization using rviz. Poses are published by type <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVPoseData</code> on topic “/sick_nav_350/nav_pose” and as ros transform on topic “/tf”.</p>

<p>The following rviz-screenshot shows the pointcloud, landmarks and pose of a NAV350:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/nav350_ros1_screenshot2.jpg" alt="nav350_ros1_screenshot2.jpg"></p>

<h3 id="odometry-messages">Odometry messages</h3>

<p>Odometry messages can be sent to the NAV350 device using ROS messages <code class="language-plaintext highlighter-rouge">nav_msgs/Odometry</code> on topic “/sick_nav_350/odom” or <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVOdomVelocity</code> on topic “/sick_nav_350/nav_odom_velocity”. Odometry messages <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVOdomVelocity</code> specify the velocity (vx, vy) in m/s in lidar coordinates. Odometry messages <code class="language-plaintext highlighter-rouge">nav_msgs/Odometry</code> specify the velocity (vx, vy) in m/s in ros coordinates. The angular velocity is expected in radians/s.</p>

<p>Example odometry messages with vx = 1 m/s, vy = -1 m/s and omega: 0.5 rad/s:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic pub --rate 10 /sick_nav_350/nav_odom_velocity sick_scan_xd/NAVOdomVelocity '{vel_x: 1.0, vel_y: -1.0, omega: 0.5, timestamp: 123456789, coordbase: 0}�
rostopic pub --rate 10 /sick_nav_350/odom nav_msgs/Odometry '{twist: { twist: { linear: {x: 1.0, y: -1.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.5}}}}'

</code></pre></div></div>

<h3 id="angle-compensation">Angle compensation</h3>

<h4 id="introduction-1">Introduction</h4>

<p>For measurements with the highest demands on the accuracy of the angle measurement, the devices of the NAV series allow compensation of slight angle deviations during a rotation. The compensation is determined by the three parameters.</p>
<ul>
  <li>Additive compensation by an angle offset</li>
  <li>Sinusoidal correction by specifying the amplitude and phase of compensation</li>
</ul>

<p>The three parameters are then used to calculate the compensation as follows:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/angle_compensation/angle_compensation_000.png" alt="Formula for angle compensation"></p>

<p>Offset and phase are given in [deg]</p>

<h4 id="example">Example</h4>

<p>The information is read from lidar by using the command <code class="language-plaintext highlighter-rouge">sRN MCAngleCompSin</code>.
The answer gives one amplitude, phase and offset compensation in tens of thousands.</p>

<p>The function reads</p>
<ul>
  <li>Amplitude-Parameter: +1893</li>
  <li>Phase-Parameter: -210503</li>
  <li>Offset-Parameter: -245</li>
</ul>

<p>These corresponds to:</p>
<ul>
  <li>Amplitude-compensation: +0.1893</li>
  <li>Phase-Compensation: -21.0503 [deg]</li>
  <li>Offset-Compensation: -0.0245 [deg]</li>
</ul>

<p><strong>Compensation formula for example for NAV210/NAV245</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Angle[comp.] = Angle[Raw] - 0.189300 * sin(Angle[Raw] + -21.050300 [deg]) -  -0.024500

</code></pre></div></div>

<p><strong>Compensation formula for example for NAV310</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Angle[comp.] = Angle[Raw] + 0.189300 * sin(Angle[Raw] - -21.050300 [deg]) +  -0.024500

</code></pre></div></div>
<p><strong>Example lookup values for NAV310 for this example (first entries)</strong></p>

<table>
  <thead>
    <tr>
      <th>IN [Deg]</th>
      <th>Out [Deg]</th>
      <th>Correction [Deg]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0.000000</td>
      <td>0.043494</td>
      <td>0.043494</td>
    </tr>
    <tr>
      <td>1.000000</td>
      <td>1.046567</td>
      <td>0.046567</td>
    </tr>
    <tr>
      <td>2.000000</td>
      <td>2.049618</td>
      <td>0.049618</td>
    </tr>
    <tr>
      <td>3.000000</td>
      <td>3.052647</td>
      <td>0.052647</td>
    </tr>
    <tr>
      <td>4.000000</td>
      <td>4.055652</td>
      <td>0.055652</td>
    </tr>
    <tr>
      <td>5.000000</td>
      <td>5.058633</td>
      <td>0.058633</td>
    </tr>
    <tr>
      <td>6.000000</td>
      <td>6.061588</td>
      <td>0.061588</td>
    </tr>
    <tr>
      <td>7.000000</td>
      <td>7.064518</td>
      <td>0.064518</td>
    </tr>
    <tr>
      <td>8.000000</td>
      <td>8.067420</td>
      <td>0.067420</td>
    </tr>
    <tr>
      <td>9.000000</td>
      <td>9.070294</td>
      <td>0.070294</td>
    </tr>
    <tr>
      <td>10.000000</td>
      <td>10.073139</td>
      <td>0.073139</td>
    </tr>
  </tbody>
</table>

<h4 id="comparing-compensated-vs-raw-values">Comparing compensated vs. raw values</h4>

<p>For the example the compensation function looks like this (X-Axis: measured angle [deg], Y-Axis: compensation in [deg])</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/angle_compensation/angle_compensation_001.png" alt="Plot of compensation function (example)"></p>

<h4 id="coordinate-systems">Coordinate systems</h4>

<p>For a better understanding of the data sheets of the different lidar systems the following drawings compare the different coordinate systems. Usually the scanners rotate counter-clockwise. The scanners of the NAV3xx series rotate clockwise. All coordinate systems following the right-hand rule, if the axis definition as shown in the picture is used.
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/angle_compensation/3d_coordinate_system_comp.png" alt="Used coordinate systems"></p>

<p>By means of simple matrix operations all axis orientations can be transformed into each other. But since we are only interested in the angle around the Z-axis, the conversions can be done as follows (CS = Coordinate System):</p>

<table>
  <thead>
    <tr>
      <th>IN From</th>
      <th>Out To</th>
      <th>Operation</th>
      <th>Additional info</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ROS</td>
      <td>NAV3xx</td>
      <td>Out=-In+180°</td>
      <td>maps [-180°…180°] to [360°…0°]</td>
    </tr>
    <tr>
      <td>NAV3xx</td>
      <td>ROS</td>
      <td>Out=-In+180°</td>
      <td>maps [0°…360°] to [180°…-180°]</td>
    </tr>
    <tr>
      <td>ROS</td>
      <td>NAV2XX</td>
      <td>Out=In+90°</td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV2xx</td>
      <td>ROS</td>
      <td>Out=In-90°</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="check-compensation-function">Check compensation function</h4>

<p>By using <code class="language-plaintext highlighter-rouge">Octave</code> ones can check the compensation function against the given values by exporting the value via a testbed function.</p>

<!--
   40 a = dlmread("angle_compensation_debug.csv",';',1,0);
   41 size(a)
   42 a
   43 mean(a(:,3))
   44 a3 = a(:,3)-mean(a(:,3))
   45 mean(a3)
   46 S3 = fft(a3)
   47 plot(abs(S3))
   48 abs(S3)
   49 S3(1)
   50 S3(2)
   51 abs(S3(2))/360
   52 abs(S3(2))/360*2
   53 angle(S3(2))
   54 angle(S3(2))/pi*180
   55 angle(S3(2))/pi*180 - 90
   56 angle(S3(2))/pi*180 + 90
   57 plot(a(:,1),a(:,3))
   58 title "compensation example"
-->

<h2 id="mrs6124">MRS6124</h2>

<h3 id="timing-between-layers">Timing between Layers</h3>

<p>The layers are taken up by the scanner in packs of 6. The scanner delivers at an output data rate of 10 Hz and 24 layers 24/6*10=40 scan packets of 6 layers per second. The following table shows an example of the timing for a complete 24 layer recording</p>

<table>
  <thead>
    <tr>
      <th>Raw Time /µs</th>
      <th style="text-align: center">Delta Time /µs</th>
      <th style="text-align: right">Elevation Angle /Deg</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">13.19</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">12.565</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">11.940</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">11.315</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">10.690</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">10.065</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">9.440</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">8.815</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">8.190</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">7.565</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">6.940</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">6.315</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">5.690</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">5.065</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">4.440</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">3.815</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">3.190</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">2.565</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">1.940</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">1.315</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">0.690</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">0.065</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">-0.560</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">-1.185</td>
    </tr>
    <tr>
      <td>NEW SCAN</td>
      <td style="text-align: center"> </td>
      <td style="text-align: right"> </td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">13.190</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">12.565</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">11.940</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">11.315</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">10.690</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">10.065</td>
    </tr>
    <tr>
      <td>2551832862</td>
      <td style="text-align: center">126514</td>
      <td style="text-align: right">9.440</td>
    </tr>
  </tbody>
</table>

<p>The time stamps between the layers are interpolated by the scanner. The time stamps of the first layer (Ang.=13.19°) are measured and show jitter accordingly.</p>

<h3 id="mrs600-with-rms1000">MRS600 with RMS1000</h3>

<ol>
  <li>Setup environment and power supply</li>
  <li>roslaunch sick_scan_xd test_0002_combi_live.launch</li>
  <li>Check setup using rviz</li>
  <li>Close all applications, which are not necessary (like IDE, browser, git client)</li>
  <li>Setup Tracking algorithm</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>top

</code></pre></div></div>
<ol>
  <li>Record data</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rosbag record record -o combi -a

</code></pre></div></div>

<h2 id="rms1000">RMS1000</h2>

<p>This driver supports the radar type RMS1000. This radar records raw targets and tracking objects. The tracking objects are determined on the basis of the raw targets. Two variants of a tracking method are already installed in the radar, which enables the radar to be put into operation quickly.</p>

<p>The RMS1000 is based on FMCW radar. With frequency-modulated continuous wave radar (FMCW radar), the transmission frequency is changed periodically. Triangle functions are usually used for distance measurement. While the transmission frequency changes as linearly as possible to the target object and back during the propagation time of the signal, the signal reflected by the object and received by the radar is time-shifted to the original transmitted frequency. By mixing the transmitted signal with the received signal, the frequency shift and thus the time shift can be determined. Based on the known modulation parameters of the transmitter, the propagation time of the signal can be determined, which in turn is proportional to the distance of the object. For precise distance measurement, therefore, the transmission frequency must be modulated as precisely as possible in linear fashion, since any non-linearity impairs the distance accuracy of the radar.</p>

<p>Through this indirect time measurement via the frequency change of the transmitter, even very close targets can be measured with high accuracy and cost-efficiency using the FMCW method, provided that the modulation parameters are selected appropriately. The distance resolution is determined by the bandwidth of the transmitted signal.</p>

<h3 id="raw-targets">Raw Targets</h3>

<p>Raw targets correspond to individual reflectors that are detected by the radar. Each individual reflector carries the following information:</p>
<ul>
  <li>Range</li>
  <li>Horizontal angle (azimuth)</li>
  <li>Doppler speed</li>
  <li>Reflectivity of the target (aka rcs - radar cross section)</li>
</ul>

<p>The radar RMSxxxx does not resolve elevation angles.  Therefore, the radar assumes the elevation values (z values) with 0.0. The error in distance estimation is usually negligible and is 0.4% (1.0 - cos(5°)) at an elevation angle of 5° compared to horizontal.</p>

<h3 id="tracking-objects">Tracking Objects</h3>

<p>Tracking objects are determined from the raw targets via a tracking procedure over the spatial and temporal
distribution of the raw targets. The track method estimates the location, direction and speed of the object based on an initial estimate.  After initialization, new raw targets are assigned to the track if they “fit” to the track.  This process is called “gating”. Once these raw targets have been assigned to the track,
the track is updated and the new estimate is used for further processing.</p>

<p>The distribution of raw targets over the object also determines the object length during the tracking process.</p>

<p>The tracking object therefore has the following properties:</p>
<ul>
  <li>Distance from radar in Cartesian coordinates</li>
  <li>Direction vector in Cartesian coordinates</li>
  <li>Direction of travel as an angle in the X/Y plane</li>
  <li>Vehicle speed</li>
  <li>Vehicle length</li>
</ul>

<h3 id="ros-message-for-radar">ROS message for Radar</h3>

<p>After parsing the telegram, the driver sends an ROS message of type RadarScan. RadarScan consists of the following components:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Header header
RadarPreHeader radarPreHeader
sensor_msgs/PointCloud2 targets
sick_scan_xd/RadarObject[] objects

</code></pre></div></div>
<h4 id="radarpreheader">RadarPreHeader</h4>
<p>The radar preheader contains information that provides general information about the radar. This data record can usually be ignored for object recognition with regard to raw targets and tracking objects.
For details please refer to the message specification of Sick.</p>

<h4 id="targets">targets</h4>

<p>The list with the raw targets of type sick_scan_xd/targets contains the information about the raw targets.
Each raw target contains the following data fields in a pointcloud2-message (height: 1, width: number of raw targets):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> std::string channelRawTargetId[] = { "x", "y", "z", "vrad","amplitude" };

</code></pre></div></div>
<p>This raw target contains cartesian coordinates, which are derived from range and azimuth angle (horizontal angle) in the following way (code snippet):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valSingle[0] = rawTargetList[i].Dist() cos(angle);    // x
valSingle[1] = rawTargetList[i].Dist() * sin(angle);  // y
valSingle[2] = 0.0;                                   // z
valSingle[3] = rawTargetList[i].Vrad();               // vrad
valSingle[4] = rawTargetList[i].Ampl();               // amplitude

</code></pre></div></div>

<h4 id="objects">objects</h4>

<p>The list with the objects of type sick_scan_xd/RadarObject[] contains the information about the track objects.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int32 id

time tracking_time                          // valid
time last_seen                              // not set

geometry_msgs/TwistWithCovariance velocity  // valid

geometry_msgs/Pose bounding_box_center      // valid
geometry_msgs/Vector3 bounding_box_size     // valid

geometry_msgs/PoseWithCovariance object_box_center // valid
geometry_msgs/Vector3 object_box_size              // valid

geometry_msgs/Point[] contour_points        // not set

</code></pre></div></div>

<p>Please note that not all fields are filled in the object messages. The message specification contains valid ones in the areas marked here in the code section.</p>

<p>The corresponding code fills the object list in the following manner:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        float heading = atan2( objectList[i].V3Dy(), objectList[i].V3Dx());

        radarMsg_.objects[i].velocity.twist.linear.x = objectList[i].V3Dx();
        radarMsg_.objects[i].velocity.twist.linear.y = objectList[i].V3Dy();
        radarMsg_.objects[i].velocity.twist.linear.z = 0.0;

        radarMsg_.objects[i].bounding_box_center.position.x = objectList[i].P3Dx();
        radarMsg_.objects[i].bounding_box_center.position.y = objectList[i].P3Dy();
        radarMsg_.objects[i].bounding_box_center.position.z = 0.0;
        radarMsg_.objects[i].bounding_box_center.orientation.x = cos(heading);
        radarMsg_.objects[i].bounding_box_center.orientation.y = sin(heading);
        radarMsg_.objects[i].bounding_box_center.orientation.z = 0.0;
        radarMsg_.objects[i].bounding_box_center.orientation.w = 1.0; // homogeneous coordinates


        radarMsg_.objects[i].bounding_box_size.x = objectList[i].ObjLength();
        radarMsg_.objects[i].bounding_box_size.y = 1.7;
        radarMsg_.objects[i].bounding_box_size.z = 1.7;
        for (int ii = 0; ii &lt; 6; ii++)
        {
          int mainDiagOffset = ii * 6 + ii;  // build eye-matrix
          radarMsg_.objects[i].object_box_center.covariance[mainDiagOffset] = 1.0;  // it is a little bit hacky ...
          radarMsg_.objects[i].velocity.covariance[mainDiagOffset] = 1.0;
        }
        radarMsg_.objects[i].object_box_center.pose = radarMsg_.objects[i].bounding_box_center;
        radarMsg_.objects[i].object_box_size= radarMsg_.objects[i].bounding_box_size;


</code></pre></div></div>
<p>As you can see there are default values for object height and object width of 1.7 (typical private vehicle)</p>

<!---

## Visualization

For the visualization a ROS node was developed, which receives
the radar messages and exports them as boxes for the objects and as arrows for the raw data.
The ROS node **radar_object_marker** receives the radar data and exports marker arrays that can be visualized in rviz.

The visualization could be controlled by the following parameters:

| Parameters                 | Description                                        |
| -------------------------- | -------------------------------------------------- |
| rawtarget_sphere_radius    | radius of the sphere for the raw data display      |
| rawtarget_arrow_scale      | Scaling factor for the arrow at the raw targets    |
| rawtarget_palette_name     | name of the color palette                          |
| rawtarget_palette_min_ampl | Minimum amplitude value mapped to color idx 0.     |
| rawtarget_palette_max_ampl | Maximum amplitude value mapped to color index 255. |
| object_arrow_scale         | Scaling factor for the arrow at the raw targets    |

The scaling values can be interpreted as the time an object or a raw target moves during this period. Using the distance/time equation, the distance corresponding to the arrow length is calculated from the product of this time period and the object speed or Doppler speed.

Example: Doppler speed: 20[m/s], rawtarget_arrow_scale: 0.4
An arrow of length 0.4 * 20[m] = 8[m] is displayed in rviz.

-->

<h3 id="launch-files">Launch Files</h3>

<p>The following launch files serve as examples for use:</p>

<ul>
  <li>sick_rms_xxxx.launch: Communication with the RMSxxxx and sending of radar ROS messages after successful parsing of SOPAS telegrams coming directly from the radar.</li>
  <li>radar_object_marker.launch : Conversion of radar messages to visualization messages</li>
</ul>

<h4 id="data-visualization-example-video">Data visualization example video</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/doc/200326_5_video_track.mp4">A video example can be found here</a>.</p>

<p>The following figure shows a viz-screenshot of the pointcloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/radar_rviz.png" alt="radar_rviz"></p>

<h3 id="parameter-for-radar-usage">Parameter for Radar Usage</h3>

<p>The following parameters are support by the node <strong>sick_generic_caller</strong> in combination with the RADAR RMS1000 / RMS2000:</p>

<ul>
  <li>scanner_type (string, default: “”) –&gt; Must be set to <strong>sick_rms_xxxx</strong>
</li>
  <li>range_max (double, default: 25.0)</li>
  <li>Maximum range</li>
  <li>hostname</li>
  <li>port</li>
  <li>timelimit</li>
  <li>tracking_mode
0: BASIC-Tracking - use for tracking smaller objects
1: TRAFFIC-Tracking - use for tracking larger objects like vehicles</li>
  <li>transmit_raw_targets (bool, default: true)</li>
  <li>transmit_objects (bool, default: true)</li>
  <li>emul_sensor (bool, default: false)</li>
</ul>

<h3 id="radar-datagram">Radar Datagram</h3>

<p>The message sick_scan_xd/RadarScan consists of four parts:</p>
<ul>
  <li>Header in standard format</li>
  <li>radarPreHeader with higher-level information</li>
  <li>targets: Raw targets output from radar</li>
  <li>objects: Tracking objects that are determined based on the raw targets using the internal tracking algorithm.</li>
</ul>

<p>The complete structure can be determined using the command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosmsg show sick_scan_xd/RadarScan'

</code></pre></div></div>

<p>The following is a short datagram showing the structure of the radar datagram.
The position of the individual elements for the data of the PreHeader is explained below.
See the documenation on https://www.sick.com/de/en/radar-sensors/c/g575803?q=:Def_Type:ProductFamily
for further information.</p>

<p><strong>Example of very short radar datagram</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sSN LMDradardata 1 1 112F6E9 0 0 BCC DC0C 730E9D16 730EA06D 0 0 0 0 0 0 1 0 0 4 DIST1 42200000 00000000 0 AZMT1 3C23D70A 00000000 0 VRAD1 3C23D70A 00000000 0 AMPL1 3DCCCCCD 00000000 0 1 MODE1 3F800000 00000000 0 0 0 0 0 0

</code></pre></div></div>

<p>In the following, the individual tokens are numbered one after another and their meaning is explained:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0: sSN
  1: LMDradardata

  MeasurementData
  ===============
  2: 1             MeasurementData.uiVersionNo  : Version Information for this while structureValue
                   Value   Range: 0 ... 65535
  DeviceBlock
  ===========
  3: 1             DeviceBlock.uiIdent      : Logical number of the device
                   Value   Range: 0 ... 65535
  4: 112F6E9       DeviceBlock.udiSerialNo  : Serial number of the device
                   Value Range  : 0..4294967295


  5: 0             DeviceBlock.xbState      : State of the device
                   Bit length   : 16

                   0.0 Bool     : Value Range False, True
                   Initialisation: False
                   Meaning       : bDeviceError

                   0.1 Bool      : Value Range False, True
                   Initialisation: False
                   Meaning       : bContaminationWarning

                   0.2 Bool      : Value Range False, True
                   Initialisation: False
                   Meaning       : bContaminationError

                   0.3 ...  0.7
  6: 0             1.0 ...  1.7 Bool      : Value Range False, True
                                           Reserved

StatusBlock
===========
  7: BCC            uiTelegramCount
  8: DC0C           uiCycleCount (or uiScanCount???)
  9: 730E9D16       udiSystemCountScan
 10: 730EA06D       udiSystemCountTransmit
 11: 0              xbInputs (Bit 0.0 .. 0.7)
 12: 0              xbInputs (Bit 1.0 .. 1.7)
 13: 0              xbOutputs (Bit 0.0 .. 0.7)
 14: 0              xbOutputs (Bit 1.0 .. 1.7)

MeasurementParam1Block
======================
 15: 0              MeasurementParam1Block.uiCycleDuration
 16: 0              MeasurementParam1Block.uiNoiseLevel

aEncoderBlock
=============
 17: 1              Number of aEncoderBlocks


 18: 0              aEncoderBlock[0].udiEncoderPos
 19: 0              aEncoderBlock[0].iEncoderSpeed

 20: 4              Number of following data channels
 21: DIST1
 22: 42200000
 23: 00000000
 24: 0
 25: AZMT1
 26: 3C23D70A
 27: 00000000
 28: 0
 29: VRAD1
 30: 3C23D70A
 31: 00000000
 32: 0
 33: AMPL1
 34: 3DCCCCCD
 35: 00000000
 36: 0
 37: 1
 38: MODE1
 39: 3F800000
 40: 00000000
 41: 0
 42: 0
 43: 0
 44: 0
 45: 0
 46: 0

</code></pre></div></div>

<h2 id="rms1000-and-lms1000-combination">RMS1000 and LMS1000 combination</h2>

<p>This tutorial shows how to combine a RMS1000radar with a LMS1000 lidar.</p>

<p>To demonstrate the lidar/radar combination, a RMS1000and a LMS1000 device were put into operation. The sick_scan_xd driver and rviz were started on ROS 1 Linux. Bagfiles have been recorded to demonstrate the required transform (rms_1xxx_lms_1xx_movement_off.bag and rms_1xxx_lms_1xx_movement_on.bag).</p>

<p>Run the following steps:</p>

<ol>
  <li>Connect RMS1000and LMS1000 and start sick_scan_xd with launchfiles sick_lms_1xxx.launch and sick_rms_xxxx.launch:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   roslaunch sick_scan_xd sick_lms_1xxx.launch
   roslaunch sick_scan_xd sick_rms_xxxx.launch
   
</code></pre></div></div>
<p>Make sure, that different ros node names and different IP-addresses are used.</p>

<p>The following rviz screenshot shows both pointclouds:
   <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/combination_rms_1xxx_lms_1xx/rms_1xxx_lms_1xx_combi_screenshot01.png" alt="rms_1xxx_lms_1xx_combi_screenshot01.png"></p>

<p>Note that each sensor has its own frame id and coordinate system. The RMS1000uses the frame id “radar”, the LMS1000 uses the frame id “cloud”. To combine both sensor, we have to transform the radar frame and coordinates to the lidar frame and coordinates.
   Radar targets have multiple echos due to reflection.</p>

<ol>
  <li>Start a ros static_transform_publisher to convert radar frames (frame id <code class="language-plaintext highlighter-rouge">/radar</code>) to lidar frames (frame id <code class="language-plaintext highlighter-rouge">/cloud</code>):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   rosrun tf static_transform_publisher 0 0 0 0 0 0 /cloud /radar 100
   
</code></pre></div></div>
<p>Using this transform, rviz displays both the radar and lidar pointcloud:
   <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/combination_rms_1xxx_lms_1xx/rms_1xxx_lms_1xx_combi.png" alt="rms_1xxx_lms_1xx_combi.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  If you use this example with a playback of bagfiles (e.g. <code class="language-plaintext highlighter-rouge">rosbag play --loop ./rms_1xxx_lms_1xx_movement_off.bag</code>), you might encounter errors due to different timestamps (the recorded timestamps in the bagfiles are different from the timestamps by the static_transform_publisher).</p>
</blockquote>

<p>Alternatively, the radar frame id and an optional transform can be configured in the radar launch file (parameter “frame_id” and “add_transform_xyz_rpy”).</p>

<h2 id="lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</h2>

<p>Most lidars create non interlaced scan data by default, i.e. a scan data telegram contains all scan points measured during a full 360 degree circulation. For MRS1xxx and LMS1000 lidars, parameter <code class="language-plaintext highlighter-rouge">ang_res</code> can be configured to increase the angular resolution. In this case, the scan data and point clouds are measured and published interlaced.</p>

<p>The following table shows valid combinations of the angular resolution (parameter <code class="language-plaintext highlighter-rouge">ang_res</code>) and scan frequency (parameter <code class="language-plaintext highlighter-rouge">scan_freq</code>) for MRS1000 and LMS1000 lidars:</p>

<table>
  <thead>
    <tr>
      <th>lidar</th>
      <th>ang_res [deg]</th>
      <th>scan_freq [Hz]</th>
      <th>interlacing</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MRS1000</td>
      <td>0.25</td>
      <td>50</td>
      <td>non-interlaced</td>
    </tr>
    <tr>
      <td>MRS1000</td>
      <td>0.125</td>
      <td>25</td>
      <td>2 x interlaced</td>
    </tr>
    <tr>
      <td>MRS1000</td>
      <td>0.0625</td>
      <td>12.5</td>
      <td>4 x interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.75</td>
      <td>150</td>
      <td>non-interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.375</td>
      <td>75</td>
      <td>2 x interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.1875</td>
      <td>37.5</td>
      <td>4 x interlaced</td>
    </tr>
  </tbody>
</table>

<p><strong>MRS1000 angular resolution</strong></p>

<p>By default, MRS1000 lidars create non-interlaced scans with an angular resolution 0.25 deg.
Using higher resolutions, the MRS1000 sends scan data interlaced.</p>

<p>MRS1000 lidars measure 4 consecutive scans with identical starting angles for each of its 4 layers, where each layer has a different elevation angle. This results in (12.5 Hz) * (4 layers) * (360 deg / 0.25 deg) * (275 deg / 360 deg) = 55000 shots per second.</p>

<p>With default configuration ang_res=0.25, the angular resolution of each scan is 0.25 [deg] and scans and point clouds are non-interlaced. The sequence of scan data telegrams is repeating with 4 consecutive telegrams (resp. 4 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5 deg, angle inc = 0.25 deg</li>
</ul>

<p>With configuration ang_res=0.125, the angular resolution of each scan is 0.125 [deg] and scans and point clouds are 2 x interlaced. The sequence of scan data telegrams is repeating with 8 consecutive telegrams (resp. 8 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.625 deg, angle inc = 0.25 deg</li>
</ul>

<p>With configuration ang_res=0.0625, the angular resolution of each scan is 0.0625 [deg] and scans and point clouds are 4 x interlaced. The sequence of scan data telegrams is repeating with 16 consecutive telegrams (resp. 16 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.6250 deg, angle inc = 0.25 deg</li>
</ul>

<p>To use the full angular resolution of one 360 degree circulation, the point cloud must be accumulated by 8 resp. 16 messages in interlaced mode.</p>

<p><strong>LMS1000 angular resolution</strong></p>

<p>By default, LMS1000 lidars create non-interlaced scans with an angular resolution 0.75 deg.
Using higher resolutions, the LMS1000 sends scan data interlaced.</p>

<p>With configuration ang_res=0.75, the angular resolution of each scan is 0.75 [deg]. This means that each point cloud message also has a resolution of 0.75 [deg]. With configuration ang_res=0.375, the scan is generated interlaced: Each scan still has 0.75 [deg] resolution, but 2 x 4 = 8 consecutive scans are rotated by 0.375 [deg] against each other. I.e. 8 consecutive point cloud messages each have an angular resolution of 0.375 [deg] at half the frequency. Within a point cloud message the angular resolution is still 0.75 [deg].</p>

<p>With ang_res=0.375, scan data are two times interlaced. The sequence of scan data telegrams is repeating with 8 consecutive telegrams:</p>
<ul>
  <li>4 scans starting at -138.000 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.375 deg, angle inc = 0.75 deg</li>
</ul>

<p>Thus the start angles of the received scan data telegrams are
{ …, -138.375, -138.375, -138.375, -138.375, -138.000, -138.000, -138.000, -138.000, … }</p>

<p>With ang_res=0.1875 the scan is generated quadruple interlaced, i.e. 4 x 4 = 16 consecutive scans are each rotated by 0.1875 [deg]. Each scan is resolved with 0.75 [deg]; 4 x 4 = 16 scans resp. 16 pointclouds together (accumulated) result in a resolution of 0.1875 [deg] at a quarter of the frequency.</p>

<p>With ang_res=0.1875, scan data are four times interlaced. The sequence of scan data telegrams is repeating with 16 consecutive telegrams:</p>
<ul>
  <li>4 scans starting at -137.8125 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.0000 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.1875 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.3750 deg, angle inc = 0.75 deg, then</li>
</ul>

<p>Thus the start angles of the received scan data telegrams are
{ …, -137.8125, -137.8125, -137.8125, -137.8125, -138.0000, -138.0000, -138.0000, -138.0000, -138.1875, -138.1875, -138.1875, -138.1875, -138.3750, -138.3750, -138.3750, -138.3750, … }</p>

<p>You can see this in rviz by increasing the decay time to e.g. 4/75=0.054 or higher. The screenshot shows an example with the default setting ang_res=0.75:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/LMS1xxx_0.7500_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>The angular resolution is (just roughly measured) about atan(0.11/0.9) / 9 points = 0.77 [deg]. With ang_res=0.375 and decay=0.1 rviz shows twice the resolution:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/LMS1xxx_0.3750_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>Correspondingly, rviz shows four times the resolution with ang_res=0.1875 and decay=0.1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/LMS1xxx_0.1875_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>To use the full angular resolution of one 360 degree circulation, the pointcloud must be accumulated by 8 resp. 16 messages.</p>

<p>The active configuration can be seen in the log output during scanner initialization, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ INFO] [1669294673.078608968]: sRA LMPscancfg: scan frequency = 75 Hz, angular resolution = 0.375 deg.

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LMS creates 4 consecutive scans with identical starting angles for each of its 4 laser LEDs. The 4 laser LEDs are mounted in one plane. All together, this gives you (4 scans) * (37.5 Hz) * (1 layer) * (360 deg / 0.75 deg) * (275 deg / 360 deg) = 55000 shots per second.</p>

</blockquote>

<h1 id="faq">FAQ</h1>

<h2 id="general">General</h2>

<p><strong>How to run multiple sensors concurrently?</strong></p>

<p>:question: How can I run multiple sensors concurrently with sick_scan_xd ?</p>

<p>:white_check_mark: To support multiple sensors, sick_scan_xd has to be started multiple times, with one sick_scan_xd-node for each sensor. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#start-multiple-nodes">start multiple nodes</a> for details.</p>

<p><strong>Driver restarts again and again after “sFA” message</strong></p>

<p>:question: The sick_scan_xd driver restarts again and again after an error message “sFA”.</p>

<p>:white_check_mark: The behaviour is intentional. The error message “sFA” can be caused by faulty configuration or errors in the lidar. Correct operation after this error message is not guaranteed. In this case, the driver restarts itself. It is recommended to identify and correct the error using its error number (“<code class="language-plaintext highlighter-rouge">sFA&lt;hexcode&gt;</code>”). The SOPAS error codes are listed in the manual.</p>

<p><strong>Driver restarts after timeout error</strong></p>

<p>:question: The sick_scan_xd driver changes the communication protocol and restarts after a timeout error.</p>

<p>:white_check_mark: The use of binary communication (Cola-B) is highly recommended due to better compatibility, lower network traffic and general support.
Recommendation:</p>
<ol>
  <li>Set parameter “use_binary_protocol” to “true” in the launch file, and</li>
  <li>Set the lidar communication mode with the SOPAS ET software to binary and save this setting in the scanner’s EEPROM.</li>
</ol>

<p><strong>Changes in launchfiles are ignored</strong></p>

<p>:question: roslaunch still uses an old version after modifying the launch-file.</p>

<p>:white_check_mark: After modifying a launch-file, it has to be installed by running <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1</code>
to be located and used by <code class="language-plaintext highlighter-rouge">roslaunch</code>.</p>

<p><strong>ROS 2 launch file support</strong></p>

<p>:question: How can I create a ROS 2 node in python to run sick_generic_caller from a launch.py-file in ROS 2?</p>

<p>:white_check_mark: Example to launch a TiM-7xx node in ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sick_scan_pkg_prefix = get_package_share_directory('sick_scan_xd')
    tim_launch_file_path = os.path.join(sick_scan_pkg_prefix, 'launch/sick_tim_7xx.launch')
    tim_top_node = Node(
        package='sick_scan_xd',
        executable='sick_generic_caller',
        output='screen',
        arguments=[
            tim_launch_file_path,
            'nodename:=/lidars/tim_top',
            'hostname:=192.168.0.110',
            'cloud_topic:=/lidars/tim_top/cloud',
            'frame_id:=tim_top'
        ]
    )

</code></pre></div></div>
<p>Thanks to user JWhitleyWork.</p>

<p><strong>Timestamps</strong></p>

<p>:question: What timestamp is provided in the pointcloud and laserscan messages?</p>

<p>:white_check_mark: Details about timestamps are given in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#time-synchronization">timing</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#software-pll">software_pll</a>.</p>

<p>In a nutshell:
The lidars do not work with absolute time stamps but with “ticks”. There are two types of tick timestamps:</p>
<ul>
  <li>Tick timestamps for the generation</li>
  <li>Tick timestamps for sending the message
To match the tick timestamps against the system time, a straight line equation is estimated via the so-called software PLL, which can be used to calculate from the system time to the ticks in the lidar (and vice versa). The assumption is that the tick timestamp for sending the message corresponds to the system time when receiving the message. In reality there will be a tiny delay here. This delay can be ignored.</li>
</ul>

<p>With the help of this straight line equation, one can now calculate the system time at which the data is generated in the lidar.</p>

<p>Summary:</p>
<ol>
  <li>lidar: stamp with ticks the generation (first shot in the scan) (TICK_GEN)</li>
  <li>lidar: stamp with ticks the sending of the scan message (TICK_TRANSMIT)</li>
  <li>PC: Stamp with system time the receiving of the message</li>
  <li>PC: Calculate back to system time of generation:
System time of generation = System time of receiving - (TICK_TRANSMIT - TICK_GEN)/TICK_FREQUENCY</li>
</ol>

<p><strong>Laserscan messages with multiple frame ids</strong></p>

<p>:question: sick_scan_xd publishes laserscan messages for multiScan100 and picoScan100 with multiple frame ids and possibly inconsistent data. Which frame id is correct?</p>

<p>:white_check_mark: By default, an echo filter is activated in the multiScan100 and picoScan100 launchfile. This echo filter suppresses multiple echos, e.g. echos from an object and a protective glass pane. The default configuration is “last echo only”. In this case (i.e. one echo only), the fullframe laserscan messages on topic scan_fullframe all have identical frame ids for each layer, i.e. “world_&lt;layer&gt;”. For the multiScan100 lidars with 16 layers, sick_scan_xd publishes laserscan messages with frame ids “world_1”, “world_2” up to “world_16”. For picoScan100 lidars with 1 layer, there is just one frame id “world_1”.</p>

<p>In case of multiple echos (i.e. echo filter is deactivated), each echo is published by a laserscan message with different frame ids “world_&lt;layer&gt;_&lt;echo_idx&gt;”. For picoScan100 lidars with 3 echos, there are 3 frame ids “world_1_0”, “world_1_1”, “world_1_2” published. For multiScan100 lidars with 16 layers and 3 echos, there are 48 different frame ids published “world_1_0”, “world_1_1”, “world_1_2”, “world_2_0”, “world_2_1”, “world_2_2”, … , “world_16_0”, “world_16_1”, “world_16_2”.</p>

<p>This behaviour is intended, since a laserscan message can not contain multiple ranges for a single scan point at one azimuth angle. Therefore, there have to be different laserscan messages for each layer and each echo. Layer and echo of a laserscan message are identified by the frame id.</p>

<p><strong>Compilation errors</strong></p>

<p>:question: Compiler reports errors in file <code class="language-plaintext highlighter-rouge">/opt/ros/&lt;distro&gt;/include/sick_scan</code></p>

<p>:white_check_mark: If sick_scan was previously installed using <code class="language-plaintext highlighter-rouge">apt-get install ros-&lt;distro&gt;-sick-scan</code>, you have to remove previous versions using <code class="language-plaintext highlighter-rouge">apt-get purge ros-&lt;distro&gt;-sick-scan</code>. Run the following steps for a complete rebuild:</p>
<ol>
  <li>Run <code class="language-plaintext highlighter-rouge">sudo apt-get purge ros-&lt;distro&gt;-sick-scan</code> (e.g. <code class="language-plaintext highlighter-rouge">sudo apt-get purge ros-noetic-sick-scan</code>) to remove previously installed sick_scan-packages</li>
  <li>Remove the folders sick_scan_xd/build, sick_scan_xd/build_isolated, sick_scan_xd/devel, sick_scan_xd/devel_isolated, sick_scan_xd/install and sick_scan_xd/install_isolated</li>
  <li>Rebuild</li>
</ol>

<p>:question: cmake cannot find diagnostic_updater</p>

<p>:white_check_mark: On ROS 2 foxy, package diagnostic_updater needs to be installed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get update
sudo apt-get install ros-$ROS_DISTRO-diagnostic-updater # install diagnostic_updater
# E.g. to install diagnostic_updater on foxy, run
# sudo apt-get install ros-foxy-diagnostic-updater

</code></pre></div></div>

<p>:question: catkin gives me the following error message:
<code class="language-plaintext highlighter-rouge">By not providing "FindSICKLDMRS.cmake" in CMAKE_MODULE_PATH this project ..., but CMake did not find one."</code></p>

<p>:white_check_mark:  One problem with ROS is that it doesn’t automatically rebuild everything if you just append “-DLMRRS=0”.
If you accidentally did the following call before</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catkin_make_isolated --install --cmake-args -DROS_VERSION=1

</code></pre></div></div>
<p>you must remove the build/devel/install-directories created by the ROS build process.
For this please run the following commands to remove the directories, which holds the previous build results:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~/ros_catkin_ws
rm -rf build_isolated
rm -rf devel_isolated
rm -rf install_isolated
rm -rf devel

</code></pre></div></div>
<p>It is possible that not all directories are present in this list. But that does not matter.
The only subdirectory left should be “src”.
You can check this with the following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls */ -d

</code></pre></div></div>
<p>The output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/

</code></pre></div></div>
<p>After doing this please rerun the command
catkin_make_isolated –install –cmake-args -DROS_VERSION=1 -DLDMRS=0</p>

<p><strong>rviz or rviz2 do not work as expected</strong></p>

<p>:question: rviz shows a grey point cloud. The size of points can be adjusted.</p>

<p>:white_check_mark: Check in the launch file that the intensity flag is set to True.</p>

<p>:question: rviz shows a grey point cloud and the size of points can not be adjusted.</p>

<p>:white_check_mark: Probably in this case you are running Linux in a virtual machine. In this case, OpenGL may not work correctly in the VM. rviz then chooses a kind of “fallback solution” and deactivates the colors.
Also, changing the “Size” and “Style” display in rviz has no effect on the display of the pointcloud data.</p>

<p>The problem can be avoided by starting rviz with the following sequence:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export LIBGL_ALWAYS_SOFTWARE=1
rosrun rviz rviz

</code></pre></div></div>

<p>:question: rviz2 on Ubuntu 24 with ROS 2 jazzy crashes immediately after start</p>

<p>:white_check_mark: This can be a wayland vs. X11 problem. Try <code class="language-plaintext highlighter-rouge">export QT_QPA_PLATFORM=xcb</code> before starting rviz2. See https://github.com/ros-visualization/rviz/issues/1442#issuecomment-553900795 and https://blog.martin-graesslin.com/blog/2015/07/porting-qt-applications-to-wayland/ for further information.</p>

<p><strong>Angular resolution and scan frequency</strong></p>

<p>:question: The angular resolution/ number of shots is too small</p>

<p>:white_check_mark: Possibly Mean or Median filters are activated. Use Sopas ET to deactivate them and store this settings permanent on the device, see picture.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/tim5xxx_filter.PNG" alt="Sopas_filter"></p>

<p>Further information can be found at http://wiki.ros.org/rviz/Troubleshooting .</p>

<p>:question: The scanner and message frequency is lower than expected</p>

<p>:white_check_mark: Mean or median filters decrease the scanner frequency. Check and configure filter settings with SOPAS ET or deactivate them in the launch file (MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx only):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="lfp_meanfilter" type="int" value="-1" /&gt; &lt;!-- MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx: lfp_meanfilter&lt;0: do not apply, lfp_meanfilter==0: deactivate LFPmeanfilter, lfp_meanfilter&gt;0: activate LFPmeanfilter with lfp_meanfilter = number of scans --&gt;
&lt;param name="lfp_medianfilter" type="int" value="-1" /&gt; &lt;!-- MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx: lfp_medianfilter&lt;0: do not apply, lfp_medianfilter==0: deactivate LFPmedianfilter, lfp_medianfilter==1: activate LFPmedianfilter --&gt;

</code></pre></div></div>
<p>By default, filter settings are not overwritten, i.e. the filter settings stored in the lidars EEPROM apply (factory defaults resp. SOPAS ET filter settings).</p>

<p><strong>LMS1xxx angular resolution</strong></p>

<p>:question: Independent of the configuration, the LMS1xxx pointcloud always displays 0.75 [deg] angular resolution</p>

<p>:white_check_mark: Using higher resolutions, the LMS1xxx sends scan data interlaced. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</a> for details.</p>

<p><strong>“ERROR: Tcp::open: Failed to open TCP connection to 192.168.0.1, aborting.”</strong></p>

<p>:question: Question:
sick_generic_caller gives you an answer like:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"ERROR: Tcp::open: Failed to open TCP connection to 192.168.0.1, aborting."</span>

</code></pre></div></div>

<p>:white_check_mark: Answer: See FAQ for network diagnosis and recommended configuration.</p>

<p><strong>IP Address of Lidar</strong></p>

<p>:question: Question:
My scanner does not use the default ip address. What shall I do?</p>

<p>:white_check_mark: Answer:
There are two options doing this:</p>

<ul>
  <li>Permanently:
Replace the following entry with your ip address.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;param <span class="nv">name</span><span class="o">=</span><span class="s2">"hostname"</span> <span class="nb">type</span><span class="o">=</span><span class="s2">"string"</span> <span class="nv">value</span><span class="o">=</span><span class="s2">"192.168.0.1"</span> /&gt;

</code></pre></div></div>
<ul>
  <li>Temporarily
Use a command line argument in addition to the launch file argument:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nb">hostname</span>:<span class="o">=</span>192.168.0.2

</code></pre></div></div>

<p><strong>Timeout Warning</strong></p>

<p>:question: Question:
During start phase the are warning/error message like</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>no answer received after 5000 ms. Maybe sopas mode is wrong.

</code></pre></div></div>
<p>and some more warning/error messages:</p>

<p>:white_check_mark: Answer:
In this case the driver tries to start the scanner in binary mode. If this is not possible, warnings and error messages are generated.
The driver switches the scanner from ASCII mode to binary mode and then restarts communication. The messages can therefore be ignored.
For a long-term solution, we recommend switching from ASCII to binary communication with SOPAS ET under Windows.</p>

<p><strong>Own Data Handling</strong></p>

<p>:question: Question:
I would like to process data with my own methods.</p>

<p>:white_check_mark: Answer:
Search for keyword “PUBLISH_DATA:” in the code and replace the code for writing
jpeg-files and CSV-files with your own source code.</p>

<p><strong>Occasionally missing scan data</strong></p>

<p>:question: Question:
Occasionally, no scan data appear, but the scanner is still reachable using <code class="language-plaintext highlighter-rouge">ping &lt;ip-address&gt;</code> or <code class="language-plaintext highlighter-rouge">nc -z -v &lt;ip-address&gt; &lt;port&gt;</code></p>

<p>:white_check_mark: Answer:
This is likely to be a data capture issue. In any case it’s recommend (if not already set) to use SOPAS-Binary instead of SOPAS-ASCII, because here the data rate is lower.</p>

<p>In addition, the following measures can help to determine the source of the problems:
a) Exchange the cables to the lidar(s) incl. the network cables
b) Exchange the power supply to the lidar(s)
c) avoidance of interconnection of other components (like switch etc.)
d) upgrade hardware and firmware of devices (if new versions available)</p>

<p>If it is not a hardware problem (e.g. cable), check if there are other software components using the network interface.</p>

<p>If there are still problems, use Wireshark to see if there are any communication problems reported. Wireshark can export the recorded network traffic as text (see screenshot). Search for entries like “LMDscandata” in the generated text file. This marks the beginning of a new scan message. You can then compare the order of the timestamps of these packets to see if there were any failures.</p>

<p><img src="https://user-images.githubusercontent.com/33296049/124088216-01aa2280-da53-11eb-91ae-2b88b37e08eb.png" alt="Wireshark screenshot"></p>

<p><strong>python_d.exe not found</strong></p>

<p>:question: Question:
On Windows with ROS, cmake complains “python_d.exe not found” when running rosidl generator</p>

<p>:white_check_mark: Answer:
Workaround: Copy python.exe to python_d.exe in the python folder.</p>

<p><strong>Debugging</strong></p>

<p>:question: Question:
How can I debug sick_generic_caller on ROS 1?</p>

<p>:white_check_mark: Answer:
Build with compiler option <code class="language-plaintext highlighter-rouge">-g</code> and run sick_generic_caller as described using a launchfile. Stop sick_generic_caller (Ctrl-C or kill) and save the current ros parameter using <code class="language-plaintext highlighter-rouge">rosparam dump &lt;dumpfile&gt;.yaml</code>. Load these parameter with <code class="language-plaintext highlighter-rouge">rosparam load &lt;dumpfile&gt;.yaml</code> and restart sick_generic_caller in gdb or in your IDE.</p>

<p><strong>Curved lines on a straight wall</strong></p>

<p>:question: Question:
The X,Y points of the lidar show a curved line even though the lidar is scanning a straight wall. How can this be?</p>

<p>:white_check_mark: Answer:
This effect occurs when the lidar has multiple planes that are tilted up or down. In this case, the laser beams of this plane do not lie on a flat plane. Rather, the beams lie on a cone. If the laser beams then hit a wall, the result is a curved course of the lidar points. If the lidar is horizontal and the wall is vertical, this is a hyperbola (see following figure):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/cone_section.png" alt="cone_section"></p>

<p>This image is generated using the website https://www.intmath.com/plane-analytic-geometry/conic-sections-summary-interactive.php.
Thus, the mathematical laws for a conic section apply, as they are explained e.g. at Wikipedia at https://en.wikipedia.org/wiki/Conic_section.</p>

<p><strong>Interlacing</strong></p>

<p>:question: Question:
How should I interpret the scan rate and lidar resolution from the manual? What is the relationship between ROS point cloud publishing rate and scan frequency here?</p>

<p>:white_check_mark: Answer:</p>

<p>The angular resolution and scan frequency is configurable in many lidars such as the LRS-4xxx or MRS1000. Depending on the lidar type, angular resolution and scan frequency can be set in the launch file either via the parameter “scan_cfg_list_entry” or the parameters “ang_res” and “scan_freq”. Angular resolution and scan frequency are not independent of each other. If no default settings are used, the values must be selected according to the manual for the respective lidar and set in launch file.</p>

<p>An increase in resolution is achieved by interlacing by a factor of N. This means that N consecutive scans are rotated by a constant angular offset. Each scan in itself still has the physically given angular resolution and frequency. By concatenating N interlaced scans, the angular resolution is increased by the factor N.</p>

<p>Example: The default setting of an MRS1000 is 0.25 degrees horizontal angular resolution at 50 Hz scan frequency without interlacing and an angular range of 275 degrees in total. I.e. each scan measures the distance at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ].</p>

<p>If 0.125 degrees horizontal angular resolution is configured at 25 Hz scan frequency, the scans are performed with 2 times interlacing (N=2). Every 2nd scan is horizontally shifted by 0.125 degrees. I.e. each scan measures alternately at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ] and [ … , 0.125, 0.375, 0.625, 0.875 … ]. 50 single scans per second resp. 25 interlaced scans per second are sent.</p>

<p>If 0.0625 degrees horizontal angular resolution at 12.5 Hz scan frequency is configured, the scans are performed with 4 times interlacing (N=4). Successive scans are shifted horizontally by 0.0625 degrees each. That is, each scan measures alternately at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ], [… , 0.0625, 0.3125, 0.5625, 0.8125 … ], [… , 0.125, 0.375, 0.625, 0.875 … ] and [… , 0.1875, 0.4375, 0.6875, 0.9375 … ]. 50 single scans per second resp. 12.5 interlaced scans per second are sent.</p>

<p>In interlacing mode, laser scan and point cloud messages are published interlaced, too. In rviz, the higher angular resolution is clearly visible when the decay time is increased.</p>

<p>With a scan frequency of 50 Hz and 4 active layers, the lidar will send a new scan line each 0.02 seconds. Each layer is scanned after 0.08 seconds resp. with 12.5 Hz (4 layers multiplied by 12.5 Hz = 50 Hz scan frequency). The point cloud accumulates all active layers and is therefore published with 12.5 Hz (i.e. scan frequency divided by number of layers).</p>

<p>If you check the publishing rate of the point cloud messages of a MRS-1104, you will measure 12.4 Hz, since the scans of 4 layers are accumulated in 1 point cloud message (50 hz scan frequency divided by 4 layers = 12.5 Hz point cloud publishing frequency). The resolution of each single point cloud message is 0.125 [deg]. Only by interleaving 4 consecutive messages you get the high resolution of 0.0625 [deg].</p>

<p>See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</a> for further informations.</p>

<h2 id="networking">Networking</h2>

<p>A TCP connection is needed to receive scan data from a lidar, which requires an appropriate network setup.</p>

<p>Common errors when establishing the TCP connection and possible solutions are described below. If you encounter network errors like “Failed to open TCP connection” when running sick_scan_xd, follow these recommendations.</p>

<p><strong>Static IP addresses</strong></p>

<p>Most lidars have the default IP address 192.168.0.1. It is highly recommended to use a static IPv4 network with IP addresses 192.168.x.y. PC and lidar should use the same subnet. <strong>Avoid using DHCP.</strong></p>

<p>Example IP address of the lidar: 192.168.0.1 (default)</p>

<p>Example IP address of the PC running sick_scan_xd: 192.168.0.100</p>

<p>The IP address of the PC running sick_scan_xd and the lidar must not be identical!</p>

<p>Use <code class="language-plaintext highlighter-rouge">ifconfig -a</code> on Linux resp. <code class="language-plaintext highlighter-rouge">ipconfig /all</code> on Windows to view network settings and lcoal IP addresses.</p>

<ol>
  <li>Try to ping your device:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>
<ol>
  <li>Disconnect your scanner and retry ping</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>
<p>The result of ping contains a pattern like</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ... Destination Host Unreachable
   
</code></pre></div></div>
<ol>
  <li>Reconnect your device and try to ping:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>

<p>If you do not know the IP addresses, try to find the IP addresses of your PC and your lidar in your subnet:</p>

<ol>
  <li>
    <p>Install fping: <code class="language-plaintext highlighter-rouge">apt-get install fping</code></p>
  </li>
  <li>
    <p>Scan your network (for example, subnet 192.168.10.0/24): <code class="language-plaintext highlighter-rouge">fping -a 192.168.0.1\24</code> to
search for all IP addresses from 192.168.0.0 to 192.168.0.255.</p>
  </li>
</ol>

<p>The result is similar to:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.0.4 is alive
192.168.0.22 is alive

</code></pre></div></div>
<p>and a lot of unreachable entries.
In the example the IP address 192.168.0.4 is the laserscanner MRS1104 and the IP address 192.168.0.22 is the computer running linux. Check this with <code class="language-plaintext highlighter-rouge">ifconfig|grep 192.168.0.22</code>.</p>

<p>We recommend to use wired Ethernet. On Ubuntu, use the “Wired Settings” menu to check the network profile. Network profiles sometimes change automatically when multiple profiles are in use or the lidar has been switched off and on.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/network_setup_02.png" alt="network_setup_02.png"></p>

<p><strong>Network configuration with SOPAS ET</strong></p>

<p>The <a href="https://www.sick.com/de/en/catalog/digital-services-and-solutions/software/sopas-engineering-tool/p/p367244">SOPAS Engineering Tool</a> (SOPAS ET) allows a detailed lidar configuration incl. network settings. We recommend to use SOPAS ET in case of network problems or to change the lidars network configuration. The operation manual contains further details.</p>

<p><strong>Diagnostic tools</strong></p>

<p>Network tools can help in case of connection errors. Examples are:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">ping &lt;lidar-ip-address&gt;</code> to check if the lidar is reachable</li>
  <li>
<code class="language-plaintext highlighter-rouge">fping -a 192.168.0.1\24</code> to see ip addresses available in the subnet</li>
  <li>
<code class="language-plaintext highlighter-rouge">netcat &lt;lidar-ip-address&gt; &lt;lidar-tcp-port&gt;</code> to read or write network data</li>
  <li>
<code class="language-plaintext highlighter-rouge">wireshark</code> to monitor and record the network traffic between PC and lidar.</li>
  <li>
<code class="language-plaintext highlighter-rouge">sudo ufw status</code> to see if a firewall is active. If active, disable firewalls with <code class="language-plaintext highlighter-rouge">sudo ufw disable</code>.</li>
</ul>

<h2 id="multiscan100--picoscan100">multiScan100 / picoScan100</h2>

<p><strong>Visual Studio: Breakpoints in Debug Mode disabled</strong></p>

<p>:question: In Windows debug version the compiler does not stop at breakpoints.</p>

<p>:white_check_mark: Check, that you are using the Debug Version. At ‘/Zi’ to compiler settings. Disable optimization.
(see <code class="language-plaintext highlighter-rouge">https://stackoverflow.com/questions/865546/generating-symbols-in-release-binaries-with-visual-studio</code> for details).</p>

<p><strong>Packages lost in benchmark</strong></p>

<p>:question: sick_scan_xd seems to drop packages, when sending 10000 msgpacks with polarscan_sender_test.py from another computer</p>

<p>:white_check_mark: There can be a number of reasons for dropped messages (udp or msgpacks). Besides slow network connection, there can be other pitfalls depending on the system:</p>

<ul>
  <li>
    <p>If Linux or Windows is running in a virtual machine, make sure UDP port 2115 is forwarded. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#firewall-configuration">Firewall configuration</a>.</p>
  </li>
  <li>
    <p>Depending on ROS 2 system settings, log messages might be buffered. To really see all log messages of sick_generic_caller, terminate sick_scan_xd/sick_generic_caller (Ctrl-C or kill) and view the ros logfile by <code class="language-plaintext highlighter-rouge">cat ~/.ros/log/sick_scan_*.log</code></p>
  </li>
</ul>

<p><strong>Convert pcapng-files to msgpack or json</strong></p>

<p>:question: How can I convert a pcapng-file with scandata to a msgpack- or json-file?</p>

<p>:white_check_mark: Run the following steps:</p>
<ul>
  <li>Install python msgpack package with <code class="language-plaintext highlighter-rouge">pip install msgpack</code>
</li>
  <li>Play the pcapng-file using multiscan_pcap_player.py</li>
  <li>Receive and convert to msgpack using multiscan_receiver.py</li>
  <li>Convert to json using online-converter https://toolslick.com/conversion/data/messagepack-to-json</li>
</ul>

<p>Linux example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pushd sick_scan_xd/test/python
python3 python multiscan_receiver.py &amp;
python3 multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20210929_multiscan_token_udp.pcapng
mv ./multiscan_dump_12472.msgpack     20210929_multiscan_token_udp.msgpack
mv ./multiscan_dump_12472.msgpack.hex 20210929_multiscan_token_udp.msgpack.hex
popd

</code></pre></div></div>
<p>Then paste the content of file <code class="language-plaintext highlighter-rouge">20210929_multiscan_token_udp.msgpack.hex</code> in https://toolslick.com/conversion/data/messagepack-to-json and save the json-output.</p>

<p>Windows example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pushd sick_scan_xd\test\python
python --version
REM Convert 20220915_multiscan_msgpack_output.pcapng (16-bit RSSI record) to msgpack resp. json
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
start python multiscan_receiver.py
python multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20220915_multiscan_msgpack_output.pcapng --udp_port=2115
move /y .\multiscan_dump_23644.msgpack     20220915_multiscan_msgpack_output.msgpack
move /y .\multiscan_dump_23644.msgpack.hex 20220915_multiscan_msgpack_output.msgpack.hex
REM Convert 20210929_multiscan_token_udp.pcapng (8-bit RSSI record) to msgpack resp. json
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
start python multiscan_receiver.py
python multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20210929_multiscan_token_udp.pcapng --verbose=0
move /y .\multiscan_dump_12472.msgpack     20210929_multiscan_token_udp.msgpack
move /y .\multiscan_dump_12472.msgpack.hex 20210929_multiscan_token_udp.msgpack.hex
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
popd

</code></pre></div></div>
<p>Then paste the content of files <code class="language-plaintext highlighter-rouge">20220915_multiscan_msgpack_output.msgpack.hex</code> resp. <code class="language-plaintext highlighter-rouge">20210929_multiscan_token_udp.msgpack.hex</code> in https://toolslick.com/conversion/data/messagepack-to-json and save the json-output.</p>

<h1 id="troubleshooting-and-technical-support">Troubleshooting and technical support</h1>

<p>The software is based on the ROS drivers sick_scan, sick_scan_base and sick_scan2. For FAQ and troubleshooting please also have a look at https://github.com/SICKAG/sick_scan , https://github.com/SICKAG/sick_scan_base and https://github.com/SICKAG/sick_scan2 .
Common problems might be solved in closed issues.</p>

<ol>
  <li>Check Scanner IP in the launch file.</li>
  <li>Check Ethernet connection to scanner with netcat e.g.
<code class="language-plaintext highlighter-rouge">nc -z -v -w5 $SCANNERIPADDRESS 2112
</code>.
For further details about setting up the correct ip settings see <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#ip-address-configuration">IP configuration</a>)</li>
  <li>View node startup output wether the IP connection could be established</li>
  <li>Check the scanner status using the LEDs on the device. The LED codes are described in the above mentioned operation manuals.</li>
  <li>Further testing and troubleshooting informations can found in the file test/readme_testplan.txt</li>
  <li>If you stop the scanner in your debugging IDE or by other hard interruption (like Ctrl-C), you must wait until 60 sec. before
the scanner is up and running again. During this time the MRS6124 reconnects twice.
If you do not wait this waiting time you could see one of the following messages:
    <ul>
      <li>TCP connection error</li>
      <li>Error-Message 0x0d</li>
    </ul>
  </li>
  <li>Amplitude values in rviz: If you see only one color in rviz try the following:
Set the min/max-Range of intensity display in the range [0…200] and switch on the intensity flag in the launch file</li>
  <li>In case of network problems check your own ip address and the ip address of your laser scanner (by using SOPAS ET).
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>List of own IP-addresses: ifconfig</td>
              <td>grep “inet addr”</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Try to ping scanner ip address (used in launch file)</li>
    </ul>
  </li>
  <li>If the driver stops during init phase please stop the driver with ctrl-c and restart (could be caused due to protocol ASCII/Binary cola-dialect)</li>
</ol>

<p>In case of technical support please open a new issue. For optimal support, add the following information to your request:</p>

<ol>
  <li>Scanner model name,</li>
  <li>Ros node startup log,</li>
  <li>Sopas file of your scanner configuration. The instructions at https://sickconnect.com/create-and-download-a-sopas-file/ show how to create the Sopas file.</li>
</ol>

<p>In case of application support please use <a href="https://support.sick.com">https://support.sick.com</a>.</p>

<h1 id="creators-and-contribution">Creators and contribution</h1>

<p>Michael Lehning (http://www.lehning.de) on behalf of SICK AG (https://www.sick.com/)</p>

<p>This <a href="https://github.com/SICKAG/sick_scan_xd/tree/master//CONTRIBUTING.md">documentation</a> is intended to provide background information on the maintenance and extension of the repository.</p>

<h1 id="keywords">Keywords</h1>

<p>MRS1000, MRS1104, LMS1000, LMS1104, MRS6000, MRS6124, RMS1xxx, RMS1000, RMSxxxx, ROS LiDAR, SICK LiDAR, SICK Laser, SICK Laserscanner, SICK Radar, LMS1xx, MRS1xxx, LMS1xxx, MRS6xxx, TiM5xx, TiM551, TiM561, TiM571, TiM781, TiM781S, LMS5xx, LMS511, NAV210, NAV245, NAV310, LD-MRS, LRS4000, LD-LRS3600, LD-LRS3601, LD-LRS3611, LD-OEM1500, LD-OEM1501, multiScan100, multiScan, picoScan100, picoScan150, picoScan120, multiScan136, multiScan165</p>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<p><img align="right" width="200" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Logo_SICK_AG_2009.svg/1200px-Logo_SICK_AG_2009.svg.png"></p>

<h2 id="executive-summary">Executive Summary</h2>

<p>This documentation is intended to provide background information on the maintenance and extension of the repository.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#adding-a-new-device-to-the-driver">Adding a new device to the driver</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#naming-convention">Naming Convention</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#launch-files">Launch Files</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#code-modification">Code Modification</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#bloom-release">Bloom release</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#first-time-installation-of-toolchain">First time installation of toolchain</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#release-build-for-ros-1">Release build for ROS 1</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#release-build-for-ros-2">Release build for ROS 2</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#check-status">Check status</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#useful-links-and-information">Useful links and information</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#testing">Testing</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#unit-tests">Unit tests</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#examples">Examples</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#simulation">Simulation</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#windows">Windows</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#linux">Linux</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#profiling">Profiling</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#installation">Installation</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#usage">Usage</a></li>
    </ul>
  </li>
</ul>

<h1 id="adding-a-new-device-to-the-driver">Adding a new device to the driver</h1>

<p>This driver is designed to support several different scanner types (including radar) from Sick. This documentation describes how to add additional devices to the driver.</p>

<h2 id="naming-convention">Naming Convention</h2>

<p>For each device type a name pattern is assigned as follows:
<code class="language-plaintext highlighter-rouge">
sick_&lt;device family&gt;_&lt;identifier&gt;
</code></p>

<p>The name type is used in the code to decide which scanner-specific parameters are set.
The name type is passed as a parameter as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="scanner_type" type="string" value="sick_lms_5xx" /&gt;

</code></pre></div></div>

<h2 id="launch-files">Launch Files</h2>

<p>A launch file is created for each device type,
which usually has the same naming convention as the scanner type.
To create a new device, it is recommended to copy, rename and edit an existing launch file.</p>

<h2 id="code-modification">Code Modification</h2>

<ol>
  <li>Hint: Construction of parser:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sick_scan_xd::SickGenericParser *parser = new sick_scan_xd::SickGenericParser(scannerName);
    
</code></pre></div></div>
<ol>
  <li>
    <p>Add string constant like the constant SICK_SCANNER_RMS_XXXX_NAME</p>
  </li>
  <li>
    <p>Append this constant to allowedScannerNames
like allowedScannerNames.push_back(SICK_SCANNER_RMS_XXXX_NAME);
in the file sick_generic_parser.cpp</p>
  </li>
  <li>
    <p>Add new parameter block like</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	if (basicParams[i].getScannerName().compare(SICK_SCANNER_MRS_1XXX_NAME) == 0)
	{...
	} in the file sick_generic_parser.cpp
	
</code></pre></div></div>

<ol>
  <li>Copy the file sick_generic_radar.cpp and add a new class following the structure
of this file.</li>
</ol>

<h1 id="bloom-release">Bloom release</h1>

<h2 id="first-time-installation-of-toolchain">First time installation of toolchain</h2>

<ol>
  <li>Install on Linux:
    <ul>
      <li>Install bloom:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        sudo apt-get update
        sudo apt-get install python3-bloom python3-catkin-pkg
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Install docker:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        pushd /tmp
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        sudo usermod -aG docker $USER
        popd
        shutdown -r now # reboot
        # short quicktest
        docker --version
        docker info
        docker run hello-world
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Install ros-buildfarm:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        # sudo apt-get install python3-ros-buildfarm # not successfully, unable to locate
        pip3 install ros-buildfarm # installs ros-buildfarm 3.0 successfully
        
</code></pre></div></div>

<ol>
  <li>Build the prerelease:
    <ul>
      <li>Short version to build a prerelase:
        <ul>
          <li>Run the following commands:</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            mkdir -p ./ws_sick_scan_xd_bloom/src
            cd ./ws_sick_scan_xd_bloom/src
            git clone -b master https://github.com/SICKAG/sick_scan_xd.git
            cd ./sick_scan_xd/test/scripts
            ./run_linux_ros1_bloom.bash
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * Fix any errors during the prerelease build and check in
    * Repeat `./run_linux_ros1_bloom.bash` until the the prerelease build finishes without errors
* Alternative version:
    * Open http://prerelease.ros.org/noetic in the brower
    * Add a custom repository: `sick_scan_xd` , `https://github.com/SICKAG/sick_scan_xd` , `master` (or `feature/bloom_pretest` or any other branch to test)
    * Add a custom repository: `msgpack11` , `https://github.com/SICKAG/msgpack11` , `master`
    * Add a custom repository: `libsick_ldmrs` , `https://github.com/SICKAG/libsick_ldmrs` , `master`
    * Confirm next steps (i.e. URL of build farm: https://raw.githubusercontent.com/ros-infrastructure/ros_buildfarm_config/production/index.yaml, Ubuntu focal)
    * Click on `Generate command`
    * Run the generated command, i.e.:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            source /opt/ros/noetic/setup.bash
            mkdir -p /tmp/prerelease_job
            cd /tmp/prerelease_job
            generate_prerelease_script.py \
              https://raw.githubusercontent.com/ros-infrastructure/ros_buildfarm_config/production/index.yaml \
              noetic default ubuntu focal amd64 \
              --custom-repo \
                sick_scan_xd:git:https://github.com/SICKAG/sick_scan_xd:master \
                msgpack11:git:https://github.com/SICKAG/msgpack11:master \
                libsick_ldmrs:git:https://github.com/SICKAG/libsick_ldmrs:master \
              --level 1 \
              --output-dir ./
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * Run `printf "\033c" ; rm -rf ~/.ccache ; mkdir -p ~/.ccache ; ./prerelease.sh` in folder `/tmp/prerelease_job`
    * In case of error message `/usr/lib/ccache/cc is not able to compile a simple test program`:
        * Remove folder `~/.ccache` before running `./prerelease.sh`
        * See https://answers.ros.org/question/347063/error-pre-release-melodic/
    * Fix any errors during the prerelease build and check in
    * Remove the temporary build folder by `rm -rf /tmp/prerelease_job`
    * Repeat until `prerelease.sh` finishes without errors.
</code></pre></div></div>

<ol>
  <li>Submit package sick_scan_xd for indexing (noetic)
    <ul>
      <li>Fork <code class="language-plaintext highlighter-rouge">https://github.com/ros/rosdistro</code> -&gt; <code class="language-plaintext highlighter-rouge">https://github.com/&lt;username&gt;/rosdistro.git</code>
</li>
      <li><code class="language-plaintext highlighter-rouge">git clone https://github.com/&lt;username&gt;/rosdistro.git</code></li>
      <li>Edit file <code class="language-plaintext highlighter-rouge">rosdistro/noetic/distribution.yaml</code> and add after <code class="language-plaintext highlighter-rouge">sick_scan</code>:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        sick_scan_xd:
          doc:
            type: git
            url: https://github.com/SICKAG/sick_scan_xd.git
            version: master
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* `cd rosdistro ; source /opt/ros/noetic/setup.bash ; rosdistro_reformat file://"$(pwd)"/index.yaml`
* git commit: `git commit -m "Adding sick_scan_xd to documentation index for distro noetic" distribution.yaml`
* git push: `git push origin master`
* Submit a pull request on `https://github.com/&lt;username&gt;/rosdistro`
</code></pre></div></div>

<ol>
  <li>For ROS 2 humble: Follow instructions on https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html</li>
</ol>

<p><strong><em>NOTE:</em></strong> Bloom releases for ROS 2 foxy are not longer supported (Pull request failed, “This pull request changes files for a ROS distribution that is no longer supported (End Of Life)”)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Submit package sick_scan_xd for indexing (ROS 2 humble)
    * Reset fork `https://github.com/&lt;username&gt;/rosdistro.git` to origin/master or delete the fork and create a new one -&gt; `https://github.com/&lt;username&gt;/rosdistro.git`
    * `git clone https://github.com/&lt;username&gt;/rosdistro.git`
    * Edit file `rosdistro/humble/distribution.yaml` and add after `sick_safevisionary_ros2`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            sick_scan_xd:
              doc:
                type: git
                url: https://github.com/SICKAG/sick_scan_xd.git
                version: develop
              status: developed
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * git commit and push ("Adding sick_scan_xd to documentation index for distro humble")
    * Submit a pull request on `https://github.com/&lt;username&gt;/rosdistro`
    * Do the same for any new ROS 2 version, e.g. iron and jazzy (`rosdistro/iron/distribution.yaml`, `rosdistro/jazzy/distribution.yaml`)
* [Start a new release team](https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&amp;labels=&amp;template=new_release_team.md&amp;title=Add+release+team)
    * ROS 2 sick_scan_xd team: https://github.com/orgs/ros2-gbp/teams/sick_scan_xd
    * ROS 2 sick_scan_xd release repository: https://github.com/ros2-gbp/sick_scan_xd-release
</code></pre></div></div>

<h2 id="release-build-for-ros-1">Release build for ROS 1</h2>

<ul>
  <li>Build a prerelease (dry run in a docker container):
    <ul>
      <li>Run the following commands:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        git clone -b master https://github.com/SICKAG/sick_scan_xd.git
        cd ./sick_scan_xd/test/scripts
        sudo dos2unix ./*.bash ; sudo chmod a+x ./*.bash
        ./run_linux_ros1_bloom.bash
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Fix any errors during the prerelease build and check in
* Repeat `./run_linux_ros1_bloom.bash` until the the prerelease build finishes without errors
</code></pre></div></div>

<ul>
  <li>Build a binary release: follow https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease
    <ul>
      <li>Update version number in package.xml, minor version number should be incremented at least</li>
      <li>Create resp. update CHANGELOG.rst:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        cd ./src/sick_scan_xd
        rm ./CHANGELOG.rst
        catkin_generate_changelog --all # create CHANGELOG.rst
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Commit and pull all changes incl. CHANGELOG.rst and package.xml:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        git add CHANGELOG.rst package.xml
        git commit -m "Update CHANGELOG.rst and package version"
        git push
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Run `catkin_prepare_release` and `bloom-release` in folder `src/sick_scan_xd`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        catkin_prepare_release -y
        bloom-release --rosdistro noetic --track noetic sick_scan_xd # at first time: call with option --edit for configuration
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* For the initial release (first time): Run `bloom-release` in folder `src/sick_scan_xd` with option `--edit`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        catkin_prepare_release -y
        bloom-release --rosdistro noetic --track noetic sick_scan_xd --edit
        Release repository url: https://github.com/SICKAG/sick_scan_xd-release.git
        upstream: &lt;default, i.e. press ENTER&gt;
        Upstream Repository URI: https://github.com/SICKAG/sick_scan_xd.git
        Upstream VCS Type: &lt;default: git, i.e. press ENTER&gt;
        Version: &lt;default: auto, i.e. press ENTER&gt;
        Release Tag: &lt;default: version, i.e. press ENTER&gt;
        Upstream Devel Branch: feature/bloom_pretest
        ROS Distro: noetic
        Patches Directory: &lt;default: none, i.e. press ENTER&gt;
        Release Repository Push URL:  &lt;default: none, i.e. press ENTER&gt;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Check status: https://index.ros.org/p/sick_scan_xd/#noetic
* Install binary release: `sudo apt update ; sudo apt-get install ros-noetic-sick-scan-xd`. Note from https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease : Packages built are periodically synchronized over to the shadow-fixed and public repositories, so it might take as long as a month before your package is available on the public ROS debian repositories (i.e. available via apt-get).
</code></pre></div></div>

<h2 id="release-build-for-ros-2">Release build for ROS 2</h2>

<p>For ROS 2 follow the instructions on https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html :</p>
<ul>
  <li>Checkout the sick_scan_xd version to be released and run:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    git clone -b master https://github.com/SICKAG/sick_scan_xd.git
    cd ./sick_scan_xd
    rm ./CHANGELOG.rst
    catkin_generate_changelog --all # create CHANGELOG.rst
    
</code></pre></div></div>
<ul>
  <li>Commit CHANGELOG.rst and optional modifications:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    git add CHANGELOG.rst
    git commit -m "Update CHANGELOG.rst"
    git push
    
</code></pre></div></div>
<ul>
  <li>Run <code class="language-plaintext highlighter-rouge">catkin_prepare_release</code> and <code class="language-plaintext highlighter-rouge">bloom-release</code>:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    bloom-release --rosdistro humble --track humble sick_scan_xd # at first time: call with option --new-track
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For the initial release (i.e. at the first time): Run bloom-relase configuration with option --new-track:
`bloom-release --new-track --rosdistro humble --track humble sick_scan_xd`
* Release repository url: https://github.com/ros2-gbp/sick_scan_xd-release.git
* Upstream: &lt;default&gt;
* Upstream Repository URI: https://github.com/SICKAG/sick_scan_xd.git
* Upstream Devel Branch: develop
* ROS Distro: humble
After the initial release has been approved: Run
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo rosdep init
    rosdep update
    
</code></pre></div></div>

<h2 id="check-status">Check status</h2>
<p>Jenkins build status:</p>
<ul>
  <li>ROS 1 noetic jenkins build status: https://build.ros.org/job/Ndev__sick_scan_xd__ubuntu_focal_amd64/lastBuild/</li>
  <li>ROS 2 humble jenkins build status: https://build.ros2.org/job/Hdev__sick_scan_xd__ubuntu_jammy_amd64/lastBuild/</li>
  <li>ROS 2 iron   jenkins build status: https://build.ros2.org/job/Idev__sick_scan_xd__ubuntu_jammy_amd64/lastBuild/</li>
  <li>ROS 2 jazzy  jenkins build status: https://build.ros2.org/job/Jdev__sick_scan_xd__ubuntu_noble_amd64/lastBuild/</li>
  <li>ROS 1 jenkins: https://build.ros.org/search/?q=sick_scan_xd</li>
  <li>ROS 2 jenkins: https://build.ros2.org/search/?q=sick_scan_xd</li>
</ul>

<p>Release repositories:</p>
<ul>
  <li>ROS 1 release repository: https://github.com/SICKAG/sick_scan_xd-release</li>
  <li>ROS 2 release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git</li>
</ul>

<p>Show version and list information about prebuilt binaries:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt show ros-noetic-sick-scan-xd
sudo apt show ros-humble-sick-scan-xd
sudo apt show ros-iron-sick-scan-xd
sudo apt show ros-jazzy-sick-scan-xd

</code></pre></div></div>

<p>Installation of prebuilt binaries:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-noetic-sick-scan-xd
sudo apt-get install ros-humble-sick-scan-xd
sudo apt-get install ros-iron-sick-scan-xd
sudo apt-get install ros-jazzy-sick-scan-xd
sudo apt-get remove ros-noetic-sick-scan-xd
sudo apt-get remove ros-humble-sick-scan-xd
sudo apt-get remove ros-iron-sick-scan-xd
sudo apt-get remove ros-jazzy-sick-scan-xd

</code></pre></div></div>

<h2 id="useful-links-and-information">Useful links and information</h2>

<ul>
  <li>http://wiki.ros.org/bloom</li>
  <li>https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease</li>
  <li>https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html</li>
</ul>

<p><strong>Bloom builds an old sick_scan_xd version (ROS 1)</strong></p>

<p>Check <code class="language-plaintext highlighter-rouge">devel_branch</code> in https://github.com/SICKAG/sick_scan_xd-release/blob/master/tracks.yaml . If devel_branch is an old branch, replace it with e.g. <code class="language-plaintext highlighter-rouge">develop</code> or <code class="language-plaintext highlighter-rouge">master</code>, or update the <code class="language-plaintext highlighter-rouge">&lt;devel_branch&gt;</code> to a new version.</p>

<p><strong>Bloom builds an old sick_scan_xd version (ROS 2)</strong>
Check <code class="language-plaintext highlighter-rouge">devel_branch</code> in https://github.com/ros2-gbp/sick_scan_xd-release/blob/master/tracks.yaml . If devel_branch is an old branch, replace it with e.g. <code class="language-plaintext highlighter-rouge">develop</code> or <code class="language-plaintext highlighter-rouge">master</code>, or update the <code class="language-plaintext highlighter-rouge">&lt;devel_branch&gt;</code> to a new version.</p>

<p><strong>Bloom builds a new sick_scan_xd version, but apt still installs an old version</strong></p>

<ul>
  <li>Check the sick_scan_xd version in the release repositories https://github.com/SICKAG/sick_scan_xd-release.git (ROS 1) and https://github.com/ros2-gbp/sick_scan_xd-release.git (ROS 2)</li>
  <li>Install bloom (if not yet done) using <code class="language-plaintext highlighter-rouge">sudo apt-get install python-bloom</code> on Linux or <code class="language-plaintext highlighter-rouge">pip install -U bloom</code> on Windows</li>
  <li>Run</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        bloom-release --rosdistro noetic -d sick_scan_xd # release repository: https://github.com/SICKAG/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro humble -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro iron   -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro jazzy  -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        
</code></pre></div></div>
<ul>
  <li>In case of github 2FA errors: Follow http://wiki.ros.org/bloom/Tutorials/GithubManualAuthorization to create a 2FA token and configure the token in file <code class="language-plaintext highlighter-rouge">~/.config/bloom</code>.</li>
  <li>Note: Updates of release repository https://github.com/SICKAG/sick_scan_xd-release.git require github authentification via ssh. See https://docs.github.com/en/authentication/connecting-to-github-with-ssh and https://wiki.ros.org/bloom/Tutorials/GithubManualAuthorization for details.</li>
</ul>

<h1 id="testing">Testing</h1>

<h2 id="unit-tests">Unit tests</h2>

<p>For a quick unit test after installation without the sensor hardware, a test server is provided to simulate a scanner. It implements a simple tcp server, which responds to binary cola messages and sends predefined LMDscandata to a tcp-client. The sick_scan_xd driver can connect to the local test server instead of the lidar device for offline-tests. Please note, that this test server does not emulate a Lidar sensor. It just sends some simple scan data and response messages to a tcp client. It can be used for a quick unit test after build and install.</p>

<p>To build the test server, activate cmake option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> in CMakeLists.txt and rebuild sick_scan_xd. By default, option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> is switched off.</p>

<p>For a unit test of LMS1xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_lms1xx.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms1xx.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_lms_1xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS5xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_lms5xx.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms5xx.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS7xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_tim_7xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS7xxS, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>Alternatively, you can just run the test scripts provided in folder <code class="language-plaintext highlighter-rouge">sick_scan_xd/test/scripts</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd/test/scripts
./makeall.bash
./run_simu_lms1xx.bash
./run_simu_lms5xx.bash
./run_simu_tim7xx_tim7xxS.bash

</code></pre></div></div>

<p>Make sure to finish all sick_scan_xd nodes after a test. All nodes can be killed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosnode kill -a ; sleep 1
killall sick_generic_caller ; sleep 1
killall sick_scan_emulator ; sleep 1

</code></pre></div></div>

<h2 id="examples">Examples</h2>

<p>rviz example screenshots using sick_scan_xd with LMS1xx and LMS5xx test server:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/emulator_lms1xx_screenshot.png" alt="emulator_lms1xx_screenshot.png"></p>

<p>rviz example screenshots using sick_scan_xd with LMS7xx and LMS7xxS test server:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/emulator_lms7xx_screenshot.png" alt="emulator_lms1xx_screenshot.png"></p>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h1 id="simulation">Simulation</h1>

<p>For unittests without sensor hardware, a simple test server is provided. To build the test server, call either cmake with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code>, or activate cmake option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> in CMakeLists.txt. Then rebuild sick_scan_xd. By default, option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> is switched off.</p>

<p>Please note that this just builds a simple test server for basic unittests of sick_scan_xd drivers. Its purpose is to run basic tests and to help with diagnosis in case of issues. It does not emulate a real scanner!</p>

<p>Simulation requires jsoncpp. Install with <code class="language-plaintext highlighter-rouge">sudo apt-get install libjsoncpp-dev</code> on Linux and with <code class="language-plaintext highlighter-rouge">vcpkg install jsoncpp:x64-windows</code> on Windows.</p>

<p>You can find examples to test and run sick_scan_xd in offline mode in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>. Their purpose is to demonstrate the usage of the sick_scan_xd driver. Please feel free to customize the scripts or use them as a starting point for own projects.</p>

<h2 id="windows">Windows</h2>

<p>Run script <code class="language-plaintext highlighter-rouge">run_simu_lms_5xx.cmd</code> in folder <code class="language-plaintext highlighter-rouge">test/scripts</code> or execute the following commands:</p>

<ol>
  <li>Start the test server:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    cd .\build
    start "testserver" cmd /k python ../test/emulator/test_server.py --scandata_file=../test/emulator/scandata/20210302_lms511.pcapng.scandata.txt --scandata_frequency=20.0 --tcp_port=2112
    @timeout /t 1
    
</code></pre></div></div>

<ol>
  <li>Run sick_generic_caller. On native Windows:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    .\Debug\sick_generic_caller.exe ../launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>On Windows with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False
    
</code></pre></div></div>

<ol>
  <li>Open file <code class="language-plaintext highlighter-rouge">image_viewer.html</code> in folder <code class="language-plaintext highlighter-rouge">demo</code> in your browser to view a jpg-image of the current scan.</li>
</ol>

<p>Note, that python version 3 incl. runtime dlls must be accessable, f.e. by extending the PATH environment variable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PYTHON_DIR=%ProgramFiles(x86)%/Microsoft Visual Studio/Shared/Python37_64
set PATH=%PYTHON_DIR%;%PYTHON_DIR%/Scripts;c:\vcpkg\installed\x64-windows\bin;%PATH%

</code></pre></div></div>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h2 id="linux">Linux</h2>

<p>Run script <code class="language-plaintext highlighter-rouge">run_simu_lms_5xx.bash</code> in folder <code class="language-plaintext highlighter-rouge">test/scripts</code> or execute the following commands:</p>

<ol>
  <li>Start the test server:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    python3 ./test/emulator/test_server.py --scandata_file=./test/emulator/scandata/20210302_lms511.pcapng.scandata.txt --scandata_frequency=20.0 --tcp_port=2112 &amp;
    sleep 1
    
</code></pre></div></div>

<ol>
  <li>Run sick_generic_caller.
    <ul>
      <li>On native Linux:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        ./build/sick_generic_caller ./launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 1:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>

<ol>
  <li>View the point cloud.
    <ul>
      <li>On native Linux:<br>
   Open file <code class="language-plaintext highlighter-rouge">image_viewer.html</code> in folder <code class="language-plaintext highlighter-rouge">demo</code> in a browser (f.e. firefox) to view a jpg-image of the current scan.</li>
      <li>On Linux with ROS 1:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg_lms5xx.rviz &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_lms5xx.rviz &amp;
        
</code></pre></div></div>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h1 id="profiling">Profiling</h1>

<p>Since the existing node can basically be used on different platforms, bottlenecks can occur with weak hardware. To better analyze these bottlenecks, software profiling can be performed.
The following example shows how to perform profiling.
For further details on profiling, please refer to https://baptiste-wicht.com/posts/2011/09/profile-c-application-with-callgrind-kcachegrind.html, for example.</p>

<h2 id="installation">Installation</h2>

<p>First of all, you need to install Callgrind and KCachegrind.
You also need to install graphviz in order to view the call graph in KCachegrind. The applications are already packaged for the most important Linux distributions. You can just use apt-get to install them:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install valgrind kcachegrind graphviz

</code></pre></div></div>
<h2 id="usage">Usage</h2>
<p>We have to start by profiling the application with Callgrind. To profile an application with Callgrind, you just have to prepend the Callgrind invocation in front of your normal program invocation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind --tool=callgrind program [program_options]

</code></pre></div></div>
<p>In order to establish a reference to the source code during profiling, the program must be compiled with debug symbols, this can be done with catkin_make</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catkin_make install -DCMAKE_BUILD_TYPE=Debug

</code></pre></div></div>
<p>It is necessary to create a rosmaster so that the sick_scan_xd node can connect to it because we can’t use roslaunch during profiling.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roscore

</code></pre></div></div>
<p>To set the parameters we start a node as usual with roslaunch.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=192.168.0.151

</code></pre></div></div>
<p>While this node is running we can use
<code class="language-plaintext highlighter-rouge">ps -aef| grep sick_scan_xd
</code> to determine the program path and the call parameters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosuser@ROS-NB:~$ ps -aef|grep sick_scan_xd
rosuser   4839  2443  0 14:43 pts/1    00:00:00 /usr/bin/python /opt/ros/melodic/bin/roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=192.168.0.151
rosuser   4854  4839  1 14:43 ?        00:00:03 /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller __name:=sick_lms_5xx __log:=/home/rosuser/.ros/log/f9861670-304c-11e9-9839-54e1ad2921b6/sick_lms_5xx-1.log
rosuser   4910  4875  0 14:46 pts/6    00:00:00 grep --color=auto sick_scan_xd

</code></pre></div></div>
<p>now we can close the node and restart with callgrid</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind --tool=callgrind program /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller __name:=sick_lms_5xx

</code></pre></div></div>
<p>The result will be stored in a callgrind.out.XXX file where XXX will be the process identifier.
You can read this file using a text editor, but it won’t be very useful because it’s very cryptic.
That’s here that KCacheGrind will be useful. You can launch KCacheGrind using command line
or in the program menu if your system installed it here. Then, you have to open your profile file.</p>

<p>The first view present a list of all the profiled functions. You can see the inclusive
and the self cost of each function and the location of each one.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/src_view.png" alt="src_view.png"></p>

<p>Once you click on a function, the other views are filled with information. The view in uppper right part of the window gives some information about the selected function.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/profile_002.png" alt="profile_002"></p>

<p>The view have several tabs presenting different information:</p>

<ul>
  <li>Types : Present the types of events that have been recorded. In our case, it’s not really interesting, it’s just the number of instructions fetch</li>
  <li>Callers : List of the direct callers.</li>
  <li>All Callers : List of all the callers, it seems the callers and the callers of the callers.</li>
  <li>Callee Map : A map of the callee, personally, I do not really understand this view, but it’s a kind of call graph representing the cost of the functions.</li>
  <li>Source code : The source code of the function if the application has been compiled with the debug symbol.</li>
</ul>

<p>And finally, you have another view with data about the selected function.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/profile_003.png" alt="profile_003"></p>

<p>Again, several tabs:</p>

<ul>
  <li>Callees : The direct callees of the function</li>
  <li>Call Graph : The call graph from the function to the end</li>
  <li>All Callees : All the callees and the callees of the callees</li>
  <li>Caller Map : All functions are represented as blocks the size corresponds to their CPU time. Callees are stacked on the callers.</li>
  <li>Machine Code : The machine code of the function if the application has been profiled with –dump-instr=yes option</li>
</ul>

<p>You have also several display options and filter features to find exactly what you want and display it the way you want.</p>

<p>The information provided by KCacheGrind can be very useful to find which functions takes too much time or which functions are called too much.
This text is an adopted version of https://baptiste-wicht.com/posts/2011/09/profile-c-application-with-callgrind-kcachegrind.html . Thanks to Baptiste Wicht.</p>
</div>
              <hr id="humble-contribute-lists">
              <ul class="nav nav-tabs nav-justified" id="humble-contribute-lists-tabs">
                <li class="better-tabs active">
                  <a href="#humble-contribute-lists-help-wanted" data-toggle="tab"><span class="contribute-lists-help-wanted-count label label-primary">0</span> Help Wanted</a>
                </li>
                <li class="better-tabs">
                  <a href="#humble-contribute-lists-good-first-issue" data-toggle="tab"><span class="contribute-lists-good-first-issue-count label label-primary">0</span> Good First Issue</a>
                </li>
                <li class="better-tabs">
                  <a href="#humble-contribute-lists-pull-requests" data-toggle="tab"><span class="contribute-lists-pull-requests-count label label-primary">0</span> Pull Requests to Review</a>
                </li>
              </ul>
              <div class="tab-content contribute-lists">
                <div class="tab-pane active" id="humble-contribute-lists-help-wanted">
                  <div class="contribute-lists-help-wanted"></div>
                </div>
                <div class="tab-pane" id="humble-contribute-lists-good-first-issue">
                  <div class="contribute-lists-good-first-issue"></div>
                </div>
                <div class="tab-pane" id="humble-contribute-lists-pull-requests">
                  <div class="contribute-lists-pull-requests"></div>
                </div>
              </div>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-jazzy">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/sick_scan_xd">sick_scan_xd</a> <small>repository</small></h3>
        <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        
        <a class="label label-primary pkg-label" href="/p/sick_scan_xd">sick_scan_xd</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-SICKAG-sick_scan_xd
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-SICKAG-sick_scan_xd" role="menuitem" tabindex="-1" href="/r/sick_scan_xd/github-SICKAG-sick_scan_xd" data="github-SICKAG-sick_scan_xd">
                    <span class="glyphicon glyphicon-star"></span>
                    github-SICKAG-sick_scan_xd
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">A versatile driver for a wide range of SICK LiDAR and RADAR devices, providing support for both Linux (native, ROS 1, ROS 2) and Windows (native, ROS 2) platforms.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/SICKAG/sick_scan_xd.git">https://github.com/SICKAG/sick_scan_xd.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">develop</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-04-03
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/sick_scan_xd/#jazzy-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/sick_scan_xd/#jazzy-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/sick_scan_xd/#jazzy-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/sick_scan_xd">sick_scan_xd</a></td>
                    <td>3.6.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<p><img align="right" width="200" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Logo_SICK_AG_2009.svg/1200px-Logo_SICK_AG_2009.svg.png"></p>

<h2 id="executive-summary">Executive Summary</h2>

<p>This project provides a driver for the SICK LiDARs and Radar sensors mentioned <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#supported-sick-devices">here</a>. The driver supports both Linux (native, ROS 1, ROS 2) and Windows (native and ROS 2). See the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/CHANGELOG.md">CHANGELOG.md</a> for the latest updates.</p>

<p><strong>Main features and characteristics</strong></p>
<ul>
  <li>Support of ROS 1 (Linux), ROS 2 (Linux and Windows)</li>
  <li>Generic C/C++ and python API for usage without ROS (Linux and Windows)</li>
  <li>SLAM support</li>
  <li>Compatible with x64 and ARM64 architecture (incl. Raspberry Pi)</li>
  <li>No dependencies to 3rd party libraries like boost</li>
</ul>

<h2 id="table-of-contents">Table of Contents</h2>

<details>
  <summary>Expand to full table of contents </summary>

- [Repository organization](#repository-organization)
- [Supported SICK Devices](#supported-sick-devices)
- [Getting started](#getting-started)
  - [Detecting SICK devices in the network](#detecting-sick-devices-in-the-network)
  - [Change IP address](#change-ip-address)
  - [Starting with a new lidar](#starting-with-a-new-lidar)
  - [Test connection (Linux)](#test-connection-linux)
- [Building the driver](#building-the-driver)
  - [Build on Linux ROS 1](#build-on-linux-ros-1)
    - [Install prebuilt binaries](#install-prebuilt-binaries)
    - [Build from sources](#build-from-sources)
  - [Build on Linux ROS 2](#build-on-linux-ros-2)
    - [Install prebuilt binaries](#install-prebuilt-binaries-1)
    - [Build from sources](#build-from-sources-1)
  - [Build on Windows ROS 2](#build-on-windows-ros-2)
  - [Build on Linux generic without ROS](#build-on-linux-generic-without-ros)
  - [Build on Windows generic without ROS](#build-on-windows-generic-without-ros)
- [Running the driver](#running-the-driver)
  - [Starting Scanner with Specific IP Address](#starting-scanner-with-specific-ip-address)
  - [Start Multiple Nodes](#start-multiple-nodes)
  - [Common parameters](#common-parameters)
  - [Further useful parameters and features](#further-useful-parameters-and-features)
  - [ROS services](#ros-services)
  - [Driver states, timeouts](#driver-states-timeouts)
  - [SOPAS Mode](#sopas-mode)
  - [Example Startup Sequence](#example-startup-sequence)
- [Driver features and additional information](#driver-features-and-additional-information)
  - [Software Overview](#software-overview)
    - [Software structure](#software-structure)
    - [Message receiving and message handling](#message-receiving-and-message-handling)
    - [sick\_scansegment\_xd](#sick_scansegment_xd)
    - [Files and folders](#files-and-folders)
  - [Generic Driver API](#generic-driver-api)
    - [Overview](#overview)
    - [Build and test shared library](#build-and-test-shared-library)
    - [Usage example](#usage-example)
    - [C-API](#c-api)
    - [Useful links](#useful-links)
  - [Timestamps and synchronization (Software PLL)](#timestamps-and-synchronization-software-pll)
  - [Coordinate transforms](#coordinate-transforms)
  - [IMU Support](#imu-support)
  - [Encoders](#encoders)
    - [Connecting encoders](#connecting-encoders)
    - [Example circuit to trigger encoder counts](#example-circuit-to-trigger-encoder-counts)
    - [Activation of encoder information](#activation-of-encoder-information)
  - [Field Evaluation Information](#field-evaluation-information)
    - [Field monitoring messages](#field-monitoring-messages)
    - [Visualization with rviz](#visualization-with-rviz)
    - [Cola commands](#cola-commands)
    - [Tools, emulation and unittests](#tools-emulation-and-unittests)
  - [SLAM Support](#slam-support)
    - [Introduction](#introduction)
    - [Measuring Principle](#measuring-principle)
    - [NAV350 ROS 1 SLAM example](#nav350-ros-1-slam-example)
    - [NAV350 ROS 2 SLAM example](#nav350-ros-2-slam-example)
    - [picoScan100 ROS 1 SLAM example](#picoscan100-ros-1-slam-example)
    - [MRS1104 SLAM support](#mrs1104-slam-support)
    - [Google Cartographer](#google-cartographer)
    - [OctoMap](#octomap)
    - [RTAB-Map](#rtab-map)
  - [Raspberry Pi Support](#raspberry-pi-support)
    - [multiScan100 example](#multiscan100-example)
    - [Performance](#performance)
    - [Troubleshooting](#troubleshooting)
  - [More Tools](#more-tools)
- [Device specific information](#device-specific-information)
  - [picoScan100/multiScan100](#picoscan100multiscan100)
    - [Configuration](#configuration)
    - [IMU support](#imu-support-1)
    - [SOPAS support](#sopas-support)
    - [Run multiScan100 and picoScan100 simultaneously](#run-multiscan100-and-picoscan100-simultaneously)
    - [Visualization](#visualization)
    - [PointCloud memory layout](#pointcloud-memory-layout)
    - [Customized point clouds](#customized-point-clouds)
    - [Customized point clouds on a Raspberry Pi](#customized-point-clouds-on-a-raspberry-pi)
    - [MSGPACK validation](#msgpack-validation)
    - [Firewall configuration](#firewall-configuration)
    - [SOPAS support for sick\_scan\_segment\_xd](#sopas-support-for-sick_scan_segment_xd)
  - [TiM781 and TiM781S](#tim781-and-tim781s)
  - [TiM240](#tim240)
  - [NAV350](#nav350)
    - [Process loop](#process-loop)
    - [Initialization and setup](#initialization-and-setup)
    - [Messages](#messages)
    - [Odometry messages](#odometry-messages)
    - [Angle compensation](#angle-compensation)
  - [MRS6124](#mrs6124)
    - [Timing between Layers](#timing-between-layers)
    - [MRS600 with RMS1000](#mrs600-with-rms1000)
  - [RMS1000](#rms1000)
    - [Raw Targets](#raw-targets)
    - [Tracking Objects](#tracking-objects)
    - [ROS message for Radar](#ros-message-for-radar)
    - [Launch Files](#launch-files)
    - [Parameter for Radar Usage](#parameter-for-radar-usage)
    - [Radar Datagram](#radar-datagram)
  - [RMS1000 and LMS1000 combination](#rms1000-and-lms1000-combination)
  - [LMS1000 and MRS1000 interlacing](#lms1000-and-mrs1000-interlacing)
- [FAQ](#faq)
  - [General](#general)
  - [Networking](#networking)
  - [multiScan100 / picoScan100](#multiscan100--picoscan100)
- [Troubleshooting and technical support](#troubleshooting-and-technical-support)
- [Creators and contribution](#creators-and-contribution)
- [Keywords](#keywords)


</details>

<h1 id="repository-organization">Repository organization</h1>

<p>The repository supports two main branches. The <strong>“master”</strong> branch is the branch that contains official releases that are tagged and versioned and also included in the ROS distribution. If you want to work with this official branch, you must explicitly specify this branch in the ‘git clone’ command by adding “-b master”. The “develop” branch is the default branch and contains the latest development status.</p>

<p>Example:</p>

<p>Checking out the latest revision (usually older than the develop version, but officially released):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone -b master https://github.com/SICKAG/sick_scan_xd.git

</code></pre></div></div>

<p>Checking out the latest development status:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/SICKAG/sick_scan_xd.git

</code></pre></div></div>

<h1 id="supported-sick-devices">Supported SICK Devices</h1>

<p>The driver supports Ethernet-IPv4-based communication with all of the following SICK products.</p>

<table>
  <thead>
    <tr>
      <th>2D LiDAR sensors</th>
      <th>Part no.</th>
      <th>3D LiDAR sensors</th>
      <th>Part no.</th>
      <th>RADAR sensors</th>
      <th>Part no.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>picoScan100 <a href="https://support.sick.com/sick-knowledgebase/article/?code=KA-09438">(supports native ROS 2 as well)</a>
</td>
      <td><a href="https://www.sick.com/de/en/search?text=1134610">e.g. 1134610</a></td>
      <td>multiScan100</td>
      <td><a href="https://www.sick.com/de/en/search?text=1131164">e.g. 1131164</a></td>
      <td>RMS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1107598">e.g. 1107598</a></td>
    </tr>
    <tr>
      <td>LRS4000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1098855">e.g. 1098855</a></td>
      <td>MRS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1081208">e.g. 1081208</a></td>
      <td>RMS2000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1129088">e.g. 1129088</a></td>
    </tr>
    <tr>
      <td>TiM2xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1104981">1104981</a></td>
      <td>MRS6124</td>
      <td><a href="https://www.sick.com/de/en/search?text=6065086">6065086</a></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM5xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060445">e.g. 1060445</a></td>
      <td>LD-MRS</td>
      <td><a href="https://www.sick.com/de/de/p/p662073">e.g. 1115128</a></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM7xxS</td>
      <td><a href="https://www.sick.com/de/en/search?text=1105052">e.g. 1105052</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM7xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1096807">e.g 1096807</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS5xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1046135">e.g. 1046135</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1092445">1092445</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS1xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1041114">e.g. 1041114</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS4000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1091423">e.g. 1091423</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LD-LRS</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060831">e.g. 1060831</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LD-OEM</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060828">e.g. 1060828</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV3xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060834">e.g. 1060834</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV2xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1074308">e.g. 1074308</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS family is currently not supported on Windows.</li>
    <li>ROS services require installation of ROS 1 or ROS 2.</li>
    <li>ROS services are currently not available for LD-MRS.</li>
    <li>Publishing point cloud data requires ROS 1 or ROS 2. On native Linux and native Windows, point cloud data are exported via API</li>
    <li>The driver is not tested on MAC</li>
  </ul>
</blockquote>

<h1 id="getting-started">Getting started</h1>

<p>Run the following steps for a quick start:</p>

<ol>
  <li>
    <p>Create a workspace (e.g. folder <code class="language-plaintext highlighter-rouge">sick_scan_ws</code>), clone the sick_scan_xd repository and build sick_generic_caller and shared library:</p>

    <ul>
      <li>For <strong>Linux without ROS</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-generic-without-ros">build instructions for Linux generic without ROS</a>
</li>
      <li>For <strong>Linux with ROS 1</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-ros-1">build instructions for Linux ROS 1</a>
</li>
      <li>For <strong>Linux with ROS 2</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-ros-2">build instructions for Linux ROS 2</a>
</li>
      <li>For <strong>Windows without ROS</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-windows-generic-without-ros">build instructions for Windows without ROS</a>
</li>
      <li>For <strong>Windows with ROS 2</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-windows-ros-2">build instructions for Windows with ROS 2</a>
</li>
    </ul>
  </li>
  <li>
    <p>Connect your lidar. Check the network connection by <code class="language-plaintext highlighter-rouge">ping &lt;lidar-ip-address&gt;</code>.</p>
  </li>
  <li>
    <p>Run the sick_scan_xd driver:</p>

    <p>For <strong>Linux without ROS</strong>: Use the sick_scan_xd API and run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to the build folder
      ./build/sick_scan_xd_api_test ./sick_scan_xd/launch/sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Linux with ROS 1</strong>: Launch sick_scan_xd: <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      source ./devel_isolated/setup.bash
      roslaunch sick_scan_xd sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Linux with ROS 2</strong>: Run <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      source ./install/setup.bash
      ros2 launch sick_scan_xd sick_tim_7xx.launch.py hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Windows without ROS</strong>: Use the sick_scan_xd API and run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd .\sick_scan_ws\sick_scan_xd
      set PATH=.;.\build;..\build\Debug;%PATH%
      .\build\Debug\sick_scan_xd_api_test.exe launch/sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Windows with ROS 2</strong>: Run <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd .\sick_scan_ws
      call .\install\setup.bat
      ros2 launch sick_scan_xd sick_tim_7xx.launch.py hostname:=192.168.0.1
      
</code></pre></div></div>

<h2 id="detecting-sick-devices-in-the-network">Detecting SICK devices in the network</h2>

<p>The Python script</p>

<pre><code class="language-sick_scan_xd/tools/sick_generic_device_finder/sick_generic_device_finder.py">
</code></pre>
<p>sends a UDP broadcast to which all available scanners respond with a device description.
The variable
<code class="language-plaintext highlighter-rouge">UDP_IP = "192.168.0.255"
</code> defines the broadcast address used by the script.
If you are using a different IP address configuration on your host pc you have to change this variable according to the broadcast address of your network card.</p>

<pre><code class="language-ifconfig">``` shows the broadcast address for every network adapter.

## Change IP address

The IP address of the device can be changed with a customized launch file. The following launch sequence is an example:

```roslaunch sick_scan_xd sick_new_ip.launch hostname:=192.168.0.1 new_IP:=192.168.0.100
</code></pre>

<p>The launch file restarts the lidar after the address change and stops the sick_scan_xd node. After a few seconds of booting time the scanner is reachable under the new IP address. The Python script is experimental. It is known that some ethernet adapter are not fully supported. As a fallback solution you can always use the SOPAS ET software under windows.</p>

<h2 id="starting-with-a-new-lidar">Starting with a new lidar</h2>

<p>The lidar is delivered with a standard IP address, to read or change it the <a href="https://www.sick.com/de/de/sopas-engineering-tool-2018/p/p367244">SICK SOPAS ET</a> for windows can be used.
When the tool is started, a search is performed which lists all scanners available in the network.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/scanner_found.PNG" alt="SOPAS start" title="SOPAS start"></p>

<p>Double-click to select the scanner for the project</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/scanner_added.PNG" alt="SOPAS select" title="SOPAS select"></p>

<p>Double click on the lidar icon to open the configuration menu of the scanner. Select here the network configuration menu and set the parameters by clicking on the save icon (red arrow)</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/set_config.PNG" alt="SOPAS save network" title="SOPAS save network"></p>

<p>To ensure that the settings are stored even after a power cycle, they must be stored in the eeprom. To do this, click on the eeprom icon and confirm the save.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/save_permanent.PNG" alt="SOPAS save eeprom" title="SOPAS save eeprom"></p>

<p>To test the settings under Windows use the commands</p>
<pre><code class="language-ipconfig">``` and 
```ping
``` in the 
```cmd.exe
```. Make sure that the lidar and host pc have different IP addresses e.g. 192.168.0.1 for the pc and 192.168.0.2 for the scanner.

## Test connection (Linux)

to test the settings under the Linux target system you can use netcat to check if a TCP connection to the scanner can be established

```nc -z -v -w5 $SCANNERIPADDRESS 2112
</code></pre>
<p>the connection can be successfully established</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/nc_scanner.PNG" alt="Linux netcat scanner" title="linux netcat scanner"></p>

<p>unlike a ping, the connection attempt to the host PC is not successful</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/nc_win_host.PNG" alt="Linux netcat host" title="linux netcat host"></p>

<h1 id="building-the-driver">Building the driver</h1>

<p>sick_scan_xd can be build on 64-bit Linux and Windows, with and without ROS, with and without LDMRS. The following table shows the allowed combinations and how to build. sick_scan_xd supports 64 bit Linux and Windows, 32 bit systems are not supported.</p>

<table>
  <thead>
    <tr>
      <th><strong>target</strong></th>
      <th><strong>cmake settings</strong></th>
      <th><strong>build script</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linux, native, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_linux.bash</td>
    </tr>
    <tr>
      <td>Linux, native, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_linux_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 1, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros1.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 1, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros1_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 2, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros2.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 2, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros2_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Windows, native, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test\scripts &amp;&amp; make_win64.cmd</td>
    </tr>
    <tr>
      <td>Windows, ROS 2, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test\scripts &amp;&amp; make_ros2.cmd</td>
    </tr>
  </tbody>
</table>

<p>If you’re using ROS, set your ROS-environment before running one of these scripts, f.e.
<code class="language-plaintext highlighter-rouge">source /opt/ros/noetic/setup.bash</code> for ROS 1 noetic, or
<code class="language-plaintext highlighter-rouge">source /opt/ros/foxy/setup.bash</code> for ROS 2 foxy, or
<code class="language-plaintext highlighter-rouge">source /opt/ros/humble/setup.bash</code> for ROS 2 humble.
See the build descriptions for more details.</p>

<h2 id="build-on-linux-ros-1">Build on Linux ROS 1</h2>

<p>To build resp. install sick_scan_xd on Linux with ROS 1, you can build sick_scan_xd from sources or install prebuilt binaries.</p>

<h3 id="install-prebuilt-binaries">Install prebuilt binaries</h3>

<p>Run the following steps to install sick_scan_xd on Linux with ROS 1 noetic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-noetic-sick-scan-xd

</code></pre></div></div>

<p>After successful installation, you can run sick_scan_xd using <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd &lt;launchfile&gt;</code>, e.g. <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_picoscan.launch</code> for picoScan. sick_scan_xd can be removed by <code class="language-plaintext highlighter-rouge">sudo apt-get remove ros-noetic-sick-scan-xd</code>.</p>

<h3 id="build-from-sources">Build from sources</h3>

<p>Run the following steps to build sick_scan_xd on Linux with ROS 1:</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir ./src
   pushd ./src
   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   rm -rf ./build ./build_isolated/ ./devel ./devel_isolated/ ./install ./install_isolated/ ./log/ # remove any files from a previous build
   
</code></pre></div></div>
<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   source /opt/ros/noetic/setup.bash # replace noetic by your ros distro
   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
   source ./devel_isolated/setup.bash
   # source ./install_isolated/setup.bash
   
</code></pre></div></div>
<p>For ROS versions other than noetic, please replace <code class="language-plaintext highlighter-rouge">source /opt/ros/noetic/setup.bash</code> with your ros distribution.</p>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DRASPBERRY=1 -Wno-dev
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call catkin_make_isolated with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -Wno-dev
   
</code></pre></div></div>

<p>To build sick_generic_caller without multiScan136/sick_scansegment_xd/picoScan150 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DSCANSEGMENT_XD=0 -Wno-dev
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build <strong>without LDMRS</strong> and <strong>without multiScan100/picoScan100 support</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DSCANSEGMENT_XD=0 -Wno-dev
   
</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<p><strong>Build options</strong></p>

<p><strong>Without LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DSCANSEGMENT_XD=0 -Wno-dev

</code></pre></div></div>
<p><strong>Without LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -Wno-dev

</code></pre></div></div>
<p><strong>with LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DSCANSEGMENT_XD=0 -Wno-dev

</code></pre></div></div>
<p><strong>with LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev

</code></pre></div></div>

<p>To create source code documentation by doxygen, run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-linux-ros-2">Build on Linux ROS 2</h2>

<p>To build resp. install sick_scan_xd on Linux with ROS 2, you can build sick_scan_xd from sources or install prebuilt binaries.</p>

<h3 id="install-prebuilt-binaries-1">Install prebuilt binaries</h3>

<p>Run the following steps to install sick_scan_xd on Linux with ROS 2 humble:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-humble-sick-scan-xd

</code></pre></div></div>

<p>After successful installation, you can run sick_scan_xd using <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt;.py</code>, e.g. <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py</code> for multiScan. sick_scan_xd can be removed by <code class="language-plaintext highlighter-rouge">sudo apt-get remove ros-humble-sick-scan-xd</code>.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> ROS 2 humble Debian packages require Ubuntu 22 or newer, see https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html for system requirements.</p>
</blockquote>

<h3 id="build-from-sources-1">Build from sources</h3>

<p>Run the following steps to build sick_scan_xd on Linux with ROS 2:</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir ./src
   pushd ./src
   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   rm -rf ./build ./build_isolated/ ./devel ./devel_isolated/ ./install ./install_isolated/ ./log/ # remove any files from a previous build
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   source /opt/ros/foxy/setup.bash # replace foxy by your ros distro
   colcon build --packages-select libsick_ldmrs --event-handlers console_direct+
   source ./install/setup.bash
   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" --event-handlers console_direct+
   source ./install/setup.bash
   
</code></pre></div></div>
<p>For ROS versions other than foxy, please replace <code class="language-plaintext highlighter-rouge">source /opt/ros/foxy/setup.bash</code> with your ros distribution.</p>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DRASPBERRY=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call colcon with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" --event-handlers console_direct+
   
</code></pre></div></div>
<p>To build sick_generic_caller without multiScan136/sick_scansegment_xd/picoScan150 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build <strong>without LDMRS</strong> and <strong>without multiScan100/picoScan100 support</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>Depending on the ROS 2 distribution, package diagnostic_updater might not be found (compiler error: <code class="language-plaintext highlighter-rouge">diagnostic_updater.hpp not found</code>). In this case package diagnostic_updater has to be installed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install ros-${ROS_DISTRO}-diagnostic-updater
sudo apt install ros-${ROS_DISTRO}-diagnostic-msgs
# E.g. to install diagnostic_updater on foxy, run
# sudo apt-get install ros-foxy-diagnostic-updater
# sudo apt install ros-foxy-diagnostic-msgs

</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<p><strong>Build options</strong></p>

<p><strong>Without LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>Without LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>with LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>with LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " --event-handlers console_direct+

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong> To create source code documentation by doxygen, run</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-windows-ros-2">Build on Windows ROS 2</h2>

<p>To install sick_scan_xd on Windows with ROS 2, follow the steps below:</p>

<ol>
  <li>
    <p>If not yet done, install Visual Studio. Visual Studio 2019 Community or Professional Edition is recommended.</p>
  </li>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir sick_scan_ws
   cd sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repository https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir .\src
   pushd .\src
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   
</code></pre></div></div>

<ol>
  <li>Set the ROS 2 and Visual-Studio environment:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   call "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\Common7\Tools\VsDevCmd.bat" -arch=amd64 -host_arch=amd64
   call C:\opt\ros\foxy\x64\setup.bat
   
</code></pre></div></div>
<p>This step depends on your local ROS 2 and Visual-Studio installation. Please replace <code class="language-plaintext highlighter-rouge">C:\opt\ros\foxy\x64\setup.bat</code> with your ROS 2 version and adapt the path to the Visual Studio folder if your installation is different.</p>

<ol>
  <li>Cleanup to insure a complete rebuild:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   rmdir /s/q .\build
   rmdir /s/q .\install
   rmdir /s/q .\log
   del /f/q .\src\CMakeLists.txt
   
</code></pre></div></div>
<p>This step is only required for a complete rebuild. A complete rebuild is recommended e.g. after an update of the sick_scan_xd sources.</p>

<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" --event-handlers console_direct+
   call .\install\setup.bat
   
</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS sensors are currently not supported on Windows.</li>
    <li>To build sick_generic_caller without multiScan136/sick_scansegment_xd support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<h2 id="build-on-linux-generic-without-ros">Build on Linux generic without ROS</h2>

<p>Run the following steps to build sick_scan_xd on Linux (no ROS required):</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   
</code></pre></div></div>

<ol>
  <li>Build libsick_ldmrs (required only once for LD-MRS sensors):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   pushd libsick_ldmrs
   mkdir -p ./build
   cd ./build
   cmake -G "Unix Makefiles" ..
   make -j4
   sudo make -j4 install
   popd
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller and libsick_scan_xd_shared_lib.so:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./build
   pushd ./build
   rm -rf ./*
   export ROS_VERSION=0
   cmake -DROS_VERSION=0 -G "Unix Makefiles" ../sick_scan_xd
   make -j4
   sudo make -j4 install
   popd
   
</code></pre></div></div>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -DRASPBERRY=1 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>To build sick_generic_caller without multiScan100/picoScan100 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DSCANSEGMENT_XD=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build without LD-MRS and scansegment_xd support:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -DSCANSEGMENT_XD=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> To create source code documentation by doxygen, run</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-windows-generic-without-ros">Build on Windows generic without ROS</h2>

<p>To install sick_scan_xd on Windows, follow the steps below:</p>

<ol>
  <li>
    <p>If not yet done, install Visual Studio. Visual Studio 2019 Community or Professional Edition is recommended.</p>
  </li>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir sick_scan_ws
   cd sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repository https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller and sick_scan_xd_shared_lib.dll with cmake and Visual Studio 2019:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cd sick_scan_xd
   set _os=x64
   set _cmake_string=Visual Studio 16 2019
   set _msvc=Visual Studio 2019
   set _cmake_build_dir=build
   if not exist %_cmake_build_dir% mkdir %_cmake_build_dir%
   pushd %_cmake_build_dir%
   cmake -DROS_VERSION=0 -G "%_cmake_string%" ..
   cmake --build . --clean-first --config Debug
   cmake --build . --clean-first --config Release
   REM open sick_scan_xd.sln in Visual Studio 2019 for development and debugging
   popd
   
</code></pre></div></div>
<p>For development or debugging, open file <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\sick_scan_xd.sln</code> in Visual Studio. To install the library and header in the system folder, run <code class="language-plaintext highlighter-rouge">cmake --build . --target install</code> with admin privileges.</p>

<p>After successful build, binary files <code class="language-plaintext highlighter-rouge">sick_generic_caller.exe</code> and <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> are created in folders <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\Debug</code> and <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\Release</code>.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS sensors are currently not supported on Windows.</li>
    <li>To build sick_generic_caller without multiScan100/picoScan100 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DSCANSEGMENT_XD=0 -G "%_cmake_string%" ..
   
</code></pre></div></div>

<h1 id="running-the-driver">Running the driver</h1>

<p>The sick_scan_xd driver can be started on the command line by <code class="language-plaintext highlighter-rouge">sick_generic_caller &lt;launchfile&gt; [hostname:=&lt;ip-address&gt;]</code>. The start process varies slightly depending on the target OS:</p>

<p>On native Linux without ROS, call</p>

<p>```sick_generic_caller <launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On Linux with ROS 1, call

    
```./devel_isolated/setup.bash
</code></pre></div></div>

<p>```roslaunch sick_scan_xd <launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On Linux with ROS 2, call

    
```source ./install/setup.bash
</code></pre></div></div>

<p>```ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/<launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On native Windows without ROS, call

    
```sick_generic_caller &lt;launchfile&gt;
</code></pre></div></div>

<p>On Windows with ROS 2, call</p>

<p>```call .\install\setup.bat</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    
```ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/&lt;launchfile&gt;
</code></pre></div></div>

<p>Use the following commands to run the sick_scan_xd driver for a specific scanner type:</p>

<ul>
  <li>For MRS6124:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_6xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_mrs_6xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_6xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_6xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_6xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For MRS1104:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_1xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_mrs_1xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_1xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_1xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_1xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1104 with firmware 1.x:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1104 with firmware 2.x:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx_v2.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xxx_v2.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx_v2.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx_v2.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx_v2.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM240-prototype:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_240.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_240.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_240.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_240.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_240.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM5xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_5xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_5xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_5xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_5xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_5xx.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM7xx-family (no safety scanner):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM7xxS-family (safety scanner):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xxS.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xxS.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xxS.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xxS.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xxS.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS5xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_5xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_5xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_5xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS4xxx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_4xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_4xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_4xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_4xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_4xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS4000:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_4xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_4xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_4xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_4xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_4xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LDMRS-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_ldmrs.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_ldmrs.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_ldmrs.launch</code>
</li>
      <li>Note that LD-MRS are currently not supported on Windows</li>
    </ul>
  </li>
  <li>For LRS36x0:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x0.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS36x0 mounted upside down:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0_upside_down.launch</code>
  <br>For upside down mounted devices, the point cloud is rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>.</li>
    </ul>
  </li>
  <li>For LRS36x1:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x1.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS36x1 mounted upside down:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1_upside_down.launch</code>
</li>
    </ul>

    <p><br>For upside down mounted devices, the point cloud is rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>.</p>
  </li>
  <li>For LD-OEM15xx:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_oem_15xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_oem_15xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_oem_15xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_oem_15xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_oem_15xx.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV210 and NAV245:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_2xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_2xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_2xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_2xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_2xx.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV310:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_31x.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_31x.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_31x.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_31x.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_31x.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV350:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_350.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_350.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_350.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_350.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_350.launch</code>
</li>
    </ul>
  </li>
  <li>For RMS-family (RMS1xxx, RMS2xxx):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_rms_xxxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_rms_xxxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_rms_xxxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_rms_xxxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_rms_xxxx.launch</code>
</li>
    </ul>
  </li>
  <li>For multiScan136 (sick_scansegement_xd):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">hostname</code> is the ip-address of the lidar, <code class="language-plaintext highlighter-rouge">udp_receiver_ip</code> is the ip-address of the receiver (i.e. the ip of the computer running sick_generic_caller).</li>
    </ul>
  </li>
  <li>For picoScan150:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_picoscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_picoscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">hostname</code> is the ip-address of the lidar, <code class="language-plaintext highlighter-rouge">udp_receiver_ip</code> is the ip-address of the receiver (i.e. the ip of the computer running sick_generic_caller).</li>
    </ul>
  </li>
</ul>

<p>Common command line options are</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">hostname:=&lt;ip-address&gt;</code> to connect to a sensor with a given IP address. Default value is always the factory default IP address of the scanner.</li>
</ul>

<p>Further (common and scanner specific) options can be set via launch file, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#common-parameters">Common parameters</a> and configure the settings in the launch file corresponding to the scanner type.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> After modifying a launch-file, it has to be installed by running <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev</code>
to be located and used by <code class="language-plaintext highlighter-rouge">roslaunch</code>.</p>
</blockquote>

<p>On ROS 2 you can launch sick_generic_caller by python launch files, too. Use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 launch sick_scan_xd &lt;name&gt;.launch.py &lt;param&gt;:=&lt;value&gt;

</code></pre></div></div>
<p>E.g. for LMS-5xx: <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_lms_5xx.launch.py hostname:=192.168.0.1</code></p>

<p>The launch.py-files on ROS 2 passes the corresponding launch-file to the driver: <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lms_5xx.launch.py">sick_lms_5xx.launch.py</a> gives an example for LMS-5xx. Parameter can be overwritten</p>
<ul>
  <li>either by command line, e.g. <br> <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_lms_5xx.launch.py hostname:=192.168.0.1</code>,</li>
  <li>or by passing additional arguments in the launch.py-file, e.g. <br> <code class="language-plaintext highlighter-rouge">node = Node(package='sick_scan_xd', executable='sick_generic_caller', arguments=[launch_file_path, 'hostname:=192.168.0.1'])</code>
</li>
</ul>

<h2 id="starting-scanner-with-specific-ip-address">Starting Scanner with Specific IP Address</h2>

<p>To start the scanner with a specific IP address, option <code class="language-plaintext highlighter-rouge">hostname:=&lt;ip-address&gt;</code> can be used.
The hostname is the ip-address of the scanner, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71                         # Linux native
roslaunch sick_scan_xd sick_tim_5xx.launch hostname:=192.168.0.71                      # Linux ROS 1
ros2 run sick_scan_xd sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71   # Linux ROS 2
sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71                         # Windows native
ros2 run sick_scan_xd sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71   # Windows ROS 2

</code></pre></div></div>

<h2 id="start-multiple-nodes">Start Multiple Nodes</h2>

<p>Multiple nodes can be started to support multiple sensors. In this case, multiple instances of sick_scan_xd have to be started, each node with different name and topic. ROS 1 example to run two TiM 7xx devices with ip address <code class="language-plaintext highlighter-rouge">192.168.0.1</code> and <code class="language-plaintext highlighter-rouge">192.168.0.2</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1 &amp;
roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2 &amp;

</code></pre></div></div>

<p>On Linux with ROS 1, multiple nodes to support multiple sensors can be started by one launch file, too.
Take the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_tim_5xx_twin.launch">sick_tim_5xx_twin.launch</a> as an example.
Remapping the scan and cloud topics is essential to distinguish the scandata and provide TF information.</p>

<p>ROS 2 example to run two TiM 7xx devices with IP address <code class="language-plaintext highlighter-rouge">192.168.0.1</code> and <code class="language-plaintext highlighter-rouge">192.168.0.2</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1 &amp;
ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2 &amp;

</code></pre></div></div>

<p>To support multiple sensors, sick_scan_xd has to be started multiple times, with one sick_scan_xd-node for each sensor. By default, each sick_scan_xd-node connects to “192.168.0.1” and publishes its point cloud on topic “cloud”. Therefore both the node name, the ip-address of the sensor and the point cloud topic have to be configured differently for each node.</p>

<p>Node name, ip-address and point cloud topic can be configured in the launch-file or by command line argument:</p>

<p>Topic, nodename and ip configuration in a launch-file (example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;launch&gt;
        &lt;arg name="nodename" default="sick_tim_7xx"/&gt;
        &lt;arg name="hostname" default="192.168.0.1"/&gt;
        &lt;arg name="cloud_topic" default="cloud"/&gt;
        &lt;node name="$(arg nodename)" pkg="sick_scan_xd" type="sick_generic_caller" respawn="false" output="screen"&gt;
            &lt;param name="scanner_type" type="string" value="sick_tim_7xx"/&gt;
            &lt;param name="nodename" type="string" value="$(arg nodename)"/&gt;
            &lt;param name="hostname" type="string" value="$(arg hostname)"/&gt;
            &lt;param name="cloud_topic" type="string" value="$(arg cloud_topic)"/&gt;
    
</code></pre></div></div>

<p>Topic, node name and ip configuration by command line (ROS 1 example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1
    roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2
    
</code></pre></div></div>

<p>Topic, node name and IP configuration by command line (ROS 2 example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1
    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2
    
</code></pre></div></div>

<p>Scripts <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/scripts/run_linux_ros1_simu_tim7xx_twin.bash">run_linux_ros1_simu_tim7xx_twin.bash</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/scripts/run_linux_ros2_simu_tim7xx_twin.bash">run_linux_ros2_simu_tim7xx_twin.bash</a> show a complete example with emulation of two TiM7xx sensors and two sick_scan_xd nodes running concurrently using different nodenames and topics.</p>

<p>To run two multiScan100 or picoScan100 devices simultanously, each sick_scan_xd node must be configured with different lidar ip addresses and udp ports, different node names, different ros topics and frame ids for each point cloud. Therefore the following launch file parameter should be overwritten by individual settings for each lidar:</p>
<ul>
  <li>“hostname”: e.g. “192.168.0.190” and “192.168.0.98”</li>
  <li>“nodename”: e.g. sick_picoscan0” and “sick_picoscan1”</li>
  <li>“publish_frame_id”: e.g. “world0” and “world1”</li>
  <li>“publish_laserscan_segment_topic”: e.g. “scan0_segment” and “scan1_segment”</li>
  <li>“publish_laserscan_fullframe_topic”: e.g. “scan0_fullframe” and “scan1_fullframe”</li>
  <li>“imu_topic”: e.g. “imu0” and “imu1”</li>
  <li>“udp_port”: e.g. “56661” and “56662”</li>
  <li>“imu_udp_port”: e.g. “7503” and “7504”</li>
  <li>individual topics and frame ids for each customized point cloud, e.g.
    <ul>
      <li>replace all “topic=/cloud_” by “topic=/cloud0<em>” resp. “topic=/cloud1</em>”</li>
      <li>replace all “frameid=world” by “frameid=world0” resp. “frameid=world1”
It is recommend to first verify the launch file configurations separately for each picoScan100 before running them simultanously.</li>
    </ul>
  </li>
</ul>

<p>For picoScan100 and multiScan, parameter udp_receiver_ip must be set to the ip address of the PC running sick_scan_xd. It is recommend to use ip addresses in the same subnet.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The sick_scan_xd API does not support running multiple lidars simultaneously in a single process.** Currently the sick_scan_xd API does not support the single or multi-threaded use of 2 or more lidars in one process, since the sick_scan_xd library is not guaranteed to be thread-safe. To run multiple lidars simultaneously, we recommend using ROS or running sick_scan_xd in multiple and separate processes, so that each process serves one sensor.</p>
</blockquote>

<h2 id="common-parameters">Common parameters</h2>

<p>For the launch-file settings and the tag/values pairs the following keywords are supported:</p>

<table>
  <thead>
    <tr>
      <th>Keyword</th>
      <th>Meaning</th>
      <th>Default value</th>
      <th>Hint</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>scanner_type</td>
      <td>Scanner family</td>
      <td>???</td>
      <td>see list above</td>
    </tr>
    <tr>
      <td>min_ang</td>
      <td>Start scan angle in [rad]</td>
      <td>-2.3998277</td>
      <td> </td>
    </tr>
    <tr>
      <td>max_ang</td>
      <td>End scan angle in [rad]</td>
      <td>+2.3998277</td>
      <td> </td>
    </tr>
    <tr>
      <td>intensity_resolution_16bit</td>
      <td>Switch between 8Bit/16Bit</td>
      <td>“false”</td>
      <td>do not change</td>
    </tr>
    <tr>
      <td>hostname</td>
      <td>Ip address of scanner</td>
      <td>192.168.0.1</td>
      <td>change to scanner ip address in your network (see faq)</td>
    </tr>
    <tr>
      <td>port</td>
      <td>port number</td>
      <td>2112</td>
      <td>do not change, check firewall rules if there is blocking traffic</td>
    </tr>
    <tr>
      <td>timelimit</td>
      <td>Timelimit in [sec]</td>
      <td>5</td>
      <td>do not change</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">scanner_type</code>
Name of the used scanner. Usually this is also the name of the launch file. This entry is used to differentiate
between the various scanner properties within the software code.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">hostname</code>
IP-address of the scanner (default: 192.168.0.1)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">port</code>
IP-port of the scanner (default: 2112)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">min_ang</code>
Start angle in [rad]</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">max_ang</code>
End angle in [rad]</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">use_binary_protocol</code>
Switch between SOPAS Binary and SOPAS ASCII protocol</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">intensity</code>
Enable or disable transport of intensity values</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">intensity_resolution_16bit</code>
If true, the intensity values is transferred as 16 bit value. If false, as 8 bit value.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">min_intensity</code>
If min_intensity &gt; 0, all range values in a LaserScan message are set to infinity, if their intensity value is below min_intensity</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cloud_topic</code>
Topic name of the published pointcloud2 data</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">frame_id</code>
Frame id used for the published data</p>
  </li>
</ul>

<p>Tag/value pairs of the command line overwrite settings in the launch file.
The use of the parameters can be looked up in the launch files. This is also recommended as a starting point.</p>

<h2 id="further-useful-parameters-and-features">Further useful parameters and features</h2>

<ul>
  <li>
    <p><strong>Timestamps</strong>: If parameter<code class="language-plaintext highlighter-rouge">sw_pll_only_publish</code> is true (default), an internal Software PLL is used to sync the scan generation timestamps to system timestamps. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#timestamps-and-synchronization-software-pll">Timestamps and synchronization (Software PLL)</a> for details.</p>
  </li>
  <li>
    <p><strong>Angle compensation</strong>: For highest angle accuracy the NAV-Lidar series supports an <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#angle-compensation">angle compensation mechanism</a>.</p>
  </li>
  <li>
    <p><strong>Angle correction</strong>: MRS1000 lidars transmit accurate azimuth angles for each scan point. Therefore, the stride (angle increment) of the MRS1000 azimuth angles in polar and cartesian point clouds is not exactly constant. Since laserscan messages assume a constant angle increment, scan points in point cloud and laserscan messages have slightly different azimuth angles.</p>
  </li>
  <li>
    <p><strong>Field monitoring</strong>: The <strong>LMS1xx</strong>, <strong>LMS5xx</strong>, <strong>TiM7xx</strong> and <strong>TiM7xxS</strong> families have <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#field-evaluation-information">extended settings for field monitoring</a>.</p>
  </li>
  <li>
    <p><strong>Radar devices</strong>: For radar devices (RMS1000/RMS2000), radar raw targets or radar objects or both can be tracked and transmitted. You can activate parameter transmit_raw_targets, transmit_objects or both in the launch file:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   &lt;param name="transmit_raw_targets" type="bool" value="false"/&gt;
   &lt;param name="transmit_objects" type="bool" value="true"/&gt;
   
</code></pre></div></div>
<p>By default, radar objects are tracked.</p>

<ul>
  <li>
<strong>Coordinate transform</strong>: An optional coordinate transform can be applied to the point cloud. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#coordinate-transforms">coordinate transforms</a>) for details.</li>
</ul>

<h2 id="ros-services">ROS services</h2>

<p>On ROS 1 and ROS 2, services can be used to send COLA commands to the sensor. This can be very helpful for diagnosis, e.g. by querying the device status or its id.</p>

<p>Use the following examples to run a cola command on ROS 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_lms_5xx/ColaMsg "{request: 'sMN IsSystemReady'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sRN SCdevicestate'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sEN LIDinputstate 1'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sEN LIDoutputstate 1'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sMN LMCstartmeas'}"
rosservice call /sick_lms_5xx/SCdevicestate "{}" # query device state
rosservice call /sick_lms_5xx/SCreboot "{}"      # execute a software reset on the device
rosservice call /sick_lms_5xx/SCsoftreset "{}"   # save current parameter and shut down device

</code></pre></div></div>

<p>Use the following examples to run a cola command on ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN IsSystemReady'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN SCdevicestate'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sEN LIDinputstate 1'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sEN LIDoutputstate 1'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN LMCstartmeas'}"
ros2 service call /SCdevicestate sick_scan_xd/srv/SCdevicestateSrv "{}" # query device state
ros2 service call /SCreboot sick_scan_xd/srv/SCrebootSrv "{}"           # execute a software reset on the device
ros2 service call /SCsoftreset sick_scan_xd/srv/SCsoftresetSrv "{}"     # save current parameter and shut down device

</code></pre></div></div>

<p>Use ros service <code class="language-plaintext highlighter-rouge">SickScanExit</code> to stop the scanner and driver:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_nav_31x/SickScanExit "{}" # stop scanner and driver on ROS 1
ros2 service call /SickScanExit sick_scan_xd/srv/SickScanExitSrv "{}" # stop scanner and driver on ROS 2

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>The COLA commands are sensor specific. See the user manual and telegram listing for further details.</li>
    <li>ROS services require installation of ROS 1 or ROS 2, i.e. services for Cola commands are currently not supported on native Linux or native Windows.</li>
    <li>ROS services are currently not available for the LDMRS.</li>
    <li>ROS service “ColaMsg” should only be used for diagnosis. It is not recommended to change the lidar settings while the driver is running. Otherwise the driver settings can become different or inconsistant to the lidar settings. Restart the driver after changing lidar settings by SOAPS ET or SOPAS commands.</li>
    <li>Some SOPAS commands like <code class="language-plaintext highlighter-rouge">sMN SetAccessMode 3 F4724744</code> stop the current measurement. In this case, the driver restarts after a timeout (5 seconds by default). To process those SOPAS commands without restart, you can
      <ul>
        <li>send <code class="language-plaintext highlighter-rouge">sMN LMCstartmeas</code> and <code class="language-plaintext highlighter-rouge">sMN Run</code> to switch again into measurement mode within the timeout, or</li>
        <li>increase the driver timeout <code class="language-plaintext highlighter-rouge">read_timeout_millisec_default</code> in the launch-file.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Additional services can be available for specific lidars. Service “GetContaminationResult” is e.g. available for MRS1xxx, LMS1000 and multiScan:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ROS 1 example for service GetContaminationResult (LMS 1xxx)
rosservice call /sick_lms_1xxx/GetContaminationResult "{}"
# ROS 2 example for service GetContaminationResult (LMS 1xxx)
ros2 service call /GetContaminationResult sick_scan_xd/srv/GetContaminationResultSrv "{}"

</code></pre></div></div>

<p>Example sequence with stop and start measurement to set a particle filter (TiM-7xxx on ROS 1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LFPparticle'}" # response: "sRA LFPparticle \\x00\\x01\\xf4"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sWN LFPparticle 0101F4'}" # response: "sWA LFPparticle"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN LMCstartmeas'}"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN Run'}"

</code></pre></div></div>

<h2 id="driver-states-timeouts">Driver states, timeouts</h2>

<p>The driver runs in two different states:</p>

<ol>
  <li>
    <p>Initialization: The scanner is initialized and configured by a list of sopas commands</p>
  </li>
  <li>
    <p>Measurement: The scanner is operational, scandata are transmitted and the point cloud is published.
After start, the driver enters initialization mode. After successful initialization, the driver switches automatically into measurement mode.</p>
  </li>
</ol>

<p>The communication between driver and scanner is monitored. In case of communication timeouts, e.g. due to network problems, the TCP connection is reset and the scanner is re-initialized. The driver uses 3 different timeouts (i.e time since last message received from lidar):</p>

<ol>
  <li>
    <p>In measurement mode: If no messages arrive for 5 seconds [timeout 0], the TCP/IP connection is closed. After a short delay, the tcp connection is reopened and the driver switches to initialization mode and reinitializes the Lidar.</p>
  </li>
  <li>
    <p>In initialization mode: If no messages received after 120 sec [Timeout 1] the TCP/IP connection is closed. After a short delay, the tcp connection is reopened and the driver switches to initialization mode and reinitializes the Lidar.</p>
  </li>
  <li>
    <p>In any mode: If no messages received after 150 sec [Timeout 2] the driver terminates.</p>
  </li>
</ol>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The internal timer is reset on successful communication. i.e. the timeout refers to the time of the last message from the Lidar. If there was no message yet, then the time of programme start is used.</p>
</blockquote>

<p>All timeouts can be configured in the launchfile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="message_monitoring_enabled" type="bool" value="True" /&gt;      &lt;!-- Enable message monitoring with reconnect+reinit in case of timeouts, default: true --&gt;
&lt;param name="read_timeout_millisec_default" type="int" value="5000"/&gt;     &lt;!-- 5 sec read timeout in operational mode (measurement mode), default: 5000 milliseconds --&gt;
&lt;param name="read_timeout_millisec_startup" type="int" value="120000"/&gt;   &lt;!-- 120 sec read timeout during startup (sensor may be starting up, which can take up to 120 sec.), default: 120000 milliseconds --&gt;
&lt;param name="read_timeout_millisec_kill_node" type="int" value="150000"/&gt; &lt;!-- 150 sec point cloud timeout, ros node will be killed if no point cloud published within the last 150 sec., default: 150000 milliseconds --&gt;

</code></pre></div></div>

<p>The following diagram shows the transition between the driver states:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/./doc/driverStatesDiagram1.png" alt="driverStatesDiagram"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Timeout 2 (i.e. no lidar message after 150 seconds) terminates the driver. By default, the driver does not restart automatically. It is therefor recommended to run the driver within an endless loop, e.g. in bash:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while(true) ; do roslaunch sick_scan_xd &lt;launchfile&gt; [&lt;arguments&gt;] ; done

</code></pre></div></div>

<p>The following table summarizes the timeout parameter:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/./doc/timeout_parameter.png" alt="timeout_parameter"></p>

<p>Details of timeout settings:</p>

<ul>
  <li>
    <p>message_monitoring_enabled: Enable or disable timeouts and monitoring. Disabling deactivates any error handling in case of network problems. Recommended default value: True</p>
  </li>
  <li>
    <p>read_timeout_millisec_default: Read timeout in milliseconds in operational (measurement) mode. If no datagrams are received from lidar within 5 seconds (default), the TCP socket is closed and the lidar is reinitialized.</p>
  </li>
  <li>
    <p>read_timeout_millisec_startup: Read timeout in milliseconds during initialization after startup. If SOPAS commands are not responded within 120 seconds (default), the TCP socket is closed and lidar is reinitialized.</p>
  </li>
  <li>
    <p>read_timeout_millisec_kill_node: Pointcloud timeout in milliseconds in operational (measurement) mode. If the sick_scan_xd does not publish a point cloud within the last 150 seconds, the sick_scan_xd process is killed. Should never happen, but is the �last resort� to exit after any kind of error (e.g. socket hangs up and blocks after network trouble).</p>
  </li>
  <li>
    <p>All timeouts configured in milliseconds</p>
  </li>
  <li>To disable timeouts (not recommended):
    <ul>
      <li>Set message_monitoring_enabled = false, or</li>
      <li>Set timeouts to “infinite” values, i.e MAX_INT = 2147483647 milliseconds (24.9 days)</li>
    </ul>
  </li>
  <li>To disable point cloud monitoring (not recommended):
    <ul>
      <li>read_timeout_millisec_kill_node &lt;= 0 deactivates pointcloud monitoring</li>
    </ul>
  </li>
  <li>Parameter read_timeout_millisec_default and read_timeout_millisec_startup: value 0 and negative values are currently NOT mapped to other values, i.e. will cause an immediately timeout error. Use value 2147483647 or message_monitoring_enabled = false to deactivate read timeouts (not recommended)</li>
</ul>

<h2 id="sopas-mode">SOPAS Mode</h2>

<p>This driver supports both COLA-B (binary) and COLA-A (ASCII) communication with the laser scanner. Binary mode is activated by default, since this mode generates less network traffic and enables more compatibility to all scanners.
If the communication mode set in the scanner memory is different from that used by the driver, the scanner’s communication mode is changed. This requires a restart of the TCP-IP connection, which can extend the start time by up to 30 seconds.
There are two ways to prevent this:</p>
<ol>
  <li>Recommended:
    <ul>
      <li>Set the communication mode with the SOPAS ET software to binary and save this setting in the scanner’s EEPROM.</li>
      <li>Set “use_binary_protocol” to default value “true”.</li>
    </ul>
  </li>
  <li>Use the parameter “use_binary_protocol” to overwrite the default settings of the driver.</li>
</ol>

<h2 id="example-startup-sequence">Example Startup Sequence</h2>

<p>The following ROS boot protocol shows the typical start sequence when starting a SICK laser scanner. The MRS6124 is shown here as an example. However, the startup sequence is generally similar for all scanners.</p>

<p>After a firmware update, the following Quickcheck is performed:</p>
<ol>
  <li>Is the device accessible via ping?</li>
  <li>Can the device be started with the corresponding generic launch file?</li>
  <li>At the end of the launch process, the device switches to receive mode
 for scan data? Typically the last command sent is
<code class="language-plaintext highlighter-rouge">&lt;STX&gt;sEA LMDscandata \x01&lt;ETX&gt;
</code>.</li>
  <li>Check with rviz: Is it possible to see the Pointcloud2 data or similar? Is the shown data reasonable?</li>
  <li>Check the scan rate with the command</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic hz /cloud

</code></pre></div></div>
<ol>
  <li>Further inspection, if any, by dumping Pointcloud2 data.
The header is of particular interest here. A typical call can therefore look as follows:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic echo /cloud|grep frame -B 7 -A 26

</code></pre></div></div>
<p><strong>Example Sequence</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_mrs_6xxx.launch hostname:=192.168.0.25
... logging to /home/rosuser/.ros/log/75631922-6109-11e9-b76f-54e1ad2921b6/roslaunch-ROS-NB-10680.log
Checking log directory for disk usage. This may take awhile.
Press Ctrl-C to interrupt
Done checking log file disk usage. Usage is &lt;1GB.
started roslaunch server http://ROS-NB:40757/
SUMMARY
========
PARAMETERS
 * /rosdistro: melodic
 * /rosversion: 1.14.3
 * /sick_mrs_6xxx/filter_echos: 0
 * /sick_mrs_6xxx/hostname: 192.168.0.25
 * /sick_mrs_6xxx/max_ang: 1.047197333
 * /sick_mrs_6xxx/min_ang: -1.040216
 * /sick_mrs_6xxx/port: 2112
 * /sick_mrs_6xxx/range_max: 250.0
 * /sick_mrs_6xxx/range_min: 0.1
 * /sick_mrs_6xxx/scanner_type: sick_mrs_6xxx
 * /sick_mrs_6xxx/timelimit: 5
 * /sick_mrs_6xxx/use_binary_protocol: True
NODES
  /
    sick_mrs_6xxx (sick_scan_xd/sick_generic_caller)
auto-starting new master
process[master]: started with pid [10690]
ROS_MASTER_URI=http://localhost:11311
setting /run_id to 75631922-6109-11e9-b76f-54e1ad2921b6
process[rosout-1]: started with pid [10701]
started core service [/rosout]
process[sick_mrs_6xxx-2]: started with pid [10708]
[ INFO] [1555502887.036684738]: sick_generic_caller V. 001.003.016
[ INFO] [1555502887.036717573]: Program arguments: /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller
[ INFO] [1555502887.036725741]: Program arguments: __name:=sick_mrs_6xxx
[ INFO] [1555502887.036731933]: Program arguments: __log:=/home/rosuser/.ros/log/75631922-6109-11e9-b76f-54e1ad2921b6/sick_mrs_6xxx-2.log
[ INFO] [1555502887.048425000]: Found sopas_protocol_type param overwriting default protocol:
[ INFO] [1555502887.048956468]: Binary protocol activated
[ INFO] [1555502887.048984179]: Start initialising scanner [Ip: 192.168.0.25] [Port: 2112]
[ INFO] [1555502887.067528995]: Publishing laserscan-pointcloud2 to cloud
[ INFO] [1555502887.071035827]: Parameter setting for &lt;active_echo: 0&gt;
[ INFO] [1555502887.271739084]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0023&gt;sMN SetAccessMode 0x03 0xf4 0x72 0x47 0x44 CRC:&lt;0xb3&gt;
[ INFO] [1555502887.273290840]: Receiving: &lt;STX&gt;sAN SetAccessMode \x01&lt;ETX&gt;
[ INFO] [1555502887.473927858]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sWN EIHstCola 0x01 CRC:&lt;0x09&gt;
[ INFO] [1555502887.475365983]: Receiving: &lt;STX&gt;sWA EIHstCola &lt;ETX&gt;
[ INFO] [1555502887.675864993]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sMN LMCstopmeas CRC:&lt;0x10&gt;
[ INFO] [1555502888.199590269]: Receiving: &lt;STX&gt;sAN LMCstopmeas \x00&lt;ETX&gt;
[ INFO] [1555502888.400030148]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sRN DeviceIdent CRC:&lt;0x25&gt;
[ INFO] [1555502888.401393378]: Receiving: &lt;STX&gt;sRA DeviceIdent \x00\x08\x4d\x52\x53\x36\x31\x32\x34\x52\x00\x0a\x31\x2e\x31\x2e\x30\x2e\x35\x36\x35\x43&lt;ETX&gt;
[ INFO] [1555502888.401653485]: Deviceinfo MRS6124R V1.1.0.565C found and supported by this driver.
[ INFO] [1555502888.602062286]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0019&gt;sRN FirmwareVersion CRC:&lt;0x24&gt;
[ INFO] [1555502888.603444526]: Receiving: &lt;STX&gt;sRA FirmwareVersion \x00\x0a\x31\x2e\x31\x2e\x30\x2e\x35\x36\x35\x43&lt;ETX&gt;
[ INFO] [1555502888.804094446]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0017&gt;sRN SCdevicestate CRC:&lt;0x30&gt;
[ INFO] [1555502888.805521867]: Receiving: &lt;STX&gt;sRA SCdevicestate \x01&lt;ETX&gt;
[ INFO] [1555502889.006161400]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0010&gt;sRN ODoprh CRC:&lt;0x41&gt;
[ INFO] [1555502889.007613972]: Receiving: &lt;STX&gt;sRA ODoprh \x00\x00\x19\xf1&lt;ETX&gt;
[ INFO] [1555502889.209949897]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0010&gt;sRN ODpwrc CRC:&lt;0x52&gt;
[ INFO] [1555502889.211413041]: Receiving: &lt;STX&gt;sRA ODpwrc \x00\x00\x02\x55&lt;ETX&gt;
[ INFO] [1555502889.413742132]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0016&gt;sRN LocationName CRC:&lt;0x55&gt;
[ INFO] [1555502889.415205992]: Receiving: &lt;STX&gt;sRA LocationName \x00\x0b\x6e\x6f\x74\x20\x64\x65\x66\x69\x6e\x65\x64&lt;ETX&gt;
[ INFO] [1555502889.417205292]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMPoutputRange CRC:&lt;0x5e&gt;
[ INFO] [1555502889.418631134]: Receiving: &lt;STX&gt;sRA LMPoutputRange \x00\x01\x00\x00\x05\x15\x00\x04\xa3\x80\x00\x16\xe3\x60&lt;ETX&gt;
[ INFO] [1555502889.418830949]: Angle resolution of scanner is 0.13010 [deg]  (in 1/10000th deg: 0x515)
[ INFO] [1555502889.418907556]: MIN_ANG:   -1.040 [rad]  -59.600 [deg]
[ INFO] [1555502889.418975818]: MAX_ANG:    1.047 [rad]   60.000 [deg]
[ INFO] [1555502889.419156102]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0033&gt;sWN LMPoutputRange 0x00 0x01 0x00 0x00 0x05 0x15 0x00 0x04 0xa3 0x80 0x00 0x16 0xe3 0x60 CRC:&lt;0xd8&gt;
[ INFO] [1555502889.420488646]: Receiving: &lt;STX&gt;sWA LMPoutputRange &lt;ETX&gt;
[ INFO] [1555502889.420719836]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMPoutputRange CRC:&lt;0x5e&gt;
[ INFO] [1555502889.421994443]: Receiving: &lt;STX&gt;sRA LMPoutputRange \x00\x01\x00\x00\x05\x15\x00\x04\xa3\x80\x00\x16\xe3\x60&lt;ETX&gt;
[ INFO] [1555502889.422165198]: Angle resolution of scanner is 0.13010 [deg]  (in 1/10000th deg: 0x515)
[ INFO] [1555502889.424815945]: MIN_ANG (after command verification):   -1.040 [rad]  -59.600 [deg]
[ INFO] [1555502889.424901901]: MAX_ANG (after command verification):    1.047 [rad]   60.000 [deg]
[ INFO] [1555502889.425102725]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0032&gt;sWN LMDscandatacfg 0x1f 0x00 0x01 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01 CRC:&lt;0x5c&gt;
[ INFO] [1555502889.426373088]: Receiving: &lt;STX&gt;sWA LMDscandatacfg &lt;ETX&gt;
[ INFO] [1555502889.426606493]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMDscandatacfg CRC:&lt;0x67&gt;
[ INFO] [1555502889.427933309]: Receiving: &lt;STX&gt;sRA LMDscandatacfg \x1f\x00\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01&lt;ETX&gt;
[ INFO] [1555502889.430654546]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sWN FREchoFilter 0x00 CRC:&lt;0x7f&gt;
[ INFO] [1555502889.431952374]: Receiving: &lt;STX&gt;sWA FREchoFilter &lt;ETX&gt;
[ INFO] [1555502889.432180430]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0016&gt;sMN LMCstartmeas CRC:&lt;0x68&gt;
[ INFO] [1555502889.963840302]: Receiving: &lt;STX&gt;sAN LMCstartmeas \x00&lt;ETX&gt;
[ INFO] [1555502889.964083670]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0007&gt;sMN Run CRC:&lt;0x19&gt;
[ INFO] [1555502889.965558914]: Receiving: &lt;STX&gt;sAN Run \x01&lt;ETX&gt;
[ INFO] [1555502889.965813465]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0017&gt;sEN LMDscandata 0x01 CRC:&lt;0x33&gt;
[ INFO] [1555502889.967297195]: Receiving: &lt;STX&gt;sEA LMDscandata \x01&lt;ETX&gt;

</code></pre></div></div>

<h1 id="driver-features-and-additional-information">Driver features and additional information</h1>

<h2 id="software-overview">Software Overview</h2>

<p>The sick_scan_xd software is essentially affected by its use cases:</p>

<ul>
  <li>Implement the common tasks for different lidars:
    <ul>
      <li>Provide driver software on Linux and Windows, generic, ROS 1 and ROS 2</li>
      <li>Receive and convert scan data, publish point cloud</li>
      <li>Run startup, configuration and setup</li>
    </ul>
  </li>
  <li>Use cases:
    <ul>
      <li>Provide a point cloud to the customer/application</li>
      <li>Provide a common high level interface for all supported lidars</li>
      <li>Hide datagram details, encodings and parsing knowhow</li>
      <li>The most common use case is to run lidar + sick_scan_xd to get a point cloud.</li>
    </ul>
  </li>
  <li>Software requirements:
    <ul>
      <li>Support different lidars (LMS, LRS, LDMRS, MRS, NAV, TiM, RMS, multiScan, etc.)</li>
      <li>Support different OS (Linux, Windows)</li>
      <li>Support different targets (ROS 1, ROS 2, generic)</li>
      <li>Support different protocols (Cola-A, Cola-B, TCP, UDP, msgpack)</li>
      <li>Implement parser for different telegrams (scandata, scancfg, fields, etc.)</li>
    </ul>
  </li>
</ul>

<p>This overview describes the most important modules and their relationship.</p>

<h3 id="software-structure">Software structure</h3>

<p>The following figures show the most important software blocks:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/software_overview_01.png" alt="software_overview_01"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/software_overview_02.png" alt="software_overview_02"></p>

<p>sick_scan_xd contains 6 main functional blocks:</p>

<ul>
  <li>sick_generic_caller and sick_generic_laser for initialization and setup:
    <ul>
      <li>Read configuration from launchfile:
        <ul>
          <li>ROS 1: <code class="language-plaintext highlighter-rouge">ros::NodeHandle::getParam</code>
</li>
          <li>ROS 2 and generic: <code class="language-plaintext highlighter-rouge">LaunchParser</code> (ros-wrapper)</li>
        </ul>
      </li>
      <li>Lidar specific setup:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickGenericParser</code>: lidar specific properties and messages parsing</li>
          <li>Set and get lidar specific properties: number of layers, angular resolution, etc.</li>
          <li>Parse and convert scan data, input: scan data (ascii or binary datagram), output: <code class="language-plaintext highlighter-rouge">ros::sensor_msgs::LaserScan</code>
</li>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanCommonTcp</code>: receive TCP messages, convert and publish point cloud</li>
        </ul>
      </li>
      <li>Start ros services:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanServices</code>: register ros services, convert from/to SOPAS</li>
        </ul>
      </li>
      <li>Start monitoring:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanMonitor</code>: monitor scan data, reinit on timeout</li>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::PointCloudMonitor</code>: monitor point cloud, reinit on timeout</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>sick_scan_common for the most common lidar devices (LMS, LRS, MRS, NAV, TiM, RMS, etc.):
    <ul>
      <li>Implemention by SickScanCommon and SickScanCommonTcp</li>
      <li>Uses SickGenericParser for lidar specific properties and parsing</li>
      <li>Runs common tasks for LMS/LRS/MRS/NAV/TiM/RMS:</li>
      <li>Run SOPAS startup sequence</li>
      <li>Run TCP receiver thread</li>
      <li>Process telegrams: parse and convert to point cloud</li>
      <li>Publish point cloud</li>
    </ul>
  </li>
  <li>sick_ldmrs for LD-MRS support using the ldmrs-library from https://github.com/SICKAG/libsick_ldmrs.git</li>
  <li>sick_scansegment_xd for multiScan136 and picoScan150 lidars using SOPAS, msgpack and UDP-communication</li>
  <li>sick_scan_services for ros services</li>
  <li>sick_generic_monitoring for monitoring and re-initialization in case of errors (e.g. network errors).</li>
</ul>

<p>The following figures show these 6 functional blocks:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/software_overview_03.png" alt="software_overview_03"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/software_overview_04.png" alt="software_overview_04"></p>

<p>The function blocks depend on and use the underlying system (ROS, TCP, etc.):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/driverComponentsDiagram1.png" alt="driver_components_01"></p>

<h3 id="message-receiving-and-message-handling">Message receiving and message handling</h3>

<p>Message receiving and message handling are decoupled, i.e. both tasks run in separate thread and exchange messages via a FIFO-buffer. This way, message handling cannot block tcp recv and vice versa. The following figure shows the message handling:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/software_overview_05.png" alt="software_overview_05"></p>

<p>The following figure shows the sequence diagram for a LMDscandata telegram:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/messageSequenceDiagram1.png" alt="messageSequenceDiagram1"></p>

<p>Incoming TCP messages and exported point cloud messages are monitored. sick_scan_xd reinitialises the lidar and the tcp connection in case of timeouts.</p>

<h3 id="sick_scansegment_xd">sick_scansegment_xd</h3>

<p>sick_scansegment_xd implements support for multiScan136 and picoScan150 lidars using SOPAS, msgpack and UDP-communication. It has 5 functional blocks:</p>

<ul>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackThreads</code>:
    <ul>
      <li>Init and run all sick_scansegment_xd components</li>
      <li>SOPAS startup (multiScan136, picoScan150)</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::UdpReceiver</code>:
    <ul>
      <li>Run UDP receiver thread</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackConverter</code>:
    <ul>
      <li>Parse and convert msgpacks</li>
      <li>Collect scan segments</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackValidator</code>:
    <ul>
      <li>Validate msgpacks and scansegments</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::RosMsgpackPublisher</code>:
    <ul>
      <li>Publish point cloud (single segments)</li>
      <li>Publish cloud_fullframe (fullframe pointcloud, 360 deg for Multiscan136 resp. 270 deg for picoscan)</li>
    </ul>
  </li>
</ul>

<p>The following figure shows the compoenent diagram for sick_scansegment_xd:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/driverComponentsDiagram2.png" alt="driverComponentsDiagram2"></p>

<p>Message receiving, converting and publishing run in 3 separate threads and exchange their messages via a FIFO-buffer.</p>

<p>The following figure shows the sequence diagram for a multiScan136 msgpack:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/messageSequenceDiagram2.png" alt="messageSequenceDiagram2"></p>

<p>The following figure shows the sequence diagram for a picoScan and compact format:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/messageSequenceDiagram3.png" alt="messageSequenceDiagram3"></p>

<h3 id="files-and-folders">Files and folders</h3>

<p>The source files for the sick_scan_xd core can be found in the following folders:</p>
<ul>
  <li>driver/src: source files</li>
  <li>include: header files</li>
  <li>launch: configuration</li>
  <li>msg: ros messages definitions</li>
  <li>srv: ros services definitions</li>
  <li>roswrap: ros wrapper (ROS 2 and generic)</li>
</ul>

<p>These folders are required to build sick_generic_caller.</p>

<p>Additional folders for sick_scan_xd support, development and test are:</p>
<ul>
  <li>test: test scripts and emulator</li>
  <li>tools: additional development tools</li>
</ul>

<h2 id="generic-driver-api">Generic Driver API</h2>

<h3 id="overview">Overview</h3>

<p>A generic API for sick_scan_xd has the following goals:</p>
<ul>
  <li>Easy integration of sick_scan_xd into customer systems with and without ROS</li>
  <li>Integrate SICK lidars with one API, independent of lidar types or underlying operating system</li>
  <li>Provide the same sick_scan_xd functionality on systems without ROS</li>
  <li>In particular: make the sick_scan_xd functionality available on non-ROS-systems without need to customize sources or configuration files.</li>
</ul>

<p>The generic sick_scan_xd API provides an interface to all lidars supported by sick_scan_xd. This API can be used in C, C++, Python, or any other language with support of C-bindings.</p>

<p>The generic sick_scan_xd API ships with the API-header, the library (binary or sources) and usage examples for C, C++ and Python. The following component diagram shows the relationship between API, library, lidar and a customized application:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_api/apiComponentsDiagram1.png" alt="apiComponentsDiagram1.png"></p>

<p>Running multiple lidars simultaneously in a single process is not supported.** Currently the sick_scan_xd API does not support the single or multi-threaded use of 2 or more lidars in one process, since the sick_scan_xd library is not guaranteed to be thread-safe. To run multiple lidars simultaneously, we recommend using ROS or running sick_scan_xd in multiple and separate processes, so that each process serves one sensor. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#start-multiple-nodes">start multiple lidars</a> for further information.</p>

<h3 id="build-and-test-shared-library">Build and test shared library</h3>

<p>The shared library, which implements the C-API, is built native on Linux or Windows (i.e. without ROS). Follow the instructions on <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-generic-without-ros">Build on Linux generic without ROS</a> for Linux resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-windows-generic-without-ros">Build on Windows</a> for Windows.</p>

<h4 id="build-the-shared-library-on-linux">Build the shared library on Linux</h4>

<p>Run the following commands to build the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Clone repositories
git clone https://github.com/SICKAG/libsick_ldmrs.git
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
# Build libsick_ldmrs library
mkdir -p ./build
mkdir -p ./libsick_ldmrs/build
pushd libsick_ldmrs/build
cmake -G "Unix Makefiles" ..
make -j4
sudo make -j4 install
popd
# Build libsick_scan_xd_shared_lib.so
pushd ./build
export ROS_VERSION=0
cmake -DROS_VERSION=0 -G "Unix Makefiles" ../sick_scan_xd
make -j4
sudo make -j4 install
# Check build and library dependencies
ls -al ./sick_generic_caller
ls -al ./libsick_scan_xd_shared_lib.so
ls -al ./sick_scan_xd_api_test
ldd -r ./libsick_scan_xd_shared_lib.so
popd

</code></pre></div></div>
<p>After successful build, the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> and a tiny test executable <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> are created.</p>

<h4 id="build-the-shared-library-on-windows">Build the shared library on Windows</h4>

<p>Run the following commands to build the shared library <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> with Visual Studio 2019 on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Clone repository sick_scan_xd
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
# Build libraries sick_scan_xd_shared_lib.dll
call "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\Common7\Tools\VsDevCmd.bat" -arch=amd64 -host_arch=amd64
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
cd sick_scan_xd
if not exist %_cmake_build_dir% mkdir %_cmake_build_dir%
pushd %_cmake_build_dir%
cmake -DROS_VERSION=0 -G "%_cmake_string%" ..
if %ERRORLEVEL% neq 0 ( @echo ERROR building %_cmake_string% sick_scan_xd with cmake &amp; @pause )
cmake --build . --clean-first --config Debug

</code></pre></div></div>
<p>After successful build, the shared library <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> and a tiny test executable <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test.exe</code> are created. To install the library and header in the system folder, run <code class="language-plaintext highlighter-rouge">cmake --build . --target install</code> with admin privileges. Note that LD-MRS is not supported on Windows.
privileges</p>
<blockquote>
  <p><strong><em>NOTE:</em></strong> sick_scan_xd builds and runs with both Visual Studio 2019 and 2022. Visual Studio 2019 is recommended, since ROS on Windows requires VS 2019.</p>
</blockquote>

<p>Replace <code class="language-plaintext highlighter-rouge">cmake -DROS_VERSION=0 -G "%_cmake_string%" ..</code> by  <code class="language-plaintext highlighter-rouge">cmake -DROS_VERSION=0 -DCMAKE_ENABLE_EMULATOR=1 -G "%_cmake_string%" ..</code> to build emulators for unit tests without lidar hardware, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CONTRIBUTING.md">Simulation</a>.</p>

<h4 id="test-the-shared-library">Test the shared library</h4>

<p>The executable file <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> provides a minimalistic API test. Run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;ip-address&gt;</code> to test the API against a lidar, e.g. on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH # append relative path to build folder
export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to build folder
./build/sick_scan_xd_api_test ./sick_scan_xd/launch/sick_tim_7xx.launch hostname:=192.168.0.1

</code></pre></div></div>
<p>On Windows, run e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;..\build\Debug;%PATH%
.\build\Debug\sick_scan_xd_api_test.exe launch/sick_lms_5xx.launch hostname:=192.168.0.1

</code></pre></div></div>

<p>The executable binary <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> will just load library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code>, start the lidar and print a message when receiving lidar messages, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test: pointcloud callback</code>. Replace <code class="language-plaintext highlighter-rouge">sick_lms_1xx.launch</code> in the example by the launch file corresponding to your type of lidar.</p>

<p>To load the library, the build folder has to be included in <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code> (Linux) resp. <code class="language-plaintext highlighter-rouge">PATH</code> (Windows). Set this environment variable to your build folder, e.g. on Linux using</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH # append relative path to build folder
export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to build folder

</code></pre></div></div>
<p>resp. on Windows</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;.\build\Debug;%PATH%

</code></pre></div></div>

<h3 id="usage-example">Usage example</h3>

<p>The sick_scan_xd API can be used on Linux or Windows in any language with support of C-bindings. There are 3 steps required to use the API:</p>

<ol>
  <li>API- and lidar-initialization by
    <ul>
      <li>SickScanApiLoadLibrary</li>
      <li>SickScanApiCreate</li>
      <li>SickScanApiInitByLaunchfile or SickScanApiInitByCli</li>
    </ul>
  </li>
  <li>
    <p>Receive messages by registration of callbacks using <code class="language-plaintext highlighter-rouge">SickScanApiRegister&lt;MsgType&gt;Msg</code>-functions (recommended) or by polling using <code class="language-plaintext highlighter-rouge">SickScanApiWaitNext&lt;MsgType&gt;Msg</code>-functions.</p>

    <p>Alternative examples to receive lidar scan data as a point cloud:</p>
    <ul>
      <li>Register a callback for cartesian point cloud data using SickScanApiRegisterCartesianPointCloudMsg, or</li>
      <li>register a callback for polar point cloud data using SickScanApiRegisterPolarPointCloudMsg.</li>
    </ul>

    <p>The registered callback will be executed whenever the lidar has sent new scan data and receives the (cartesian or polar) point cloud by a parameter of type SickScanPointCloudMsg. The SickScanPointCloudMsg in sick_scan_xd API corresponds to ROS pointcloud: The cartesian point cloud  (registered by SickScanApiRegisterCartesianPointCloudMsg) contains the fields (x, y, z, intensity). The polar point cloud (registered by SickScanApiRegisterPolarPointCloudMsg) contains the fields (range, azimuth, elevation, intensity). Each field contains its name (i.e. x, y, z, range, azimuth, elevation, or intensity) and offset. The scan data is a flat buffer of size width x height fields:</p>

    <p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_api/apiPointCloudMsg.png" alt="apiPointCloudMsg"></p>

    <p>The following python code shows how to convert a cartesian point cloud to 3D points (x, y, z):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Convert a SickScanCartesianPointCloudMsg to points
    def pySickScanCartesianPointCloudMsgToXYZ(pointcloud_msg):
        # get point cloud fields
        num_fields = pointcloud_msg.fields.size
        msg_fields_buffer = pointcloud_msg.fields.buffer
        field_offset_x = -1
        field_offset_y = -1
        field_offset_z = -1
        for n in range(num_fields):
            field_name = ctypesCharArrayToString(msg_fields_buffer[n].name)
            field_offset = msg_fields_buffer[n].offset
            if field_name == "x":
                field_offset_x = msg_fields_buffer[n].offset
            elif field_name == "y":
                field_offset_y = msg_fields_buffer[n].offset
            elif field_name == "z":
                field_offset_z = msg_fields_buffer[n].offset
        # Extract x,y,z
        cloud_data_buffer_len = (pointcloud_msg.row_step * pointcloud_msg.height) # length of polar cloud data in byte
        assert(pointcloud_msg.data.size == cloud_data_buffer_len and field_offset_x &gt;= 0 and field_offset_y &gt;= 0 and field_offset_z &gt;= 0)
        cloud_data_buffer = bytearray(cloud_data_buffer_len)
        for n in range(cloud_data_buffer_len):
            cloud_data_buffer[n] = pointcloud_msg.data.buffer[n]
        points_x = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        points_y = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        points_z = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        point_idx = 0
        for row_idx in range(pointcloud_msg.height):
            for col_idx in range(pointcloud_msg.width):
                # Get lidar point in polar coordinates (range, azimuth and elevation)
                pointcloud_offset = row_idx * pointcloud_msg.row_step + col_idx * pointcloud_msg.point_step
                points_x[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_x)[0]
                points_y[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_y)[0]
                points_z[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_z)[0]
                point_idx = point_idx + 1
        return points_x, points_y, points_z
   
</code></pre></div></div>
<p>Exchange field names (“x”, “y”, “z”) by (“range”, “azimuth”, “elevation”) to get 3D polar points (range, azimuth, elevation).</p>

<p>For further details, see minimalistic usage examples in C and Python.</p>

<p>Note for multiScan100 and picoScan100 lidars:</p>

<ul>
  <li>
    <p>The WaitNext-functions of the API return the next received message. For multiScan100 and picoScan, this can be a scan segment (i.e. a part of the full scan) or a fullframe point cloud (i.e. all scan points of a 360 degree scan). Depending on the timing, you may not receive all messages, i.e. you may e.g. receive scan points of different segments. We therefore recommend to register a message callback instead of a WaitNext-function. With a registered message callback, you will get all fullframe and segment point cloud messages.</p>
  </li>
  <li>
    <p>For multiScan100 and picoScan, point cloud messages can contain a scan segment (i.e. a part of the full scan) or a fullframe point cloud  (i.e. all scan points of a 360 degree scan). The type can be determined by the topic (default: “/cloud_unstructured_segments” for segments, “/cloud_unstructured_fullframe” for fullframe point clouds) or by segment index (-1 for fullframe, 0 up to 11 for segment point clouds).</p>
  </li>
</ul>

<ol>
  <li>Close lidar and API by
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">SickScanApiDeregister&lt;MsgType&gt;Msg</code>-functions</li>
      <li>SickScanApiClose</li>
      <li>SickScanApiRelease</li>
    </ul>
  </li>
</ol>

<p>It is recommended to store a deep copy of the point cloud data in a fifo buffer (first in, first out) for further data processing. After the registered callback is executed, the point cloud memory will be released. Make sure to store a deep copy of the point cloud, not a shallow copy.</p>

<p>All functions named <code class="language-plaintext highlighter-rouge">SickScanApi</code> are implemented within the library file (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux). A small wrapper is provided (<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/src/sick_scan_xd_api/sick_scan_xd_api_wrapper.c">sick_scan_xd_api_wrapper.c</a> for C/C++, <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a> for python), which loads and unloads the library (functions <code class="language-plaintext highlighter-rouge">SickScanApiLoadLibrary</code> and <code class="language-plaintext highlighter-rouge">SickScanApiUnloadLibrary</code>) and delegates the function calls to the binary.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). Otherwise, please install numpy with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> if numpy is not yet installed.</p>
</blockquote>

<h4 id="minimalistic-usage-example-in-c">Minimalistic usage example in C</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/examples/c/minimum_sick_scan_api_client.c">minimum_sick_scan_api_client.c</a> shows a minimalistic example of a C client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the build and run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd examples/c
mkdir -p ./build
cd ./build
cmake -G "Unix Makefiles" ..
make -j4
cd ../..
export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH
./examples/c/build/minimum_sick_scan_api_client &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the build and run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REM Set environment for Visual Studio 2019 (VS 16)
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
REM Build the minimalistic C usage example
cd examples\c
mkdir %_cmake_build_dir%
cd %_cmake_build_dir%
cmake -G "%_cmake_string%" ..
cmake --build . --clean-first --config Debug
REM Set environment: add build folder to LD_LIBRARY_PATH, add python/api to PYTHONPATH
cd ..\..
set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
REM Run minimalistic C api example
.\examples\c\build\Debug\minimum_sick_scan_api_client.exe &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<h4 id="minimalistic-usage-example-in-c-1">Minimalistic usage example in C++</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/examples/cpp/minimum_sick_scan_api_client.cpp">minimum_sick_scan_api_client.cpp</a> shows a minimalistic example of a C++ client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the build and run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd examples/cpp
mkdir -p ./build
cd ./build
cmake -G "Unix Makefiles" ..
make -j4
cd ../..
export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH
./examples/cpp/build/minimum_sick_scan_api_client &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the build and run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REM Set environment for Visual Studio 2019 (VS 16)
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
REM Build the minimalistic C++ usage example
cd examples\cpp
mkdir %_cmake_build_dir%
cd %_cmake_build_dir%
cmake -G "%_cmake_string%" ..
cmake --build . --clean-first --config Debug
REM Set environment: add build folder to LD_LIBRARY_PATH, add python/api to PYTHONPATH
cd ..\..
set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
REM Run minimalistic C++ api example
.\examples\cpp\build\Debug\minimum_sick_scan_api_client.exe &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<h4 id="minimalistic-usage-example-in-python">Minimalistic usage example in Python</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/examples/python/minimum_sick_scan_api_client.py">minimum_sick_scan_api_client.py</a> shows a minimalistic example of a python client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export LD_LIBRARY_PATH=`pwd`:`pwd`/build:$LD_LIBRARY_PATH
export PYTHONPATH=`pwd`:`pwd`/python/api:$PYTHONPATH
python3 ./examples/python/minimum_sick_scan_api_client.py &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
set PYTHONPATH=.;.\python\api;%PATH%
python ./examples/python/minimum_sick_scan_api_client.py &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). Otherwise, please install numpy with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> if numpy is not yet installed.</p>
</blockquote>

<h4 id="complete-usage-example-in-c">Complete usage example in C++</h4>

<p>A complete C/C++ usage example is implemented in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a>. Note that the shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) has no dependencies to ROS. The usage example on the other hand supports both ROS 1, ROS 2 and native Linux or Windows. When build on ROS, it converts the SickScanApi-messages into ROS-messages. On ROS, they can be visualized by rviz. The following screenshot shows a point cloud published by <code class="language-plaintext highlighter-rouge">rosrun sick_scan_xd sick_scan_xd_api_test _sick_scan_args:="./src/sick_scan_xd/launch/sick_tim_7xx.launch"</code>:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_api/api_test_linux_ros1_tim7xx.png" alt="api_test_linux_ros1_tim7xx.png"></p>

<p>Without ROS, sick_scan_xd_api_test plots a jpeg-file to enable a simple visualization of a point cloud. E.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>firefox ./demo/image_viewer_api_test.html &amp;
./build_linux/sick_scan_xd_api_test ./launch/sick_tim_7xx.launch

</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_api/api_test_linux_tim7xx.png" alt="api_test_linux_tim7xx.png"></p>

<h4 id="complete-usage-example-in-python">Complete usage example in Python</h4>

<p>A complete python usage example is implemented in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a>. It is handy to test the sick_scan_xd library. Like its C++ counterpart <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a>, it just loads library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code>, starts a lidar and receives the lidar point cloud and messages via API. On ROS 1, the lidar point cloud and messages are converted to ROS and published. The lidar point cloud can be visualized by rviz using topic “/sick_scan_xd_api_test/api_cloud”.</p>

<p>Run <code class="language-plaintext highlighter-rouge">python3 sick_scan_xd_api_test.py &lt;launchfile&gt; hostname:=&lt;ip-address&gt;</code> to test the API against a lidar.
On Linux e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PYTHONPATH=`pwd`:`pwd`/src/sick_scan_xd/python/api:$PYTHONPATH
source /opt/ros/noetic/setup.bash # replace by noetic by your ros version
python3 ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_lms_1xx.launch hostname:=192.168.0.1

</code></pre></div></div>
<p>On Windows e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PYTHONPATH=.;.\src\sick_scan_xd\python\api;%PYTHONPATH%
python ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_lms_1xx.launch hostname:=192.168.0.1

</code></pre></div></div>

<p>The pthon usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> imports <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a>, which contains the python definitions of the sick_scan_xd API. Make sure that sick_scan_api.py can be imported, e.g. by including folder <code class="language-plaintext highlighter-rouge">python/api</code> in PYTHONPATH by:</p>

<p><code class="language-plaintext highlighter-rouge">export PYTHONPATH=</code>pwd<code class="language-plaintext highlighter-rouge">:</code>pwd<code class="language-plaintext highlighter-rouge">/src/sick_scan_xd/python/api:$PYTHONPATH</code> on Linux, resp. <br>
<code class="language-plaintext highlighter-rouge">set PYTHONPATH=.;.\src\sick_scan_xd\python\api;%PYTHONPATH%</code> on Windows</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  The shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) works standalone and does not have any ROS dependencies. The usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> converts API- to ROS-messages for visualization and is therefore dependent on ROS, if ROS is installed.</p>
</blockquote>

<p>If ROS is not installed, <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> uses matplotlib to visualize the pointcloud. The following screenshot shows a TiM-7xx point cloud on Linux without ROS:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_api/api_test_python_tim7xx.png" alt="api_test_python_tim7xx.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows without ROS, <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> requires numpy and matplotlib. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). These python distributions provide the necessary packages and tools. Otherwise, please install numpy and matplotlib with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> and <code class="language-plaintext highlighter-rouge">python -m pip install matplotlib</code> if not yet done.</p>
</blockquote>

<h4 id="diagnostic">Diagnostic</h4>

<p>The API provides the following functions for diagnostics:</p>

<ul>
  <li>SickScanApiRegisterDiagnosticMsg and SickScanApiDeregisterDiagnosticMsg: Register resp. deregister a callback to receive diagnostic messages. Diagnostic messages contain a status code and status message. The status code is one of the following numbers:
    <ul>
      <li>OK=0 (normal operation)</li>
      <li>WARN=1 (warning)</li>
      <li>ERROR=2 (error, should not occur)</li>
      <li>INIT=3 (initialization after startup or reconnection)</li>
      <li>EXIT=4 (sick_scan_xd exiting)</li>
    </ul>

    <p>The status message is descriptional C-string.</p>

    <p>A typical sequence of the status code is:</p>
    <ul>
      <li>INIT at startup, then</li>
      <li>after lidar initialization is completed: change to OK (normal operation) and run, and</li>
      <li>EXIT at shutdown.
 Diagnostic messages are generated whenever the status changed or an ERROR occured. Status code 2 (i.e. error) should not occur under normal operation.</li>
    </ul>
  </li>
  <li>
    <p>SickScanApiRegisterLogMsg and SickScanApiDeregisterLogMsg: Register resp. deregister a callback to receive log messages. This callback will receive all informational or error messages printed on console. The log messages contain a log level (Info=1, Warn=2, Error=3, Fatal=4) and the log message.</p>
  </li>
  <li>
    <p>SickScanApiGetStatus queries the current status. This function returns the current status code (OK=0 i.e. normal operation, WARN=1, ERROR=2, INIT=3 i.e. initialization after startup or reconnection or EXIT=4) and the descriptional status message.</p>
  </li>
  <li>SickScanApiSendSOPAS sends a SOPAS command (Cola-A) to the lidar and returns the response from the device.
    <ul>
      <li>C++ example:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     char sopas_response_buffer[1024] = { 0 };
     SickScanApiSendSOPAS(apiHandle, "sRN SCdevicestate", &amp;sopas_response_buffer[0], (int32_t)sizeof(sopas_response_buffer); // returns "sRA SCdevicestate \x00" in sopas_response_buffer
     
</code></pre></div></div>

<ul>
  <li>Python example:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     sopas_response = SickScanApiSendSOPAS(sick_scan_library, api_handle, "sRN SCdevicestate")` # returns "sRA SCdevicestate \x00".
      
</code></pre></div></div>
<p>See the telegram listing for valid SOPAS commands.</p>

<ul>
  <li>SickScanApiSetVerboseLevel and SickScanApiGetVerboseLevel sets resp. returns the verbose level. The verbose level can be 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR, 4=FATAL or 5=QUIET (equivalent to ros::console::levels). Default verbose level is 1 (INFO), i.e. sick_scan_xd prints informational, warnings and error messages on the console. Logging callbacks registered with SickScanApiRegisterLogMsg will receive all informational, warnings and error messages independent of the verbose level.</li>
</ul>

<p>To monitor sick_scan_xd resp. the lidar, it is recommended to register a callback for diagnostic messages using SickScanApiRegisterDiagnosticMsg and to display the error message in case for status code 2 (error). See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> for an example.</p>

<h4 id="simulation-and-unit-test">Simulation and unit test</h4>

<p>sick_scan_xd provides a tiny server for offline tests which simulates a basic lidar. It just accepts TCP connections, responds to sopas requests with predefined responses and sends lidar data from file. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CONTRIBUTING.md">Simulation</a> for further details. Note that the simulation does not emulate or replace a lidar, it just supports basic unit tests.</p>

<p>Open a new terminal and run the following steps to test the api against a TiM7xx simulation using the python example mentioned above:</p>

<ol>
  <li>Build library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> incl. emulator with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code>:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./src/build
   pushd ./src/build
   rm -rf ./*
   cmake -DROS_VERSION=0 -DCMAKE_ENABLE_EMULATOR=1 -G "Unix Makefiles" ../sick_scan_xd
   make -j4
   ls -al libsick_scan_xd_shared_lib.so sick_scan_xd_api_test sick_generic_caller sick_scan_emulator # list size and date of the binaries
   popd
   
</code></pre></div></div>
<p>Building sick_scan_xd with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code> requires jsoncpp. Install libjsoncpp by running “sudo apt-get install libjsoncpp-dev” on Linux resp. “vcpkg install jsoncpp:x64-windows” on Windows (vcpkg required). Run the following steps to install Visual Studios package manager vcpkg on Windows:
      * Download vcpkg-master.zip from https://github.com/microsoft/vcpkg/archive/master.zip and unzip to <code class="language-plaintext highlighter-rouge">c:\vcpkg</code>. Alternatively, run “git clone https://github.com/microsoft/vcpkg”
      * Install vcpkg by running the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        cd c:/vcpkg
        bootstrap-vcpkg.bat
        vcpkg integrate install
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  * Include vcpkg in your path:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        set PATH=c:\vcpkg\installed\x64-windows\bin;%PATH%
        
</code></pre></div></div>

<ol>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
  <li>
    <p>Build sick_scan_xd for ROS 1 on Linux, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-ros1">Build on Linux ROS 1</a></p>
  </li>
  <li>
    <p>Start the TiM7xx simulator:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cp -f ./src/sick_scan_xd/test/emulator/scandata/sopas_et_field_test_1_2_both_010.pcapng.json /tmp/lmd_scandata.pcapng.json
   ./src/build/sick_scan_emulator ./src/sick_scan_xd/test/emulator/launch/emulator_01_default.launch &amp;
   sleep 1
   
</code></pre></div></div>

<ol>
  <li>Run sick_scan_xd_api_test.py against the TiM7xx simulator on localhost:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   export PYTHONPATH=.:./src/sick_scan_xd/python/api:$PYTHONPATH
   python3 ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_tim_7xx.launch hostname:=127.0.0.1 port:=2111 sw_pll_only_publish:=False
   
</code></pre></div></div>

<ol>
  <li>Start rviz and visualize the point cloud on topic “/sick_scan_xd_api_test/api_cloud”.</li>
</ol>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) works standalone and does not have any ROS dependencies. The usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> uses ROS for visualization.</p>
</blockquote>

<h3 id="c-api">C-API</h3>

<p>The header file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/include/sick_scan_xd_api/sick_scan_api.h">sick_scan_api.h</a> defines the C-interface. It defines all datatypes, messages and functions of the generic sick_scan_xd API. To allow equal operations on all systems, the definition of datatypes and messages is as close as possible to their equivalents currently used on ROS.</p>

<p>Python file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a> defines the same interface in python.</p>

<h3 id="useful-links">Useful links</h3>

<p><a href="https://docs.python.org/3/library/ctypes.html">ctypes</a> is used for data exchange and function calls between Python and C-libraries:</p>
<ul>
  <li>https://docs.python.org/3/library/ctypes.html</li>
  <li>https://docs.python.org/3/library/ctypes.html#structures-and-unions</li>
  <li>https://docs.python.org/3/library/ctypes.html#callback-functions</li>
</ul>

<h2 id="timestamps-and-synchronization-software-pll">Timestamps and synchronization (Software PLL)</h2>

<p>Often there is a requirement that the time stamp of the measurements should be calculated for each individual shot. This article explains some background information about the determination of these time stamps. Here the statements refer to the LMS511. However, they can be transferred to other lidars using the same logic.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/lms511_scan.png" alt="lms511_scan.png"></p>

<p>The lidar sends a pulsed beam onto a rotating mirror. Since the speed of rotation is relatively low, this mirror serves as transmitter and receiver. The direction of rotation can be seen in the drawing.</p>

<p>25 scans per second means that the mirror makes 25 360° rounds per second. The actual laser unit is only active during the 190°. Therefore the so-called duty cycle is 190/360. The rotation is unaccelerated, so that the lidar arrives at the same angular direction again after 40 ms (1/25). From the angular distance from shot to shot you can calculate the pulse rate of the laser. For example, if the angular difference from shot to shot is 0.1 degree, the so-called shot rate would be: 360/0.1 * 25 shots/second.</p>

<p>A scan means the group of all shots during one revolution. Just imagine the lidar as a lighthouse that rotates evenly and measures the distance values over time of flight in a certain sector (here 190°) with the above mentioned shot rate. Also you find some background material in the documentation of SICK.</p>

<p>In the transmission protocol of the lidar two points in time are given in so-called ticks (resolution in microseconds):
a) Start of the scans in ticks
b) Start of IP data transfer from lidar to PC in ticks</p>

<p>It is assumed that the transfer between lidar and PC is near latency-free.
The software PLL generates an assignment between the tick of the IP data transmission and the system time of the PC via an estimated line mapping. On the basis of this straight line equation, the start of the scan is then calculated relative to the system time. This generation time stamp is the time of the first shot of the scan. This timestamp is assigned to the point cloud timestamp. From there, the rotation speed and the angular distance from shot to shot can be used to approximately calculate the time for each shot.</p>

<p>A software pll is used to convert LiDAR timestamps in ticks to the ros system time.</p>

<p>Many sensor devices, e.g. lidar devices, provide sensor data with timestamps. These timestamps can be synchronized with the current system time by additional hardware, e.g. by GPS. But without specialized hardware, sensor timestamps and system time is normally unsynchronized. Sensor timestamps are often quite accurate, but have a different time base and a bias to the system time or to other sensor clocks. This difference is estimated and compensated by this Software PLL.</p>

<p>The scanner has an internal time base of microseconds since system startup. Against this “tick” time base all time stamps are made in the scanner. When sending messages from the scanner, two time stamps are added:</p>

<ol>
  <li>scan generation ticks–&gt; timestamp at the time of the first shot</li>
  <li>scan transmission ticks–&gt; time stamp for the transmission of the data</li>
</ol>

<p>When data packets are received, they are timestamped by the driver against the systemtime in ros::time format. See following Fig.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/timing_sync.png" alt="timing_syn.png"></p>

<p>The relationship between system time and ticks is then derived from the time stamps and kept synchronous.The time required for the transmission of data over the network is assumed to be short and constant and is therefore neglected. The function of the algorithms is shown in the following Fig.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sequence_time_pll.png" alt="sequence_time_pll.png"></p>

<p>To compensate the different time base and bias between sensor and system clock, the system time when receiving sensor data is gathered together with the sensor timestamp. While the system time is often measured in seconds resp. nanoseconds, the sensor timestamp is normally received in clock ticks. SoftwarePLL estimates the correlation between system time in secondsnanoseconds and sensor ticks, and computes a corrected time from ticks. This way you know at which time stamp the data
have been measured by your sensor.</p>

<p>SoftwarePLL is a generic module and independant from specific sensor types. It just uses the system timestamps and ticks, estimates their correlation and predicts the time from sensor ticks.SoftwarePLL computes a linear regression between ticks and system timestamps. The system time is measured immediately after receiving new sensor data, while sensor ticks represent the sensor clock at the time of measurement. Thus we have three different times for each measurement</p>

<ul>
  <li>The time when the system receives the sensor data (receive time t_rec), measured in seconds resp. nanoseconds.</li>
  <li>The sensor ticks (or just ticks) at the time of the measurement. These ticks are contained in the sensor data and
received later by the system.</li>
  <li>The time of the measurement (measurement time t_mea). We don’t know this time yet, but we estimate it from both the ticks
and their receive time t_rec using the SoftwarePLL.</li>
</ul>

<p>During initialization, ticks and system timestamps are stored in fifo buffer (first-in, first-out). After initialization,
typically after N=7 measurements, a regression line is computed, i.e. the slope <code class="language-plaintext highlighter-rouge">m</code> (gradient) of a function
<code class="language-plaintext highlighter-rouge">f(ticks) = m  ticks + c</code> is estimated from ticks <code class="language-plaintext highlighter-rouge">x(i)</code> and timestamps <code class="language-plaintext highlighter-rouge">y(i)</code> by a linear regression
<code class="language-plaintext highlighter-rouge">m = (N  sum(x(i)  y(i)) - sum(x(i))  sum(y(i)))  (N  sum(x(i)  x(i)) - sum(x(i))sum(x(i)))</code> with <code class="language-plaintext highlighter-rouge">0 = i  N</code> and
unbiased values <code class="language-plaintext highlighter-rouge">x(i) = tick(i) - tick(0)</code>, <code class="language-plaintext highlighter-rouge">y(i) = t_rec(i) - t_rec(0)</code>.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/pll_regression.png" alt="pll_regression.png"></p>

<p>The estimated system time <code class="language-plaintext highlighter-rouge">t_esti(i)</code> of a measurement can be computed from its sensor tick by <code class="language-plaintext highlighter-rouge">t_esti(i) = m  (ticks(i) - ticks(0)) + t_rec(0)</code>.
If the difference between estimated times <code class="language-plaintext highlighter-rouge">t_esti(i)</code> and the measured system timestamps <code class="language-plaintext highlighter-rouge">t_rec(i)</code> is small (typically
less than 100 milliseconds), the estimation can be considered to be valid. With a valid estimation of <code class="language-plaintext highlighter-rouge">m</code>, we can
get a corrected timestamp for new measurements by applying function <code class="language-plaintext highlighter-rouge">SoftwarePLLGetCorrectedTimeStamp</code>, which returns
the estimated system time of a measurement <code class="language-plaintext highlighter-rouge">t_esti  = m  (ticks - ticks(0)) + t_rec(0)</code>.</p>

<p>If the estimation is not valid (i.e. the difference between estimated times and measured system timestamps in the buffer is
significant), we can’t estimate system timestamps from sensor ticks. If this happens more than a given number of times
after initialization (typically 20 times), the fifo is reset and a new initialization is done.</p>

<p>Use the following code snippet as an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include softwarePLL.h

 Create an instance of SoftwarePLL
SoftwarePLL&amp; software_pll = SoftwarePLLInstance(Sensor1);

 Get system time t_rec in seconds and nanoseconds when receiving sensor data
rosTime t_rec = rosTimenow();
uint32_t sec = t_rec.nsec;
uint32_t nanosec = t_rec.nsec;

 Get sensor ticks from sensor data
uint32_t ticks = scanner_msg.ticks;

 Update SoftwarePLL
software_pll.UpdatePLL(sec, nanosec, ticks);

 Get corrected timestamp (time of measurement from ticks)
software_pll.GetCorrectedTimeStamp(sec, nanosec, ticks);

</code></pre></div></div>

<p><strong>Data buffering in MRS1000</strong></p>

<p>Due to their construction the MRS1000 scanners generate different layers at the same time which are output sequentially by the scanner firmware. In order to ensure that only point cloud messages that follow one another in time are sent, buffering can be activated in the driver.
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/scannbuffering.png" alt="scannbuffering.png"></p>

<h2 id="coordinate-transforms">Coordinate transforms</h2>

<p>Different lidars use different coordinate systems. sick_scan_xd transforms all points of the published pointclouds to the ROS coordinate system, independant of the lidar. The following figure shows the commonly used coordinate systems:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/3d_coordinate_system_comp.png" alt="3d_coordinate_system_comp.png"></p>

<p>An additional coordinate transform can be applied to the pointcloud. This optional transform can be used to transform the pointclouds into a user defined coordinate system. If the lidar is e.g. mounted on a vehicle, the pointclouds can be transformed into a vehicle coordinates.</p>

<p>An additional coordinate transform can be configured by a 6D pose (x, y, z, roll, pitch, yaw) with a translational part (x, y, z) in [m] and a rotational part (roll, pitch, yaw) in [rad].</p>

<p>If configured, it will transform the point cloud from its “cloud” coordinates into user defined “world” coordinate system:</p>

<p><code class="language-plaintext highlighter-rouge">T[world,cloud] with P_world = T[world,cloud] * P_cloud</code> (parent: world, child: cloud)</p>

<p>The final rotation is defined by: Rotation = Rot[yaw] * Rot[pitch] * Rot[roll] with roll = rotation about x-axis, pitch = rotation about y-axis and yaw = rotation about z-axis.</p>

<p>An additional transform can be configured in the launchfile, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- Apply an additional transform to the cartesian pointcloud, default: "0,0,0,0,0,0" (i.e. no transform) --&gt;
&lt;!-- &gt; **_NOTE:_** add_transform_xyz_rpy is specified by 6D pose x, y, z, roll, pitch, yaw in [m] resp. [rad] --&gt;
&lt;!-- It transforms a 3D point in cloud coordinates to 3D point in user defined world coordinates: --&gt;
&lt;!-- add_transform_xyz_rpy := T[world,cloud] with parent "world" and child "cloud", i.e. P_world = T[world,cloud] * P_cloud --&gt;
&lt;param name="add_transform_xyz_rpy" type="string" value="0,0,0,0,0,0" /&gt;

</code></pre></div></div>

<p>Default value is <code class="language-plaintext highlighter-rouge">"0,0,0,0,0,0"</code>, i.e. no additional transform will be applied.</p>

<p>The additional transform applies to cartesian lidar pointclouds and visualization marker (fields).
It is <strong>NOT</strong> applied to polar point clouds, radarscans, LD-MRS objects or other messages.</p>

<p>Note that sick_scan_xd configures an additional transform using (x, y, z, roll, pitch, yaw). In contrast, the ROS static_transform_publisher uses commandline arguments in order x, y, z, yaw, pitch, roll.</p>

<p>Example using ROS static_transform_publisher with x=0, y=0, z=0, roll=15, pitch=-10, yaw=5 [deg]:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source /opt/ros/noetic/setup.bash
# static_transform_publisher x y z yaw pitch roll frame_id child_frame_id period_in_ms
# tf_echo &lt;source_frame&gt; &lt;target_frame&gt;
# rot_x = 5 deg: 0.0872665, rot_y = -10 deg: -0.1745329, rot_z = 15 deg: 0.2617994
rosrun tf static_transform_publisher 0 0 0 0.2617994 -0.1745329 0.0872665 parent_frame child_frame 100
rosrun tf tf_echo parent_frame child_frame

</code></pre></div></div>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/doc/sick_scan_api/trafo_example.py">trafo_example.py</a> demonstrates how a transform can be computed.</p>

<p>For upside down mounted devices, the point cloud can be rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lrs_36x0_upside_down.launch">sick_lrs_36x0_upside_down.launch</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lrs_36x1_upside_down.launch">sick_lrs_36x1_upside_down.launch</a> show examples for compensating the point cloud of an upside down mounted device by a 180 deg rotation about the x axis.</p>

<h2 id="imu-support">IMU Support</h2>

<p>Devices of the MRS6xxx and MRS1xxx series are available with an optionally built-in IMU.</p>

<p>For the IMU support of multiScan100 and picoScan100 refer to the device specific section.</p>

<p>By setting the following config parameter in the launch file, the output of <a href="http://docs.ros.org/melodic/api/sensor_msgs/html/msg/Imu.html">imu messages</a> can be enabled with a compatible scanner. Currently the messages are published in the /imu Topic.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_enable"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">value=</span><span class="s">"True"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_topic"</span> <span class="na">type=</span><span class="s">"string"</span> <span class="na">value=</span><span class="s">"imu"</span><span class="nt">/&gt;</span>

</code></pre></div></div>
<p>The imu Messages contain covariance matrices, these are currently determined from empirical values and are not measured specifically for each scanner.
The laser scanner provides additional information (tick timestamp and confidence) to the Imu messages these can be activated by activating the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/msg/SickImu.msg">SickImu messages</a>.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_enable_additional_info"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">value=</span><span class="s">"True"</span> <span class="nt">/&gt;</span>

</code></pre></div></div>

<p>IMU messages are only supported in SOPAS binary mode. Due to the high data rate of the IMU messages (100 Hz and more) while sending the standard laser scanner messages at the same time, the ASCII mode is not supported. Please set the scanner to binary mode if you are using the IMU.</p>

<h2 id="encoders">Encoders</h2>

<p>If the device is mounted for mobile use or if the objects to be measured are in motion,the application will usually also need position data to further process the measured val‐ues.Encoders can be connected for this purpose. The encoder data is then available withthe other measured values in a single scan and at the same interface. A volume,for example, can be calculated by evaluating the measurement data. The input fre‐quency of the encoder signal must not exceed 50 kHz.The following encoders with push-pull output stage can be used:</p>
<ol>
  <li>Single-channel, only connected at encoder A, no direction detection.</li>
  <li>Dual-channel (phase), connected at encoder A and encoder B; the pulses have aphase shift of 90°, making direction detection possible. By definition, during for‐ward motion (CW = clockwise) phase A precedes phase B; conversely, duringreverse motion (CCW = counterclockwise) edge A rises before edge B.</li>
  <li>Dual-channel (level), connected at encoder A and encoder B; the pulses are atencoder A; at encoder B, the direction is indicated by level 0 or level 1 (rarely).</li>
</ol>

<h3 id="connecting-encoders">Connecting encoders</h3>
<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/lms4xxx_encoder_connection.png" alt="LMS4000 encoder connection" title="LMS4000 encoder connection">
See also <a href="https://cdn.sick.com/media/docs/0/90/790/Operating_instructions_LMS4000_2D_LiDAR_sensors_en_IM0079790.PDF">LMS4000 Manual</a></p>

<h3 id="example-circuit-to-trigger-encoder-counts">Example circuit to trigger encoder counts</h3>
<p>Whenever the switch is closed a potential of 24 V is applied to the encoder input A in mode (01 single-channel) this leads to an increase of the count by 1.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/circuit.png" alt="encoder trigger" title="encoder trigger"></p>

<h3 id="activation-of-encoder-information">Activation of encoder information</h3>
<p>If the parameter</p>
<pre><code class="language-encoder_mode">``` is set to 1-4 in the launch file, the encoder is activated in the laser scanner in the corresponding mode (see list above).

The following encoder modes can be configured in the launch file or by commandline parameter:
* `encoder_mode:=-1`: Default value, i.e. encoder configuration not set
* `encoder_mode:=0`: Encoder off (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=1`: Single increment (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=2`: Direction recognition phase (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=3`: Direction recognition level (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=4`: Fixed increment speed/ticks (supported by LMS4000 only)

Encoder messages are published on topic `/encoder` synchronously to the point cloud messages. They contain a timestamp and the encoder value, e.g.:

```console
foo@bar:~$rostopic echo /encoder
header:
  seq: 20700
  stamp:
    secs: 1570722972
    nsecs:  28866142
  frame_id: "Encoder"
enc_count: 836
---
header:
  seq: 20701
  stamp:
    secs: 1570722972
    nsecs:  30598181
  frame_id: "Encoder"
enc_count: 836
---
header:
  seq: 20702
  stamp:
    secs: 1570722972
    nsecs:  32138020
  frame_id: "Encoder"
enc_count: 836

</code></pre>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/Encoder_data.png" alt="Encoderdata in Sopas datagramm" title="Encoderdata in Sopas datagramm"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/set_encoder_settings.png" alt="Set encoder config" title="Set encoder config"></p>

<h2 id="field-evaluation-information">Field Evaluation Information</h2>

<p>The LMS1xx, LMS5xx, TiM7xx and TiM7xxS families support extensions for field monitoring.</p>

<h3 id="field-monitoring-messages">Field monitoring messages</h3>

<p>LMS1xx, LMS5xx, TiM7xx and TiM7xxS scanner support field monitoring. Fields can be configured by Sopas ET. Once they are configured, sick_scan_xd publishes ros messages containing the monitoring information from the lidar.</p>

<p>By default, field monitoring is enabled in the launch files <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lms_1xx.launch">sick_lms_1xx.launch</a>,  <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lms_5xx.launch">sick_lms_5xx.launch</a>,
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_tim_7xx.launch">sick_tim_7xx.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_tim_7xxS.launch">sick_tim_7xxS.launch</a> by following settings:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="activate_lferec" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lferec messages --&gt;
&lt;param name="activate_lidoutputstate" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lidoutputstate messages --&gt;
&lt;param name="activate_lidinputstate" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lidinputstate messages --&gt;

</code></pre></div></div>

<p>The driver queries the field configuration from the lidar and activates field monitoring by sending cola commands <code class="language-plaintext highlighter-rouge">"sEN LFErec 1"</code> and <code class="language-plaintext highlighter-rouge">"sEN LIDoutputstate 1"</code> at startup. Field monitoring is deactivated when driver exits. During runtime, it’s possible to query, activate or deactivate monitoring using ros service ColaMsg with the following command (see section <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#cola-commands">Cola commands</a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LFErec 1'}" # activate LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LFErec 0'}" # deactivate LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LFErec'}"   # query activation status of LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDoutputstate 1'}" # activate LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDoutputstate 0'}" # deactivate LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LIDoutputstate'}"   # query activation status of LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDinputstate 1'}"  # activate LIDinputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDinputstate 0'}"  # deactivate LIDinputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LIDinputstate'}"    # query activation status of LIDinputstate messages

</code></pre></div></div>

<p>LFErec and LIDoutputstate messages are defined in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/msg/LFErecMsg.msg">LFErecMsg.msg</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/msg/LFErecFieldMsg.msg">LFErecFieldMsg.msg</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/msg/LIDoutputstateMsg.msg">LIDoutputstateMsg.msg</a> and published on the following topics: <code class="language-plaintext highlighter-rouge">"/sick_tim_7xxS/lferec"</code> resp. <code class="language-plaintext highlighter-rouge">"/sick_tim_7xxS/lidoutputstate"</code>.</p>

<table>
  <thead>
    <tr>
      <th>** Lidar **</th>
      <th>** lferec topic **</th>
      <th>** lidoutputstate topic **</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>lms_1xx</td>
      <td>/sick_lms_1xx/lferec</td>
      <td>/sick_lms_1xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_5xx</td>
      <td>/sick_lms_5xx/lferec</td>
      <td>/sick_lms_5xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_7xx</td>
      <td>/sick_tim_7xx/lferec</td>
      <td>/sick_tim_7xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_7xxS</td>
      <td>/sick_tim_7xxS/lferec</td>
      <td>/sick_tim_7xxS/lidoutputstate</td>
    </tr>
  </tbody>
</table>

<p>To view the field monitoring messages, run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic echo "/sick_lms_1xx/lferec"
rostopic echo "/sick_lms_1xx/lidoutputstate"
rostopic echo "/sick_lms_5xx/lferec"
rostopic echo "/sick_lms_5xx/lidoutputstate"
rostopic echo "/sick_tim_7xx/lferec"
rostopic echo "/sick_tim_7xx/lidoutputstate"
rostopic echo "/sick_tim_7xxS/lferec"
rostopic echo "/sick_tim_7xxS/lidoutputstate"

</code></pre></div></div>
<p>or use rviz to visualize monitored fields and their status (see section <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#visualization-with-rviz">Visualization with rviz</a>)</p>

<p>The most important values of the field monitoring messages are</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">field_index</code> (uint8) and <code class="language-plaintext highlighter-rouge">field_result_mrs</code> (uint8) for each field of a LFErec message with result status<br>&lt;ul&gt;
    </li>
<li>0: invalid / incorrect,</li>
    <li>1: free / clear, or</li>
    <li>2: infringed.</li>
    <p>&lt;/ul&gt;</p>
  
  <li>
<code class="language-plaintext highlighter-rouge">output_state</code> (uint8) for each LIDoutputstate message with status 0 (not active), 1 (active) or 2 (not used).</li>
</ul>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Field monitoring currently supports binary cola messages only, which is the default. If cola ascii is activated, please switch back to cola binary for field monitoring.</p>
</blockquote>

<h3 id="visualization-with-rviz">Visualization with rviz</h3>

<p>The point cloud, the monitored fields and their status can be visualized using rviz. Use the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/emulator/config/rviz_emulator_cfg.rviz">rviz configuration file</a>
and run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz

</code></pre></div></div>

<p>Otherwise you can just add visualizations of type <code class="language-plaintext highlighter-rouge">/cloud/PointCloud2</code> and <code class="language-plaintext highlighter-rouge">/sick_tim_7xxS/marker</code> (resp. <code class="language-plaintext highlighter-rouge">/sick_tim_1xx/marker</code> for lms_1xx,  <code class="language-plaintext highlighter-rouge">/sick_tim_5xx/marker</code> for lms_5xx and  <code class="language-plaintext highlighter-rouge">/sick_tim_7xx/marker</code> for tim_7xx):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/tim7xxs_screenshot01.png" alt="tim7xxs_screenshot01.png"></p>

<p>The following screenshot shows a TiM781S example with 2 fields (the 3. field is not configured), the first field with status “Clear”, the second with status “Infringed”:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/tim7xxs_screenshot02.png" alt="tim7xxs_screenshot02.png"></p>

<p>The following screenshot shows a LMS511 example with a segmented field, two rectangular fields and a dynamic fields:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/lms511_screenshot01.png" alt="lms511_screenshot01.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Some combinations of rviz, OpenGL 3, VMware and graphic card drivers may cause visualization issues. In case of missing markers, try rviz with Open GL 2 using the command</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz --opengl 210

</code></pre></div></div>

<h3 id="cola-commands">Cola commands</h3>

<p>Cola commands can be sent for diagnosis and development using the ros service ColaMsg. This service is implemented in sick_scan_xd and started by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="start_services" type="bool" value="True"/&gt;

</code></pre></div></div>
<p>in the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_tim_7xxS.launch">sick_tim_7xxS.launch</a> (resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lms_1xx.launch">sick_lms_1xx.launch</a>, <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lms_5xx.launch">sick_lms_5xx.launch</a>, <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_tim_7xx.launch">sick_tim_7xx.launch</a> ). The ros service sends the given cola command to the lidar and returns its response.</p>

<p>Example for cola command <code class="language-plaintext highlighter-rouge">"sRN SCdevicestate"</code> and response <code class="language-plaintext highlighter-rouge">"sRA SCdevicestate \\x00"</code> with error status 0 (no error):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN SCdevicestate'}"
response: "sRA SCdevicestate \\x00"

</code></pre></div></div>

<h3 id="tools-emulation-and-unittests">Tools, emulation and unittests</h3>

<p>Package sick_scan_xd implements some tools to support unittests, development and emulation of Tim781S devices:</p>

<ul>
  <li>sick_scan_emulator to emulate lidar devices and enable unittests (currently for Tim781S only)</li>
  <li>pcap_json_converter to convert pcapng-files to json.</li>
</ul>

<h4 id="lms-and-tim-emulation">LMS and TiM emulation</h4>

<p>sick_scan_emulator implements a simple test server for cola commands. It rececives Cola-commands, returns Tim781S-like responses and sends Scandata from a json-file. Run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_01_default.launch

</code></pre></div></div>
<p>to emulate a local Tim781S device. Then start and connect the sick_scan_xd driver by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>Note that sick_scan_emulator just implements a simple server for offline tests. It does not emulate a lidar device completely and should only be used for development and testing.</p>

<p>Scandata messages are parsed from json-file(s). These json-files are configured in the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/emulator/launch/emulator_01_default.launch">emulator.launch</a> and converted form wireshark-records (pcapng-files) using pcap_json_converter.py (see section Pcapng converter tool](#pcapng-converter-tool)).</p>

<p>A LMS111 device can be emulated by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_lms1xx.launch &amp;
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms1xx.rviz &amp;
roslaunch sick_scan_xd sick_lms_1xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>A LMS511 device can be emulated by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_lms5xx.launch &amp;
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms5xx.rviz &amp;
roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<h4 id="unittests">Unittests</h4>

<p>Folder <code class="language-plaintext highlighter-rouge">test/emulator/scandata</code> contains scandata examples for unittests. To run an offline unittest for LMS111, LMS511, TiM781, TiM781S enter the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd test/scripts
./run_simu_lms1xx.bash
./run_simu_lms5xx.bash
./run_simu_tim7xx_tim7xxS.bash

</code></pre></div></div>
<p>or start emulator, driver and rviz by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1
# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz --opengl 210 &amp;
sleep 1
# Start sick_scan_xd driver for TiM871S
roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<h4 id="pcapng-converter-tool">Pcapng converter tool</h4>

<p>The pcapng converter tool <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/pcap_json_converter/pcap_json_converter.py">pcap_json_converter.py</a> converts pcapng-files to json-files. Run the following steps to create a json-file with scandata for the emulator:</p>

<ol>
  <li>Start wireshark and filter the tcp traffic on port 2112 with the filter expression <code class="language-plaintext highlighter-rouge">tcp and tcp.port==2112</code>.</li>
  <li>Start TiM781S and run the sick_scan_xd driver.</li>
  <li>Capture the network traffic for some time.</li>
  <li>Stop capturing and save the network traffic in a pcapng-file.</li>
  <li>Convert the pcapng-file to json by <code class="language-plaintext highlighter-rouge">python pcap_json_converter.py --pcap_filename=&lt;filepath&gt;.pcapng</code>. Result is a jsonfile <code class="language-plaintext highlighter-rouge">&lt;filepath&gt;.pcapng.json</code>
</li>
  <li>Set the resulting json-file in the emulator configuration <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/emulator/launch/emulator_01_default.launch">emulator.launch</a> by <code class="language-plaintext highlighter-rouge">&lt;arg name="scandatafiles" default="&lt;filepath&gt;.pcapng.json"/&gt;</code>
</li>
</ol>

<h2 id="slam-support">SLAM Support</h2>

<h3 id="introduction">Introduction</h3>

<p>In robotic mapping and navigation, simultaneous localization and mapping (SLAM) is the computational problem of constructing or updating a map of an unknown environment while simultaneously keeping track of an agent’s location within it. For further details please refer to https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping .</p>

<h3 id="measuring-principle">Measuring Principle</h3>

<p>The following assumes that the SLAM algorithm works with a laser scanner mounted on a mobile base. The mobile base (e.g. a robot) records the environment while driving and creates the map from it. The mobile base usually has a so-called intertial measurement unit (IMU). In principle, however, it is also possible to estimate the direction of movement from the chronological sequence of the laser scans by means of correlation observations. The laser scanner then virtually takes over the task of the IMU and other components (e.g. counting the wheel revolutions). The method of estimating the position and orientation (position estimation) of a mobile system based on data from its driving system is called odometry (cf. https://en.wikipedia.org/wiki/Odometry).</p>

<p>The SLAM algorithm hector_slam (http://wiki.ros.org/hector_slam) supports odometry estimation directly from the laser scans and is therefore used as a reference implementation in the following.</p>

<p>Other widely used SLAM algorithms such as gmapping (cf. http://wiki.ros.org/gmapping ) do not have this option. They depend on the data of an IMU. One possibility to use Gmapping nevertheless is the integration of the project laser_scan_matcher (https://answers.ros.org/question/63457/gmapping-without-odom/ and http://wiki.ros.org/laser_scan_matcher ).  Here, however, the pose must still be converted into an odometry message (see https://answers.ros.org/question/12489/obtaining-nav_msgsodometry-from-a-laser_scan-eg-with-laser_scan_matcher/ ).</p>

<h3 id="nav350-ros-1-slam-example">NAV350 ROS 1 SLAM example</h3>

<p>Build hector_slam and sick_scan_xd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd src
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
git clone https://github.com/tu-darmstadt-ros-pkg/hector_slam.git
cd ..
catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DCMAKE_ENABLE_EMULATOR=1 -Wno-dev

</code></pre></div></div>

<p>Run rviz, sick_scan_xd with NAV350 and hector_slam:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./devel_isolated/setup.bash
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_slam_nav350.rviz &amp;
roslaunch sick_scan sick_nav_350.launch hostname:=192.168.0.1 tf_publish_rate:=0 &amp;
roslaunch sick_scan test_200_slam_ros1_hector.launch scan_topic:=/scan scan_layer_0_frame_id:=cloud_POS_000_DIST1 cloud_frame_id:=cloud &amp;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  By default, sick_scan_xd publishes transform (TF) messages, which map frame id “map” to the point cloud frame id. To avoid conflicts with hector SLAM, it is recommended to disable these TF messages by commandline parameter <strong><code class="language-plaintext highlighter-rouge">tf_publish_rate:=0</code></strong> or by setting <code class="language-plaintext highlighter-rouge">&lt;param name="tf_publish_rate" type="double" value="0"/&gt;</code> in the launchfile.</p>
</blockquote>

<p>The following rviz screenshot shows an example of a NAV350 pointcloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/slam_example_ros1_nav350.png" alt="slam_example_ros1_nav350.png"></p>

<h3 id="nav350-ros-2-slam-example">NAV350 ROS 2 SLAM example</h3>

<p>Install ths ROS 2 slam-toolbox with <code class="language-plaintext highlighter-rouge">sudo apt install ros-foxy-navigation2 ros-foxy-nav2-bringup ros-foxy-slam-toolbox</code> (replace <code class="language-plaintext highlighter-rouge">foxy</code> by your ros distribution).</p>

<p>Build sick_scan_xd for ROS 2 as described in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#install-on-ros-2">INSTALL ROS 2</a></p>

<p>Run rviz2, sick_scan_xd, slam_toolbox and static transforms:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
ros2 run rviz2 rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_slam_nav350.rviz &amp;
ros2 launch sick_scan sick_nav_350.launch.py hostname:=192.168.0.1 tf_publish_rate:=0 &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 base_link cloud  &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 base_footprint base_link  &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 odom base_footprint  &amp;
ros2 launch nav2_bringup navigation_launch.py &amp;
ros2 launch slam_toolbox online_async_launch.py &amp;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Laserscan messages need to be remapped to topic <code class="language-plaintext highlighter-rouge">/scan</code> (default is <code class="language-plaintext highlighter-rouge">/sick_nav_350/scan</code>). Use <code class="language-plaintext highlighter-rouge">remappings=[ ('/sick_nav_350/scan', '/scan'), ]</code> in the launchfile, e.g.:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node = Node(
    package='sick_scan',
    executable='sick_generic_caller',
    output='screen',
    remappings=[ ('/sick_nav_350/scan', '/scan'), ], # remap laserscan messages to topic /scan
)

</code></pre></div></div>

<p>The following rviz2 screenshot shows an example of a NAV350 laserscan created by sick_scan_xd and its map generated by slam_toolbox on ROS 2:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/slam_example_ros2_nav350.png" alt="slam_example_ros2_nav350.png"></p>

<h3 id="picoscan100-ros-1-slam-example">picoScan100 ROS 1 SLAM example</h3>

<p>Run rviz, sick_scan_xd with picoScan100 and hector_slam:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./devel_isolated/setup.bash
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_slam_multiscan.rviz &amp;
roslaunch sick_scan sick_nav_350.launch hostname:=192.168.0.1 hostname:=127.0.0.1 udp_receiver_ip:=192.168.0.100 tf_publish_rate:=0 &amp;
roslaunch sick_scan test_200_slam_ros1_hector.launch scan_topic:=/sick_picoscan/scan_fullframe scan_layer_0_frame_id:=world_1 cloud_frame_id:=world &amp;

</code></pre></div></div>
<p>Replace ip address <code class="language-plaintext highlighter-rouge">192.168.0.100</code> with the ip address of your local machine running sick_scan_xd.</p>

<p>The following rviz screenshot shows an example of a picoScan100 point cloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/slam_example_ros1_picoscan.png" alt="slam_example_ros1_picoscan.png"></p>

<h3 id="mrs1104-slam-support">MRS1104 SLAM support</h3>

<p>MRS1104 provides 4 layers covering elevation angles at -2.5°, 0.0°, 2.5° and 5.0°. The layer with 0.0° is used for SLAM by default. The following rviz screenshot shows an example of a MRS1104 point cloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/slam_example_ros1_mrs1104.png" alt="slam_example_ros1_mrs1104.png"></p>

<p>Since Hector-Slam expects only one laser scan frame with a unique identifier for the laser scans, the following parameters were added to the driver.</p>

<p>slam_echo: The name of the echo is entered here, which is filtered out of all possible 12 echoes. This should be “laser_POS_000_DIST1”. This exports the first hit in the position with an elevation angle of 0°. If you want to use the layers with elevation angles -2.5°, 2.5° and 5.0°, you can set another flag with the name slam_bundle to True. If this flag is set, the oblique distances are multiplied by the cosine in this direction to obtain the projection onto the XY plane. This quadruples the number of points and increases the scan rate from 12.5 Hz to 50 Hz. However, for oblique impact surfaces (i.e. no vertical walls) this method can lead to larger estimation errors. In this case slam_bundle should be set to false.</p>

<h3 id="google-cartographer">Google Cartographer</h3>

<p>The support of Google Cartographer was made possible by a number of extensions to the driver. On the driver side, the MRS1104 is prepared to support the Google Cartographer. The Google Cartographer expects data packets at a high recording density (several hundred packets per second) to perform the SLAM algorithm. For this reason, an option has been introduced that allows the scans to be chopped into small angular ranges. The time stamps for these small ranges were converted accordingly.</p>

<p>Setup Google Cartographer (these steps are for illustration only, you must adapt these lines to your local directory names)</p>

<ol>
  <li>Login to Ubuntu.</li>
  <li>Open multiple terminals.</li>
  <li>Terminal 1:
. ros1_start.sh
roscore</li>
  <li>Terminal 2:
  . ros1_start.sh
cd ~/ros_catkin_ws
source ./devel/setup.bash</li>
  <li>Terminal 3:
roslaunch sick_scan_xd sick_mrs_1xxx_cartographer.launch cloud_topic:=horizontal_laser_3d frame_id:=horizontal_vlp16_link</li>
  <li>Terminal 4:
roslaunch sick_scan_xd sick_tim_5xx.launch cloud_topic:=vertical_laser_3d frame_id:=vertical_vlp16_link hostname:=192.168.0.71</li>
  <li>
    <p>Terminal 5:</p>

    <ul>
      <li>. ros1_start.sh</li>
      <li>cd ~/ros_cartographer_ws</li>
      <li>source ./install_isolated/setup.bash</li>
      <li>catkin_make_isolated</li>
      <li>roslaunch cartographer_ros live_demo_backpack_3d.launch</li>
    </ul>
  </li>
</ol>

<p><strong>Example output</strong></p>

<p>The following figure shows an example of an outdoor slam result using a MRS1104:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/slam_example.png" alt="slam_example"></p>

<h3 id="octomap">OctoMap</h3>

<p><a href="https://github.com/OctoMap">OctoMap</a> models a 3D occupancy map. The octomap_server builds and distributes volumetric 3D occupancy maps from a 3D point cloud. Tutorials and examples can be found e.g. in <a href="https://www.arminhornung.de/Research/pub/hornung13roscon.pdf">3D Mapping with OctoMap</a>, <a href="https://github.com/tejalbarnwal/octomap_tutorial">octomap_tutorial</a> and <a href="https://www.youtube.com/watch?v=dF2mlKJqkUg">Basic usage of octomap_mapping</a>. Note that OctoMap is not a fully SLAM algorithm, but it can create 2D and 3D maps from point clouds.</p>

<p>Run the following steps to build and run OctoMap and sick_scan_xd with a multiScan100 lidar on ROS 1:</p>
<ol>
  <li>Clone OctoMap + sick_scan_xd:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone https://github.com/SICKAG/sick_scan_xd.git
    git clone https://github.com/OctoMap/octomap_ros.git
    git clone https://github.com/OctoMap/octomap_msgs.git
    git clone https://github.com/OctoMap/octomap_mapping.git
    popd
    
</code></pre></div></div>
<ol>
  <li>Set topic and frame_id for multiScan100 in octomap_mapping.launch:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="frame_id" type="string" value="world" /&gt;
    &lt;remap from="cloud_in" to="/cloud_unstructured_fullframe" /&gt;
    
</code></pre></div></div>
<ol>
  <li>Build:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
    
</code></pre></div></div>
<ol>
  <li>Run OctoMap + sick_scan_xd:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Run sick_scan_xd + multiScan100
    roslaunch sick_scan_xd sick_multiscan.launch hostname:="192.168.0.1" udp_receiver_ip:=" 192.168.0.100"
    # Run octomap_server
    roslaunch octomap_server octomap_mapping.launch
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Replace parameter "hostname" with the ip address of the multiScan100 lidar and "udp_receiver_ip" with the ip address of the PC running sick_scan_xd. 5. Visualize OctoMap with rviz:
* Add MarkerArray topic "/occupied_cells_vis_array“ (colored voxels)
* Add Map topic "/projected_map“ (gray 2D Projection) 6. Save the OctoMap:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rosrun octomap_server octomap_saver -f ./octomap_multiscan.bt
    
</code></pre></div></div>
<ol>
  <li>Publish the saved OctoMap:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rosrun octomap_server octomap_server_node ./octomap_multiscan.bt
    
</code></pre></div></div>
<p>The following screenshot shows an example of an octomap created from a multiScan100 point cloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/octomap_example_ros1_multiscan.png" alt="octomap_example_ros1_multiscan"></p>

<h3 id="rtab-map">RTAB-Map</h3>

<p><a href="https://introlab.github.io/rtabmap/">RTAB-Map</a> (Real-Time Appearance-Based Mapping) is a RGB-D, Stereo and Lidar Graph-Based SLAM approach, which can be used for 3D-SLAM in combination with multiScan100 or other SICK lidars. sick_scan_xd provides a 3D-SLAM example using RTAB-Map with the multiScan100 lidar. The following section describes how to install and run RTAB-Map with sick_scan_xd and a multiScan.</p>

<h4 id="install-on-ros-1">Install on ROS 1</h4>

<p>Run the following steps to build rtabmap and sick_scan_xd with on ROS 1:</p>

<ol>
  <li>Build the prerequisites for RTAB-Map:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo apt-get install libboost-all-dev
    sudo apt-get install libeigen3-dev
    sudo apt-get install libsdl-image1.2-dev
    sudo apt-get install libsdl-dev
    sudo apt-get install ros-noetic-nav-msgs
    sudo apt-get install ros-noetic-tf2-sensor-msgs
    sudo apt-get install ros-noetic-imu-filter-madgwick
    sudo apt-get install python3-wstool
    sudo apt-get install ros-noetic-scan-tools
    pushd /tmp
    mkdir -p libnabo/build &amp;&amp; pushd libnabo/build
    cmake ..
    cmake --build .
    sudo cmake --build . --target install
    popd
    mkdir -p libpointmatcher/build &amp;&amp; pushd libpointmatcher/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    mkdir -p rtabmap/build &amp;&amp; pushd rtabmap/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    popd
    
</code></pre></div></div>
<ol>
  <li>Build RTAB-Map and sick_scan_xd in your workspace:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone https://github.com/ros-planning/navigation.git
    git clone https://github.com/ros-planning/navigation_msgs.git
    git clone https://github.com/introlab/rtabmap_ros.git
    git clone https://github.com/SICKAG/sick_scan_xd.git
    popd
    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
    sudo ldconfig
    
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">sudo ldconfig</code> if you encounter errors while loading shared libraries.</p>

<p>Note that building rtabmap with libpointermatch is highly recommended.</p>

<h4 id="run-rtab-map-and-multiscan100-on-ros-1">Run RTAB-MAP and multiScan100 on ROS 1</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan_rtabmap.launch">sick_multiscan_rtabmap.launch</a> provides a launch file to run 3D-SLAM using rtabmap and sick_scan_xd with a multiScan100 lidar. The SLAM parameters are just examples taken from <a href="https://github.com/introlab/rtabmap_ros/blob/master/rtabmap_examples/launch/test_ouster.launch">rtabmap_examples/launch/test_ouster.launch</a>. Run <code class="language-plaintext highlighter-rouge">rosrun rtabmap_slam rtabmap --params</code> to see all RTAB-Map options, parameters and their meaning and adopt launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan_rtabmap.launch">sick_multiscan_rtabmap.launch</a> if required.</p>

<p>Run the following command to start rtabmap and sick_scan_xd with a multiScan100 lidar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install_isolated/setup.bash
roslaunch sick_scan_xd sick_multiscan_rtabmap.launch hostname:="191.168.0.1" udp_receiver_ip:=" 191.168.0.100"

</code></pre></div></div>
<p>Replace parameter “hostname” with the ip address of the multiScan100 lidar and “udp_receiver_ip” with the ip address of the PC running sick_scan_xd. The following screenshot shows an example of RTAB-MAP and a multiScan100 point cloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/rtabmap_example_ros1_multiscan.png" alt="rtabmap_example_ros1_multiscan"></p>

<p>To visualize SLAM results, add e.g. topics <code class="language-plaintext highlighter-rouge">/rtabmap/grid_map</code>, <code class="language-plaintext highlighter-rouge">/rtabmap/localization_pose</code> and <code class="language-plaintext highlighter-rouge">/rtabmap/odom</code> in rviz.</p>

<p>rtabmap provides services to switch to mapping or localization mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /rtabmap/resume                # resume after pause
rosservice call /rtabmap/trigger_new_map       # start a new map
rosservice call /rtabmap/set_mode_mapping      # set mapping mode
rosservice call /rtabmap/set_mode_localization # set localization mode

</code></pre></div></div>

<p>Alternatively, you can use the options in rtabmap-viz:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/rtabmap_viz_options.png" alt="rtabmap_viz_options"></p>

<h4 id="install-on-ros-2">Install on ROS 2</h4>

<p>Building rtabmap and sick_scan_xd on ROS 2 is similar to ROS 1. Run the following steps to build rtabmap and sick_scan_xd with on ROS 2:</p>

<ol>
  <li>Build the prerequisites for RTAB-Map:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo apt-get install libboost-all-dev
    sudo apt-get install libeigen3-dev
    sudo apt-get install libsdl-image1.2-dev
    sudo apt-get install libsdl1.2-dev
    sudo apt-get install ros-humble-nav-msgs
    sudo apt-get install ros-humble-tf2-sensor-msgs
    sudo apt-get install ros-humble-imu-filter-madgwick
    sudo apt-get install python3-wstool
    sudo apt-get install ros-humble-scan-tools
    sudo apt install ros-humble-pcl-ros
    pushd /tmp
    git clone https://github.com/introlab/rtabmap.git rtabmap
    git clone https://github.com/ethz-asl/libnabo.git libnabo
    git clone https://github.com/ethz-asl/libpointmatcher.git libpointmatcher
    mkdir -p libnabo/build &amp;&amp; pushd libnabo/build
    cmake ..
    cmake --build .
    sudo cmake --build . --target install
    popd
    mkdir -p libpointmatcher/build &amp;&amp; pushd libpointmatcher/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    mkdir -p rtabmap/build &amp;&amp; pushd rtabmap/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    popd
    
</code></pre></div></div>
<ol>
  <li>Build RTAB-Map and sick_scan_xd in your workspace:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone --branch ros2 https://github.com/introlab/rtabmap_ros.git rtabmap_ros
    git clone https://github.com/SICKAG/sick_scan_xd.git
    popd
    rosdep update &amp;&amp; rosdep install --from-paths src --ignore-src -r -y
    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    colcon build --symlink-install --cmake-args " -DROS_VERSION=2" " -DCMAKE_ENABLE_EMULATOR=1" "-DCMAKE_BUILD_TYPE=Release" --event-handlers console_direct+
    sudo ldconfig
    
</code></pre></div></div>

<h4 id="run-rtab-map-and-multiscan100-on-ros-2">Run RTAB-MAP and multiScan100 on ROS 2</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan_rtabmap.launch.py">sick_multiscan_rtabmap.launch.py</a> provides a launch file to run 3D-SLAM using rtabmap and sick_scan_xd with a multiScan100 lidar. The SLAM parameters are examples taken from <a href="https://github.com/introlab/rtabmap_ros/blob/master/rtabmap_examples/launch/test_ouster.launch">rtabmap_examples/launch/test_ouster.launch</a>.</p>

<p>Run the following command to start rtabmap and sick_scan_xd with a multiScan100 lidar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
ros2 launch sick_scan_xd sick_multiscan_rtabmap.launch.py hostname:="191.168.0.1" udp_receiver_ip:=" 191.168.0.100"

</code></pre></div></div>
<p>Replace parameter “hostname” with the ip address of the multiScan100 lidar and “udp_receiver_ip” with the ip address of the PC running sick_scan_xd.</p>

<p>rtabmap provides services to switch to mapping or localization mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /rtabmap/resume std_srvs/srv/Empty                # resume after pause
ros2 service call /rtabmap/trigger_new_map std_srvs/srv/Empty       # start a new map
ros2 service call /rtabmap/set_mode_mapping std_srvs/srv/Empty      # set mapping mode
ros2 service call /rtabmap/set_mode_localization std_srvs/srv/Empty # set localization mode

</code></pre></div></div>

<h2 id="raspberry-pi-support">Raspberry Pi Support</h2>

<p>sick_scan_xd supports Linux on Raspberry Pi 4. Follow the build instructions for Linux to run sick_scan_xd on a Raspberry:</p>
<ul>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-generic-without-ros">Build on Linux generic without ROS</a></li>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-ros-1">Build on Linux ROS 1</a></li>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-ros-2">Build on Linux ROS 2</a></li>
</ul>

<p>Cmake option “ -DRASPBERRY=1” activates compiler settings for the Raspberry. Laserscan messages and polar pointclouds are not published on the Raspberry due to performance reasons.</p>

<h3 id="multiscan100-example">multiScan100 example</h3>

<p>The following screenshot shows sick_scan_xd running under ROS 1 on a Raspberry Pi 4 connected to a multiScan100 lidar. A Linux-PC uses rviz to display the fullframe point cloud generated on the Raspberry. The ssh-terminal shows the sick_scan_xd log messages on the Raspberry:
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/raspberry-perftest-04.png" alt="screenshot raspberry performance test"></p>

<p>On a Raspberry Pi 4, sick_scan_xd processes 240 messages/second with a mean latency of 2.7 milliseconds/message.</p>

<h3 id="performance">Performance</h3>

<p>Due to the low power consumption of a Raspberry Pi, performance is critical for applications using sick_scan_xd, especially for multiScan100 lidars.</p>

<p>Symptoms for performance problems can be e.g.:</p>
<ul>
  <li>sick_scan_xd reports the loss of UDP packets or message drops</li>
  <li>sick_scan_xd does not publish the fullframe pointcloud</li>
  <li>rviz shows flickering segment pointclouds even with increased decay time</li>
  <li>low frequency of segment or fullframe pointcloud messages</li>
  <li>generally high system load</li>
</ul>

<p>Performance problems can have very different reasons. Notes to help with the elimination of performance issues:</p>

<ol>
  <li>
    <p>Use the latest Raspberry Pi 4. Previous Raspberry Pi models may work with sick_scan_xd, but are not supported officially.</p>
  </li>
  <li>
    <p>Eliminate multiple echos. For most lidars, the echo filter is activated by default and only the last echo is transmitted. Check the launch file configuration and set parameter <code class="language-plaintext highlighter-rouge">filter_echos</code> if not yet done:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="filter_echos" type="int" value="2"/&gt; &lt;!-- FREchoFilter settings: 0: first echo, 1: all echos, 2: last echo --&gt;
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For multican lidars, the echo filter is activated in the launch file by parameter `host_FREchoFilter`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="host_FREchoFilter" type="int" value="2" /&gt;          &lt;!-- Optionally set FREchoFilter with 0 for FIRST_ECHO (default, EchoCount=1), 1 for ALL_ECHOS (EchoCount=3), or 2 for LAST_ECHO (EchoCount=1) --&gt;
    &lt;param name="host_set_FREchoFilter" type="bool" value="True" /&gt;  &lt;!-- If true, FREchoFilter is set at startup (default: false) --&gt;
    
</code></pre></div></div>

<ol>
  <li>Run a basic performance test on ROS 2 using a tiny sopas test server and a udp player to emulate a multiscan:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Start multiScan100 emulator (sopas test server)
    python3 ./src/sick_scan_xd/test/python/multiscan_sopas_test_server.py --tcp_port=2111 --cola_binary=0 &amp;
    # Start rviz
    ros2 run rviz2 rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_cfg_multiscan_emu_360_perftest.rviz &amp;
    sleep 1
    # Start sick_generic_caller with sick_scansegment_xd
    ros2 launch sick_scan sick_multiscan.launch.py hostname:=127.0.0.1 udp_receiver_ip:="127.0.0.1" &amp;
    sleep 3
    # Play udp packets to emulate multiScan
    python3 ./src/sick_scan_xd/test/python/multiscan_perftest_player.py --udp_port=2115 --repeat=100 --send_rate=100 --verbose=0 --prompt=0
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The result should look like the follwing screenshot:
![screenshot raspberry performance test](doc/screenshots/raspberry-perftest-01.png)
If you otherwise observe the loss of UDP packets, message drops, missing pointclouds or mean latency times significantly higher than 6 milliseconds/message, check the system load of your Raspberry and try to eliminate cpu or network intensive processes.
</code></pre></div></div>

<ol>
  <li>Start sick_scan and the sopas test server on the Raspberry as above, but run the udp player <code class="language-plaintext highlighter-rouge">multiscan_perftest_player.py</code> on another PC in your local subnet, e.g.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    python3 multiscan_perftest_player.py --dst_ip=192.168.1.27 --udp_port=2115 --repeat=1000 --send_rate=0 --force_delay=3.0e-3 --verbose=0 --prompt=0
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Replace the example ip adress `192.168.1.27` by the ip adress of your Raspberry. The result should look like the follwing screenshot:
![screenshot raspberry performance test](doc/screenshots/raspberry-perftest-02.png)
If you otherwise observe the loss of UDP packets, message drops, missing pointclouds or mean latency times significantly higher than 6 milliseconds/message, check the system load of your Raspberry and try to eliminate cpu or network intensive processes. sick_scan_xd (i.e. process sick_generic_caller) should consume ca. 80% of one core resp. cause ca. 20% of the total cpu load.
</code></pre></div></div>

<h3 id="troubleshooting">Troubleshooting</h3>

<h4 id="endianess">Endianess</h4>

<p>ARM processors support both little and big endian mode. sick_scan_xd has been tested on Raspberry Pi 4 using ROS 1 and ROS 2 on Linux in little endian mode. You can check the endianess of your system with <code class="language-plaintext highlighter-rouge">lscpu</code>.</p>

<h4 id="build-sick_scan_xd-on-a-raspberry-without-internet-or-github-access">Build sick_scan_xd on a Raspberry without internet or github access</h4>

<p>Checkout sick_scan_xd and use <code class="language-plaintext highlighter-rouge">scp -rp</code> to copy files and directories recursively from local host to a Raspberry, e.g.:</p>

<p>On your local Linux PC (Raspberry IP-address is 192.168.178.52 in this example):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p ./sick_scan_xd_raspberry_pi_pretest/src
pushd ./sick_scan_xd_raspberry_pi_pretest/src
git clone https://github.com/SICKAG/libsick_ldmrs.git
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
popd
scp -rp ./sick_scan_xd_raspberry_pi_pretest 192.168.178.52:/home/rostest/sick_scan_xd_raspberry_pi_pretest

</code></pre></div></div>

<p>On your Raspberry Pi (ROS 1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /home/rostest/sick_scan_xd_raspberry_pi_pretest
pushd ./src/sick_scan_xd/test/scripts
chmod a+x ./*.bash
./makeall_ros1.bash
popd
source ./devel_isolated/setup.bash

</code></pre></div></div>

<p>To view the pointcloud on your local Linux PC (with Raspberry IP-address is 192.168.178.52 in this example):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export ROS_MASTER_URI=http://192.168.178.52:11311/
rviz

</code></pre></div></div>

<h2 id="more-tools">More Tools</h2>

<p>Various tools exist in the repository to improve the operation of the scanners. It is also recommended to read the section <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#Troubleshooting">Troubleshooting</a>.
Overview of the tools:</p>

<ul>
  <li>Search for scanner in the network:
Use the Python3 tool “sick_generic_device_finder.py” in the tools/sick_generic_device_finder directory.
The tools will output the IP addresses of the connected scanners and some more information about the scanner.
Call it with python3, i.e.
<code class="language-plaintext highlighter-rouge">
python3 sick_generic_device_finder.py
</code>
</li>
  <li>Setting new IP address: With the help of the parameter “new_IP” a new IP address can be assigned when calling the node sick_scan_xd.
The launch file sick_new_ip.launch in the launch directory shows an example of how to use this parameter.</li>
  <li>Converting of pointclouds to images: With the tool pcl_converter.cpp one can convert pointcloud2-data
to image. That is especial convenient for 24-layers scanners like the MRS6124.</li>
  <li>Setting up a brand new scanner: To set up a brand new scanner,
it is recommended to use the two tools “sick_generic_device_finder.py” to find the scanner in the network
and the launch file sick_new_ip.launch to set a new IP address. If further settings are to be saved that cannot be made via ROS   parameters, we recommend using the Windows tool “Sopas ET” from SICK.</li>
  <li>Unit tests: For a quick unit test after installation without the sensor hardware, a test server is provided to simulate a scanner. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CONTRIBUTING.md">Simulation</a> for further details.</li>
  <li>Testing: The sick_scan_test program was developed for testing the driver. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CONTRIBUTING.md">Testing</a> for details.</li>
</ul>

<h1 id="device-specific-information">Device specific information</h1>

<h2 id="picoscan100multiscan100">picoScan100/multiScan100</h2>

<p>The multiScan100 and picoScan100 are new lidars from Sick. multiScan100 has a total of 16 lidar units rotating around a vertical axis. The rotation speed is 20 rounds per second.</p>

<p>Scan data are transmitted in msgpack or compact format over UDP.</p>

<p>multiScan100/picoScan100 lidars are supported by sick_scan_xd.
The following describes the configuration, validation and test in more detail.</p>

<h3 id="configuration">Configuration</h3>

<p>multiScan100 is configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan.launch">sick_multiscan.launch</a>.
picoScan100 is configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_picoscan.launch">sick_picoscan.launch</a>.</p>

<p>Modify file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan.launch">sick_multiscan.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_picoscan.launch">sick_picoscan.launch</a> to change configuration. Note that the ip address of the udp receiver <strong>must</strong> be configured on each system. This is the ip address of the computer running sick_scan_xd.</p>

<p>The ip address of the lidar and the udp receiver can be configured in the launch file by e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;arg name="hostname" default="192.168.0.1"/&gt;
&lt;arg name="udp_receiver_ip" default="192.168.0.100"/&gt;

</code></pre></div></div>
<p>or by command line by e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Run sick_scansegment_xd generic without ROS:
sick_generic_caller ./launch/sick_multiscan.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100
# Run sick_scansegment_xd on ROS 1:
roslaunch sick_scan_xd sick_multiscan.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100
# Run sick_scansegment_xd on ROS 2:
ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100

</code></pre></div></div>

<h3 id="imu-support-1">IMU support</h3>

<p>IMU support for multiScan100 and picoScan100 is enabled by default and can be configured in the launchfile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="imu_enable" type="bool" value="True"/&gt;  &lt;!-- Enable inertial measurement unit IMU, compact format only --&gt;
&lt;param name="imu_udp_port" type="int" value="7503"/&gt; &lt;!-- udp port for multiScan100 imu data (if imu_enable is true) --&gt;
&lt;param name="imu_topic" type="string" value="imu"/&gt;  &lt;!-- topic of ros IMU messages --&gt;

</code></pre></div></div>

<p>sick_scan_xd receives IMU data by UDP and publishes <a href="https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/Imu.html">ROS 1 sensor_msgs/Imu</a> resp. <a href="https://docs.ros2.org/latest/api/sensor_msgs/msg/Imu.html">ROS 2 sensor_msgs/msg/Imu</a> messages.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> IMU support requires compact format, which is the default. If msgpack communication is configured, imu support is automatically disabled.</p>
</blockquote>

<p>IMU support for picoScan100 requires firmware version 1.1 or newer, see https://www.sick.com/de/en/downloads/media/swp680096 for firmware downloads.</p>

<h3 id="sopas-support">SOPAS support</h3>

<p>On ROS 1 and ROS 2, service <code class="language-plaintext highlighter-rouge">ColaMsg</code> is provided to send CoLa commands to the lidar. Using this service, filters can be applied during runtime.</p>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#sopas-support-for-sick_scan_segment_xd">See</a> here for examples.</p>

<p>See the manual for further information of filter settings and parameter.</p>

<p>The driver sends the following SOPAS start and stop sequence at program start resp. exit (example with default ip address 192.168.0.1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Prerequirement: measurement is active, but no UDP data is sent
// Start sending scan data output
sMN SetAccessMode 3 F4724744  // set authorization level for writing settings
sWN ScanDataEthSettings 1 +192 +168 +0 +1 +2115  // configure destination scan data output destination to 192.168.0.52 port 2115
sWN ScanDataFormat 1   // set scan data output format to MSGPACK
sWN ScanDataPreformatting 1 // for multiscan136 only
sWN ScanDataEnable 1   // enable scan data ouput
sMN LMCstartmeas       // start measurement
sMN Run                // apply the settings and logout
// ...
// UDP data is sent
// ...
// Stop sending scan data output
sMN SetAccessMode   3 F4724744   // set authorization level for writing settings
sWN ScanDataEnable 0   // disable scan data output
sMN Run   // apply the settings and logout
// No UDP data is sent anymore

</code></pre></div></div>

<h3 id="run-multiscan100-and-picoscan100-simultaneously">Run multiScan100 and picoScan100 simultaneously</h3>

<p>The following example shows a multiScan100 and a picoScan100 device running simultaneously on ROS 1. The ip address of the multiScan100 is <code class="language-plaintext highlighter-rouge">192.168.0.1</code> (default), the ip address of the picoScan100 has been set to <code class="language-plaintext highlighter-rouge">192.168.0.2</code>. The Linux-PC running sick_scan_xd uses ip address <code class="language-plaintext highlighter-rouge">192.168.0.100</code>. <code class="language-plaintext highlighter-rouge">fping -a -q -g 192.168.0.0/24</code> shows all available devices in subnet <code class="language-plaintext highlighter-rouge">192.168.0.x</code>:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_01.png" alt="multiple_lidars_01.png"></p>

<table>
  <thead>
    <tr>
      <th>device</th>
      <th>ip</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>192.168.0.1</td>
      <td>multiScan100</td>
    </tr>
    <tr>
      <td>192.168.0.2</td>
      <td>picoScan100</td>
    </tr>
    <tr>
      <td>192.168.0.100</td>
      <td>Linux-PC</td>
    </tr>
  </tbody>
</table>

<p>Open 192.168.0.1 and 192.168.0.2 in a browser to view the network settings with SOPAS Air:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_02.png" alt="multiple_lidars_02.png"></p>

<p>The frame ids and ros topics of both lidars should be configured differently. Copy both launchfiles (sick_multiscan.launch and sick_piocscan.launch in this example) e.g. to lidar1.launch and lidar2.launch and replace ros topics and frame ids, e.g.
    * replace all “topic=/cloud_” by “topic=/cloud1<em>” in lidar1.launch
    * replace all “topic=/cloud</em>” by “topic=/cloud2_” in lidar2.launch
    * replace all “frameid=world” by “frameid=world1” in lidar1.launch
    * replace all “frameid=world” by “frameid=world2” in lidar2.launch</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_03.png" alt="multiple_lidars_03.png"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_04.png" alt="multiple_lidars_04.png"></p>

<p>Provide the launchfiles with <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1</code>.</p>

<p>Then launch sick_scan_xd twice with two different launchfiles, ip addresses, node names, udp ports, topic and frame ids.</p>

<p>Example:</p>

<p>`
roslaunch sick_scan_xd lidar1.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100 nodename:=lidar1 udp_port:=2115 imu_udp_port:=7503 publish_frame_id:=world1 publish_laserscan_segment_topic:=scan1_segment publish_laserscan_fullframe_topic:=scan1_fullframe imu_topic:=imu1 &amp;
`</p>

<p>`
roslaunch sick_scan_xd lidar2.launch hostname:=192.168.0.2 udp_receiver_ip:=192.168.0.100 nodename:=lidar2 udp_port:=2116 imu_udp_port:=7504 publish_frame_id:=world2 publish_laserscan_segment_topic:=scan2_segment publish_laserscan_fullframe_topic:=scan2_fullframe imu_topic:=imu2 &amp;
`</p>

<p>Rviz shows the point clouds of both lidars running simultaneously, with frame id <code class="language-plaintext highlighter-rouge">world1</code> for lidar1 (multiScan) and frame id <code class="language-plaintext highlighter-rouge">world2</code> for lidar2 (picoScan):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_05.png" alt="multiple_lidars_05.png"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_06.png" alt="multiple_lidars_06.png"></p>

<p>If the 6D poses of the lidars are known, their coordinates can be transformed to a common frame by a static_transform_publisher. Example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun tf static_transform_publisher 0 0 0 0 0 0 world world1 100 &amp;
rosrun tf static_transform_publisher 0 0 0 0 0 0 world world2 100 &amp;

</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_07.png" alt="multiple_lidars_07.png"></p>

<p>The big purple dots show the picoScan100 pointcloud, the other points are the multiScan100 point clouds. Both are transformed to the common frame id <code class="language-plaintext highlighter-rouge">world</code>. Note that both point clouds do not match exactly, because the 6D poses are just assumed to be (x=0, y=0, z=0, yaw=0, pitch=0, roll=0) in this example.</p>

<h3 id="visualization">Visualization</h3>

<p>The multiScan100 and picoScan100 scans can be visualized by rviz. The following screenshots show two examples of a multiScan100 pointcloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/20210929-tokenized-msgpacks-emulator-rviz.png" alt="msgpacks-emulator-rviz">
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/20210929-tokenized-msgpacks-multiScan-rviz.png" alt="msgpacks-emulator-rviz"></p>

<p>Note that sick_scan_xd publishes 2 pointclouds:</p>
<ul>
  <li>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud</code> is published for each scan segment.</li>
  <li>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_fullframe</code> collects all segments for a complete 360 degree full scan (360 degree for multiScan100, 276 degree for picoscan100).</li>
</ul>

<p>Pointcloud callbacks defined in the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#generic-driver-api">API</a> are called the same way: A callback registered with SickScanApiRegisterPolarPointCloudMsg is called</p>
<ul>
  <li>with a segment_idx &gt;= 0 for each scan segment, and</li>
  <li>with segment_idx := -1 for the complete 360 degree full scan.</li>
</ul>

<h3 id="pointcloud-memory-layout">PointCloud memory layout</h3>

<p>The Multiscan136 scans with 12 segments and 16 layer. For test, development and debugging, knowledge the internal memory layout of the pointclouds can be helpful.</p>

<p>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_unstructured_segments</code> (topic <code class="language-plaintext highlighter-rouge">/cloud</code> for sick_scan_xd version 2.10 or earlier) is published for each scan segment. Each pointcloud concatenates the layer of that segment. Each layer concatenates the points of that layer and segment. Each point concatenates the cartesian position (x, y, z) and the intensity i of a scan point. Each value of a point (x, y, z, i) is represented by a 4 byte float value. The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_unstructured_fullframe</code> (topic <code class="language-plaintext highlighter-rouge">/cloud_fullframe</code> for sick_scan_xd version 2.10 or earlier) collects all segments of a complete 360 degree full scan. Therefore, a total of 13 cartesian pointclouds are published for a 360 degree full scan:</p>

<ul>
  <li>
    <p>12 segment pointclouds. Each segment pointcloud concatenates the points of each layer in this segment in a flat memory layout:<br>
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_segment_xd_01.png" alt="sick_scan_segment_xd_01.png"></p>
  </li>
  <li>
    <p>1 full scan pointcloud concatenating all 12 segments:<br>
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_segment_xd_02.png" alt="sick_scan_segment_xd_02.png"></p>
  </li>
</ul>

<p>Note that segments and layer are not sorted in ascending order. They are published in the same order as they are received from the lidar.</p>

<h3 id="customized-point-clouds">Customized point clouds</h3>

<p>Pointclouds can be customized, i.e. the fields and points can be configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan.launch">sick_multiscan.launch</a>.</p>

<p>Parameter “custom_pointclouds” lists all customized pointclouds to be published. Each pointcloud is given by its name, e.g:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="custom_pointclouds" type="string" value="cloud_unstructured_segments cloud_unstructured_fullframe cloud_polar_unstructured_segments cloud_polar_unstructured_fullframe cloud_all_fields_fullframe"/&gt;

</code></pre></div></div>
<p>This example publishes 5 types of pointclouds:</p>
<ul>
  <li>Pointcloud for each segment in cartesian coordinates (x,y,z,i), named “cloud_unstructured_segments”</li>
  <li>Pointcloud for each fullframe in cartesian coordinates (x,y,z,i), named “cloud_unstructured_fullframe”</li>
  <li>Pointcloud for each segment in polar coordinates (azimuth,elevation,range,i), named “cloud_polar_unstructured_segments”</li>
  <li>Pointcloud for each fullframe in polar coordinates (azimuth,elevation,range,i), named “cloud_polar_unstructured_fullframe”</li>
  <li>Pointcloud for each fullframe with all available fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), named “cloud_all_fields_fullframe”</li>
</ul>

<p>These 5 pointclouds are published by default.</p>

<p>The properties of the pointcloud, i.e. their fields and points, are configured by the pointcloud name, e.g. pointcloud “cloud_unstructured_segments” (i.e. the segment pointcloud in cartesian coordinates):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_unstructured_segments: cartesian coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_unstructured_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_segments frameid=world publish=1"/&gt;

</code></pre></div></div>
<p>The cloud property configuration is a list of key-value-pairs, where each key-value-pair specifies a property and its value. E.g. <code class="language-plaintext highlighter-rouge">topic=/cloud_unstructured_segments frameid=world</code> defines ros topic “/cloud_unstructured_segments” and frame id “world” for the pointcloud named “cloud_unstructured_segments”.</p>

<p>The following key-value-pairs of a customized pointcloud are currently supported:</p>

<ul>
  <li>Parameter “coordinateNotation” is an enum to configure pointcloud coordinates:
    <ul>
      <li>coordinateNotation=0: cartesian (default, pointcloud has fields x,y,z,i), identical to customized with fields=x,y,z,i</li>
      <li>coordinateNotation=1: polar (pointcloud has fields azimuth,elevation,r,i), identical to customized with fields=azimuth,elevation,range,i</li>
      <li>coordinateNotation=2: both cartesian and polar (pointcloud has fields x,y,z,azimuth,elevation,r,i), identical to customized with fields=x,y,z,azimuth,elevation,range,i</li>
      <li>coordinateNotation=3: customized pointcloud fields, i.e. the pointcloud has fields configured by parameter “fields”</li>
    </ul>
  </li>
  <li>Parameter “updateMethod” is an enum to configure fullframe pointclouds versus segmented pointcloud:
    <ul>
      <li>updateMethod=0: fullframe pointcloud (default)</li>
      <li>updateMethod=1: segmented pointcloud</li>
    </ul>
  </li>
  <li>Parameter “fields” defines the fields of the pointcloud for coordinateNotation == 3 (customized pointcloud fields), e.g.
    <ul>
      <li>fields=x,y,z,i: cartesian pointcloud</li>
      <li>fields=range,azimuth,elevation: polar pointcloud</li>
      <li>or any other combination of x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector</li>
    </ul>

    <p>These fields have the following meaning:</p>
    <ul>
      <li>field “x”: cartesian x coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “y”: cartesian y coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “z”: cartesian z coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “i”: intensity  (4 byte, float32)</li>
      <li>field “range”: polar coordinate range in meter (4 byte, float32)</li>
      <li>field “azimuth”: polar coordinate azimuth in radians  (4 byte, float32)</li>
      <li>field “elevation”: polar coordinate elevation in radians  (4 byte, float32)</li>
      <li>field “t”:  time offset in nano seconds relative to the header timestamp in the point cloud (4 byte, uint32), used by rtabmap for deskewing</li>
      <li>field “ts”: time offset in seconds relative to the header timestamp (4 byte, float32)</li>
      <li>field “lidar_sec”: uint32 seconds part of the lidar timestamp in microseconds (lidar time), lidar_sec = (uint32_t)(lidar_timestamp_microsec / 1000000)</li>
      <li>field “lidar_nsec”: uint32nano seconds part of the lidar timestamp in microseconds (lidar time), lidar_nsec = (uint32_t)(1000 * (lidar_timestamp_microsec % 1000000))</li>
      <li>field “ring”:  layer id (1 byte, int8), identical to field “layer”</li>
      <li>field “layer”: layer (group) index (4 byte, int32), 0 &lt;= layer &lt; 16 for multiScan100 (16 layer), 0 for picoScan100 (1 layer)</li>
      <li>field “echo”: echo index (4 byte, int32)</li>
      <li>field “reflector”: optional reflector bit (1 byte, uint8), 0 or 1, default: 0</li>
    </ul>
  </li>
  <li>Parameter “echos” defines which echos are included in the pointcloud, e.g.
    <ul>
      <li>echos=0,1,2: all echos</li>
      <li>echos=2: last echo
 or any other combination of 0,1,2</li>
    </ul>
  </li>
  <li>Parameter “layers” defines which echos are included in the pointcloud, e.g
    <ul>
      <li>layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 for all layers</li>
      <li>layers=5 for the 0 degree layer
 or any other combination of 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</li>
    </ul>
  </li>
  <li>Parameter “reflectors” filters the points by the reflector bit, i.e.
    <ul>
      <li>reflectors=0,1 for points with reflector bit set or not set</li>
      <li>reflectors=0 for points with reflector bit not set</li>
      <li>reflectors=1 for points with reflector bit set</li>
    </ul>
  </li>
  <li>Parameter “infringed” defines filters the points by infringement, i.e.
    <ul>
      <li>infringed=0,1 for points with infringement bit set or not set</li>
      <li>infringed=0 for points with infringement bit not set</li>
      <li>infringed=1 for points with infringement bit set
 Parameter “infringed” is currently not supported (reserved for future use)</li>
    </ul>
  </li>
  <li>
    <p>Parameter “topic” defines the ros topic, e.g. topic=/cloud_fullframe for cartesian fullframe pointclouds</p>
  </li>
  <li>
    <p>Parameter “frameid” defines the ros frame of the pointcloud, e.g. frameid=world, frameid=map or frameid=base_link</p>
  </li>
  <li>Parameter “publish” activates or deactivates the pointcloud, e.g. publish=1 to generate and publish, or publish=0 to deactivate that pointcloud</li>
</ul>

<p>To add a new pointcloud, define a pointcloud name (e.g. “cloud_layer7_cartesian”), add “cloud_layer7_cartesian” in parameter “custom_pointclouds” and specify a new parameter “cloud_layer7_cartesian” with the new cloud properties, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_layer7_cartesian: cartesian coordinates, fullframe, first echo, layer7 --&gt;
&lt;param name="cloud_layer7_cartesian" type="string" value="coordinateNotation=0 updateMethod=0 echos=0 layers=7 reflectors=0,1 infringed=0,1 topic=/cloud_layer7_cartesian frameid=world publish=1"/&gt;

</code></pre></div></div>

<p>The following pointclouds are currently predefined in launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan.launch">sick_multiscan.launch</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_unstructured_segments: cartesian coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_unstructured_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_fullframe: cartesian coordinates, fullframe, all echos, all layers, max. 32400 points, mean ca. 10000 points per cloud --&gt;
&lt;param name="cloud_unstructured_fullframe" type="string" value="coordinateNotation=0 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_fullframe frameid=world publish=1"/&gt;

&lt;!-- cloud_polar_unstructured_segments: polar coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_polar_unstructured_segments" type="string" value="coordinateNotation=1 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_polar_unstructured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_polar_unstructured_fullframe: polar coordinates, fullframe, all echos, all layers --&gt;
&lt;param name="cloud_polar_unstructured_fullframe" type="string" value="coordinateNotation=1 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_polar_unstructured_fullframe frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo1: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo1" type="string" value="coordinateNotation=0 updateMethod=0 echos=0 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo1 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo1_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo1_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo1_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo2: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo2" type="string" value="coordinateNotation=0 updateMethod=0 echos=1 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo2 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo2_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo2_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=1 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo2_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo3: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo3" type="string" value="coordinateNotation=0 updateMethod=0 echos=2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo3 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo3_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo3_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_echo3_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_reflector: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_reflector" type="string" value="coordinateNotation=0 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_reflector frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_reflector_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_reflector_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_reflector_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires0: cartesian and polar coordinates, fullframe, all echos, high resolution layer 5, fields=x,y,z,i,range,azimuth,elevation, 12*2880x3=103680 points per cloud --&gt;
&lt;param name="cloud_structured_hires0" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=5 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires0 frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires0_segments: cartesian and polar coordinates, segments, all echos, high resolution layer 5, fields=x,y,z,i,range,azimuth,elevation, 2880x3=8640 points per cloud --&gt;
&lt;param name="cloud_structured_hires0_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=5 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires0_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires1: cartesian and polar coordinates, fullframe, all echos, high resolution layer 13, fields=x,y,z,i,range,azimuth,elevation, 12*2880x3=103680 points per cloud --&gt;
&lt;param name="cloud_structured_hires1" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=13 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires1 frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires1_segments: cartesian and polar coordinates, segments, all echos, high resolution layer 13, fields=x,y,z,i,range,azimuth,elevation, 2880x3=8640 points per cloud --&gt;
&lt;param name="cloud_structured_hires1_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=13 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires1_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured: cartesian and polar coordinates, fullframe, all echos, low resolution layers 0,1,2,3,4,6,7,8,9,10,11,12,14,15, fields=x,y,z,i,range,azimuth,elevation, 12*360*14*3=181440 points per cloud --&gt;
&lt;param name="cloud_structured" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=0,1,2,3,4,6,7,8,9,10,11,12,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_structured frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_segments: cartesian and polar coordinates, segments, all echos, low resolution layers 0,1,2,3,4,6,7,8,9,10,11,12,14,15, fields=x,y,z,i,range,azimuth,elevation, 360*14*3=15120 points per cloud --&gt;
&lt;param name="cloud_structured_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=0,1,2,3,4,6,7,8,9,10,11,12,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_structured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_all_fields_segments: all fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), segments, all echos, all layers --&gt;
&lt;param name="cloud_all_fields_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_all_fields_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_all_fields_fullframe: all fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), fullframe, all echos, all layers --&gt;
&lt;param name="cloud_all_fields_fullframe" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_all_fields_fullframe frameid=world publish=1"/&gt;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  The sick_scan_xd API callback functions <code class="language-plaintext highlighter-rouge">SickScanApiRegisterCartesianPointCloudMsg</code> and <code class="language-plaintext highlighter-rouge">SickScanApiRegisterPolarPointCloudMsg</code> provide cartesian and polar pointclouds, i.e. pointclouds configured with <code class="language-plaintext highlighter-rouge">coordinateNotation=0</code> (cartesian) or <code class="language-plaintext highlighter-rouge">coordinateNotation=1</code> (polar). Pointclouds with <code class="language-plaintext highlighter-rouge">coordinateNotation=2</code> (cartesian + polar) or <code class="language-plaintext highlighter-rouge">coordinateNotation=3</code> (customized fields) are currently not supported by the generic API.</p>
</blockquote>

<h3 id="customized-point-clouds-on-a-raspberry-pi">Customized point clouds on a Raspberry Pi</h3>

<p>Performance is critical on a Raspberry. To reduce the cpu load, you may restrict the number of pointclouds to the minimum required for your application. E.g. if you just need the cartesian fullframe pointcloud, you can use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="custom_pointclouds" type="string" value="cloud_unstructured_fullframe"/&gt;

</code></pre></div></div>
<p>to decrease the cpu usage.</p>

<h3 id="msgpack-validation">MSGPACK validation</h3>

<p>A msgpack validation can be activated. This validation checks</p>
<ol>
  <li>each incoming msgpack for scan data out of the expected values, and</li>
  <li>missing scandata after collecting the msgpack data for a full scan (360 degree for multiScan100, 276 degree for picoScan100)</li>
</ol>

<p>If a msgpack contains scan data out of expected values, the msgpack is discarded and an error message is printed. This should not happen in normal operation mode. If scan data are missing after a full 360 degree scan, an error message is printed. This might happen in case of udp packet drops.</p>

<p>By default, the full range of scan data is expected, i.e. all echos, all segments, all layers and azimuth values covering -180 up to +180 degree. If filters are activated (echo-, layer- or angle-range-filter to reduce network traffic), the msgpack validation should currently be deactivated or configured thoroughly to avoid error messages. In the next release, the filter configuration is queried from  multiScan136 Beta and validation settings are adopted to the multiScan136 Beta filter settings.</p>

<p>The msgpack validation is configured in file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan.launch">sick_multiscan.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_picoscan.launch">sick_picoscan.launch</a>. To activate or deactivate msgpack validation, set <code class="language-plaintext highlighter-rouge">msgpack_validator_enabled</code> to True (activated) resp. False (deactivated).</p>

<p>Msgpack validation leads to error messages in case of udp packet drops. Increase the value <code class="language-plaintext highlighter-rouge">msgpack_validator_check_missing_scandata_interval</code> to tolerate udp packet drops. Higher values increase the number of msgpacks collected for verification.</p>

<h3 id="firewall-configuration">Firewall configuration</h3>

<p>By default, UDP communication is allowed on localhosts. To enable udp communication between 2 different machines, firewalls have to be configured.</p>

<p>On Windows: Setup the windows firewall to allow sick_scan_xd to receive udp packages on port 2115.
To pass udp packages from a remote sender, the default rule for incoming udp packages has to be configured in the windows firewall:</p>
<ol>
  <li>Run “wf.msc” as admin,</li>
  <li>Click Inbound Rules and locate the rule(s) for lidar3d_msr100_recv (resp. python to allow python test scripts), and</li>
  <li>Deactivate the UDP-rule for this process(es) or configure exceptions for remote computers.</li>
  <li>Alternatively, you can create a new rule allowing udp communication on port 2115.</li>
</ol>

<p>On Linux: Run the following commands to allow any udp communication on port 2115:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo iptables -A INPUT -p udp -m udp --dport 2115 -j ACCEPT
sudo iptables -A OUTPUT -p udp -m udp --sport 2115 -j ACCEPT
sudo iptables-save

</code></pre></div></div>
<p>Alternatively, you can also use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ufw allow from any to any port 2115 proto udp

</code></pre></div></div>
<p>to allow all udp traffic on port 2115.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  If Linux or Windows is running in a virtual machine, make sure UDP port 2115 is forwarded. With VMware Workstation Pro, you can configure port forwarding
using the Virtual Network Editor. Udp echos, delays, drops and other unexpected errors might occur when more than one network card is configured in VMware.
Make sure you have only one network adapter activated with custom NAT:</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/vmware_network_settings.png" alt="vmware_network_settings"></p>

<h3 id="sopas-support-for-sick_scan_segment_xd">SOPAS support for sick_scan_segment_xd</h3>

<p>On ROS 1 and ROS 2, sick_scan_segment_xd provides ros service <code class="language-plaintext highlighter-rouge">ColaMsg</code> to send CoLa commands to the lidar. Using this service, filters can be applied to multiScan136 and picoScan150 lidars during runtime.</p>

<p>Examples on ROS 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice list
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN IsSystemReady'}"                             # response: "sAN IsSystemReady 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"                  # response: "sAN SetAccessMode 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataEthSettings 1 +127 +0 +0 +1 +2115'}" # response: "sWA ScanDataEthSettings"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataFormat 1'}"                          # response: "sWA ScanDataFormat"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataPreformatting 1'}"                   # response: "sWA ScanDataPreformatting"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataEnable 1'}"                          # response: "sWA ScanDataEnable"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN LMCstartmeas'}"                              # response: "sAN LMCstartmeas"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN Run'}"                                       # response: "sAN Run 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"                                    # response: "sAN SetAccessMode 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN FREchoFilter 1'}"                                              # response: "sWA FREchoFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1'}" # response: "sWA LFPangleRangeFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'}"            # response: "sWA LFPlayerFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN Run'}"                                                         # response: "sAN Run 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LFPlayerFilter is not supported by picoscan150.</p>
</blockquote>

<p>Examples on ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service list
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN IsSystemReady'}"                             # response: "sAN IsSystemReady 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN SetAccessMode 3 F4724744'}"                  # response: "sAN SetAccessMode 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataEthSettings 1 +127 +0 +0 +1 +2115'}" # response: "sWA ScanDataEthSettings"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataFormat 1'}"                          # response: "sWA ScanDataFormat"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataPreformatting 1'}"                   # response: "sWA ScanDataPreformatting"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataEnable 1'}"                          # response: "sWA ScanDataEnable"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN LMCstartmeas'}"                              # response: "sAN LMCstartmeas"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN Run'}"                                       # response: "sAN Run 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN SetAccessMode 3 F4724744'}"                                    # response: "sAN SetAccessMode 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN FREchoFilter 1'}"                                              # response: "sWA FREchoFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1'}" # response: "sWA LFPangleRangeFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'}"            # response: "sWA LFPlayerFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN Run'}"                                                         # response: "sAN Run 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LFPlayerFilter is not supported by picoscan150.</p>
</blockquote>

<h2 id="tim781-and-tim781s">TiM781 and TiM781S</h2>

<p>For TiM781S lidars, the initial lidar configuration can be deactivated using optional argument initialize_scanner:=0.
Note that this mode does not initialize the lidar. The mode assumes that the scanner is in an appropriate state corresponding to the properties configured in the launchfile. It is not recommended to use this option unless for specific tasks in a controlled environment.</p>

<p><strong>Do not use this mode except the lidar has been configured properly and initialized successfully and is in the same state as after initialization by the launchfile! This option is for advanced users only!</strong></p>

<p>Example: <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=192.168.0.1 initialize_scanner:=0</code></p>

<h3 id="field-evaluation-tim7xx">Field evaluation TiM7xx</h3>

<p>The field evaluation for TiM7xx lidars support two additional options to configure the active field set: FieldSetSelectionMethod and ActiveFieldSet. These options allow to set the active field set during runtime, see the operation manual for details.</p>

<p>Options FieldSetSelectionMethod and ActiveFieldSet can be configured in the launch file and by ros services “FieldSetRead” and “FieldSetWrite”.</p>

<p>Initial values for FieldSetSelectionMethod and ActiveFieldSet can be configured in the launch file, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="active_field_set" type="int" value="-1"/&gt; &lt;!-- set ActiveFieldSet at startup: -1 = do not set (default), index of active field otherwise --&gt;
&lt;param name="field_set_selection_method" type="int" value="-1"/&gt; &lt;!-- set FieldSetSelectionMethod at startup: -1 = do not set (default), 0 = active field selection by digital inputs, 1 = active field selection by telegram --&gt;

</code></pre></div></div>
<p>By default, options FieldSetSelectionMethod and ActiveFieldSet are not written by the driver, i.e. the default values apply (factory defaults or settings by SOPAS ET).</p>

<p>Example service call for ROS1 to read resp. write options FieldSetSelectionMethod and ActiveFieldSet:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/FieldSetRead "{}" # returns field_set_selection_method and active_field_set
rosservice call /sick_tim_7xx/FieldSetWrite "{field_set_selection_method_in: -1, active_field_set_in: 1}" # write active_field_set

</code></pre></div></div>
<p>Example service call for ROS1 to read resp. write options FieldSetSelectionMethod and ActiveFieldSet:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /FieldSetRead sick_scan_xd/srv/FieldSetReadSrv "{}" # returns field_set_selection_method and active_field_set
ros2 service call /FieldSetWrite sick_scan_xd/srv/FieldSetWriteSrv "{field_set_selection_method_in: -1, active_field_set_in: 1}" # write active_field_set

</code></pre></div></div>

<p>Parameter active_field_set &lt; 0: do not set (default), active_field_set &gt; 0: index of active field otherwise (see operation manual for details about ActiveFieldSet telegram)</p>

<p>Parameter field_set_selection_method &lt; 0: do not set (default), field_set_selection_method = 0: active field selection by digital inputs, field_set_selection_method = 1: active field selection by telegram</p>

<p>Note that FieldSetSelectionMethod (parameter field_set_selection_method) requires a higher authorization level and should be configured in the launch file. It is therefore recommended to set <code class="language-plaintext highlighter-rouge">field_set_selection_method_in: -1</code> when using ros service FieldSetWrite.</p>

<h2 id="tim240">TiM240</h2>

<p>The TiM240 is a new scanner that fits seamlessly into the family of other TiM devices. The TiM240 has an opening angle of 240 degrees. In contrast to the previous scanners from SICK, the coordinate system used corresponds directly to the ROS convention. For this reason, this scanner does not require a coordinate conversion of 90 degrees around the Z-axis. However, this is taken into account in the driver code, so that the user will not notice any difference in the setting of the angular ranges during use.
The angular position according to the data sheet can be taken from the drawings below.</p>

<p>The following figures show the difference between the TiM5xx family and the TiM240 device.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/tim240/tim_5xx_scanarea.jpg" alt="TiM5xx scan area"></p>

<p>TiM5xx scanning area</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/tim240/tim_240_scanarea.jpg" alt="TiM240 scan area"></p>

<p>TiM240 scanning area</p>

<h2 id="nav350">NAV350</h2>

<p>NAV350 devices are supported by sick_scan_xd since 2023. Since they support navigation and use a different communication mode, this chapter gives an overview of the NAV350 support in sick_scan_xd. Please refer to the manuals for further information.</p>

<h3 id="process-loop">Process loop</h3>

<p>Scan data, landmarks and poses of NAV350 devices are queried by SOPAS commands with polling. Therefore the sick_scan_xd process loop runs as followed:</p>

<ol>
  <li>Initialization and setup</li>
  <li>Main loop (polling):
1 . Send data request “sMN mNPOSGetData 1 2”
2 . Receive and parse response
3 . Convert and publish pointcloud, laserscan, landmarks, pose and transform
4 . API: notify listeners and run their callback functions
5 . Repeat from step 1</li>
  <li>In case of incoming odometry messages (asynchron):
1 . Convert to SOPAS command
2 . Send “sMN mNPOSSetSpeed <odom_data>" to NAV350</odom_data>
</li>
</ol>

<h3 id="initialization-and-setup">Initialization and setup</h3>

<p>After initialization, sick_scan_xd switches to navigation mode by default. Navigation requires mapping (i.e. a valid landmark layout), which can be done by</p>
<ul>
  <li>SOPAS ET (recommended), or</li>
  <li>optional mapping with parameter <code class="language-plaintext highlighter-rouge">nav_do_initial_mapping:=True</code> using the landmarks detected at start, or</li>
  <li>using an optional imk-file.</li>
</ul>

<p>Configuration and setup using SOPAS ET is most powerful and recommended.</p>

<p>The default sopas initialization sequence runs as followed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"sMN SetAccessMode 3 F4724744"     # switch to access level authorized client
"sMN mNEVAChangeState 1"           # switch to operation mode standby
"sWN NEVACurrLayer &lt;layer&gt;"        # set layer configured by launchfile
"sWN NLMDLandmarkDataFormat 0 1 1" # set result format (landmark data)
"sWN NAVScanDataFormat 1 1"        # set result format (scan data)
"sWN NPOSPoseDataFormat 1 1"       # set result format (pose data)
"sMN mNEVAChangeState 4"           # switch to navigation mode
"sMN mNPOSGetData 1 2"             # query pose, landmark and scan data

</code></pre></div></div>

<p>If optional parameter <code class="language-plaintext highlighter-rouge">nav_do_initial_mapping</code> is true, a landmark layout is initialized using the reflectors detected at startup (sopas command “sMN mNMAPDoMapping”). The sopas initialization sequence for an initial mapping runs as followed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"sMN SetAccessMode 3 F4724744"     # switch to access level authorized client
"sMN mNEVAChangeState 1"           # switch to operation mode standby
"sWN NEVACurrLayer &lt;layer&gt;"        # set layer configured by launchfile
"sWN NLMDLandmarkDataFormat 0 1 1" # set result format (landmark data)
"sWN NAVScanDataFormat 1 1"        # set result format (scan data)
"sWN NPOSPoseDataFormat 1 1"       # set result format (pose data)
"sMN mNEVAChangeState 2"           # switch to mapping mode
"sMN mNLAYEraseLayout 1"           # clear landmark layout
"sWN NMAPMapCfg ..."               # configure mapping parameter
"sWN NLMDReflSize &lt;size&gt;"          # set reflector size configured by launchfile
"sMN mNMAPDoMapping"               # detect landmarks and run mapping
"sMN mNLAYAddLandmark ..."         # add all detected landmarks to the layout
"sMN mNLAYStoreLayout"             # store landmark layout
"sMN mNEVAChangeState 4"           # switch to navigation mode
"sMN mNPOSGetData 1 2"             # query pose, landmark and scan data

</code></pre></div></div>

<p>The landmark layout stored in an imk-file can optionally loaded at startup with optional parameter. See the NAV350 manual for details about imk-files.</p>

<p>The settings are configured in launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_nav_350.launch">sick_nav_350.launch</a>.</p>

<h3 id="messages">Messages</h3>

<p>sick_scan_xd polls the NAV350 scan data, reflectors and poses in its main loop. Scan data are published by pointcloud messages (in topic “cloud” by default). Reflectors are published by type <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVLandmarkData</code> on topic “/sick_nav_350/nav_landmark” and as MarkerArray on topic “/sick_nav_350/nav_reflectors” for easy visualization using rviz. Poses are published by type <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVPoseData</code> on topic “/sick_nav_350/nav_pose” and as ros transform on topic “/tf”.</p>

<p>The following rviz-screenshot shows the pointcloud, landmarks and pose of a NAV350:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/nav350_ros1_screenshot2.jpg" alt="nav350_ros1_screenshot2.jpg"></p>

<h3 id="odometry-messages">Odometry messages</h3>

<p>Odometry messages can be sent to the NAV350 device using ROS messages <code class="language-plaintext highlighter-rouge">nav_msgs/Odometry</code> on topic “/sick_nav_350/odom” or <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVOdomVelocity</code> on topic “/sick_nav_350/nav_odom_velocity”. Odometry messages <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVOdomVelocity</code> specify the velocity (vx, vy) in m/s in lidar coordinates. Odometry messages <code class="language-plaintext highlighter-rouge">nav_msgs/Odometry</code> specify the velocity (vx, vy) in m/s in ros coordinates. The angular velocity is expected in radians/s.</p>

<p>Example odometry messages with vx = 1 m/s, vy = -1 m/s and omega: 0.5 rad/s:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic pub --rate 10 /sick_nav_350/nav_odom_velocity sick_scan_xd/NAVOdomVelocity '{vel_x: 1.0, vel_y: -1.0, omega: 0.5, timestamp: 123456789, coordbase: 0}�
rostopic pub --rate 10 /sick_nav_350/odom nav_msgs/Odometry '{twist: { twist: { linear: {x: 1.0, y: -1.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.5}}}}'

</code></pre></div></div>

<h3 id="angle-compensation">Angle compensation</h3>

<h4 id="introduction-1">Introduction</h4>

<p>For measurements with the highest demands on the accuracy of the angle measurement, the devices of the NAV series allow compensation of slight angle deviations during a rotation. The compensation is determined by the three parameters.</p>
<ul>
  <li>Additive compensation by an angle offset</li>
  <li>Sinusoidal correction by specifying the amplitude and phase of compensation</li>
</ul>

<p>The three parameters are then used to calculate the compensation as follows:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/angle_compensation/angle_compensation_000.png" alt="Formula for angle compensation"></p>

<p>Offset and phase are given in [deg]</p>

<h4 id="example">Example</h4>

<p>The information is read from lidar by using the command <code class="language-plaintext highlighter-rouge">sRN MCAngleCompSin</code>.
The answer gives one amplitude, phase and offset compensation in tens of thousands.</p>

<p>The function reads</p>
<ul>
  <li>Amplitude-Parameter: +1893</li>
  <li>Phase-Parameter: -210503</li>
  <li>Offset-Parameter: -245</li>
</ul>

<p>These corresponds to:</p>
<ul>
  <li>Amplitude-compensation: +0.1893</li>
  <li>Phase-Compensation: -21.0503 [deg]</li>
  <li>Offset-Compensation: -0.0245 [deg]</li>
</ul>

<p><strong>Compensation formula for example for NAV210/NAV245</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Angle[comp.] = Angle[Raw] - 0.189300 * sin(Angle[Raw] + -21.050300 [deg]) -  -0.024500

</code></pre></div></div>

<p><strong>Compensation formula for example for NAV310</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Angle[comp.] = Angle[Raw] + 0.189300 * sin(Angle[Raw] - -21.050300 [deg]) +  -0.024500

</code></pre></div></div>
<p><strong>Example lookup values for NAV310 for this example (first entries)</strong></p>

<table>
  <thead>
    <tr>
      <th>IN [Deg]</th>
      <th>Out [Deg]</th>
      <th>Correction [Deg]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0.000000</td>
      <td>0.043494</td>
      <td>0.043494</td>
    </tr>
    <tr>
      <td>1.000000</td>
      <td>1.046567</td>
      <td>0.046567</td>
    </tr>
    <tr>
      <td>2.000000</td>
      <td>2.049618</td>
      <td>0.049618</td>
    </tr>
    <tr>
      <td>3.000000</td>
      <td>3.052647</td>
      <td>0.052647</td>
    </tr>
    <tr>
      <td>4.000000</td>
      <td>4.055652</td>
      <td>0.055652</td>
    </tr>
    <tr>
      <td>5.000000</td>
      <td>5.058633</td>
      <td>0.058633</td>
    </tr>
    <tr>
      <td>6.000000</td>
      <td>6.061588</td>
      <td>0.061588</td>
    </tr>
    <tr>
      <td>7.000000</td>
      <td>7.064518</td>
      <td>0.064518</td>
    </tr>
    <tr>
      <td>8.000000</td>
      <td>8.067420</td>
      <td>0.067420</td>
    </tr>
    <tr>
      <td>9.000000</td>
      <td>9.070294</td>
      <td>0.070294</td>
    </tr>
    <tr>
      <td>10.000000</td>
      <td>10.073139</td>
      <td>0.073139</td>
    </tr>
  </tbody>
</table>

<h4 id="comparing-compensated-vs-raw-values">Comparing compensated vs. raw values</h4>

<p>For the example the compensation function looks like this (X-Axis: measured angle [deg], Y-Axis: compensation in [deg])</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/angle_compensation/angle_compensation_001.png" alt="Plot of compensation function (example)"></p>

<h4 id="coordinate-systems">Coordinate systems</h4>

<p>For a better understanding of the data sheets of the different lidar systems the following drawings compare the different coordinate systems. Usually the scanners rotate counter-clockwise. The scanners of the NAV3xx series rotate clockwise. All coordinate systems following the right-hand rule, if the axis definition as shown in the picture is used.
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/angle_compensation/3d_coordinate_system_comp.png" alt="Used coordinate systems"></p>

<p>By means of simple matrix operations all axis orientations can be transformed into each other. But since we are only interested in the angle around the Z-axis, the conversions can be done as follows (CS = Coordinate System):</p>

<table>
  <thead>
    <tr>
      <th>IN From</th>
      <th>Out To</th>
      <th>Operation</th>
      <th>Additional info</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ROS</td>
      <td>NAV3xx</td>
      <td>Out=-In+180°</td>
      <td>maps [-180°…180°] to [360°…0°]</td>
    </tr>
    <tr>
      <td>NAV3xx</td>
      <td>ROS</td>
      <td>Out=-In+180°</td>
      <td>maps [0°…360°] to [180°…-180°]</td>
    </tr>
    <tr>
      <td>ROS</td>
      <td>NAV2XX</td>
      <td>Out=In+90°</td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV2xx</td>
      <td>ROS</td>
      <td>Out=In-90°</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="check-compensation-function">Check compensation function</h4>

<p>By using <code class="language-plaintext highlighter-rouge">Octave</code> ones can check the compensation function against the given values by exporting the value via a testbed function.</p>

<!--
   40 a = dlmread("angle_compensation_debug.csv",';',1,0);
   41 size(a)
   42 a
   43 mean(a(:,3))
   44 a3 = a(:,3)-mean(a(:,3))
   45 mean(a3)
   46 S3 = fft(a3)
   47 plot(abs(S3))
   48 abs(S3)
   49 S3(1)
   50 S3(2)
   51 abs(S3(2))/360
   52 abs(S3(2))/360*2
   53 angle(S3(2))
   54 angle(S3(2))/pi*180
   55 angle(S3(2))/pi*180 - 90
   56 angle(S3(2))/pi*180 + 90
   57 plot(a(:,1),a(:,3))
   58 title "compensation example"
-->

<h2 id="mrs6124">MRS6124</h2>

<h3 id="timing-between-layers">Timing between Layers</h3>

<p>The layers are taken up by the scanner in packs of 6. The scanner delivers at an output data rate of 10 Hz and 24 layers 24/6*10=40 scan packets of 6 layers per second. The following table shows an example of the timing for a complete 24 layer recording</p>

<table>
  <thead>
    <tr>
      <th>Raw Time /µs</th>
      <th style="text-align: center">Delta Time /µs</th>
      <th style="text-align: right">Elevation Angle /Deg</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">13.19</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">12.565</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">11.940</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">11.315</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">10.690</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">10.065</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">9.440</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">8.815</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">8.190</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">7.565</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">6.940</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">6.315</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">5.690</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">5.065</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">4.440</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">3.815</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">3.190</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">2.565</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">1.940</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">1.315</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">0.690</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">0.065</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">-0.560</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">-1.185</td>
    </tr>
    <tr>
      <td>NEW SCAN</td>
      <td style="text-align: center"> </td>
      <td style="text-align: right"> </td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">13.190</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">12.565</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">11.940</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">11.315</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">10.690</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">10.065</td>
    </tr>
    <tr>
      <td>2551832862</td>
      <td style="text-align: center">126514</td>
      <td style="text-align: right">9.440</td>
    </tr>
  </tbody>
</table>

<p>The time stamps between the layers are interpolated by the scanner. The time stamps of the first layer (Ang.=13.19°) are measured and show jitter accordingly.</p>

<h3 id="mrs600-with-rms1000">MRS600 with RMS1000</h3>

<ol>
  <li>Setup environment and power supply</li>
  <li>roslaunch sick_scan_xd test_0002_combi_live.launch</li>
  <li>Check setup using rviz</li>
  <li>Close all applications, which are not necessary (like IDE, browser, git client)</li>
  <li>Setup Tracking algorithm</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>top

</code></pre></div></div>
<ol>
  <li>Record data</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rosbag record record -o combi -a

</code></pre></div></div>

<h2 id="rms1000">RMS1000</h2>

<p>This driver supports the radar type RMS1000. This radar records raw targets and tracking objects. The tracking objects are determined on the basis of the raw targets. Two variants of a tracking method are already installed in the radar, which enables the radar to be put into operation quickly.</p>

<p>The RMS1000 is based on FMCW radar. With frequency-modulated continuous wave radar (FMCW radar), the transmission frequency is changed periodically. Triangle functions are usually used for distance measurement. While the transmission frequency changes as linearly as possible to the target object and back during the propagation time of the signal, the signal reflected by the object and received by the radar is time-shifted to the original transmitted frequency. By mixing the transmitted signal with the received signal, the frequency shift and thus the time shift can be determined. Based on the known modulation parameters of the transmitter, the propagation time of the signal can be determined, which in turn is proportional to the distance of the object. For precise distance measurement, therefore, the transmission frequency must be modulated as precisely as possible in linear fashion, since any non-linearity impairs the distance accuracy of the radar.</p>

<p>Through this indirect time measurement via the frequency change of the transmitter, even very close targets can be measured with high accuracy and cost-efficiency using the FMCW method, provided that the modulation parameters are selected appropriately. The distance resolution is determined by the bandwidth of the transmitted signal.</p>

<h3 id="raw-targets">Raw Targets</h3>

<p>Raw targets correspond to individual reflectors that are detected by the radar. Each individual reflector carries the following information:</p>
<ul>
  <li>Range</li>
  <li>Horizontal angle (azimuth)</li>
  <li>Doppler speed</li>
  <li>Reflectivity of the target (aka rcs - radar cross section)</li>
</ul>

<p>The radar RMSxxxx does not resolve elevation angles.  Therefore, the radar assumes the elevation values (z values) with 0.0. The error in distance estimation is usually negligible and is 0.4% (1.0 - cos(5°)) at an elevation angle of 5° compared to horizontal.</p>

<h3 id="tracking-objects">Tracking Objects</h3>

<p>Tracking objects are determined from the raw targets via a tracking procedure over the spatial and temporal
distribution of the raw targets. The track method estimates the location, direction and speed of the object based on an initial estimate.  After initialization, new raw targets are assigned to the track if they “fit” to the track.  This process is called “gating”. Once these raw targets have been assigned to the track,
the track is updated and the new estimate is used for further processing.</p>

<p>The distribution of raw targets over the object also determines the object length during the tracking process.</p>

<p>The tracking object therefore has the following properties:</p>
<ul>
  <li>Distance from radar in Cartesian coordinates</li>
  <li>Direction vector in Cartesian coordinates</li>
  <li>Direction of travel as an angle in the X/Y plane</li>
  <li>Vehicle speed</li>
  <li>Vehicle length</li>
</ul>

<h3 id="ros-message-for-radar">ROS message for Radar</h3>

<p>After parsing the telegram, the driver sends an ROS message of type RadarScan. RadarScan consists of the following components:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Header header
RadarPreHeader radarPreHeader
sensor_msgs/PointCloud2 targets
sick_scan_xd/RadarObject[] objects

</code></pre></div></div>
<h4 id="radarpreheader">RadarPreHeader</h4>
<p>The radar preheader contains information that provides general information about the radar. This data record can usually be ignored for object recognition with regard to raw targets and tracking objects.
For details please refer to the message specification of Sick.</p>

<h4 id="targets">targets</h4>

<p>The list with the raw targets of type sick_scan_xd/targets contains the information about the raw targets.
Each raw target contains the following data fields in a pointcloud2-message (height: 1, width: number of raw targets):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> std::string channelRawTargetId[] = { "x", "y", "z", "vrad","amplitude" };

</code></pre></div></div>
<p>This raw target contains cartesian coordinates, which are derived from range and azimuth angle (horizontal angle) in the following way (code snippet):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valSingle[0] = rawTargetList[i].Dist() cos(angle);    // x
valSingle[1] = rawTargetList[i].Dist() * sin(angle);  // y
valSingle[2] = 0.0;                                   // z
valSingle[3] = rawTargetList[i].Vrad();               // vrad
valSingle[4] = rawTargetList[i].Ampl();               // amplitude

</code></pre></div></div>

<h4 id="objects">objects</h4>

<p>The list with the objects of type sick_scan_xd/RadarObject[] contains the information about the track objects.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int32 id

time tracking_time                          // valid
time last_seen                              // not set

geometry_msgs/TwistWithCovariance velocity  // valid

geometry_msgs/Pose bounding_box_center      // valid
geometry_msgs/Vector3 bounding_box_size     // valid

geometry_msgs/PoseWithCovariance object_box_center // valid
geometry_msgs/Vector3 object_box_size              // valid

geometry_msgs/Point[] contour_points        // not set

</code></pre></div></div>

<p>Please note that not all fields are filled in the object messages. The message specification contains valid ones in the areas marked here in the code section.</p>

<p>The corresponding code fills the object list in the following manner:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        float heading = atan2( objectList[i].V3Dy(), objectList[i].V3Dx());

        radarMsg_.objects[i].velocity.twist.linear.x = objectList[i].V3Dx();
        radarMsg_.objects[i].velocity.twist.linear.y = objectList[i].V3Dy();
        radarMsg_.objects[i].velocity.twist.linear.z = 0.0;

        radarMsg_.objects[i].bounding_box_center.position.x = objectList[i].P3Dx();
        radarMsg_.objects[i].bounding_box_center.position.y = objectList[i].P3Dy();
        radarMsg_.objects[i].bounding_box_center.position.z = 0.0;
        radarMsg_.objects[i].bounding_box_center.orientation.x = cos(heading);
        radarMsg_.objects[i].bounding_box_center.orientation.y = sin(heading);
        radarMsg_.objects[i].bounding_box_center.orientation.z = 0.0;
        radarMsg_.objects[i].bounding_box_center.orientation.w = 1.0; // homogeneous coordinates


        radarMsg_.objects[i].bounding_box_size.x = objectList[i].ObjLength();
        radarMsg_.objects[i].bounding_box_size.y = 1.7;
        radarMsg_.objects[i].bounding_box_size.z = 1.7;
        for (int ii = 0; ii &lt; 6; ii++)
        {
          int mainDiagOffset = ii * 6 + ii;  // build eye-matrix
          radarMsg_.objects[i].object_box_center.covariance[mainDiagOffset] = 1.0;  // it is a little bit hacky ...
          radarMsg_.objects[i].velocity.covariance[mainDiagOffset] = 1.0;
        }
        radarMsg_.objects[i].object_box_center.pose = radarMsg_.objects[i].bounding_box_center;
        radarMsg_.objects[i].object_box_size= radarMsg_.objects[i].bounding_box_size;


</code></pre></div></div>
<p>As you can see there are default values for object height and object width of 1.7 (typical private vehicle)</p>

<!---

## Visualization

For the visualization a ROS node was developed, which receives
the radar messages and exports them as boxes for the objects and as arrows for the raw data.
The ROS node **radar_object_marker** receives the radar data and exports marker arrays that can be visualized in rviz.

The visualization could be controlled by the following parameters:

| Parameters                 | Description                                        |
| -------------------------- | -------------------------------------------------- |
| rawtarget_sphere_radius    | radius of the sphere for the raw data display      |
| rawtarget_arrow_scale      | Scaling factor for the arrow at the raw targets    |
| rawtarget_palette_name     | name of the color palette                          |
| rawtarget_palette_min_ampl | Minimum amplitude value mapped to color idx 0.     |
| rawtarget_palette_max_ampl | Maximum amplitude value mapped to color index 255. |
| object_arrow_scale         | Scaling factor for the arrow at the raw targets    |

The scaling values can be interpreted as the time an object or a raw target moves during this period. Using the distance/time equation, the distance corresponding to the arrow length is calculated from the product of this time period and the object speed or Doppler speed.

Example: Doppler speed: 20[m/s], rawtarget_arrow_scale: 0.4
An arrow of length 0.4 * 20[m] = 8[m] is displayed in rviz.

-->

<h3 id="launch-files">Launch Files</h3>

<p>The following launch files serve as examples for use:</p>

<ul>
  <li>sick_rms_xxxx.launch: Communication with the RMSxxxx and sending of radar ROS messages after successful parsing of SOPAS telegrams coming directly from the radar.</li>
  <li>radar_object_marker.launch : Conversion of radar messages to visualization messages</li>
</ul>

<h4 id="data-visualization-example-video">Data visualization example video</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/doc/200326_5_video_track.mp4">A video example can be found here</a>.</p>

<p>The following figure shows a viz-screenshot of the pointcloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/radar_rviz.png" alt="radar_rviz"></p>

<h3 id="parameter-for-radar-usage">Parameter for Radar Usage</h3>

<p>The following parameters are support by the node <strong>sick_generic_caller</strong> in combination with the RADAR RMS1000 / RMS2000:</p>

<ul>
  <li>scanner_type (string, default: “”) –&gt; Must be set to <strong>sick_rms_xxxx</strong>
</li>
  <li>range_max (double, default: 25.0)</li>
  <li>Maximum range</li>
  <li>hostname</li>
  <li>port</li>
  <li>timelimit</li>
  <li>tracking_mode
0: BASIC-Tracking - use for tracking smaller objects
1: TRAFFIC-Tracking - use for tracking larger objects like vehicles</li>
  <li>transmit_raw_targets (bool, default: true)</li>
  <li>transmit_objects (bool, default: true)</li>
  <li>emul_sensor (bool, default: false)</li>
</ul>

<h3 id="radar-datagram">Radar Datagram</h3>

<p>The message sick_scan_xd/RadarScan consists of four parts:</p>
<ul>
  <li>Header in standard format</li>
  <li>radarPreHeader with higher-level information</li>
  <li>targets: Raw targets output from radar</li>
  <li>objects: Tracking objects that are determined based on the raw targets using the internal tracking algorithm.</li>
</ul>

<p>The complete structure can be determined using the command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosmsg show sick_scan_xd/RadarScan'

</code></pre></div></div>

<p>The following is a short datagram showing the structure of the radar datagram.
The position of the individual elements for the data of the PreHeader is explained below.
See the documenation on https://www.sick.com/de/en/radar-sensors/c/g575803?q=:Def_Type:ProductFamily
for further information.</p>

<p><strong>Example of very short radar datagram</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sSN LMDradardata 1 1 112F6E9 0 0 BCC DC0C 730E9D16 730EA06D 0 0 0 0 0 0 1 0 0 4 DIST1 42200000 00000000 0 AZMT1 3C23D70A 00000000 0 VRAD1 3C23D70A 00000000 0 AMPL1 3DCCCCCD 00000000 0 1 MODE1 3F800000 00000000 0 0 0 0 0 0

</code></pre></div></div>

<p>In the following, the individual tokens are numbered one after another and their meaning is explained:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0: sSN
  1: LMDradardata

  MeasurementData
  ===============
  2: 1             MeasurementData.uiVersionNo  : Version Information for this while structureValue
                   Value   Range: 0 ... 65535
  DeviceBlock
  ===========
  3: 1             DeviceBlock.uiIdent      : Logical number of the device
                   Value   Range: 0 ... 65535
  4: 112F6E9       DeviceBlock.udiSerialNo  : Serial number of the device
                   Value Range  : 0..4294967295


  5: 0             DeviceBlock.xbState      : State of the device
                   Bit length   : 16

                   0.0 Bool     : Value Range False, True
                   Initialisation: False
                   Meaning       : bDeviceError

                   0.1 Bool      : Value Range False, True
                   Initialisation: False
                   Meaning       : bContaminationWarning

                   0.2 Bool      : Value Range False, True
                   Initialisation: False
                   Meaning       : bContaminationError

                   0.3 ...  0.7
  6: 0             1.0 ...  1.7 Bool      : Value Range False, True
                                           Reserved

StatusBlock
===========
  7: BCC            uiTelegramCount
  8: DC0C           uiCycleCount (or uiScanCount???)
  9: 730E9D16       udiSystemCountScan
 10: 730EA06D       udiSystemCountTransmit
 11: 0              xbInputs (Bit 0.0 .. 0.7)
 12: 0              xbInputs (Bit 1.0 .. 1.7)
 13: 0              xbOutputs (Bit 0.0 .. 0.7)
 14: 0              xbOutputs (Bit 1.0 .. 1.7)

MeasurementParam1Block
======================
 15: 0              MeasurementParam1Block.uiCycleDuration
 16: 0              MeasurementParam1Block.uiNoiseLevel

aEncoderBlock
=============
 17: 1              Number of aEncoderBlocks


 18: 0              aEncoderBlock[0].udiEncoderPos
 19: 0              aEncoderBlock[0].iEncoderSpeed

 20: 4              Number of following data channels
 21: DIST1
 22: 42200000
 23: 00000000
 24: 0
 25: AZMT1
 26: 3C23D70A
 27: 00000000
 28: 0
 29: VRAD1
 30: 3C23D70A
 31: 00000000
 32: 0
 33: AMPL1
 34: 3DCCCCCD
 35: 00000000
 36: 0
 37: 1
 38: MODE1
 39: 3F800000
 40: 00000000
 41: 0
 42: 0
 43: 0
 44: 0
 45: 0
 46: 0

</code></pre></div></div>

<h2 id="rms1000-and-lms1000-combination">RMS1000 and LMS1000 combination</h2>

<p>This tutorial shows how to combine a RMS1000radar with a LMS1000 lidar.</p>

<p>To demonstrate the lidar/radar combination, a RMS1000and a LMS1000 device were put into operation. The sick_scan_xd driver and rviz were started on ROS 1 Linux. Bagfiles have been recorded to demonstrate the required transform (rms_1xxx_lms_1xx_movement_off.bag and rms_1xxx_lms_1xx_movement_on.bag).</p>

<p>Run the following steps:</p>

<ol>
  <li>Connect RMS1000and LMS1000 and start sick_scan_xd with launchfiles sick_lms_1xxx.launch and sick_rms_xxxx.launch:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   roslaunch sick_scan_xd sick_lms_1xxx.launch
   roslaunch sick_scan_xd sick_rms_xxxx.launch
   
</code></pre></div></div>
<p>Make sure, that different ros node names and different IP-addresses are used.</p>

<p>The following rviz screenshot shows both pointclouds:
   <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/combination_rms_1xxx_lms_1xx/rms_1xxx_lms_1xx_combi_screenshot01.png" alt="rms_1xxx_lms_1xx_combi_screenshot01.png"></p>

<p>Note that each sensor has its own frame id and coordinate system. The RMS1000uses the frame id “radar”, the LMS1000 uses the frame id “cloud”. To combine both sensor, we have to transform the radar frame and coordinates to the lidar frame and coordinates.
   Radar targets have multiple echos due to reflection.</p>

<ol>
  <li>Start a ros static_transform_publisher to convert radar frames (frame id <code class="language-plaintext highlighter-rouge">/radar</code>) to lidar frames (frame id <code class="language-plaintext highlighter-rouge">/cloud</code>):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   rosrun tf static_transform_publisher 0 0 0 0 0 0 /cloud /radar 100
   
</code></pre></div></div>
<p>Using this transform, rviz displays both the radar and lidar pointcloud:
   <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/combination_rms_1xxx_lms_1xx/rms_1xxx_lms_1xx_combi.png" alt="rms_1xxx_lms_1xx_combi.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  If you use this example with a playback of bagfiles (e.g. <code class="language-plaintext highlighter-rouge">rosbag play --loop ./rms_1xxx_lms_1xx_movement_off.bag</code>), you might encounter errors due to different timestamps (the recorded timestamps in the bagfiles are different from the timestamps by the static_transform_publisher).</p>
</blockquote>

<p>Alternatively, the radar frame id and an optional transform can be configured in the radar launch file (parameter “frame_id” and “add_transform_xyz_rpy”).</p>

<h2 id="lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</h2>

<p>Most lidars create non interlaced scan data by default, i.e. a scan data telegram contains all scan points measured during a full 360 degree circulation. For MRS1xxx and LMS1000 lidars, parameter <code class="language-plaintext highlighter-rouge">ang_res</code> can be configured to increase the angular resolution. In this case, the scan data and point clouds are measured and published interlaced.</p>

<p>The following table shows valid combinations of the angular resolution (parameter <code class="language-plaintext highlighter-rouge">ang_res</code>) and scan frequency (parameter <code class="language-plaintext highlighter-rouge">scan_freq</code>) for MRS1000 and LMS1000 lidars:</p>

<table>
  <thead>
    <tr>
      <th>lidar</th>
      <th>ang_res [deg]</th>
      <th>scan_freq [Hz]</th>
      <th>interlacing</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MRS1000</td>
      <td>0.25</td>
      <td>50</td>
      <td>non-interlaced</td>
    </tr>
    <tr>
      <td>MRS1000</td>
      <td>0.125</td>
      <td>25</td>
      <td>2 x interlaced</td>
    </tr>
    <tr>
      <td>MRS1000</td>
      <td>0.0625</td>
      <td>12.5</td>
      <td>4 x interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.75</td>
      <td>150</td>
      <td>non-interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.375</td>
      <td>75</td>
      <td>2 x interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.1875</td>
      <td>37.5</td>
      <td>4 x interlaced</td>
    </tr>
  </tbody>
</table>

<p><strong>MRS1000 angular resolution</strong></p>

<p>By default, MRS1000 lidars create non-interlaced scans with an angular resolution 0.25 deg.
Using higher resolutions, the MRS1000 sends scan data interlaced.</p>

<p>MRS1000 lidars measure 4 consecutive scans with identical starting angles for each of its 4 layers, where each layer has a different elevation angle. This results in (12.5 Hz) * (4 layers) * (360 deg / 0.25 deg) * (275 deg / 360 deg) = 55000 shots per second.</p>

<p>With default configuration ang_res=0.25, the angular resolution of each scan is 0.25 [deg] and scans and point clouds are non-interlaced. The sequence of scan data telegrams is repeating with 4 consecutive telegrams (resp. 4 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5 deg, angle inc = 0.25 deg</li>
</ul>

<p>With configuration ang_res=0.125, the angular resolution of each scan is 0.125 [deg] and scans and point clouds are 2 x interlaced. The sequence of scan data telegrams is repeating with 8 consecutive telegrams (resp. 8 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.625 deg, angle inc = 0.25 deg</li>
</ul>

<p>With configuration ang_res=0.0625, the angular resolution of each scan is 0.0625 [deg] and scans and point clouds are 4 x interlaced. The sequence of scan data telegrams is repeating with 16 consecutive telegrams (resp. 16 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.6250 deg, angle inc = 0.25 deg</li>
</ul>

<p>To use the full angular resolution of one 360 degree circulation, the point cloud must be accumulated by 8 resp. 16 messages in interlaced mode.</p>

<p><strong>LMS1000 angular resolution</strong></p>

<p>By default, LMS1000 lidars create non-interlaced scans with an angular resolution 0.75 deg.
Using higher resolutions, the LMS1000 sends scan data interlaced.</p>

<p>With configuration ang_res=0.75, the angular resolution of each scan is 0.75 [deg]. This means that each point cloud message also has a resolution of 0.75 [deg]. With configuration ang_res=0.375, the scan is generated interlaced: Each scan still has 0.75 [deg] resolution, but 2 x 4 = 8 consecutive scans are rotated by 0.375 [deg] against each other. I.e. 8 consecutive point cloud messages each have an angular resolution of 0.375 [deg] at half the frequency. Within a point cloud message the angular resolution is still 0.75 [deg].</p>

<p>With ang_res=0.375, scan data are two times interlaced. The sequence of scan data telegrams is repeating with 8 consecutive telegrams:</p>
<ul>
  <li>4 scans starting at -138.000 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.375 deg, angle inc = 0.75 deg</li>
</ul>

<p>Thus the start angles of the received scan data telegrams are
{ …, -138.375, -138.375, -138.375, -138.375, -138.000, -138.000, -138.000, -138.000, … }</p>

<p>With ang_res=0.1875 the scan is generated quadruple interlaced, i.e. 4 x 4 = 16 consecutive scans are each rotated by 0.1875 [deg]. Each scan is resolved with 0.75 [deg]; 4 x 4 = 16 scans resp. 16 pointclouds together (accumulated) result in a resolution of 0.1875 [deg] at a quarter of the frequency.</p>

<p>With ang_res=0.1875, scan data are four times interlaced. The sequence of scan data telegrams is repeating with 16 consecutive telegrams:</p>
<ul>
  <li>4 scans starting at -137.8125 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.0000 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.1875 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.3750 deg, angle inc = 0.75 deg, then</li>
</ul>

<p>Thus the start angles of the received scan data telegrams are
{ …, -137.8125, -137.8125, -137.8125, -137.8125, -138.0000, -138.0000, -138.0000, -138.0000, -138.1875, -138.1875, -138.1875, -138.1875, -138.3750, -138.3750, -138.3750, -138.3750, … }</p>

<p>You can see this in rviz by increasing the decay time to e.g. 4/75=0.054 or higher. The screenshot shows an example with the default setting ang_res=0.75:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/LMS1xxx_0.7500_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>The angular resolution is (just roughly measured) about atan(0.11/0.9) / 9 points = 0.77 [deg]. With ang_res=0.375 and decay=0.1 rviz shows twice the resolution:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/LMS1xxx_0.3750_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>Correspondingly, rviz shows four times the resolution with ang_res=0.1875 and decay=0.1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/LMS1xxx_0.1875_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>To use the full angular resolution of one 360 degree circulation, the pointcloud must be accumulated by 8 resp. 16 messages.</p>

<p>The active configuration can be seen in the log output during scanner initialization, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ INFO] [1669294673.078608968]: sRA LMPscancfg: scan frequency = 75 Hz, angular resolution = 0.375 deg.

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LMS creates 4 consecutive scans with identical starting angles for each of its 4 laser LEDs. The 4 laser LEDs are mounted in one plane. All together, this gives you (4 scans) * (37.5 Hz) * (1 layer) * (360 deg / 0.75 deg) * (275 deg / 360 deg) = 55000 shots per second.</p>

</blockquote>

<h1 id="faq">FAQ</h1>

<h2 id="general">General</h2>

<p><strong>How to run multiple sensors concurrently?</strong></p>

<p>:question: How can I run multiple sensors concurrently with sick_scan_xd ?</p>

<p>:white_check_mark: To support multiple sensors, sick_scan_xd has to be started multiple times, with one sick_scan_xd-node for each sensor. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#start-multiple-nodes">start multiple nodes</a> for details.</p>

<p><strong>Driver restarts again and again after “sFA” message</strong></p>

<p>:question: The sick_scan_xd driver restarts again and again after an error message “sFA”.</p>

<p>:white_check_mark: The behaviour is intentional. The error message “sFA” can be caused by faulty configuration or errors in the lidar. Correct operation after this error message is not guaranteed. In this case, the driver restarts itself. It is recommended to identify and correct the error using its error number (“<code class="language-plaintext highlighter-rouge">sFA&lt;hexcode&gt;</code>”). The SOPAS error codes are listed in the manual.</p>

<p><strong>Driver restarts after timeout error</strong></p>

<p>:question: The sick_scan_xd driver changes the communication protocol and restarts after a timeout error.</p>

<p>:white_check_mark: The use of binary communication (Cola-B) is highly recommended due to better compatibility, lower network traffic and general support.
Recommendation:</p>
<ol>
  <li>Set parameter “use_binary_protocol” to “true” in the launch file, and</li>
  <li>Set the lidar communication mode with the SOPAS ET software to binary and save this setting in the scanner’s EEPROM.</li>
</ol>

<p><strong>Changes in launchfiles are ignored</strong></p>

<p>:question: roslaunch still uses an old version after modifying the launch-file.</p>

<p>:white_check_mark: After modifying a launch-file, it has to be installed by running <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1</code>
to be located and used by <code class="language-plaintext highlighter-rouge">roslaunch</code>.</p>

<p><strong>ROS 2 launch file support</strong></p>

<p>:question: How can I create a ROS 2 node in python to run sick_generic_caller from a launch.py-file in ROS 2?</p>

<p>:white_check_mark: Example to launch a TiM-7xx node in ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sick_scan_pkg_prefix = get_package_share_directory('sick_scan_xd')
    tim_launch_file_path = os.path.join(sick_scan_pkg_prefix, 'launch/sick_tim_7xx.launch')
    tim_top_node = Node(
        package='sick_scan_xd',
        executable='sick_generic_caller',
        output='screen',
        arguments=[
            tim_launch_file_path,
            'nodename:=/lidars/tim_top',
            'hostname:=192.168.0.110',
            'cloud_topic:=/lidars/tim_top/cloud',
            'frame_id:=tim_top'
        ]
    )

</code></pre></div></div>
<p>Thanks to user JWhitleyWork.</p>

<p><strong>Timestamps</strong></p>

<p>:question: What timestamp is provided in the pointcloud and laserscan messages?</p>

<p>:white_check_mark: Details about timestamps are given in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#time-synchronization">timing</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#software-pll">software_pll</a>.</p>

<p>In a nutshell:
The lidars do not work with absolute time stamps but with “ticks”. There are two types of tick timestamps:</p>
<ul>
  <li>Tick timestamps for the generation</li>
  <li>Tick timestamps for sending the message
To match the tick timestamps against the system time, a straight line equation is estimated via the so-called software PLL, which can be used to calculate from the system time to the ticks in the lidar (and vice versa). The assumption is that the tick timestamp for sending the message corresponds to the system time when receiving the message. In reality there will be a tiny delay here. This delay can be ignored.</li>
</ul>

<p>With the help of this straight line equation, one can now calculate the system time at which the data is generated in the lidar.</p>

<p>Summary:</p>
<ol>
  <li>lidar: stamp with ticks the generation (first shot in the scan) (TICK_GEN)</li>
  <li>lidar: stamp with ticks the sending of the scan message (TICK_TRANSMIT)</li>
  <li>PC: Stamp with system time the receiving of the message</li>
  <li>PC: Calculate back to system time of generation:
System time of generation = System time of receiving - (TICK_TRANSMIT - TICK_GEN)/TICK_FREQUENCY</li>
</ol>

<p><strong>Laserscan messages with multiple frame ids</strong></p>

<p>:question: sick_scan_xd publishes laserscan messages for multiScan100 and picoScan100 with multiple frame ids and possibly inconsistent data. Which frame id is correct?</p>

<p>:white_check_mark: By default, an echo filter is activated in the multiScan100 and picoScan100 launchfile. This echo filter suppresses multiple echos, e.g. echos from an object and a protective glass pane. The default configuration is “last echo only”. In this case (i.e. one echo only), the fullframe laserscan messages on topic scan_fullframe all have identical frame ids for each layer, i.e. “world_&lt;layer&gt;”. For the multiScan100 lidars with 16 layers, sick_scan_xd publishes laserscan messages with frame ids “world_1”, “world_2” up to “world_16”. For picoScan100 lidars with 1 layer, there is just one frame id “world_1”.</p>

<p>In case of multiple echos (i.e. echo filter is deactivated), each echo is published by a laserscan message with different frame ids “world_&lt;layer&gt;_&lt;echo_idx&gt;”. For picoScan100 lidars with 3 echos, there are 3 frame ids “world_1_0”, “world_1_1”, “world_1_2” published. For multiScan100 lidars with 16 layers and 3 echos, there are 48 different frame ids published “world_1_0”, “world_1_1”, “world_1_2”, “world_2_0”, “world_2_1”, “world_2_2”, … , “world_16_0”, “world_16_1”, “world_16_2”.</p>

<p>This behaviour is intended, since a laserscan message can not contain multiple ranges for a single scan point at one azimuth angle. Therefore, there have to be different laserscan messages for each layer and each echo. Layer and echo of a laserscan message are identified by the frame id.</p>

<p><strong>Compilation errors</strong></p>

<p>:question: Compiler reports errors in file <code class="language-plaintext highlighter-rouge">/opt/ros/&lt;distro&gt;/include/sick_scan</code></p>

<p>:white_check_mark: If sick_scan was previously installed using <code class="language-plaintext highlighter-rouge">apt-get install ros-&lt;distro&gt;-sick-scan</code>, you have to remove previous versions using <code class="language-plaintext highlighter-rouge">apt-get purge ros-&lt;distro&gt;-sick-scan</code>. Run the following steps for a complete rebuild:</p>
<ol>
  <li>Run <code class="language-plaintext highlighter-rouge">sudo apt-get purge ros-&lt;distro&gt;-sick-scan</code> (e.g. <code class="language-plaintext highlighter-rouge">sudo apt-get purge ros-noetic-sick-scan</code>) to remove previously installed sick_scan-packages</li>
  <li>Remove the folders sick_scan_xd/build, sick_scan_xd/build_isolated, sick_scan_xd/devel, sick_scan_xd/devel_isolated, sick_scan_xd/install and sick_scan_xd/install_isolated</li>
  <li>Rebuild</li>
</ol>

<p>:question: cmake cannot find diagnostic_updater</p>

<p>:white_check_mark: On ROS 2 foxy, package diagnostic_updater needs to be installed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get update
sudo apt-get install ros-$ROS_DISTRO-diagnostic-updater # install diagnostic_updater
# E.g. to install diagnostic_updater on foxy, run
# sudo apt-get install ros-foxy-diagnostic-updater

</code></pre></div></div>

<p>:question: catkin gives me the following error message:
<code class="language-plaintext highlighter-rouge">By not providing "FindSICKLDMRS.cmake" in CMAKE_MODULE_PATH this project ..., but CMake did not find one."</code></p>

<p>:white_check_mark:  One problem with ROS is that it doesn’t automatically rebuild everything if you just append “-DLMRRS=0”.
If you accidentally did the following call before</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catkin_make_isolated --install --cmake-args -DROS_VERSION=1

</code></pre></div></div>
<p>you must remove the build/devel/install-directories created by the ROS build process.
For this please run the following commands to remove the directories, which holds the previous build results:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~/ros_catkin_ws
rm -rf build_isolated
rm -rf devel_isolated
rm -rf install_isolated
rm -rf devel

</code></pre></div></div>
<p>It is possible that not all directories are present in this list. But that does not matter.
The only subdirectory left should be “src”.
You can check this with the following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls */ -d

</code></pre></div></div>
<p>The output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/

</code></pre></div></div>
<p>After doing this please rerun the command
catkin_make_isolated –install –cmake-args -DROS_VERSION=1 -DLDMRS=0</p>

<p><strong>rviz or rviz2 do not work as expected</strong></p>

<p>:question: rviz shows a grey point cloud. The size of points can be adjusted.</p>

<p>:white_check_mark: Check in the launch file that the intensity flag is set to True.</p>

<p>:question: rviz shows a grey point cloud and the size of points can not be adjusted.</p>

<p>:white_check_mark: Probably in this case you are running Linux in a virtual machine. In this case, OpenGL may not work correctly in the VM. rviz then chooses a kind of “fallback solution” and deactivates the colors.
Also, changing the “Size” and “Style” display in rviz has no effect on the display of the pointcloud data.</p>

<p>The problem can be avoided by starting rviz with the following sequence:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export LIBGL_ALWAYS_SOFTWARE=1
rosrun rviz rviz

</code></pre></div></div>

<p>:question: rviz2 on Ubuntu 24 with ROS 2 jazzy crashes immediately after start</p>

<p>:white_check_mark: This can be a wayland vs. X11 problem. Try <code class="language-plaintext highlighter-rouge">export QT_QPA_PLATFORM=xcb</code> before starting rviz2. See https://github.com/ros-visualization/rviz/issues/1442#issuecomment-553900795 and https://blog.martin-graesslin.com/blog/2015/07/porting-qt-applications-to-wayland/ for further information.</p>

<p><strong>Angular resolution and scan frequency</strong></p>

<p>:question: The angular resolution/ number of shots is too small</p>

<p>:white_check_mark: Possibly Mean or Median filters are activated. Use Sopas ET to deactivate them and store this settings permanent on the device, see picture.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/tim5xxx_filter.PNG" alt="Sopas_filter"></p>

<p>Further information can be found at http://wiki.ros.org/rviz/Troubleshooting .</p>

<p>:question: The scanner and message frequency is lower than expected</p>

<p>:white_check_mark: Mean or median filters decrease the scanner frequency. Check and configure filter settings with SOPAS ET or deactivate them in the launch file (MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx only):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="lfp_meanfilter" type="int" value="-1" /&gt; &lt;!-- MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx: lfp_meanfilter&lt;0: do not apply, lfp_meanfilter==0: deactivate LFPmeanfilter, lfp_meanfilter&gt;0: activate LFPmeanfilter with lfp_meanfilter = number of scans --&gt;
&lt;param name="lfp_medianfilter" type="int" value="-1" /&gt; &lt;!-- MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx: lfp_medianfilter&lt;0: do not apply, lfp_medianfilter==0: deactivate LFPmedianfilter, lfp_medianfilter==1: activate LFPmedianfilter --&gt;

</code></pre></div></div>
<p>By default, filter settings are not overwritten, i.e. the filter settings stored in the lidars EEPROM apply (factory defaults resp. SOPAS ET filter settings).</p>

<p><strong>LMS1xxx angular resolution</strong></p>

<p>:question: Independent of the configuration, the LMS1xxx pointcloud always displays 0.75 [deg] angular resolution</p>

<p>:white_check_mark: Using higher resolutions, the LMS1xxx sends scan data interlaced. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</a> for details.</p>

<p><strong>“ERROR: Tcp::open: Failed to open TCP connection to 192.168.0.1, aborting.”</strong></p>

<p>:question: Question:
sick_generic_caller gives you an answer like:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"ERROR: Tcp::open: Failed to open TCP connection to 192.168.0.1, aborting."</span>

</code></pre></div></div>

<p>:white_check_mark: Answer: See FAQ for network diagnosis and recommended configuration.</p>

<p><strong>IP Address of Lidar</strong></p>

<p>:question: Question:
My scanner does not use the default ip address. What shall I do?</p>

<p>:white_check_mark: Answer:
There are two options doing this:</p>

<ul>
  <li>Permanently:
Replace the following entry with your ip address.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;param <span class="nv">name</span><span class="o">=</span><span class="s2">"hostname"</span> <span class="nb">type</span><span class="o">=</span><span class="s2">"string"</span> <span class="nv">value</span><span class="o">=</span><span class="s2">"192.168.0.1"</span> /&gt;

</code></pre></div></div>
<ul>
  <li>Temporarily
Use a command line argument in addition to the launch file argument:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nb">hostname</span>:<span class="o">=</span>192.168.0.2

</code></pre></div></div>

<p><strong>Timeout Warning</strong></p>

<p>:question: Question:
During start phase the are warning/error message like</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>no answer received after 5000 ms. Maybe sopas mode is wrong.

</code></pre></div></div>
<p>and some more warning/error messages:</p>

<p>:white_check_mark: Answer:
In this case the driver tries to start the scanner in binary mode. If this is not possible, warnings and error messages are generated.
The driver switches the scanner from ASCII mode to binary mode and then restarts communication. The messages can therefore be ignored.
For a long-term solution, we recommend switching from ASCII to binary communication with SOPAS ET under Windows.</p>

<p><strong>Own Data Handling</strong></p>

<p>:question: Question:
I would like to process data with my own methods.</p>

<p>:white_check_mark: Answer:
Search for keyword “PUBLISH_DATA:” in the code and replace the code for writing
jpeg-files and CSV-files with your own source code.</p>

<p><strong>Occasionally missing scan data</strong></p>

<p>:question: Question:
Occasionally, no scan data appear, but the scanner is still reachable using <code class="language-plaintext highlighter-rouge">ping &lt;ip-address&gt;</code> or <code class="language-plaintext highlighter-rouge">nc -z -v &lt;ip-address&gt; &lt;port&gt;</code></p>

<p>:white_check_mark: Answer:
This is likely to be a data capture issue. In any case it’s recommend (if not already set) to use SOPAS-Binary instead of SOPAS-ASCII, because here the data rate is lower.</p>

<p>In addition, the following measures can help to determine the source of the problems:
a) Exchange the cables to the lidar(s) incl. the network cables
b) Exchange the power supply to the lidar(s)
c) avoidance of interconnection of other components (like switch etc.)
d) upgrade hardware and firmware of devices (if new versions available)</p>

<p>If it is not a hardware problem (e.g. cable), check if there are other software components using the network interface.</p>

<p>If there are still problems, use Wireshark to see if there are any communication problems reported. Wireshark can export the recorded network traffic as text (see screenshot). Search for entries like “LMDscandata” in the generated text file. This marks the beginning of a new scan message. You can then compare the order of the timestamps of these packets to see if there were any failures.</p>

<p><img src="https://user-images.githubusercontent.com/33296049/124088216-01aa2280-da53-11eb-91ae-2b88b37e08eb.png" alt="Wireshark screenshot"></p>

<p><strong>python_d.exe not found</strong></p>

<p>:question: Question:
On Windows with ROS, cmake complains “python_d.exe not found” when running rosidl generator</p>

<p>:white_check_mark: Answer:
Workaround: Copy python.exe to python_d.exe in the python folder.</p>

<p><strong>Debugging</strong></p>

<p>:question: Question:
How can I debug sick_generic_caller on ROS 1?</p>

<p>:white_check_mark: Answer:
Build with compiler option <code class="language-plaintext highlighter-rouge">-g</code> and run sick_generic_caller as described using a launchfile. Stop sick_generic_caller (Ctrl-C or kill) and save the current ros parameter using <code class="language-plaintext highlighter-rouge">rosparam dump &lt;dumpfile&gt;.yaml</code>. Load these parameter with <code class="language-plaintext highlighter-rouge">rosparam load &lt;dumpfile&gt;.yaml</code> and restart sick_generic_caller in gdb or in your IDE.</p>

<p><strong>Curved lines on a straight wall</strong></p>

<p>:question: Question:
The X,Y points of the lidar show a curved line even though the lidar is scanning a straight wall. How can this be?</p>

<p>:white_check_mark: Answer:
This effect occurs when the lidar has multiple planes that are tilted up or down. In this case, the laser beams of this plane do not lie on a flat plane. Rather, the beams lie on a cone. If the laser beams then hit a wall, the result is a curved course of the lidar points. If the lidar is horizontal and the wall is vertical, this is a hyperbola (see following figure):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/cone_section.png" alt="cone_section"></p>

<p>This image is generated using the website https://www.intmath.com/plane-analytic-geometry/conic-sections-summary-interactive.php.
Thus, the mathematical laws for a conic section apply, as they are explained e.g. at Wikipedia at https://en.wikipedia.org/wiki/Conic_section.</p>

<p><strong>Interlacing</strong></p>

<p>:question: Question:
How should I interpret the scan rate and lidar resolution from the manual? What is the relationship between ROS point cloud publishing rate and scan frequency here?</p>

<p>:white_check_mark: Answer:</p>

<p>The angular resolution and scan frequency is configurable in many lidars such as the LRS-4xxx or MRS1000. Depending on the lidar type, angular resolution and scan frequency can be set in the launch file either via the parameter “scan_cfg_list_entry” or the parameters “ang_res” and “scan_freq”. Angular resolution and scan frequency are not independent of each other. If no default settings are used, the values must be selected according to the manual for the respective lidar and set in launch file.</p>

<p>An increase in resolution is achieved by interlacing by a factor of N. This means that N consecutive scans are rotated by a constant angular offset. Each scan in itself still has the physically given angular resolution and frequency. By concatenating N interlaced scans, the angular resolution is increased by the factor N.</p>

<p>Example: The default setting of an MRS1000 is 0.25 degrees horizontal angular resolution at 50 Hz scan frequency without interlacing and an angular range of 275 degrees in total. I.e. each scan measures the distance at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ].</p>

<p>If 0.125 degrees horizontal angular resolution is configured at 25 Hz scan frequency, the scans are performed with 2 times interlacing (N=2). Every 2nd scan is horizontally shifted by 0.125 degrees. I.e. each scan measures alternately at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ] and [ … , 0.125, 0.375, 0.625, 0.875 … ]. 50 single scans per second resp. 25 interlaced scans per second are sent.</p>

<p>If 0.0625 degrees horizontal angular resolution at 12.5 Hz scan frequency is configured, the scans are performed with 4 times interlacing (N=4). Successive scans are shifted horizontally by 0.0625 degrees each. That is, each scan measures alternately at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ], [… , 0.0625, 0.3125, 0.5625, 0.8125 … ], [… , 0.125, 0.375, 0.625, 0.875 … ] and [… , 0.1875, 0.4375, 0.6875, 0.9375 … ]. 50 single scans per second resp. 12.5 interlaced scans per second are sent.</p>

<p>In interlacing mode, laser scan and point cloud messages are published interlaced, too. In rviz, the higher angular resolution is clearly visible when the decay time is increased.</p>

<p>With a scan frequency of 50 Hz and 4 active layers, the lidar will send a new scan line each 0.02 seconds. Each layer is scanned after 0.08 seconds resp. with 12.5 Hz (4 layers multiplied by 12.5 Hz = 50 Hz scan frequency). The point cloud accumulates all active layers and is therefore published with 12.5 Hz (i.e. scan frequency divided by number of layers).</p>

<p>If you check the publishing rate of the point cloud messages of a MRS-1104, you will measure 12.4 Hz, since the scans of 4 layers are accumulated in 1 point cloud message (50 hz scan frequency divided by 4 layers = 12.5 Hz point cloud publishing frequency). The resolution of each single point cloud message is 0.125 [deg]. Only by interleaving 4 consecutive messages you get the high resolution of 0.0625 [deg].</p>

<p>See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</a> for further informations.</p>

<h2 id="networking">Networking</h2>

<p>A TCP connection is needed to receive scan data from a lidar, which requires an appropriate network setup.</p>

<p>Common errors when establishing the TCP connection and possible solutions are described below. If you encounter network errors like “Failed to open TCP connection” when running sick_scan_xd, follow these recommendations.</p>

<p><strong>Static IP addresses</strong></p>

<p>Most lidars have the default IP address 192.168.0.1. It is highly recommended to use a static IPv4 network with IP addresses 192.168.x.y. PC and lidar should use the same subnet. <strong>Avoid using DHCP.</strong></p>

<p>Example IP address of the lidar: 192.168.0.1 (default)</p>

<p>Example IP address of the PC running sick_scan_xd: 192.168.0.100</p>

<p>The IP address of the PC running sick_scan_xd and the lidar must not be identical!</p>

<p>Use <code class="language-plaintext highlighter-rouge">ifconfig -a</code> on Linux resp. <code class="language-plaintext highlighter-rouge">ipconfig /all</code> on Windows to view network settings and lcoal IP addresses.</p>

<ol>
  <li>Try to ping your device:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>
<ol>
  <li>Disconnect your scanner and retry ping</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>
<p>The result of ping contains a pattern like</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ... Destination Host Unreachable
   
</code></pre></div></div>
<ol>
  <li>Reconnect your device and try to ping:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>

<p>If you do not know the IP addresses, try to find the IP addresses of your PC and your lidar in your subnet:</p>

<ol>
  <li>
    <p>Install fping: <code class="language-plaintext highlighter-rouge">apt-get install fping</code></p>
  </li>
  <li>
    <p>Scan your network (for example, subnet 192.168.10.0/24): <code class="language-plaintext highlighter-rouge">fping -a 192.168.0.1\24</code> to
search for all IP addresses from 192.168.0.0 to 192.168.0.255.</p>
  </li>
</ol>

<p>The result is similar to:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.0.4 is alive
192.168.0.22 is alive

</code></pre></div></div>
<p>and a lot of unreachable entries.
In the example the IP address 192.168.0.4 is the laserscanner MRS1104 and the IP address 192.168.0.22 is the computer running linux. Check this with <code class="language-plaintext highlighter-rouge">ifconfig|grep 192.168.0.22</code>.</p>

<p>We recommend to use wired Ethernet. On Ubuntu, use the “Wired Settings” menu to check the network profile. Network profiles sometimes change automatically when multiple profiles are in use or the lidar has been switched off and on.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/network_setup_02.png" alt="network_setup_02.png"></p>

<p><strong>Network configuration with SOPAS ET</strong></p>

<p>The <a href="https://www.sick.com/de/en/catalog/digital-services-and-solutions/software/sopas-engineering-tool/p/p367244">SOPAS Engineering Tool</a> (SOPAS ET) allows a detailed lidar configuration incl. network settings. We recommend to use SOPAS ET in case of network problems or to change the lidars network configuration. The operation manual contains further details.</p>

<p><strong>Diagnostic tools</strong></p>

<p>Network tools can help in case of connection errors. Examples are:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">ping &lt;lidar-ip-address&gt;</code> to check if the lidar is reachable</li>
  <li>
<code class="language-plaintext highlighter-rouge">fping -a 192.168.0.1\24</code> to see ip addresses available in the subnet</li>
  <li>
<code class="language-plaintext highlighter-rouge">netcat &lt;lidar-ip-address&gt; &lt;lidar-tcp-port&gt;</code> to read or write network data</li>
  <li>
<code class="language-plaintext highlighter-rouge">wireshark</code> to monitor and record the network traffic between PC and lidar.</li>
  <li>
<code class="language-plaintext highlighter-rouge">sudo ufw status</code> to see if a firewall is active. If active, disable firewalls with <code class="language-plaintext highlighter-rouge">sudo ufw disable</code>.</li>
</ul>

<h2 id="multiscan100--picoscan100">multiScan100 / picoScan100</h2>

<p><strong>Visual Studio: Breakpoints in Debug Mode disabled</strong></p>

<p>:question: In Windows debug version the compiler does not stop at breakpoints.</p>

<p>:white_check_mark: Check, that you are using the Debug Version. At ‘/Zi’ to compiler settings. Disable optimization.
(see <code class="language-plaintext highlighter-rouge">https://stackoverflow.com/questions/865546/generating-symbols-in-release-binaries-with-visual-studio</code> for details).</p>

<p><strong>Packages lost in benchmark</strong></p>

<p>:question: sick_scan_xd seems to drop packages, when sending 10000 msgpacks with polarscan_sender_test.py from another computer</p>

<p>:white_check_mark: There can be a number of reasons for dropped messages (udp or msgpacks). Besides slow network connection, there can be other pitfalls depending on the system:</p>

<ul>
  <li>
    <p>If Linux or Windows is running in a virtual machine, make sure UDP port 2115 is forwarded. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#firewall-configuration">Firewall configuration</a>.</p>
  </li>
  <li>
    <p>Depending on ROS 2 system settings, log messages might be buffered. To really see all log messages of sick_generic_caller, terminate sick_scan_xd/sick_generic_caller (Ctrl-C or kill) and view the ros logfile by <code class="language-plaintext highlighter-rouge">cat ~/.ros/log/sick_scan_*.log</code></p>
  </li>
</ul>

<p><strong>Convert pcapng-files to msgpack or json</strong></p>

<p>:question: How can I convert a pcapng-file with scandata to a msgpack- or json-file?</p>

<p>:white_check_mark: Run the following steps:</p>
<ul>
  <li>Install python msgpack package with <code class="language-plaintext highlighter-rouge">pip install msgpack</code>
</li>
  <li>Play the pcapng-file using multiscan_pcap_player.py</li>
  <li>Receive and convert to msgpack using multiscan_receiver.py</li>
  <li>Convert to json using online-converter https://toolslick.com/conversion/data/messagepack-to-json</li>
</ul>

<p>Linux example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pushd sick_scan_xd/test/python
python3 python multiscan_receiver.py &amp;
python3 multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20210929_multiscan_token_udp.pcapng
mv ./multiscan_dump_12472.msgpack     20210929_multiscan_token_udp.msgpack
mv ./multiscan_dump_12472.msgpack.hex 20210929_multiscan_token_udp.msgpack.hex
popd

</code></pre></div></div>
<p>Then paste the content of file <code class="language-plaintext highlighter-rouge">20210929_multiscan_token_udp.msgpack.hex</code> in https://toolslick.com/conversion/data/messagepack-to-json and save the json-output.</p>

<p>Windows example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pushd sick_scan_xd\test\python
python --version
REM Convert 20220915_multiscan_msgpack_output.pcapng (16-bit RSSI record) to msgpack resp. json
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
start python multiscan_receiver.py
python multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20220915_multiscan_msgpack_output.pcapng --udp_port=2115
move /y .\multiscan_dump_23644.msgpack     20220915_multiscan_msgpack_output.msgpack
move /y .\multiscan_dump_23644.msgpack.hex 20220915_multiscan_msgpack_output.msgpack.hex
REM Convert 20210929_multiscan_token_udp.pcapng (8-bit RSSI record) to msgpack resp. json
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
start python multiscan_receiver.py
python multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20210929_multiscan_token_udp.pcapng --verbose=0
move /y .\multiscan_dump_12472.msgpack     20210929_multiscan_token_udp.msgpack
move /y .\multiscan_dump_12472.msgpack.hex 20210929_multiscan_token_udp.msgpack.hex
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
popd

</code></pre></div></div>
<p>Then paste the content of files <code class="language-plaintext highlighter-rouge">20220915_multiscan_msgpack_output.msgpack.hex</code> resp. <code class="language-plaintext highlighter-rouge">20210929_multiscan_token_udp.msgpack.hex</code> in https://toolslick.com/conversion/data/messagepack-to-json and save the json-output.</p>

<h1 id="troubleshooting-and-technical-support">Troubleshooting and technical support</h1>

<p>The software is based on the ROS drivers sick_scan, sick_scan_base and sick_scan2. For FAQ and troubleshooting please also have a look at https://github.com/SICKAG/sick_scan , https://github.com/SICKAG/sick_scan_base and https://github.com/SICKAG/sick_scan2 .
Common problems might be solved in closed issues.</p>

<ol>
  <li>Check Scanner IP in the launch file.</li>
  <li>Check Ethernet connection to scanner with netcat e.g.
<code class="language-plaintext highlighter-rouge">nc -z -v -w5 $SCANNERIPADDRESS 2112
</code>.
For further details about setting up the correct ip settings see <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#ip-address-configuration">IP configuration</a>)</li>
  <li>View node startup output wether the IP connection could be established</li>
  <li>Check the scanner status using the LEDs on the device. The LED codes are described in the above mentioned operation manuals.</li>
  <li>Further testing and troubleshooting informations can found in the file test/readme_testplan.txt</li>
  <li>If you stop the scanner in your debugging IDE or by other hard interruption (like Ctrl-C), you must wait until 60 sec. before
the scanner is up and running again. During this time the MRS6124 reconnects twice.
If you do not wait this waiting time you could see one of the following messages:
    <ul>
      <li>TCP connection error</li>
      <li>Error-Message 0x0d</li>
    </ul>
  </li>
  <li>Amplitude values in rviz: If you see only one color in rviz try the following:
Set the min/max-Range of intensity display in the range [0…200] and switch on the intensity flag in the launch file</li>
  <li>In case of network problems check your own ip address and the ip address of your laser scanner (by using SOPAS ET).
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>List of own IP-addresses: ifconfig</td>
              <td>grep “inet addr”</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Try to ping scanner ip address (used in launch file)</li>
    </ul>
  </li>
  <li>If the driver stops during init phase please stop the driver with ctrl-c and restart (could be caused due to protocol ASCII/Binary cola-dialect)</li>
</ol>

<p>In case of technical support please open a new issue. For optimal support, add the following information to your request:</p>

<ol>
  <li>Scanner model name,</li>
  <li>Ros node startup log,</li>
  <li>Sopas file of your scanner configuration. The instructions at https://sickconnect.com/create-and-download-a-sopas-file/ show how to create the Sopas file.</li>
</ol>

<p>In case of application support please use <a href="https://support.sick.com">https://support.sick.com</a>.</p>

<h1 id="creators-and-contribution">Creators and contribution</h1>

<p>Michael Lehning (http://www.lehning.de) on behalf of SICK AG (https://www.sick.com/)</p>

<p>This <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop//CONTRIBUTING.md">documentation</a> is intended to provide background information on the maintenance and extension of the repository.</p>

<h1 id="keywords">Keywords</h1>

<p>MRS1000, MRS1104, LMS1000, LMS1104, MRS6000, MRS6124, RMS1xxx, RMS1000, RMSxxxx, ROS LiDAR, SICK LiDAR, SICK Laser, SICK Laserscanner, SICK Radar, LMS1xx, MRS1xxx, LMS1xxx, MRS6xxx, TiM5xx, TiM551, TiM561, TiM571, TiM781, TiM781S, LMS5xx, LMS511, NAV210, NAV245, NAV310, LD-MRS, LRS4000, LD-LRS3600, LD-LRS3601, LD-LRS3611, LD-OEM1500, LD-OEM1501, multiScan100, multiScan, picoScan100, picoScan150, picoScan120, multiScan136, multiScan165</p>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<p><img align="right" width="200" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Logo_SICK_AG_2009.svg/1200px-Logo_SICK_AG_2009.svg.png"></p>

<h2 id="executive-summary">Executive Summary</h2>

<p>This documentation is intended to provide background information on the maintenance and extension of the repository.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#adding-a-new-device-to-the-driver">Adding a new device to the driver</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#naming-convention">Naming Convention</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#launch-files">Launch Files</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#code-modification">Code Modification</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#bloom-release">Bloom release</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#first-time-installation-of-toolchain">First time installation of toolchain</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#release-build-for-ros-1">Release build for ROS 1</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#release-build-for-ros-2">Release build for ROS 2</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#check-status">Check status</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#useful-links-and-information">Useful links and information</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#testing">Testing</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#unit-tests">Unit tests</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#examples">Examples</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#simulation">Simulation</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#windows">Windows</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#linux">Linux</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#profiling">Profiling</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#installation">Installation</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#usage">Usage</a></li>
    </ul>
  </li>
</ul>

<h1 id="adding-a-new-device-to-the-driver">Adding a new device to the driver</h1>

<p>This driver is designed to support several different scanner types (including radar) from Sick. This documentation describes how to add additional devices to the driver.</p>

<h2 id="naming-convention">Naming Convention</h2>

<p>For each device type a name pattern is assigned as follows:
<code class="language-plaintext highlighter-rouge">
sick_&lt;device family&gt;_&lt;identifier&gt;
</code></p>

<p>The name type is used in the code to decide which scanner-specific parameters are set.
The name type is passed as a parameter as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="scanner_type" type="string" value="sick_lms_5xx" /&gt;

</code></pre></div></div>

<h2 id="launch-files">Launch Files</h2>

<p>A launch file is created for each device type,
which usually has the same naming convention as the scanner type.
To create a new device, it is recommended to copy, rename and edit an existing launch file.</p>

<h2 id="code-modification">Code Modification</h2>

<ol>
  <li>Hint: Construction of parser:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sick_scan_xd::SickGenericParser *parser = new sick_scan_xd::SickGenericParser(scannerName);
    
</code></pre></div></div>
<ol>
  <li>
    <p>Add string constant like the constant SICK_SCANNER_RMS_XXXX_NAME</p>
  </li>
  <li>
    <p>Append this constant to allowedScannerNames
like allowedScannerNames.push_back(SICK_SCANNER_RMS_XXXX_NAME);
in the file sick_generic_parser.cpp</p>
  </li>
  <li>
    <p>Add new parameter block like</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	if (basicParams[i].getScannerName().compare(SICK_SCANNER_MRS_1XXX_NAME) == 0)
	{...
	} in the file sick_generic_parser.cpp
	
</code></pre></div></div>

<ol>
  <li>Copy the file sick_generic_radar.cpp and add a new class following the structure
of this file.</li>
</ol>

<h1 id="bloom-release">Bloom release</h1>

<h2 id="first-time-installation-of-toolchain">First time installation of toolchain</h2>

<ol>
  <li>Install on Linux:
    <ul>
      <li>Install bloom:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        sudo apt-get update
        sudo apt-get install python3-bloom python3-catkin-pkg
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Install docker:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        pushd /tmp
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        sudo usermod -aG docker $USER
        popd
        shutdown -r now # reboot
        # short quicktest
        docker --version
        docker info
        docker run hello-world
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Install ros-buildfarm:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        # sudo apt-get install python3-ros-buildfarm # not successfully, unable to locate
        pip3 install ros-buildfarm # installs ros-buildfarm 3.0 successfully
        
</code></pre></div></div>

<ol>
  <li>Build the prerelease:
    <ul>
      <li>Short version to build a prerelase:
        <ul>
          <li>Run the following commands:</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            mkdir -p ./ws_sick_scan_xd_bloom/src
            cd ./ws_sick_scan_xd_bloom/src
            git clone -b master https://github.com/SICKAG/sick_scan_xd.git
            cd ./sick_scan_xd/test/scripts
            ./run_linux_ros1_bloom.bash
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * Fix any errors during the prerelease build and check in
    * Repeat `./run_linux_ros1_bloom.bash` until the the prerelease build finishes without errors
* Alternative version:
    * Open http://prerelease.ros.org/noetic in the brower
    * Add a custom repository: `sick_scan_xd` , `https://github.com/SICKAG/sick_scan_xd` , `master` (or `feature/bloom_pretest` or any other branch to test)
    * Add a custom repository: `msgpack11` , `https://github.com/SICKAG/msgpack11` , `master`
    * Add a custom repository: `libsick_ldmrs` , `https://github.com/SICKAG/libsick_ldmrs` , `master`
    * Confirm next steps (i.e. URL of build farm: https://raw.githubusercontent.com/ros-infrastructure/ros_buildfarm_config/production/index.yaml, Ubuntu focal)
    * Click on `Generate command`
    * Run the generated command, i.e.:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            source /opt/ros/noetic/setup.bash
            mkdir -p /tmp/prerelease_job
            cd /tmp/prerelease_job
            generate_prerelease_script.py \
              https://raw.githubusercontent.com/ros-infrastructure/ros_buildfarm_config/production/index.yaml \
              noetic default ubuntu focal amd64 \
              --custom-repo \
                sick_scan_xd:git:https://github.com/SICKAG/sick_scan_xd:master \
                msgpack11:git:https://github.com/SICKAG/msgpack11:master \
                libsick_ldmrs:git:https://github.com/SICKAG/libsick_ldmrs:master \
              --level 1 \
              --output-dir ./
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * Run `printf "\033c" ; rm -rf ~/.ccache ; mkdir -p ~/.ccache ; ./prerelease.sh` in folder `/tmp/prerelease_job`
    * In case of error message `/usr/lib/ccache/cc is not able to compile a simple test program`:
        * Remove folder `~/.ccache` before running `./prerelease.sh`
        * See https://answers.ros.org/question/347063/error-pre-release-melodic/
    * Fix any errors during the prerelease build and check in
    * Remove the temporary build folder by `rm -rf /tmp/prerelease_job`
    * Repeat until `prerelease.sh` finishes without errors.
</code></pre></div></div>

<ol>
  <li>Submit package sick_scan_xd for indexing (noetic)
    <ul>
      <li>Fork <code class="language-plaintext highlighter-rouge">https://github.com/ros/rosdistro</code> -&gt; <code class="language-plaintext highlighter-rouge">https://github.com/&lt;username&gt;/rosdistro.git</code>
</li>
      <li><code class="language-plaintext highlighter-rouge">git clone https://github.com/&lt;username&gt;/rosdistro.git</code></li>
      <li>Edit file <code class="language-plaintext highlighter-rouge">rosdistro/noetic/distribution.yaml</code> and add after <code class="language-plaintext highlighter-rouge">sick_scan</code>:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        sick_scan_xd:
          doc:
            type: git
            url: https://github.com/SICKAG/sick_scan_xd.git
            version: master
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* `cd rosdistro ; source /opt/ros/noetic/setup.bash ; rosdistro_reformat file://"$(pwd)"/index.yaml`
* git commit: `git commit -m "Adding sick_scan_xd to documentation index for distro noetic" distribution.yaml`
* git push: `git push origin master`
* Submit a pull request on `https://github.com/&lt;username&gt;/rosdistro`
</code></pre></div></div>

<ol>
  <li>For ROS 2 humble: Follow instructions on https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html</li>
</ol>

<p><strong><em>NOTE:</em></strong> Bloom releases for ROS 2 foxy are not longer supported (Pull request failed, “This pull request changes files for a ROS distribution that is no longer supported (End Of Life)”)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Submit package sick_scan_xd for indexing (ROS 2 humble)
    * Reset fork `https://github.com/&lt;username&gt;/rosdistro.git` to origin/master or delete the fork and create a new one -&gt; `https://github.com/&lt;username&gt;/rosdistro.git`
    * `git clone https://github.com/&lt;username&gt;/rosdistro.git`
    * Edit file `rosdistro/humble/distribution.yaml` and add after `sick_safevisionary_ros2`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            sick_scan_xd:
              doc:
                type: git
                url: https://github.com/SICKAG/sick_scan_xd.git
                version: develop
              status: developed
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * git commit and push ("Adding sick_scan_xd to documentation index for distro humble")
    * Submit a pull request on `https://github.com/&lt;username&gt;/rosdistro`
    * Do the same for any new ROS 2 version, e.g. iron and jazzy (`rosdistro/iron/distribution.yaml`, `rosdistro/jazzy/distribution.yaml`)
* [Start a new release team](https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&amp;labels=&amp;template=new_release_team.md&amp;title=Add+release+team)
    * ROS 2 sick_scan_xd team: https://github.com/orgs/ros2-gbp/teams/sick_scan_xd
    * ROS 2 sick_scan_xd release repository: https://github.com/ros2-gbp/sick_scan_xd-release
</code></pre></div></div>

<h2 id="release-build-for-ros-1">Release build for ROS 1</h2>

<ul>
  <li>Build a prerelease (dry run in a docker container):
    <ul>
      <li>Run the following commands:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        git clone -b master https://github.com/SICKAG/sick_scan_xd.git
        cd ./sick_scan_xd/test/scripts
        sudo dos2unix ./*.bash ; sudo chmod a+x ./*.bash
        ./run_linux_ros1_bloom.bash
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Fix any errors during the prerelease build and check in
* Repeat `./run_linux_ros1_bloom.bash` until the the prerelease build finishes without errors
</code></pre></div></div>

<ul>
  <li>Build a binary release: follow https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease
    <ul>
      <li>Update version number in package.xml, minor version number should be incremented at least</li>
      <li>Create resp. update CHANGELOG.rst:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        cd ./src/sick_scan_xd
        rm ./CHANGELOG.rst
        catkin_generate_changelog --all # create CHANGELOG.rst
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Commit and pull all changes incl. CHANGELOG.rst and package.xml:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        git add CHANGELOG.rst package.xml
        git commit -m "Update CHANGELOG.rst and package version"
        git push
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Run `catkin_prepare_release` and `bloom-release` in folder `src/sick_scan_xd`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        catkin_prepare_release -y
        bloom-release --rosdistro noetic --track noetic sick_scan_xd # at first time: call with option --edit for configuration
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* For the initial release (first time): Run `bloom-release` in folder `src/sick_scan_xd` with option `--edit`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        catkin_prepare_release -y
        bloom-release --rosdistro noetic --track noetic sick_scan_xd --edit
        Release repository url: https://github.com/SICKAG/sick_scan_xd-release.git
        upstream: &lt;default, i.e. press ENTER&gt;
        Upstream Repository URI: https://github.com/SICKAG/sick_scan_xd.git
        Upstream VCS Type: &lt;default: git, i.e. press ENTER&gt;
        Version: &lt;default: auto, i.e. press ENTER&gt;
        Release Tag: &lt;default: version, i.e. press ENTER&gt;
        Upstream Devel Branch: feature/bloom_pretest
        ROS Distro: noetic
        Patches Directory: &lt;default: none, i.e. press ENTER&gt;
        Release Repository Push URL:  &lt;default: none, i.e. press ENTER&gt;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Check status: https://index.ros.org/p/sick_scan_xd/#noetic
* Install binary release: `sudo apt update ; sudo apt-get install ros-noetic-sick-scan-xd`. Note from https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease : Packages built are periodically synchronized over to the shadow-fixed and public repositories, so it might take as long as a month before your package is available on the public ROS debian repositories (i.e. available via apt-get).
</code></pre></div></div>

<h2 id="release-build-for-ros-2">Release build for ROS 2</h2>

<p>For ROS 2 follow the instructions on https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html :</p>
<ul>
  <li>Checkout the sick_scan_xd version to be released and run:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    git clone -b master https://github.com/SICKAG/sick_scan_xd.git
    cd ./sick_scan_xd
    rm ./CHANGELOG.rst
    catkin_generate_changelog --all # create CHANGELOG.rst
    
</code></pre></div></div>
<ul>
  <li>Commit CHANGELOG.rst and optional modifications:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    git add CHANGELOG.rst
    git commit -m "Update CHANGELOG.rst"
    git push
    
</code></pre></div></div>
<ul>
  <li>Run <code class="language-plaintext highlighter-rouge">catkin_prepare_release</code> and <code class="language-plaintext highlighter-rouge">bloom-release</code>:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    bloom-release --rosdistro humble --track humble sick_scan_xd # at first time: call with option --new-track
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For the initial release (i.e. at the first time): Run bloom-relase configuration with option --new-track:
`bloom-release --new-track --rosdistro humble --track humble sick_scan_xd`
* Release repository url: https://github.com/ros2-gbp/sick_scan_xd-release.git
* Upstream: &lt;default&gt;
* Upstream Repository URI: https://github.com/SICKAG/sick_scan_xd.git
* Upstream Devel Branch: develop
* ROS Distro: humble
After the initial release has been approved: Run
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo rosdep init
    rosdep update
    
</code></pre></div></div>

<h2 id="check-status">Check status</h2>
<p>Jenkins build status:</p>
<ul>
  <li>ROS 1 noetic jenkins build status: https://build.ros.org/job/Ndev__sick_scan_xd__ubuntu_focal_amd64/lastBuild/</li>
  <li>ROS 2 humble jenkins build status: https://build.ros2.org/job/Hdev__sick_scan_xd__ubuntu_jammy_amd64/lastBuild/</li>
  <li>ROS 2 iron   jenkins build status: https://build.ros2.org/job/Idev__sick_scan_xd__ubuntu_jammy_amd64/lastBuild/</li>
  <li>ROS 2 jazzy  jenkins build status: https://build.ros2.org/job/Jdev__sick_scan_xd__ubuntu_noble_amd64/lastBuild/</li>
  <li>ROS 1 jenkins: https://build.ros.org/search/?q=sick_scan_xd</li>
  <li>ROS 2 jenkins: https://build.ros2.org/search/?q=sick_scan_xd</li>
</ul>

<p>Release repositories:</p>
<ul>
  <li>ROS 1 release repository: https://github.com/SICKAG/sick_scan_xd-release</li>
  <li>ROS 2 release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git</li>
</ul>

<p>Show version and list information about prebuilt binaries:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt show ros-noetic-sick-scan-xd
sudo apt show ros-humble-sick-scan-xd
sudo apt show ros-iron-sick-scan-xd
sudo apt show ros-jazzy-sick-scan-xd

</code></pre></div></div>

<p>Installation of prebuilt binaries:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-noetic-sick-scan-xd
sudo apt-get install ros-humble-sick-scan-xd
sudo apt-get install ros-iron-sick-scan-xd
sudo apt-get install ros-jazzy-sick-scan-xd
sudo apt-get remove ros-noetic-sick-scan-xd
sudo apt-get remove ros-humble-sick-scan-xd
sudo apt-get remove ros-iron-sick-scan-xd
sudo apt-get remove ros-jazzy-sick-scan-xd

</code></pre></div></div>

<h2 id="useful-links-and-information">Useful links and information</h2>

<ul>
  <li>http://wiki.ros.org/bloom</li>
  <li>https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease</li>
  <li>https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html</li>
</ul>

<p><strong>Bloom builds an old sick_scan_xd version (ROS 1)</strong></p>

<p>Check <code class="language-plaintext highlighter-rouge">devel_branch</code> in https://github.com/SICKAG/sick_scan_xd-release/blob/master/tracks.yaml . If devel_branch is an old branch, replace it with e.g. <code class="language-plaintext highlighter-rouge">develop</code> or <code class="language-plaintext highlighter-rouge">master</code>, or update the <code class="language-plaintext highlighter-rouge">&lt;devel_branch&gt;</code> to a new version.</p>

<p><strong>Bloom builds an old sick_scan_xd version (ROS 2)</strong>
Check <code class="language-plaintext highlighter-rouge">devel_branch</code> in https://github.com/ros2-gbp/sick_scan_xd-release/blob/master/tracks.yaml . If devel_branch is an old branch, replace it with e.g. <code class="language-plaintext highlighter-rouge">develop</code> or <code class="language-plaintext highlighter-rouge">master</code>, or update the <code class="language-plaintext highlighter-rouge">&lt;devel_branch&gt;</code> to a new version.</p>

<p><strong>Bloom builds a new sick_scan_xd version, but apt still installs an old version</strong></p>

<ul>
  <li>Check the sick_scan_xd version in the release repositories https://github.com/SICKAG/sick_scan_xd-release.git (ROS 1) and https://github.com/ros2-gbp/sick_scan_xd-release.git (ROS 2)</li>
  <li>Install bloom (if not yet done) using <code class="language-plaintext highlighter-rouge">sudo apt-get install python-bloom</code> on Linux or <code class="language-plaintext highlighter-rouge">pip install -U bloom</code> on Windows</li>
  <li>Run</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        bloom-release --rosdistro noetic -d sick_scan_xd # release repository: https://github.com/SICKAG/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro humble -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro iron   -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro jazzy  -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        
</code></pre></div></div>
<ul>
  <li>In case of github 2FA errors: Follow http://wiki.ros.org/bloom/Tutorials/GithubManualAuthorization to create a 2FA token and configure the token in file <code class="language-plaintext highlighter-rouge">~/.config/bloom</code>.</li>
  <li>Note: Updates of release repository https://github.com/SICKAG/sick_scan_xd-release.git require github authentification via ssh. See https://docs.github.com/en/authentication/connecting-to-github-with-ssh and https://wiki.ros.org/bloom/Tutorials/GithubManualAuthorization for details.</li>
</ul>

<h1 id="testing">Testing</h1>

<h2 id="unit-tests">Unit tests</h2>

<p>For a quick unit test after installation without the sensor hardware, a test server is provided to simulate a scanner. It implements a simple tcp server, which responds to binary cola messages and sends predefined LMDscandata to a tcp-client. The sick_scan_xd driver can connect to the local test server instead of the lidar device for offline-tests. Please note, that this test server does not emulate a Lidar sensor. It just sends some simple scan data and response messages to a tcp client. It can be used for a quick unit test after build and install.</p>

<p>To build the test server, activate cmake option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> in CMakeLists.txt and rebuild sick_scan_xd. By default, option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> is switched off.</p>

<p>For a unit test of LMS1xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_lms1xx.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms1xx.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_lms_1xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS5xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_lms5xx.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms5xx.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS7xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_tim_7xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS7xxS, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>Alternatively, you can just run the test scripts provided in folder <code class="language-plaintext highlighter-rouge">sick_scan_xd/test/scripts</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd/test/scripts
./makeall.bash
./run_simu_lms1xx.bash
./run_simu_lms5xx.bash
./run_simu_tim7xx_tim7xxS.bash

</code></pre></div></div>

<p>Make sure to finish all sick_scan_xd nodes after a test. All nodes can be killed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosnode kill -a ; sleep 1
killall sick_generic_caller ; sleep 1
killall sick_scan_emulator ; sleep 1

</code></pre></div></div>

<h2 id="examples">Examples</h2>

<p>rviz example screenshots using sick_scan_xd with LMS1xx and LMS5xx test server:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/emulator_lms1xx_screenshot.png" alt="emulator_lms1xx_screenshot.png"></p>

<p>rviz example screenshots using sick_scan_xd with LMS7xx and LMS7xxS test server:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/emulator_lms7xx_screenshot.png" alt="emulator_lms1xx_screenshot.png"></p>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h1 id="simulation">Simulation</h1>

<p>For unittests without sensor hardware, a simple test server is provided. To build the test server, call either cmake with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code>, or activate cmake option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> in CMakeLists.txt. Then rebuild sick_scan_xd. By default, option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> is switched off.</p>

<p>Please note that this just builds a simple test server for basic unittests of sick_scan_xd drivers. Its purpose is to run basic tests and to help with diagnosis in case of issues. It does not emulate a real scanner!</p>

<p>Simulation requires jsoncpp. Install with <code class="language-plaintext highlighter-rouge">sudo apt-get install libjsoncpp-dev</code> on Linux and with <code class="language-plaintext highlighter-rouge">vcpkg install jsoncpp:x64-windows</code> on Windows.</p>

<p>You can find examples to test and run sick_scan_xd in offline mode in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>. Their purpose is to demonstrate the usage of the sick_scan_xd driver. Please feel free to customize the scripts or use them as a starting point for own projects.</p>

<h2 id="windows">Windows</h2>

<p>Run script <code class="language-plaintext highlighter-rouge">run_simu_lms_5xx.cmd</code> in folder <code class="language-plaintext highlighter-rouge">test/scripts</code> or execute the following commands:</p>

<ol>
  <li>Start the test server:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    cd .\build
    start "testserver" cmd /k python ../test/emulator/test_server.py --scandata_file=../test/emulator/scandata/20210302_lms511.pcapng.scandata.txt --scandata_frequency=20.0 --tcp_port=2112
    @timeout /t 1
    
</code></pre></div></div>

<ol>
  <li>Run sick_generic_caller. On native Windows:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    .\Debug\sick_generic_caller.exe ../launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>On Windows with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False
    
</code></pre></div></div>

<ol>
  <li>Open file <code class="language-plaintext highlighter-rouge">image_viewer.html</code> in folder <code class="language-plaintext highlighter-rouge">demo</code> in your browser to view a jpg-image of the current scan.</li>
</ol>

<p>Note, that python version 3 incl. runtime dlls must be accessable, f.e. by extending the PATH environment variable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PYTHON_DIR=%ProgramFiles(x86)%/Microsoft Visual Studio/Shared/Python37_64
set PATH=%PYTHON_DIR%;%PYTHON_DIR%/Scripts;c:\vcpkg\installed\x64-windows\bin;%PATH%

</code></pre></div></div>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h2 id="linux">Linux</h2>

<p>Run script <code class="language-plaintext highlighter-rouge">run_simu_lms_5xx.bash</code> in folder <code class="language-plaintext highlighter-rouge">test/scripts</code> or execute the following commands:</p>

<ol>
  <li>Start the test server:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    python3 ./test/emulator/test_server.py --scandata_file=./test/emulator/scandata/20210302_lms511.pcapng.scandata.txt --scandata_frequency=20.0 --tcp_port=2112 &amp;
    sleep 1
    
</code></pre></div></div>

<ol>
  <li>Run sick_generic_caller.
    <ul>
      <li>On native Linux:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        ./build/sick_generic_caller ./launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 1:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>

<ol>
  <li>View the point cloud.
    <ul>
      <li>On native Linux:<br>
   Open file <code class="language-plaintext highlighter-rouge">image_viewer.html</code> in folder <code class="language-plaintext highlighter-rouge">demo</code> in a browser (f.e. firefox) to view a jpg-image of the current scan.</li>
      <li>On Linux with ROS 1:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg_lms5xx.rviz &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_lms5xx.rviz &amp;
        
</code></pre></div></div>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h1 id="profiling">Profiling</h1>

<p>Since the existing node can basically be used on different platforms, bottlenecks can occur with weak hardware. To better analyze these bottlenecks, software profiling can be performed.
The following example shows how to perform profiling.
For further details on profiling, please refer to https://baptiste-wicht.com/posts/2011/09/profile-c-application-with-callgrind-kcachegrind.html, for example.</p>

<h2 id="installation">Installation</h2>

<p>First of all, you need to install Callgrind and KCachegrind.
You also need to install graphviz in order to view the call graph in KCachegrind. The applications are already packaged for the most important Linux distributions. You can just use apt-get to install them:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install valgrind kcachegrind graphviz

</code></pre></div></div>
<h2 id="usage">Usage</h2>
<p>We have to start by profiling the application with Callgrind. To profile an application with Callgrind, you just have to prepend the Callgrind invocation in front of your normal program invocation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind --tool=callgrind program [program_options]

</code></pre></div></div>
<p>In order to establish a reference to the source code during profiling, the program must be compiled with debug symbols, this can be done with catkin_make</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catkin_make install -DCMAKE_BUILD_TYPE=Debug

</code></pre></div></div>
<p>It is necessary to create a rosmaster so that the sick_scan_xd node can connect to it because we can’t use roslaunch during profiling.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roscore

</code></pre></div></div>
<p>To set the parameters we start a node as usual with roslaunch.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=192.168.0.151

</code></pre></div></div>
<p>While this node is running we can use
<code class="language-plaintext highlighter-rouge">ps -aef| grep sick_scan_xd
</code> to determine the program path and the call parameters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosuser@ROS-NB:~$ ps -aef|grep sick_scan_xd
rosuser   4839  2443  0 14:43 pts/1    00:00:00 /usr/bin/python /opt/ros/melodic/bin/roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=192.168.0.151
rosuser   4854  4839  1 14:43 ?        00:00:03 /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller __name:=sick_lms_5xx __log:=/home/rosuser/.ros/log/f9861670-304c-11e9-9839-54e1ad2921b6/sick_lms_5xx-1.log
rosuser   4910  4875  0 14:46 pts/6    00:00:00 grep --color=auto sick_scan_xd

</code></pre></div></div>
<p>now we can close the node and restart with callgrid</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind --tool=callgrind program /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller __name:=sick_lms_5xx

</code></pre></div></div>
<p>The result will be stored in a callgrind.out.XXX file where XXX will be the process identifier.
You can read this file using a text editor, but it won’t be very useful because it’s very cryptic.
That’s here that KCacheGrind will be useful. You can launch KCacheGrind using command line
or in the program menu if your system installed it here. Then, you have to open your profile file.</p>

<p>The first view present a list of all the profiled functions. You can see the inclusive
and the self cost of each function and the location of each one.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/src_view.png" alt="src_view.png"></p>

<p>Once you click on a function, the other views are filled with information. The view in uppper right part of the window gives some information about the selected function.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/profile_002.png" alt="profile_002"></p>

<p>The view have several tabs presenting different information:</p>

<ul>
  <li>Types : Present the types of events that have been recorded. In our case, it’s not really interesting, it’s just the number of instructions fetch</li>
  <li>Callers : List of the direct callers.</li>
  <li>All Callers : List of all the callers, it seems the callers and the callers of the callers.</li>
  <li>Callee Map : A map of the callee, personally, I do not really understand this view, but it’s a kind of call graph representing the cost of the functions.</li>
  <li>Source code : The source code of the function if the application has been compiled with the debug symbol.</li>
</ul>

<p>And finally, you have another view with data about the selected function.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/profile_003.png" alt="profile_003"></p>

<p>Again, several tabs:</p>

<ul>
  <li>Callees : The direct callees of the function</li>
  <li>Call Graph : The call graph from the function to the end</li>
  <li>All Callees : All the callees and the callees of the callees</li>
  <li>Caller Map : All functions are represented as blocks the size corresponds to their CPU time. Callees are stacked on the callers.</li>
  <li>Machine Code : The machine code of the function if the application has been profiled with –dump-instr=yes option</li>
</ul>

<p>You have also several display options and filter features to find exactly what you want and display it the way you want.</p>

<p>The information provided by KCacheGrind can be very useful to find which functions takes too much time or which functions are called too much.
This text is an adopted version of https://baptiste-wicht.com/posts/2011/09/profile-c-application-with-callgrind-kcachegrind.html . Thanks to Baptiste Wicht.</p>
</div>
              <hr id="jazzy-contribute-lists">
              <ul class="nav nav-tabs nav-justified" id="jazzy-contribute-lists-tabs">
                <li class="better-tabs active">
                  <a href="#jazzy-contribute-lists-help-wanted" data-toggle="tab"><span class="contribute-lists-help-wanted-count label label-primary">0</span> Help Wanted</a>
                </li>
                <li class="better-tabs">
                  <a href="#jazzy-contribute-lists-good-first-issue" data-toggle="tab"><span class="contribute-lists-good-first-issue-count label label-primary">0</span> Good First Issue</a>
                </li>
                <li class="better-tabs">
                  <a href="#jazzy-contribute-lists-pull-requests" data-toggle="tab"><span class="contribute-lists-pull-requests-count label label-primary">0</span> Pull Requests to Review</a>
                </li>
              </ul>
              <div class="tab-content contribute-lists">
                <div class="tab-pane active" id="jazzy-contribute-lists-help-wanted">
                  <div class="contribute-lists-help-wanted"></div>
                </div>
                <div class="tab-pane" id="jazzy-contribute-lists-good-first-issue">
                  <div class="contribute-lists-good-first-issue"></div>
                </div>
                <div class="tab-pane" id="jazzy-contribute-lists-pull-requests">
                  <div class="contribute-lists-pull-requests"></div>
                </div>
              </div>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-kilted">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/sick_scan_xd">sick_scan_xd</a> <small>repository</small></h3>
        <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-SICKAG-sick_scan_xd
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-SICKAG-sick_scan_xd" role="menuitem" tabindex="-1" href="/r/sick_scan_xd/github-SICKAG-sick_scan_xd" data="github-SICKAG-sick_scan_xd">
                    <span class="glyphicon glyphicon-star"></span>
                    github-SICKAG-sick_scan_xd
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>kilted</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>

  <div class="distro distro-rolling">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/sick_scan_xd">sick_scan_xd</a> <small>repository</small></h3>
        <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-SICKAG-sick_scan_xd
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-SICKAG-sick_scan_xd" role="menuitem" tabindex="-1" href="/r/sick_scan_xd/github-SICKAG-sick_scan_xd" data="github-SICKAG-sick_scan_xd">
                    <span class="glyphicon glyphicon-star"></span>
                    github-SICKAG-sick_scan_xd
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>rolling</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>

  <div class="distro distro-github">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/sick_scan_xd">sick_scan_xd</a> <small>repository</small></h3>
        <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-SICKAG-sick_scan_xd
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-SICKAG-sick_scan_xd" role="menuitem" tabindex="-1" href="/r/sick_scan_xd/github-SICKAG-sick_scan_xd" data="github-SICKAG-sick_scan_xd">
                    <span class="glyphicon glyphicon-star"></span>
                    github-SICKAG-sick_scan_xd
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>github</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>

  <div class="distro distro-noetic">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/sick_scan_xd">sick_scan_xd</a> <small>repository</small></h3>
        <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        
        <a class="label label-primary pkg-label" href="/p/sick_scan_xd">sick_scan_xd</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-SICKAG-sick_scan_xd
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-SICKAG-sick_scan_xd" role="menuitem" tabindex="-1" href="/r/sick_scan_xd/github-SICKAG-sick_scan_xd" data="github-SICKAG-sick_scan_xd">
                    <span class="glyphicon glyphicon-star"></span>
                    github-SICKAG-sick_scan_xd
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">A versatile driver for a wide range of SICK LiDAR and RADAR devices, providing support for both Linux (native, ROS 1, ROS 2) and Windows (native, ROS 2) platforms.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/SICKAG/sick_scan_xd.git">https://github.com/SICKAG/sick_scan_xd.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">master</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2024-10-23
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/sick_scan_xd/#noetic-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/sick_scan_xd/#noetic-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/sick_scan_xd/#noetic-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/sick_scan_xd">sick_scan_xd</a></td>
                    <td>3.6.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<p><img align="right" width="200" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Logo_SICK_AG_2009.svg/1200px-Logo_SICK_AG_2009.svg.png"></p>

<h2 id="executive-summary">Executive Summary</h2>

<p>This project provides a driver for the SICK LiDARs and Radar sensors mentioned <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#supported-sick-devices">here</a>. The driver supports both Linux (native, ROS 1, ROS 2) and Windows (native and ROS 2). See the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/CHANGELOG.md">CHANGELOG.md</a> for the latest updates.</p>

<p><strong>Main features and characteristics</strong></p>
<ul>
  <li>Support of ROS 1 (Linux), ROS 2 (Linux and Windows)</li>
  <li>Generic C/C++ and python API for usage without ROS (Linux and Windows)</li>
  <li>SLAM support</li>
  <li>Compatible with x64 and ARM64 architecture (incl. Raspberry Pi)</li>
  <li>No dependencies to 3rd party libraries like boost</li>
</ul>

<h2 id="table-of-contents">Table of Contents</h2>

<details>
  <summary>Expand to full table of contents </summary>

- [Repository organization](#repository-organization)
- [Supported SICK Devices](#supported-sick-devices)
- [Getting started](#getting-started)
  - [Detecting SICK devices in the network](#detecting-sick-devices-in-the-network)
  - [Change IP address](#change-ip-address)
  - [Starting with a new lidar](#starting-with-a-new-lidar)
  - [Test connection (Linux)](#test-connection-linux)
- [Building the driver](#building-the-driver)
  - [Build on Linux ROS 1](#build-on-linux-ros-1)
    - [Install prebuilt binaries](#install-prebuilt-binaries)
    - [Build from sources](#build-from-sources)
  - [Build on Linux ROS 2](#build-on-linux-ros-2)
    - [Install prebuilt binaries](#install-prebuilt-binaries-1)
    - [Build from sources](#build-from-sources-1)
  - [Build on Windows ROS 2](#build-on-windows-ros-2)
  - [Build on Linux generic without ROS](#build-on-linux-generic-without-ros)
  - [Build on Windows generic without ROS](#build-on-windows-generic-without-ros)
- [Running the driver](#running-the-driver)
  - [Starting Scanner with Specific IP Address](#starting-scanner-with-specific-ip-address)
  - [Start Multiple Nodes](#start-multiple-nodes)
  - [Common parameters](#common-parameters)
  - [Further useful parameters and features](#further-useful-parameters-and-features)
  - [ROS services](#ros-services)
  - [Driver states, timeouts](#driver-states-timeouts)
  - [SOPAS Mode](#sopas-mode)
  - [Example Startup Sequence](#example-startup-sequence)
- [Driver features and additional information](#driver-features-and-additional-information)
  - [Software Overview](#software-overview)
    - [Software structure](#software-structure)
    - [Message receiving and message handling](#message-receiving-and-message-handling)
    - [sick\_scansegment\_xd](#sick_scansegment_xd)
    - [Files and folders](#files-and-folders)
  - [Generic Driver API](#generic-driver-api)
    - [Overview](#overview)
    - [Build and test shared library](#build-and-test-shared-library)
    - [Usage example](#usage-example)
    - [C-API](#c-api)
    - [Useful links](#useful-links)
  - [Timestamps and synchronization (Software PLL)](#timestamps-and-synchronization-software-pll)
  - [Coordinate transforms](#coordinate-transforms)
  - [IMU Support](#imu-support)
  - [Encoders](#encoders)
    - [Connecting encoders](#connecting-encoders)
    - [Example circuit to trigger encoder counts](#example-circuit-to-trigger-encoder-counts)
    - [Activation of encoder information](#activation-of-encoder-information)
  - [Field Evaluation Information](#field-evaluation-information)
    - [Field monitoring messages](#field-monitoring-messages)
    - [Visualization with rviz](#visualization-with-rviz)
    - [Cola commands](#cola-commands)
    - [Tools, emulation and unittests](#tools-emulation-and-unittests)
  - [SLAM Support](#slam-support)
    - [Introduction](#introduction)
    - [Measuring Principle](#measuring-principle)
    - [NAV350 ROS 1 SLAM example](#nav350-ros-1-slam-example)
    - [NAV350 ROS 2 SLAM example](#nav350-ros-2-slam-example)
    - [picoScan100 ROS 1 SLAM example](#picoscan100-ros-1-slam-example)
    - [MRS1104 SLAM support](#mrs1104-slam-support)
    - [Google Cartographer](#google-cartographer)
    - [OctoMap](#octomap)
    - [RTAB-Map](#rtab-map)
  - [Raspberry Pi Support](#raspberry-pi-support)
    - [multiScan100 example](#multiscan100-example)
    - [Performance](#performance)
    - [Troubleshooting](#troubleshooting)
  - [More Tools](#more-tools)
- [Device specific information](#device-specific-information)
  - [picoScan100/multiScan100](#picoscan100multiscan100)
    - [Configuration](#configuration)
    - [IMU support](#imu-support-1)
    - [SOPAS support](#sopas-support)
    - [Run multiScan100 and picoScan100 simultaneously](#run-multiscan100-and-picoscan100-simultaneously)
    - [Visualization](#visualization)
    - [PointCloud memory layout](#pointcloud-memory-layout)
    - [Customized point clouds](#customized-point-clouds)
    - [Customized point clouds on a Raspberry Pi](#customized-point-clouds-on-a-raspberry-pi)
    - [MSGPACK validation](#msgpack-validation)
    - [Firewall configuration](#firewall-configuration)
    - [SOPAS support for sick\_scan\_segment\_xd](#sopas-support-for-sick_scan_segment_xd)
  - [TiM781 and TiM781S](#tim781-and-tim781s)
  - [TiM240](#tim240)
  - [NAV350](#nav350)
    - [Process loop](#process-loop)
    - [Initialization and setup](#initialization-and-setup)
    - [Messages](#messages)
    - [Odometry messages](#odometry-messages)
    - [Angle compensation](#angle-compensation)
  - [MRS6124](#mrs6124)
    - [Timing between Layers](#timing-between-layers)
    - [MRS600 with RMS1000](#mrs600-with-rms1000)
  - [RMS1000](#rms1000)
    - [Raw Targets](#raw-targets)
    - [Tracking Objects](#tracking-objects)
    - [ROS message for Radar](#ros-message-for-radar)
    - [Launch Files](#launch-files)
    - [Parameter for Radar Usage](#parameter-for-radar-usage)
    - [Radar Datagram](#radar-datagram)
  - [RMS1000 and LMS1000 combination](#rms1000-and-lms1000-combination)
  - [LMS1000 and MRS1000 interlacing](#lms1000-and-mrs1000-interlacing)
- [FAQ](#faq)
  - [General](#general)
  - [Networking](#networking)
  - [multiScan100 / picoScan100](#multiscan100--picoscan100)
- [Troubleshooting and technical support](#troubleshooting-and-technical-support)
- [Creators and contribution](#creators-and-contribution)
- [Keywords](#keywords)


</details>

<h1 id="repository-organization">Repository organization</h1>

<p>The repository supports two main branches. The <strong>“master”</strong> branch is the branch that contains official releases that are tagged and versioned and also included in the ROS distribution. If you want to work with this official branch, you must explicitly specify this branch in the ‘git clone’ command by adding “-b master”. The “develop” branch is the default branch and contains the latest development status.</p>

<p>Example:</p>

<p>Checking out the latest revision (usually older than the develop version, but officially released):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone -b master https://github.com/SICKAG/sick_scan_xd.git

</code></pre></div></div>

<p>Checking out the latest development status:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/SICKAG/sick_scan_xd.git

</code></pre></div></div>

<h1 id="supported-sick-devices">Supported SICK Devices</h1>

<p>The driver supports Ethernet-IPv4-based communication with all of the following SICK products.</p>

<table>
  <thead>
    <tr>
      <th>2D LiDAR sensors</th>
      <th>Part no.</th>
      <th>3D LiDAR sensors</th>
      <th>Part no.</th>
      <th>RADAR sensors</th>
      <th>Part no.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>picoScan100 <a href="https://support.sick.com/sick-knowledgebase/article/?code=KA-09438">(supports native ROS 2 as well)</a>
</td>
      <td><a href="https://www.sick.com/de/en/search?text=1134610">e.g. 1134610</a></td>
      <td>multiScan100</td>
      <td><a href="https://www.sick.com/de/en/search?text=1131164">e.g. 1131164</a></td>
      <td>RMS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1107598">e.g. 1107598</a></td>
    </tr>
    <tr>
      <td>LRS4000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1098855">e.g. 1098855</a></td>
      <td>MRS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1081208">e.g. 1081208</a></td>
      <td>RMS2000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1129088">e.g. 1129088</a></td>
    </tr>
    <tr>
      <td>TiM2xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1104981">1104981</a></td>
      <td>MRS6124</td>
      <td><a href="https://www.sick.com/de/en/search?text=6065086">6065086</a></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM5xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060445">e.g. 1060445</a></td>
      <td>LD-MRS</td>
      <td><a href="https://www.sick.com/de/de/p/p662073">e.g. 1115128</a></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM7xxS</td>
      <td><a href="https://www.sick.com/de/en/search?text=1105052">e.g. 1105052</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM7xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1096807">e.g 1096807</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS5xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1046135">e.g. 1046135</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1092445">1092445</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS1xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1041114">e.g. 1041114</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS4000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1091423">e.g. 1091423</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LD-LRS</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060831">e.g. 1060831</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LD-OEM</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060828">e.g. 1060828</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV3xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060834">e.g. 1060834</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV2xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1074308">e.g. 1074308</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS family is currently not supported on Windows.</li>
    <li>ROS services require installation of ROS 1 or ROS 2.</li>
    <li>ROS services are currently not available for LD-MRS.</li>
    <li>Publishing point cloud data requires ROS 1 or ROS 2. On native Linux and native Windows, point cloud data are exported via API</li>
    <li>The driver is not tested on MAC</li>
  </ul>
</blockquote>

<h1 id="getting-started">Getting started</h1>

<p>Run the following steps for a quick start:</p>

<ol>
  <li>
    <p>Create a workspace (e.g. folder <code class="language-plaintext highlighter-rouge">sick_scan_ws</code>), clone the sick_scan_xd repository and build sick_generic_caller and shared library:</p>

    <ul>
      <li>For <strong>Linux without ROS</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-generic-without-ros">build instructions for Linux generic without ROS</a>
</li>
      <li>For <strong>Linux with ROS 1</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-ros-1">build instructions for Linux ROS 1</a>
</li>
      <li>For <strong>Linux with ROS 2</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-ros-2">build instructions for Linux ROS 2</a>
</li>
      <li>For <strong>Windows without ROS</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-windows-generic-without-ros">build instructions for Windows without ROS</a>
</li>
      <li>For <strong>Windows with ROS 2</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-windows-ros-2">build instructions for Windows with ROS 2</a>
</li>
    </ul>
  </li>
  <li>
    <p>Connect your lidar. Check the network connection by <code class="language-plaintext highlighter-rouge">ping &lt;lidar-ip-address&gt;</code>.</p>
  </li>
  <li>
    <p>Run the sick_scan_xd driver:</p>

    <p>For <strong>Linux without ROS</strong>: Use the sick_scan_xd API and run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to the build folder
      ./build/sick_scan_xd_api_test ./sick_scan_xd/launch/sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Linux with ROS 1</strong>: Launch sick_scan_xd: <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      source ./devel_isolated/setup.bash
      roslaunch sick_scan_xd sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Linux with ROS 2</strong>: Run <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      source ./install/setup.bash
      ros2 launch sick_scan_xd sick_tim_7xx.launch.py hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Windows without ROS</strong>: Use the sick_scan_xd API and run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd .\sick_scan_ws\sick_scan_xd
      set PATH=.;.\build;..\build\Debug;%PATH%
      .\build\Debug\sick_scan_xd_api_test.exe launch/sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Windows with ROS 2</strong>: Run <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd .\sick_scan_ws
      call .\install\setup.bat
      ros2 launch sick_scan_xd sick_tim_7xx.launch.py hostname:=192.168.0.1
      
</code></pre></div></div>

<h2 id="detecting-sick-devices-in-the-network">Detecting SICK devices in the network</h2>

<p>The Python script</p>

<pre><code class="language-sick_scan_xd/tools/sick_generic_device_finder/sick_generic_device_finder.py">
</code></pre>
<p>sends a UDP broadcast to which all available scanners respond with a device description.
The variable
<code class="language-plaintext highlighter-rouge">UDP_IP = "192.168.0.255"
</code> defines the broadcast address used by the script.
If you are using a different IP address configuration on your host pc you have to change this variable according to the broadcast address of your network card.</p>

<pre><code class="language-ifconfig">``` shows the broadcast address for every network adapter.

## Change IP address

The IP address of the device can be changed with a customized launch file. The following launch sequence is an example:

```roslaunch sick_scan_xd sick_new_ip.launch hostname:=192.168.0.1 new_IP:=192.168.0.100
</code></pre>

<p>The launch file restarts the lidar after the address change and stops the sick_scan_xd node. After a few seconds of booting time the scanner is reachable under the new IP address. The Python script is experimental. It is known that some ethernet adapter are not fully supported. As a fallback solution you can always use the SOPAS ET software under windows.</p>

<h2 id="starting-with-a-new-lidar">Starting with a new lidar</h2>

<p>The lidar is delivered with a standard IP address, to read or change it the <a href="https://www.sick.com/de/de/sopas-engineering-tool-2018/p/p367244">SICK SOPAS ET</a> for windows can be used.
When the tool is started, a search is performed which lists all scanners available in the network.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/scanner_found.PNG" alt="SOPAS start" title="SOPAS start"></p>

<p>Double-click to select the scanner for the project</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/scanner_added.PNG" alt="SOPAS select" title="SOPAS select"></p>

<p>Double click on the lidar icon to open the configuration menu of the scanner. Select here the network configuration menu and set the parameters by clicking on the save icon (red arrow)</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/set_config.PNG" alt="SOPAS save network" title="SOPAS save network"></p>

<p>To ensure that the settings are stored even after a power cycle, they must be stored in the eeprom. To do this, click on the eeprom icon and confirm the save.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/save_permanent.PNG" alt="SOPAS save eeprom" title="SOPAS save eeprom"></p>

<p>To test the settings under Windows use the commands</p>
<pre><code class="language-ipconfig">``` and 
```ping
``` in the 
```cmd.exe
```. Make sure that the lidar and host pc have different IP addresses e.g. 192.168.0.1 for the pc and 192.168.0.2 for the scanner.

## Test connection (Linux)

to test the settings under the Linux target system you can use netcat to check if a TCP connection to the scanner can be established

```nc -z -v -w5 $SCANNERIPADDRESS 2112
</code></pre>
<p>the connection can be successfully established</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/nc_scanner.PNG" alt="Linux netcat scanner" title="linux netcat scanner"></p>

<p>unlike a ping, the connection attempt to the host PC is not successful</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/ipconfig/nc_win_host.PNG" alt="Linux netcat host" title="linux netcat host"></p>

<h1 id="building-the-driver">Building the driver</h1>

<p>sick_scan_xd can be build on 64-bit Linux and Windows, with and without ROS, with and without LDMRS. The following table shows the allowed combinations and how to build. sick_scan_xd supports 64 bit Linux and Windows, 32 bit systems are not supported.</p>

<table>
  <thead>
    <tr>
      <th><strong>target</strong></th>
      <th><strong>cmake settings</strong></th>
      <th><strong>build script</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linux, native, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_linux.bash</td>
    </tr>
    <tr>
      <td>Linux, native, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_linux_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 1, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros1.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 1, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros1_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 2, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros2.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 2, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros2_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Windows, native, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test\scripts &amp;&amp; make_win64.cmd</td>
    </tr>
    <tr>
      <td>Windows, ROS 2, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test\scripts &amp;&amp; make_ros2.cmd</td>
    </tr>
  </tbody>
</table>

<p>If you’re using ROS, set your ROS-environment before running one of these scripts, f.e.
<code class="language-plaintext highlighter-rouge">source /opt/ros/noetic/setup.bash</code> for ROS 1 noetic, or
<code class="language-plaintext highlighter-rouge">source /opt/ros/foxy/setup.bash</code> for ROS 2 foxy, or
<code class="language-plaintext highlighter-rouge">source /opt/ros/humble/setup.bash</code> for ROS 2 humble.
See the build descriptions for more details.</p>

<h2 id="build-on-linux-ros-1">Build on Linux ROS 1</h2>

<p>To build resp. install sick_scan_xd on Linux with ROS 1, you can build sick_scan_xd from sources or install prebuilt binaries.</p>

<h3 id="install-prebuilt-binaries">Install prebuilt binaries</h3>

<p>Run the following steps to install sick_scan_xd on Linux with ROS 1 noetic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-noetic-sick-scan-xd

</code></pre></div></div>

<p>After successful installation, you can run sick_scan_xd using <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd &lt;launchfile&gt;</code>, e.g. <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_picoscan.launch</code> for picoScan. sick_scan_xd can be removed by <code class="language-plaintext highlighter-rouge">sudo apt-get remove ros-noetic-sick-scan-xd</code>.</p>

<h3 id="build-from-sources">Build from sources</h3>

<p>Run the following steps to build sick_scan_xd on Linux with ROS 1:</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir ./src
   pushd ./src
   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   rm -rf ./build ./build_isolated/ ./devel ./devel_isolated/ ./install ./install_isolated/ ./log/ # remove any files from a previous build
   
</code></pre></div></div>
<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   source /opt/ros/noetic/setup.bash # replace noetic by your ros distro
   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
   source ./devel_isolated/setup.bash
   # source ./install_isolated/setup.bash
   
</code></pre></div></div>
<p>For ROS versions other than noetic, please replace <code class="language-plaintext highlighter-rouge">source /opt/ros/noetic/setup.bash</code> with your ros distribution.</p>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DRASPBERRY=1 -Wno-dev
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call catkin_make_isolated with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -Wno-dev
   
</code></pre></div></div>

<p>To build sick_generic_caller without multiScan136/sick_scansegment_xd/picoScan150 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DSCANSEGMENT_XD=0 -Wno-dev
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build <strong>without LDMRS</strong> and <strong>without multiScan100/picoScan100 support</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DSCANSEGMENT_XD=0 -Wno-dev
   
</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<p><strong>Build options</strong></p>

<p><strong>Without LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DSCANSEGMENT_XD=0 -Wno-dev

</code></pre></div></div>
<p><strong>Without LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -Wno-dev

</code></pre></div></div>
<p><strong>with LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DSCANSEGMENT_XD=0 -Wno-dev

</code></pre></div></div>
<p><strong>with LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev

</code></pre></div></div>

<p>To create source code documentation by doxygen, run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-linux-ros-2">Build on Linux ROS 2</h2>

<p>To build resp. install sick_scan_xd on Linux with ROS 2, you can build sick_scan_xd from sources or install prebuilt binaries.</p>

<h3 id="install-prebuilt-binaries-1">Install prebuilt binaries</h3>

<p>Run the following steps to install sick_scan_xd on Linux with ROS 2 humble:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-humble-sick-scan-xd

</code></pre></div></div>

<p>After successful installation, you can run sick_scan_xd using <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt;.py</code>, e.g. <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py</code> for multiScan. sick_scan_xd can be removed by <code class="language-plaintext highlighter-rouge">sudo apt-get remove ros-humble-sick-scan-xd</code>.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> ROS 2 humble Debian packages require Ubuntu 22 or newer, see https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html for system requirements.</p>
</blockquote>

<h3 id="build-from-sources-1">Build from sources</h3>

<p>Run the following steps to build sick_scan_xd on Linux with ROS 2:</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir ./src
   pushd ./src
   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   rm -rf ./build ./build_isolated/ ./devel ./devel_isolated/ ./install ./install_isolated/ ./log/ # remove any files from a previous build
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   source /opt/ros/foxy/setup.bash # replace foxy by your ros distro
   colcon build --packages-select libsick_ldmrs --event-handlers console_direct+
   source ./install/setup.bash
   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" --event-handlers console_direct+
   source ./install/setup.bash
   
</code></pre></div></div>
<p>For ROS versions other than foxy, please replace <code class="language-plaintext highlighter-rouge">source /opt/ros/foxy/setup.bash</code> with your ros distribution.</p>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DRASPBERRY=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call colcon with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" --event-handlers console_direct+
   
</code></pre></div></div>
<p>To build sick_generic_caller without multiScan136/sick_scansegment_xd/picoScan150 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build <strong>without LDMRS</strong> and <strong>without multiScan100/picoScan100 support</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>Depending on the ROS 2 distribution, package diagnostic_updater might not be found (compiler error: <code class="language-plaintext highlighter-rouge">diagnostic_updater.hpp not found</code>). In this case package diagnostic_updater has to be installed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install ros-${ROS_DISTRO}-diagnostic-updater
sudo apt install ros-${ROS_DISTRO}-diagnostic-msgs
# E.g. to install diagnostic_updater on foxy, run
# sudo apt-get install ros-foxy-diagnostic-updater
# sudo apt install ros-foxy-diagnostic-msgs

</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<p><strong>Build options</strong></p>

<p><strong>Without LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>Without LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>with LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>with LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " --event-handlers console_direct+

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong> To create source code documentation by doxygen, run</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-windows-ros-2">Build on Windows ROS 2</h2>

<p>To install sick_scan_xd on Windows with ROS 2, follow the steps below:</p>

<ol>
  <li>
    <p>If not yet done, install Visual Studio. Visual Studio 2019 Community or Professional Edition is recommended.</p>
  </li>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir sick_scan_ws
   cd sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repository https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir .\src
   pushd .\src
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   
</code></pre></div></div>

<ol>
  <li>Set the ROS 2 and Visual-Studio environment:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   call "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\Common7\Tools\VsDevCmd.bat" -arch=amd64 -host_arch=amd64
   call C:\opt\ros\foxy\x64\setup.bat
   
</code></pre></div></div>
<p>This step depends on your local ROS 2 and Visual-Studio installation. Please replace <code class="language-plaintext highlighter-rouge">C:\opt\ros\foxy\x64\setup.bat</code> with your ROS 2 version and adapt the path to the Visual Studio folder if your installation is different.</p>

<ol>
  <li>Cleanup to insure a complete rebuild:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   rmdir /s/q .\build
   rmdir /s/q .\install
   rmdir /s/q .\log
   del /f/q .\src\CMakeLists.txt
   
</code></pre></div></div>
<p>This step is only required for a complete rebuild. A complete rebuild is recommended e.g. after an update of the sick_scan_xd sources.</p>

<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" --event-handlers console_direct+
   call .\install\setup.bat
   
</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS sensors are currently not supported on Windows.</li>
    <li>To build sick_generic_caller without multiScan136/sick_scansegment_xd support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<h2 id="build-on-linux-generic-without-ros">Build on Linux generic without ROS</h2>

<p>Run the following steps to build sick_scan_xd on Linux (no ROS required):</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   
</code></pre></div></div>

<ol>
  <li>Build libsick_ldmrs (required only once for LD-MRS sensors):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   pushd libsick_ldmrs
   mkdir -p ./build
   cd ./build
   cmake -G "Unix Makefiles" ..
   make -j4
   sudo make -j4 install
   popd
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller and libsick_scan_xd_shared_lib.so:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./build
   pushd ./build
   rm -rf ./*
   export ROS_VERSION=0
   cmake -DROS_VERSION=0 -G "Unix Makefiles" ../sick_scan_xd
   make -j4
   sudo make -j4 install
   popd
   
</code></pre></div></div>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -DRASPBERRY=1 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>To build sick_generic_caller without multiScan100/picoScan100 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DSCANSEGMENT_XD=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build without LD-MRS and scansegment_xd support:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -DSCANSEGMENT_XD=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> To create source code documentation by doxygen, run</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-windows-generic-without-ros">Build on Windows generic without ROS</h2>

<p>To install sick_scan_xd on Windows, follow the steps below:</p>

<ol>
  <li>
    <p>If not yet done, install Visual Studio. Visual Studio 2019 Community or Professional Edition is recommended.</p>
  </li>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir sick_scan_ws
   cd sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repository https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller and sick_scan_xd_shared_lib.dll with cmake and Visual Studio 2019:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cd sick_scan_xd
   set _os=x64
   set _cmake_string=Visual Studio 16 2019
   set _msvc=Visual Studio 2019
   set _cmake_build_dir=build
   if not exist %_cmake_build_dir% mkdir %_cmake_build_dir%
   pushd %_cmake_build_dir%
   cmake -DROS_VERSION=0 -G "%_cmake_string%" ..
   cmake --build . --clean-first --config Debug
   cmake --build . --clean-first --config Release
   REM open sick_scan_xd.sln in Visual Studio 2019 for development and debugging
   popd
   
</code></pre></div></div>
<p>For development or debugging, open file <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\sick_scan_xd.sln</code> in Visual Studio. To install the library and header in the system folder, run <code class="language-plaintext highlighter-rouge">cmake --build . --target install</code> with admin privileges.</p>

<p>After successful build, binary files <code class="language-plaintext highlighter-rouge">sick_generic_caller.exe</code> and <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> are created in folders <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\Debug</code> and <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\Release</code>.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS sensors are currently not supported on Windows.</li>
    <li>To build sick_generic_caller without multiScan100/picoScan100 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DSCANSEGMENT_XD=0 -G "%_cmake_string%" ..
   
</code></pre></div></div>

<h1 id="running-the-driver">Running the driver</h1>

<p>The sick_scan_xd driver can be started on the command line by <code class="language-plaintext highlighter-rouge">sick_generic_caller &lt;launchfile&gt; [hostname:=&lt;ip-address&gt;]</code>. The start process varies slightly depending on the target OS:</p>

<p>On native Linux without ROS, call</p>

<p>```sick_generic_caller <launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On Linux with ROS 1, call

    
```./devel_isolated/setup.bash
</code></pre></div></div>

<p>```roslaunch sick_scan_xd <launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On Linux with ROS 2, call

    
```source ./install/setup.bash
</code></pre></div></div>

<p>```ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/<launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On native Windows without ROS, call

    
```sick_generic_caller &lt;launchfile&gt;
</code></pre></div></div>

<p>On Windows with ROS 2, call</p>

<p>```call .\install\setup.bat</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    
```ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/&lt;launchfile&gt;
</code></pre></div></div>

<p>Use the following commands to run the sick_scan_xd driver for a specific scanner type:</p>

<ul>
  <li>For MRS6124:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_6xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_mrs_6xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_6xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_6xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_6xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For MRS1104:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_1xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_mrs_1xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_1xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_1xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_1xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1104 with firmware 1.x:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1104 with firmware 2.x:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx_v2.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xxx_v2.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx_v2.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx_v2.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx_v2.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM240-prototype:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_240.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_240.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_240.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_240.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_240.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM5xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_5xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_5xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_5xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_5xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_5xx.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM7xx-family (no safety scanner):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM7xxS-family (safety scanner):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xxS.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xxS.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xxS.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xxS.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xxS.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS5xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_5xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_5xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_5xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS4xxx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_4xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_4xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_4xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_4xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_4xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS4000:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_4xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_4xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_4xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_4xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_4xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LDMRS-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_ldmrs.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_ldmrs.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_ldmrs.launch</code>
</li>
      <li>Note that LD-MRS are currently not supported on Windows</li>
    </ul>
  </li>
  <li>For LRS36x0:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x0.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS36x0 mounted upside down:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0_upside_down.launch</code>
  <br>For upside down mounted devices, the point cloud is rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>.</li>
    </ul>
  </li>
  <li>For LRS36x1:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x1.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS36x1 mounted upside down:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1_upside_down.launch</code>
</li>
    </ul>

    <p><br>For upside down mounted devices, the point cloud is rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>.</p>
  </li>
  <li>For LD-OEM15xx:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_oem_15xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_oem_15xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_oem_15xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_oem_15xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_oem_15xx.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV210 and NAV245:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_2xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_2xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_2xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_2xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_2xx.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV310:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_31x.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_31x.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_31x.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_31x.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_31x.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV350:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_350.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_350.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_350.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_350.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_350.launch</code>
</li>
    </ul>
  </li>
  <li>For RMS-family (RMS1xxx, RMS2xxx):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_rms_xxxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_rms_xxxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_rms_xxxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_rms_xxxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_rms_xxxx.launch</code>
</li>
    </ul>
  </li>
  <li>For multiScan136 (sick_scansegement_xd):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">hostname</code> is the ip-address of the lidar, <code class="language-plaintext highlighter-rouge">udp_receiver_ip</code> is the ip-address of the receiver (i.e. the ip of the computer running sick_generic_caller).</li>
    </ul>
  </li>
  <li>For picoScan150:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_picoscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_picoscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">hostname</code> is the ip-address of the lidar, <code class="language-plaintext highlighter-rouge">udp_receiver_ip</code> is the ip-address of the receiver (i.e. the ip of the computer running sick_generic_caller).</li>
    </ul>
  </li>
</ul>

<p>Common command line options are</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">hostname:=&lt;ip-address&gt;</code> to connect to a sensor with a given IP address. Default value is always the factory default IP address of the scanner.</li>
</ul>

<p>Further (common and scanner specific) options can be set via launch file, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#common-parameters">Common parameters</a> and configure the settings in the launch file corresponding to the scanner type.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> After modifying a launch-file, it has to be installed by running <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev</code>
to be located and used by <code class="language-plaintext highlighter-rouge">roslaunch</code>.</p>
</blockquote>

<p>On ROS 2 you can launch sick_generic_caller by python launch files, too. Use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 launch sick_scan_xd &lt;name&gt;.launch.py &lt;param&gt;:=&lt;value&gt;

</code></pre></div></div>
<p>E.g. for LMS-5xx: <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_lms_5xx.launch.py hostname:=192.168.0.1</code></p>

<p>The launch.py-files on ROS 2 passes the corresponding launch-file to the driver: <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lms_5xx.launch.py">sick_lms_5xx.launch.py</a> gives an example for LMS-5xx. Parameter can be overwritten</p>
<ul>
  <li>either by command line, e.g. <br> <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_lms_5xx.launch.py hostname:=192.168.0.1</code>,</li>
  <li>or by passing additional arguments in the launch.py-file, e.g. <br> <code class="language-plaintext highlighter-rouge">node = Node(package='sick_scan_xd', executable='sick_generic_caller', arguments=[launch_file_path, 'hostname:=192.168.0.1'])</code>
</li>
</ul>

<h2 id="starting-scanner-with-specific-ip-address">Starting Scanner with Specific IP Address</h2>

<p>To start the scanner with a specific IP address, option <code class="language-plaintext highlighter-rouge">hostname:=&lt;ip-address&gt;</code> can be used.
The hostname is the ip-address of the scanner, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71                         # Linux native
roslaunch sick_scan_xd sick_tim_5xx.launch hostname:=192.168.0.71                      # Linux ROS 1
ros2 run sick_scan_xd sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71   # Linux ROS 2
sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71                         # Windows native
ros2 run sick_scan_xd sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71   # Windows ROS 2

</code></pre></div></div>

<h2 id="start-multiple-nodes">Start Multiple Nodes</h2>

<p>Multiple nodes can be started to support multiple sensors. In this case, multiple instances of sick_scan_xd have to be started, each node with different name and topic. ROS 1 example to run two TiM 7xx devices with ip address <code class="language-plaintext highlighter-rouge">192.168.0.1</code> and <code class="language-plaintext highlighter-rouge">192.168.0.2</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1 &amp;
roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2 &amp;

</code></pre></div></div>

<p>On Linux with ROS 1, multiple nodes to support multiple sensors can be started by one launch file, too.
Take the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_tim_5xx_twin.launch">sick_tim_5xx_twin.launch</a> as an example.
Remapping the scan and cloud topics is essential to distinguish the scandata and provide TF information.</p>

<p>ROS 2 example to run two TiM 7xx devices with IP address <code class="language-plaintext highlighter-rouge">192.168.0.1</code> and <code class="language-plaintext highlighter-rouge">192.168.0.2</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1 &amp;
ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2 &amp;

</code></pre></div></div>

<p>To support multiple sensors, sick_scan_xd has to be started multiple times, with one sick_scan_xd-node for each sensor. By default, each sick_scan_xd-node connects to “192.168.0.1” and publishes its point cloud on topic “cloud”. Therefore both the node name, the ip-address of the sensor and the point cloud topic have to be configured differently for each node.</p>

<p>Node name, ip-address and point cloud topic can be configured in the launch-file or by command line argument:</p>

<p>Topic, nodename and ip configuration in a launch-file (example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;launch&gt;
        &lt;arg name="nodename" default="sick_tim_7xx"/&gt;
        &lt;arg name="hostname" default="192.168.0.1"/&gt;
        &lt;arg name="cloud_topic" default="cloud"/&gt;
        &lt;node name="$(arg nodename)" pkg="sick_scan_xd" type="sick_generic_caller" respawn="false" output="screen"&gt;
            &lt;param name="scanner_type" type="string" value="sick_tim_7xx"/&gt;
            &lt;param name="nodename" type="string" value="$(arg nodename)"/&gt;
            &lt;param name="hostname" type="string" value="$(arg hostname)"/&gt;
            &lt;param name="cloud_topic" type="string" value="$(arg cloud_topic)"/&gt;
    
</code></pre></div></div>

<p>Topic, node name and ip configuration by command line (ROS 1 example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1
    roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2
    
</code></pre></div></div>

<p>Topic, node name and IP configuration by command line (ROS 2 example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1
    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2
    
</code></pre></div></div>

<p>Scripts <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/scripts/run_linux_ros1_simu_tim7xx_twin.bash">run_linux_ros1_simu_tim7xx_twin.bash</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/scripts/run_linux_ros2_simu_tim7xx_twin.bash">run_linux_ros2_simu_tim7xx_twin.bash</a> show a complete example with emulation of two TiM7xx sensors and two sick_scan_xd nodes running concurrently using different nodenames and topics.</p>

<p>To run two multiScan100 or picoScan100 devices simultanously, each sick_scan_xd node must be configured with different lidar ip addresses and udp ports, different node names, different ros topics and frame ids for each point cloud. Therefore the following launch file parameter should be overwritten by individual settings for each lidar:</p>
<ul>
  <li>“hostname”: e.g. “192.168.0.190” and “192.168.0.98”</li>
  <li>“nodename”: e.g. sick_picoscan0” and “sick_picoscan1”</li>
  <li>“publish_frame_id”: e.g. “world0” and “world1”</li>
  <li>“publish_laserscan_segment_topic”: e.g. “scan0_segment” and “scan1_segment”</li>
  <li>“publish_laserscan_fullframe_topic”: e.g. “scan0_fullframe” and “scan1_fullframe”</li>
  <li>“imu_topic”: e.g. “imu0” and “imu1”</li>
  <li>“udp_port”: e.g. “56661” and “56662”</li>
  <li>“imu_udp_port”: e.g. “7503” and “7504”</li>
  <li>individual topics and frame ids for each customized point cloud, e.g.
    <ul>
      <li>replace all “topic=/cloud_” by “topic=/cloud0<em>” resp. “topic=/cloud1</em>”</li>
      <li>replace all “frameid=world” by “frameid=world0” resp. “frameid=world1”
It is recommend to first verify the launch file configurations separately for each picoScan100 before running them simultanously.</li>
    </ul>
  </li>
</ul>

<p>For picoScan100 and multiScan, parameter udp_receiver_ip must be set to the ip address of the PC running sick_scan_xd. It is recommend to use ip addresses in the same subnet.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The sick_scan_xd API does not support running multiple lidars simultaneously in a single process.** Currently the sick_scan_xd API does not support the single or multi-threaded use of 2 or more lidars in one process, since the sick_scan_xd library is not guaranteed to be thread-safe. To run multiple lidars simultaneously, we recommend using ROS or running sick_scan_xd in multiple and separate processes, so that each process serves one sensor.</p>
</blockquote>

<h2 id="common-parameters">Common parameters</h2>

<p>For the launch-file settings and the tag/values pairs the following keywords are supported:</p>

<table>
  <thead>
    <tr>
      <th>Keyword</th>
      <th>Meaning</th>
      <th>Default value</th>
      <th>Hint</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>scanner_type</td>
      <td>Scanner family</td>
      <td>???</td>
      <td>see list above</td>
    </tr>
    <tr>
      <td>min_ang</td>
      <td>Start scan angle in [rad]</td>
      <td>-2.3998277</td>
      <td> </td>
    </tr>
    <tr>
      <td>max_ang</td>
      <td>End scan angle in [rad]</td>
      <td>+2.3998277</td>
      <td> </td>
    </tr>
    <tr>
      <td>intensity_resolution_16bit</td>
      <td>Switch between 8Bit/16Bit</td>
      <td>“false”</td>
      <td>do not change</td>
    </tr>
    <tr>
      <td>hostname</td>
      <td>Ip address of scanner</td>
      <td>192.168.0.1</td>
      <td>change to scanner ip address in your network (see faq)</td>
    </tr>
    <tr>
      <td>port</td>
      <td>port number</td>
      <td>2112</td>
      <td>do not change, check firewall rules if there is blocking traffic</td>
    </tr>
    <tr>
      <td>timelimit</td>
      <td>Timelimit in [sec]</td>
      <td>5</td>
      <td>do not change</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">scanner_type</code>
Name of the used scanner. Usually this is also the name of the launch file. This entry is used to differentiate
between the various scanner properties within the software code.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">hostname</code>
IP-address of the scanner (default: 192.168.0.1)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">port</code>
IP-port of the scanner (default: 2112)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">min_ang</code>
Start angle in [rad]</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">max_ang</code>
End angle in [rad]</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">use_binary_protocol</code>
Switch between SOPAS Binary and SOPAS ASCII protocol</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">intensity</code>
Enable or disable transport of intensity values</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">intensity_resolution_16bit</code>
If true, the intensity values is transferred as 16 bit value. If false, as 8 bit value.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">min_intensity</code>
If min_intensity &gt; 0, all range values in a LaserScan message are set to infinity, if their intensity value is below min_intensity</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cloud_topic</code>
Topic name of the published pointcloud2 data</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">frame_id</code>
Frame id used for the published data</p>
  </li>
</ul>

<p>Tag/value pairs of the command line overwrite settings in the launch file.
The use of the parameters can be looked up in the launch files. This is also recommended as a starting point.</p>

<h2 id="further-useful-parameters-and-features">Further useful parameters and features</h2>

<ul>
  <li>
    <p><strong>Timestamps</strong>: If parameter<code class="language-plaintext highlighter-rouge">sw_pll_only_publish</code> is true (default), an internal Software PLL is used to sync the scan generation timestamps to system timestamps. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#timestamps-and-synchronization-software-pll">Timestamps and synchronization (Software PLL)</a> for details.</p>
  </li>
  <li>
    <p><strong>Angle compensation</strong>: For highest angle accuracy the NAV-Lidar series supports an <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#angle-compensation">angle compensation mechanism</a>.</p>
  </li>
  <li>
    <p><strong>Angle correction</strong>: MRS1000 lidars transmit accurate azimuth angles for each scan point. Therefore, the stride (angle increment) of the MRS1000 azimuth angles in polar and cartesian point clouds is not exactly constant. Since laserscan messages assume a constant angle increment, scan points in point cloud and laserscan messages have slightly different azimuth angles.</p>
  </li>
  <li>
    <p><strong>Field monitoring</strong>: The <strong>LMS1xx</strong>, <strong>LMS5xx</strong>, <strong>TiM7xx</strong> and <strong>TiM7xxS</strong> families have <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#field-evaluation-information">extended settings for field monitoring</a>.</p>
  </li>
  <li>
    <p><strong>Radar devices</strong>: For radar devices (RMS1000/RMS2000), radar raw targets or radar objects or both can be tracked and transmitted. You can activate parameter transmit_raw_targets, transmit_objects or both in the launch file:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   &lt;param name="transmit_raw_targets" type="bool" value="false"/&gt;
   &lt;param name="transmit_objects" type="bool" value="true"/&gt;
   
</code></pre></div></div>
<p>By default, radar objects are tracked.</p>

<ul>
  <li>
<strong>Coordinate transform</strong>: An optional coordinate transform can be applied to the point cloud. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#coordinate-transforms">coordinate transforms</a>) for details.</li>
</ul>

<h2 id="ros-services">ROS services</h2>

<p>On ROS 1 and ROS 2, services can be used to send COLA commands to the sensor. This can be very helpful for diagnosis, e.g. by querying the device status or its id.</p>

<p>Use the following examples to run a cola command on ROS 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_lms_5xx/ColaMsg "{request: 'sMN IsSystemReady'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sRN SCdevicestate'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sEN LIDinputstate 1'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sEN LIDoutputstate 1'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sMN LMCstartmeas'}"
rosservice call /sick_lms_5xx/SCdevicestate "{}" # query device state
rosservice call /sick_lms_5xx/SCreboot "{}"      # execute a software reset on the device
rosservice call /sick_lms_5xx/SCsoftreset "{}"   # save current parameter and shut down device

</code></pre></div></div>

<p>Use the following examples to run a cola command on ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN IsSystemReady'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN SCdevicestate'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sEN LIDinputstate 1'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sEN LIDoutputstate 1'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN LMCstartmeas'}"
ros2 service call /SCdevicestate sick_scan_xd/srv/SCdevicestateSrv "{}" # query device state
ros2 service call /SCreboot sick_scan_xd/srv/SCrebootSrv "{}"           # execute a software reset on the device
ros2 service call /SCsoftreset sick_scan_xd/srv/SCsoftresetSrv "{}"     # save current parameter and shut down device

</code></pre></div></div>

<p>Use ros service <code class="language-plaintext highlighter-rouge">SickScanExit</code> to stop the scanner and driver:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_nav_31x/SickScanExit "{}" # stop scanner and driver on ROS 1
ros2 service call /SickScanExit sick_scan_xd/srv/SickScanExitSrv "{}" # stop scanner and driver on ROS 2

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>The COLA commands are sensor specific. See the user manual and telegram listing for further details.</li>
    <li>ROS services require installation of ROS 1 or ROS 2, i.e. services for Cola commands are currently not supported on native Linux or native Windows.</li>
    <li>ROS services are currently not available for the LDMRS.</li>
    <li>ROS service “ColaMsg” should only be used for diagnosis. It is not recommended to change the lidar settings while the driver is running. Otherwise the driver settings can become different or inconsistant to the lidar settings. Restart the driver after changing lidar settings by SOAPS ET or SOPAS commands.</li>
    <li>Some SOPAS commands like <code class="language-plaintext highlighter-rouge">sMN SetAccessMode 3 F4724744</code> stop the current measurement. In this case, the driver restarts after a timeout (5 seconds by default). To process those SOPAS commands without restart, you can
      <ul>
        <li>send <code class="language-plaintext highlighter-rouge">sMN LMCstartmeas</code> and <code class="language-plaintext highlighter-rouge">sMN Run</code> to switch again into measurement mode within the timeout, or</li>
        <li>increase the driver timeout <code class="language-plaintext highlighter-rouge">read_timeout_millisec_default</code> in the launch-file.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Additional services can be available for specific lidars. Service “GetContaminationResult” is e.g. available for MRS1xxx, LMS1000 and multiScan:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ROS 1 example for service GetContaminationResult (LMS 1xxx)
rosservice call /sick_lms_1xxx/GetContaminationResult "{}"
# ROS 2 example for service GetContaminationResult (LMS 1xxx)
ros2 service call /GetContaminationResult sick_scan_xd/srv/GetContaminationResultSrv "{}"

</code></pre></div></div>

<p>Example sequence with stop and start measurement to set a particle filter (TiM-7xxx on ROS 1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LFPparticle'}" # response: "sRA LFPparticle \\x00\\x01\\xf4"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sWN LFPparticle 0101F4'}" # response: "sWA LFPparticle"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN LMCstartmeas'}"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN Run'}"

</code></pre></div></div>

<h2 id="driver-states-timeouts">Driver states, timeouts</h2>

<p>The driver runs in two different states:</p>

<ol>
  <li>
    <p>Initialization: The scanner is initialized and configured by a list of sopas commands</p>
  </li>
  <li>
    <p>Measurement: The scanner is operational, scandata are transmitted and the point cloud is published.
After start, the driver enters initialization mode. After successful initialization, the driver switches automatically into measurement mode.</p>
  </li>
</ol>

<p>The communication between driver and scanner is monitored. In case of communication timeouts, e.g. due to network problems, the TCP connection is reset and the scanner is re-initialized. The driver uses 3 different timeouts (i.e time since last message received from lidar):</p>

<ol>
  <li>
    <p>In measurement mode: If no messages arrive for 5 seconds [timeout 0], the TCP/IP connection is closed. After a short delay, the tcp connection is reopened and the driver switches to initialization mode and reinitializes the Lidar.</p>
  </li>
  <li>
    <p>In initialization mode: If no messages received after 120 sec [Timeout 1] the TCP/IP connection is closed. After a short delay, the tcp connection is reopened and the driver switches to initialization mode and reinitializes the Lidar.</p>
  </li>
  <li>
    <p>In any mode: If no messages received after 150 sec [Timeout 2] the driver terminates.</p>
  </li>
</ol>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The internal timer is reset on successful communication. i.e. the timeout refers to the time of the last message from the Lidar. If there was no message yet, then the time of programme start is used.</p>
</blockquote>

<p>All timeouts can be configured in the launchfile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="message_monitoring_enabled" type="bool" value="True" /&gt;      &lt;!-- Enable message monitoring with reconnect+reinit in case of timeouts, default: true --&gt;
&lt;param name="read_timeout_millisec_default" type="int" value="5000"/&gt;     &lt;!-- 5 sec read timeout in operational mode (measurement mode), default: 5000 milliseconds --&gt;
&lt;param name="read_timeout_millisec_startup" type="int" value="120000"/&gt;   &lt;!-- 120 sec read timeout during startup (sensor may be starting up, which can take up to 120 sec.), default: 120000 milliseconds --&gt;
&lt;param name="read_timeout_millisec_kill_node" type="int" value="150000"/&gt; &lt;!-- 150 sec point cloud timeout, ros node will be killed if no point cloud published within the last 150 sec., default: 150000 milliseconds --&gt;

</code></pre></div></div>

<p>The following diagram shows the transition between the driver states:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/./doc/driverStatesDiagram1.png" alt="driverStatesDiagram"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Timeout 2 (i.e. no lidar message after 150 seconds) terminates the driver. By default, the driver does not restart automatically. It is therefor recommended to run the driver within an endless loop, e.g. in bash:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while(true) ; do roslaunch sick_scan_xd &lt;launchfile&gt; [&lt;arguments&gt;] ; done

</code></pre></div></div>

<p>The following table summarizes the timeout parameter:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/./doc/timeout_parameter.png" alt="timeout_parameter"></p>

<p>Details of timeout settings:</p>

<ul>
  <li>
    <p>message_monitoring_enabled: Enable or disable timeouts and monitoring. Disabling deactivates any error handling in case of network problems. Recommended default value: True</p>
  </li>
  <li>
    <p>read_timeout_millisec_default: Read timeout in milliseconds in operational (measurement) mode. If no datagrams are received from lidar within 5 seconds (default), the TCP socket is closed and the lidar is reinitialized.</p>
  </li>
  <li>
    <p>read_timeout_millisec_startup: Read timeout in milliseconds during initialization after startup. If SOPAS commands are not responded within 120 seconds (default), the TCP socket is closed and lidar is reinitialized.</p>
  </li>
  <li>
    <p>read_timeout_millisec_kill_node: Pointcloud timeout in milliseconds in operational (measurement) mode. If the sick_scan_xd does not publish a point cloud within the last 150 seconds, the sick_scan_xd process is killed. Should never happen, but is the �last resort� to exit after any kind of error (e.g. socket hangs up and blocks after network trouble).</p>
  </li>
  <li>
    <p>All timeouts configured in milliseconds</p>
  </li>
  <li>To disable timeouts (not recommended):
    <ul>
      <li>Set message_monitoring_enabled = false, or</li>
      <li>Set timeouts to “infinite” values, i.e MAX_INT = 2147483647 milliseconds (24.9 days)</li>
    </ul>
  </li>
  <li>To disable point cloud monitoring (not recommended):
    <ul>
      <li>read_timeout_millisec_kill_node &lt;= 0 deactivates pointcloud monitoring</li>
    </ul>
  </li>
  <li>Parameter read_timeout_millisec_default and read_timeout_millisec_startup: value 0 and negative values are currently NOT mapped to other values, i.e. will cause an immediately timeout error. Use value 2147483647 or message_monitoring_enabled = false to deactivate read timeouts (not recommended)</li>
</ul>

<h2 id="sopas-mode">SOPAS Mode</h2>

<p>This driver supports both COLA-B (binary) and COLA-A (ASCII) communication with the laser scanner. Binary mode is activated by default, since this mode generates less network traffic and enables more compatibility to all scanners.
If the communication mode set in the scanner memory is different from that used by the driver, the scanner’s communication mode is changed. This requires a restart of the TCP-IP connection, which can extend the start time by up to 30 seconds.
There are two ways to prevent this:</p>
<ol>
  <li>Recommended:
    <ul>
      <li>Set the communication mode with the SOPAS ET software to binary and save this setting in the scanner’s EEPROM.</li>
      <li>Set “use_binary_protocol” to default value “true”.</li>
    </ul>
  </li>
  <li>Use the parameter “use_binary_protocol” to overwrite the default settings of the driver.</li>
</ol>

<h2 id="example-startup-sequence">Example Startup Sequence</h2>

<p>The following ROS boot protocol shows the typical start sequence when starting a SICK laser scanner. The MRS6124 is shown here as an example. However, the startup sequence is generally similar for all scanners.</p>

<p>After a firmware update, the following Quickcheck is performed:</p>
<ol>
  <li>Is the device accessible via ping?</li>
  <li>Can the device be started with the corresponding generic launch file?</li>
  <li>At the end of the launch process, the device switches to receive mode
 for scan data? Typically the last command sent is
<code class="language-plaintext highlighter-rouge">&lt;STX&gt;sEA LMDscandata \x01&lt;ETX&gt;
</code>.</li>
  <li>Check with rviz: Is it possible to see the Pointcloud2 data or similar? Is the shown data reasonable?</li>
  <li>Check the scan rate with the command</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic hz /cloud

</code></pre></div></div>
<ol>
  <li>Further inspection, if any, by dumping Pointcloud2 data.
The header is of particular interest here. A typical call can therefore look as follows:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic echo /cloud|grep frame -B 7 -A 26

</code></pre></div></div>
<p><strong>Example Sequence</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_mrs_6xxx.launch hostname:=192.168.0.25
... logging to /home/rosuser/.ros/log/75631922-6109-11e9-b76f-54e1ad2921b6/roslaunch-ROS-NB-10680.log
Checking log directory for disk usage. This may take awhile.
Press Ctrl-C to interrupt
Done checking log file disk usage. Usage is &lt;1GB.
started roslaunch server http://ROS-NB:40757/
SUMMARY
========
PARAMETERS
 * /rosdistro: melodic
 * /rosversion: 1.14.3
 * /sick_mrs_6xxx/filter_echos: 0
 * /sick_mrs_6xxx/hostname: 192.168.0.25
 * /sick_mrs_6xxx/max_ang: 1.047197333
 * /sick_mrs_6xxx/min_ang: -1.040216
 * /sick_mrs_6xxx/port: 2112
 * /sick_mrs_6xxx/range_max: 250.0
 * /sick_mrs_6xxx/range_min: 0.1
 * /sick_mrs_6xxx/scanner_type: sick_mrs_6xxx
 * /sick_mrs_6xxx/timelimit: 5
 * /sick_mrs_6xxx/use_binary_protocol: True
NODES
  /
    sick_mrs_6xxx (sick_scan_xd/sick_generic_caller)
auto-starting new master
process[master]: started with pid [10690]
ROS_MASTER_URI=http://localhost:11311
setting /run_id to 75631922-6109-11e9-b76f-54e1ad2921b6
process[rosout-1]: started with pid [10701]
started core service [/rosout]
process[sick_mrs_6xxx-2]: started with pid [10708]
[ INFO] [1555502887.036684738]: sick_generic_caller V. 001.003.016
[ INFO] [1555502887.036717573]: Program arguments: /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller
[ INFO] [1555502887.036725741]: Program arguments: __name:=sick_mrs_6xxx
[ INFO] [1555502887.036731933]: Program arguments: __log:=/home/rosuser/.ros/log/75631922-6109-11e9-b76f-54e1ad2921b6/sick_mrs_6xxx-2.log
[ INFO] [1555502887.048425000]: Found sopas_protocol_type param overwriting default protocol:
[ INFO] [1555502887.048956468]: Binary protocol activated
[ INFO] [1555502887.048984179]: Start initialising scanner [Ip: 192.168.0.25] [Port: 2112]
[ INFO] [1555502887.067528995]: Publishing laserscan-pointcloud2 to cloud
[ INFO] [1555502887.071035827]: Parameter setting for &lt;active_echo: 0&gt;
[ INFO] [1555502887.271739084]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0023&gt;sMN SetAccessMode 0x03 0xf4 0x72 0x47 0x44 CRC:&lt;0xb3&gt;
[ INFO] [1555502887.273290840]: Receiving: &lt;STX&gt;sAN SetAccessMode \x01&lt;ETX&gt;
[ INFO] [1555502887.473927858]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sWN EIHstCola 0x01 CRC:&lt;0x09&gt;
[ INFO] [1555502887.475365983]: Receiving: &lt;STX&gt;sWA EIHstCola &lt;ETX&gt;
[ INFO] [1555502887.675864993]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sMN LMCstopmeas CRC:&lt;0x10&gt;
[ INFO] [1555502888.199590269]: Receiving: &lt;STX&gt;sAN LMCstopmeas \x00&lt;ETX&gt;
[ INFO] [1555502888.400030148]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sRN DeviceIdent CRC:&lt;0x25&gt;
[ INFO] [1555502888.401393378]: Receiving: &lt;STX&gt;sRA DeviceIdent \x00\x08\x4d\x52\x53\x36\x31\x32\x34\x52\x00\x0a\x31\x2e\x31\x2e\x30\x2e\x35\x36\x35\x43&lt;ETX&gt;
[ INFO] [1555502888.401653485]: Deviceinfo MRS6124R V1.1.0.565C found and supported by this driver.
[ INFO] [1555502888.602062286]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0019&gt;sRN FirmwareVersion CRC:&lt;0x24&gt;
[ INFO] [1555502888.603444526]: Receiving: &lt;STX&gt;sRA FirmwareVersion \x00\x0a\x31\x2e\x31\x2e\x30\x2e\x35\x36\x35\x43&lt;ETX&gt;
[ INFO] [1555502888.804094446]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0017&gt;sRN SCdevicestate CRC:&lt;0x30&gt;
[ INFO] [1555502888.805521867]: Receiving: &lt;STX&gt;sRA SCdevicestate \x01&lt;ETX&gt;
[ INFO] [1555502889.006161400]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0010&gt;sRN ODoprh CRC:&lt;0x41&gt;
[ INFO] [1555502889.007613972]: Receiving: &lt;STX&gt;sRA ODoprh \x00\x00\x19\xf1&lt;ETX&gt;
[ INFO] [1555502889.209949897]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0010&gt;sRN ODpwrc CRC:&lt;0x52&gt;
[ INFO] [1555502889.211413041]: Receiving: &lt;STX&gt;sRA ODpwrc \x00\x00\x02\x55&lt;ETX&gt;
[ INFO] [1555502889.413742132]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0016&gt;sRN LocationName CRC:&lt;0x55&gt;
[ INFO] [1555502889.415205992]: Receiving: &lt;STX&gt;sRA LocationName \x00\x0b\x6e\x6f\x74\x20\x64\x65\x66\x69\x6e\x65\x64&lt;ETX&gt;
[ INFO] [1555502889.417205292]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMPoutputRange CRC:&lt;0x5e&gt;
[ INFO] [1555502889.418631134]: Receiving: &lt;STX&gt;sRA LMPoutputRange \x00\x01\x00\x00\x05\x15\x00\x04\xa3\x80\x00\x16\xe3\x60&lt;ETX&gt;
[ INFO] [1555502889.418830949]: Angle resolution of scanner is 0.13010 [deg]  (in 1/10000th deg: 0x515)
[ INFO] [1555502889.418907556]: MIN_ANG:   -1.040 [rad]  -59.600 [deg]
[ INFO] [1555502889.418975818]: MAX_ANG:    1.047 [rad]   60.000 [deg]
[ INFO] [1555502889.419156102]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0033&gt;sWN LMPoutputRange 0x00 0x01 0x00 0x00 0x05 0x15 0x00 0x04 0xa3 0x80 0x00 0x16 0xe3 0x60 CRC:&lt;0xd8&gt;
[ INFO] [1555502889.420488646]: Receiving: &lt;STX&gt;sWA LMPoutputRange &lt;ETX&gt;
[ INFO] [1555502889.420719836]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMPoutputRange CRC:&lt;0x5e&gt;
[ INFO] [1555502889.421994443]: Receiving: &lt;STX&gt;sRA LMPoutputRange \x00\x01\x00\x00\x05\x15\x00\x04\xa3\x80\x00\x16\xe3\x60&lt;ETX&gt;
[ INFO] [1555502889.422165198]: Angle resolution of scanner is 0.13010 [deg]  (in 1/10000th deg: 0x515)
[ INFO] [1555502889.424815945]: MIN_ANG (after command verification):   -1.040 [rad]  -59.600 [deg]
[ INFO] [1555502889.424901901]: MAX_ANG (after command verification):    1.047 [rad]   60.000 [deg]
[ INFO] [1555502889.425102725]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0032&gt;sWN LMDscandatacfg 0x1f 0x00 0x01 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01 CRC:&lt;0x5c&gt;
[ INFO] [1555502889.426373088]: Receiving: &lt;STX&gt;sWA LMDscandatacfg &lt;ETX&gt;
[ INFO] [1555502889.426606493]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMDscandatacfg CRC:&lt;0x67&gt;
[ INFO] [1555502889.427933309]: Receiving: &lt;STX&gt;sRA LMDscandatacfg \x1f\x00\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01&lt;ETX&gt;
[ INFO] [1555502889.430654546]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sWN FREchoFilter 0x00 CRC:&lt;0x7f&gt;
[ INFO] [1555502889.431952374]: Receiving: &lt;STX&gt;sWA FREchoFilter &lt;ETX&gt;
[ INFO] [1555502889.432180430]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0016&gt;sMN LMCstartmeas CRC:&lt;0x68&gt;
[ INFO] [1555502889.963840302]: Receiving: &lt;STX&gt;sAN LMCstartmeas \x00&lt;ETX&gt;
[ INFO] [1555502889.964083670]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0007&gt;sMN Run CRC:&lt;0x19&gt;
[ INFO] [1555502889.965558914]: Receiving: &lt;STX&gt;sAN Run \x01&lt;ETX&gt;
[ INFO] [1555502889.965813465]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0017&gt;sEN LMDscandata 0x01 CRC:&lt;0x33&gt;
[ INFO] [1555502889.967297195]: Receiving: &lt;STX&gt;sEA LMDscandata \x01&lt;ETX&gt;

</code></pre></div></div>

<h1 id="driver-features-and-additional-information">Driver features and additional information</h1>

<h2 id="software-overview">Software Overview</h2>

<p>The sick_scan_xd software is essentially affected by its use cases:</p>

<ul>
  <li>Implement the common tasks for different lidars:
    <ul>
      <li>Provide driver software on Linux and Windows, generic, ROS 1 and ROS 2</li>
      <li>Receive and convert scan data, publish point cloud</li>
      <li>Run startup, configuration and setup</li>
    </ul>
  </li>
  <li>Use cases:
    <ul>
      <li>Provide a point cloud to the customer/application</li>
      <li>Provide a common high level interface for all supported lidars</li>
      <li>Hide datagram details, encodings and parsing knowhow</li>
      <li>The most common use case is to run lidar + sick_scan_xd to get a point cloud.</li>
    </ul>
  </li>
  <li>Software requirements:
    <ul>
      <li>Support different lidars (LMS, LRS, LDMRS, MRS, NAV, TiM, RMS, multiScan, etc.)</li>
      <li>Support different OS (Linux, Windows)</li>
      <li>Support different targets (ROS 1, ROS 2, generic)</li>
      <li>Support different protocols (Cola-A, Cola-B, TCP, UDP, msgpack)</li>
      <li>Implement parser for different telegrams (scandata, scancfg, fields, etc.)</li>
    </ul>
  </li>
</ul>

<p>This overview describes the most important modules and their relationship.</p>

<h3 id="software-structure">Software structure</h3>

<p>The following figures show the most important software blocks:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/software_overview_01.png" alt="software_overview_01"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/software_overview_02.png" alt="software_overview_02"></p>

<p>sick_scan_xd contains 6 main functional blocks:</p>

<ul>
  <li>sick_generic_caller and sick_generic_laser for initialization and setup:
    <ul>
      <li>Read configuration from launchfile:
        <ul>
          <li>ROS 1: <code class="language-plaintext highlighter-rouge">ros::NodeHandle::getParam</code>
</li>
          <li>ROS 2 and generic: <code class="language-plaintext highlighter-rouge">LaunchParser</code> (ros-wrapper)</li>
        </ul>
      </li>
      <li>Lidar specific setup:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickGenericParser</code>: lidar specific properties and messages parsing</li>
          <li>Set and get lidar specific properties: number of layers, angular resolution, etc.</li>
          <li>Parse and convert scan data, input: scan data (ascii or binary datagram), output: <code class="language-plaintext highlighter-rouge">ros::sensor_msgs::LaserScan</code>
</li>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanCommonTcp</code>: receive TCP messages, convert and publish point cloud</li>
        </ul>
      </li>
      <li>Start ros services:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanServices</code>: register ros services, convert from/to SOPAS</li>
        </ul>
      </li>
      <li>Start monitoring:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanMonitor</code>: monitor scan data, reinit on timeout</li>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::PointCloudMonitor</code>: monitor point cloud, reinit on timeout</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>sick_scan_common for the most common lidar devices (LMS, LRS, MRS, NAV, TiM, RMS, etc.):
    <ul>
      <li>Implemention by SickScanCommon and SickScanCommonTcp</li>
      <li>Uses SickGenericParser for lidar specific properties and parsing</li>
      <li>Runs common tasks for LMS/LRS/MRS/NAV/TiM/RMS:</li>
      <li>Run SOPAS startup sequence</li>
      <li>Run TCP receiver thread</li>
      <li>Process telegrams: parse and convert to point cloud</li>
      <li>Publish point cloud</li>
    </ul>
  </li>
  <li>sick_ldmrs for LD-MRS support using the ldmrs-library from https://github.com/SICKAG/libsick_ldmrs.git</li>
  <li>sick_scansegment_xd for multiScan136 and picoScan150 lidars using SOPAS, msgpack and UDP-communication</li>
  <li>sick_scan_services for ros services</li>
  <li>sick_generic_monitoring for monitoring and re-initialization in case of errors (e.g. network errors).</li>
</ul>

<p>The following figures show these 6 functional blocks:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/software_overview_03.png" alt="software_overview_03"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/software_overview_04.png" alt="software_overview_04"></p>

<p>The function blocks depend on and use the underlying system (ROS, TCP, etc.):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/driverComponentsDiagram1.png" alt="driver_components_01"></p>

<h3 id="message-receiving-and-message-handling">Message receiving and message handling</h3>

<p>Message receiving and message handling are decoupled, i.e. both tasks run in separate thread and exchange messages via a FIFO-buffer. This way, message handling cannot block tcp recv and vice versa. The following figure shows the message handling:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/software_overview_05.png" alt="software_overview_05"></p>

<p>The following figure shows the sequence diagram for a LMDscandata telegram:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/messageSequenceDiagram1.png" alt="messageSequenceDiagram1"></p>

<p>Incoming TCP messages and exported point cloud messages are monitored. sick_scan_xd reinitialises the lidar and the tcp connection in case of timeouts.</p>

<h3 id="sick_scansegment_xd">sick_scansegment_xd</h3>

<p>sick_scansegment_xd implements support for multiScan136 and picoScan150 lidars using SOPAS, msgpack and UDP-communication. It has 5 functional blocks:</p>

<ul>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackThreads</code>:
    <ul>
      <li>Init and run all sick_scansegment_xd components</li>
      <li>SOPAS startup (multiScan136, picoScan150)</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::UdpReceiver</code>:
    <ul>
      <li>Run UDP receiver thread</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackConverter</code>:
    <ul>
      <li>Parse and convert msgpacks</li>
      <li>Collect scan segments</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackValidator</code>:
    <ul>
      <li>Validate msgpacks and scansegments</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::RosMsgpackPublisher</code>:
    <ul>
      <li>Publish point cloud (single segments)</li>
      <li>Publish cloud_fullframe (fullframe pointcloud, 360 deg for Multiscan136 resp. 270 deg for picoscan)</li>
    </ul>
  </li>
</ul>

<p>The following figure shows the compoenent diagram for sick_scansegment_xd:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/driverComponentsDiagram2.png" alt="driverComponentsDiagram2"></p>

<p>Message receiving, converting and publishing run in 3 separate threads and exchange their messages via a FIFO-buffer.</p>

<p>The following figure shows the sequence diagram for a multiScan136 msgpack:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/messageSequenceDiagram2.png" alt="messageSequenceDiagram2"></p>

<p>The following figure shows the sequence diagram for a picoScan and compact format:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/messageSequenceDiagram3.png" alt="messageSequenceDiagram3"></p>

<h3 id="files-and-folders">Files and folders</h3>

<p>The source files for the sick_scan_xd core can be found in the following folders:</p>
<ul>
  <li>driver/src: source files</li>
  <li>include: header files</li>
  <li>launch: configuration</li>
  <li>msg: ros messages definitions</li>
  <li>srv: ros services definitions</li>
  <li>roswrap: ros wrapper (ROS 2 and generic)</li>
</ul>

<p>These folders are required to build sick_generic_caller.</p>

<p>Additional folders for sick_scan_xd support, development and test are:</p>
<ul>
  <li>test: test scripts and emulator</li>
  <li>tools: additional development tools</li>
</ul>

<h2 id="generic-driver-api">Generic Driver API</h2>

<h3 id="overview">Overview</h3>

<p>A generic API for sick_scan_xd has the following goals:</p>
<ul>
  <li>Easy integration of sick_scan_xd into customer systems with and without ROS</li>
  <li>Integrate SICK lidars with one API, independent of lidar types or underlying operating system</li>
  <li>Provide the same sick_scan_xd functionality on systems without ROS</li>
  <li>In particular: make the sick_scan_xd functionality available on non-ROS-systems without need to customize sources or configuration files.</li>
</ul>

<p>The generic sick_scan_xd API provides an interface to all lidars supported by sick_scan_xd. This API can be used in C, C++, Python, or any other language with support of C-bindings.</p>

<p>The generic sick_scan_xd API ships with the API-header, the library (binary or sources) and usage examples for C, C++ and Python. The following component diagram shows the relationship between API, library, lidar and a customized application:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_api/apiComponentsDiagram1.png" alt="apiComponentsDiagram1.png"></p>

<p>Running multiple lidars simultaneously in a single process is not supported.** Currently the sick_scan_xd API does not support the single or multi-threaded use of 2 or more lidars in one process, since the sick_scan_xd library is not guaranteed to be thread-safe. To run multiple lidars simultaneously, we recommend using ROS or running sick_scan_xd in multiple and separate processes, so that each process serves one sensor. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#start-multiple-nodes">start multiple lidars</a> for further information.</p>

<h3 id="build-and-test-shared-library">Build and test shared library</h3>

<p>The shared library, which implements the C-API, is built native on Linux or Windows (i.e. without ROS). Follow the instructions on <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-generic-without-ros">Build on Linux generic without ROS</a> for Linux resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-windows-generic-without-ros">Build on Windows</a> for Windows.</p>

<h4 id="build-the-shared-library-on-linux">Build the shared library on Linux</h4>

<p>Run the following commands to build the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Clone repositories
git clone https://github.com/SICKAG/libsick_ldmrs.git
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
# Build libsick_ldmrs library
mkdir -p ./build
mkdir -p ./libsick_ldmrs/build
pushd libsick_ldmrs/build
cmake -G "Unix Makefiles" ..
make -j4
sudo make -j4 install
popd
# Build libsick_scan_xd_shared_lib.so
pushd ./build
export ROS_VERSION=0
cmake -DROS_VERSION=0 -G "Unix Makefiles" ../sick_scan_xd
make -j4
sudo make -j4 install
# Check build and library dependencies
ls -al ./sick_generic_caller
ls -al ./libsick_scan_xd_shared_lib.so
ls -al ./sick_scan_xd_api_test
ldd -r ./libsick_scan_xd_shared_lib.so
popd

</code></pre></div></div>
<p>After successful build, the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> and a tiny test executable <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> are created.</p>

<h4 id="build-the-shared-library-on-windows">Build the shared library on Windows</h4>

<p>Run the following commands to build the shared library <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> with Visual Studio 2019 on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Clone repository sick_scan_xd
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
# Build libraries sick_scan_xd_shared_lib.dll
call "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\Common7\Tools\VsDevCmd.bat" -arch=amd64 -host_arch=amd64
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
cd sick_scan_xd
if not exist %_cmake_build_dir% mkdir %_cmake_build_dir%
pushd %_cmake_build_dir%
cmake -DROS_VERSION=0 -G "%_cmake_string%" ..
if %ERRORLEVEL% neq 0 ( @echo ERROR building %_cmake_string% sick_scan_xd with cmake &amp; @pause )
cmake --build . --clean-first --config Debug

</code></pre></div></div>
<p>After successful build, the shared library <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> and a tiny test executable <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test.exe</code> are created. To install the library and header in the system folder, run <code class="language-plaintext highlighter-rouge">cmake --build . --target install</code> with admin privileges. Note that LD-MRS is not supported on Windows.
privileges</p>
<blockquote>
  <p><strong><em>NOTE:</em></strong> sick_scan_xd builds and runs with both Visual Studio 2019 and 2022. Visual Studio 2019 is recommended, since ROS on Windows requires VS 2019.</p>
</blockquote>

<p>Replace <code class="language-plaintext highlighter-rouge">cmake -DROS_VERSION=0 -G "%_cmake_string%" ..</code> by  <code class="language-plaintext highlighter-rouge">cmake -DROS_VERSION=0 -DCMAKE_ENABLE_EMULATOR=1 -G "%_cmake_string%" ..</code> to build emulators for unit tests without lidar hardware, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CONTRIBUTING.md">Simulation</a>.</p>

<h4 id="test-the-shared-library">Test the shared library</h4>

<p>The executable file <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> provides a minimalistic API test. Run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;ip-address&gt;</code> to test the API against a lidar, e.g. on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH # append relative path to build folder
export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to build folder
./build/sick_scan_xd_api_test ./sick_scan_xd/launch/sick_tim_7xx.launch hostname:=192.168.0.1

</code></pre></div></div>
<p>On Windows, run e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;..\build\Debug;%PATH%
.\build\Debug\sick_scan_xd_api_test.exe launch/sick_lms_5xx.launch hostname:=192.168.0.1

</code></pre></div></div>

<p>The executable binary <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> will just load library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code>, start the lidar and print a message when receiving lidar messages, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test: pointcloud callback</code>. Replace <code class="language-plaintext highlighter-rouge">sick_lms_1xx.launch</code> in the example by the launch file corresponding to your type of lidar.</p>

<p>To load the library, the build folder has to be included in <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code> (Linux) resp. <code class="language-plaintext highlighter-rouge">PATH</code> (Windows). Set this environment variable to your build folder, e.g. on Linux using</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH # append relative path to build folder
export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to build folder

</code></pre></div></div>
<p>resp. on Windows</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;.\build\Debug;%PATH%

</code></pre></div></div>

<h3 id="usage-example">Usage example</h3>

<p>The sick_scan_xd API can be used on Linux or Windows in any language with support of C-bindings. There are 3 steps required to use the API:</p>

<ol>
  <li>API- and lidar-initialization by
    <ul>
      <li>SickScanApiLoadLibrary</li>
      <li>SickScanApiCreate</li>
      <li>SickScanApiInitByLaunchfile or SickScanApiInitByCli</li>
    </ul>
  </li>
  <li>
    <p>Receive messages by registration of callbacks using <code class="language-plaintext highlighter-rouge">SickScanApiRegister&lt;MsgType&gt;Msg</code>-functions (recommended) or by polling using <code class="language-plaintext highlighter-rouge">SickScanApiWaitNext&lt;MsgType&gt;Msg</code>-functions.</p>

    <p>Alternative examples to receive lidar scan data as a point cloud:</p>
    <ul>
      <li>Register a callback for cartesian point cloud data using SickScanApiRegisterCartesianPointCloudMsg, or</li>
      <li>register a callback for polar point cloud data using SickScanApiRegisterPolarPointCloudMsg.</li>
    </ul>

    <p>The registered callback will be executed whenever the lidar has sent new scan data and receives the (cartesian or polar) point cloud by a parameter of type SickScanPointCloudMsg. The SickScanPointCloudMsg in sick_scan_xd API corresponds to ROS pointcloud: The cartesian point cloud  (registered by SickScanApiRegisterCartesianPointCloudMsg) contains the fields (x, y, z, intensity). The polar point cloud (registered by SickScanApiRegisterPolarPointCloudMsg) contains the fields (range, azimuth, elevation, intensity). Each field contains its name (i.e. x, y, z, range, azimuth, elevation, or intensity) and offset. The scan data is a flat buffer of size width x height fields:</p>

    <p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_api/apiPointCloudMsg.png" alt="apiPointCloudMsg"></p>

    <p>The following python code shows how to convert a cartesian point cloud to 3D points (x, y, z):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Convert a SickScanCartesianPointCloudMsg to points
    def pySickScanCartesianPointCloudMsgToXYZ(pointcloud_msg):
        # get point cloud fields
        num_fields = pointcloud_msg.fields.size
        msg_fields_buffer = pointcloud_msg.fields.buffer
        field_offset_x = -1
        field_offset_y = -1
        field_offset_z = -1
        for n in range(num_fields):
            field_name = ctypesCharArrayToString(msg_fields_buffer[n].name)
            field_offset = msg_fields_buffer[n].offset
            if field_name == "x":
                field_offset_x = msg_fields_buffer[n].offset
            elif field_name == "y":
                field_offset_y = msg_fields_buffer[n].offset
            elif field_name == "z":
                field_offset_z = msg_fields_buffer[n].offset
        # Extract x,y,z
        cloud_data_buffer_len = (pointcloud_msg.row_step * pointcloud_msg.height) # length of polar cloud data in byte
        assert(pointcloud_msg.data.size == cloud_data_buffer_len and field_offset_x &gt;= 0 and field_offset_y &gt;= 0 and field_offset_z &gt;= 0)
        cloud_data_buffer = bytearray(cloud_data_buffer_len)
        for n in range(cloud_data_buffer_len):
            cloud_data_buffer[n] = pointcloud_msg.data.buffer[n]
        points_x = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        points_y = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        points_z = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        point_idx = 0
        for row_idx in range(pointcloud_msg.height):
            for col_idx in range(pointcloud_msg.width):
                # Get lidar point in polar coordinates (range, azimuth and elevation)
                pointcloud_offset = row_idx * pointcloud_msg.row_step + col_idx * pointcloud_msg.point_step
                points_x[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_x)[0]
                points_y[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_y)[0]
                points_z[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_z)[0]
                point_idx = point_idx + 1
        return points_x, points_y, points_z
   
</code></pre></div></div>
<p>Exchange field names (“x”, “y”, “z”) by (“range”, “azimuth”, “elevation”) to get 3D polar points (range, azimuth, elevation).</p>

<p>For further details, see minimalistic usage examples in C and Python.</p>

<p>Note for multiScan100 and picoScan100 lidars:</p>

<ul>
  <li>
    <p>The WaitNext-functions of the API return the next received message. For multiScan100 and picoScan, this can be a scan segment (i.e. a part of the full scan) or a fullframe point cloud (i.e. all scan points of a 360 degree scan). Depending on the timing, you may not receive all messages, i.e. you may e.g. receive scan points of different segments. We therefore recommend to register a message callback instead of a WaitNext-function. With a registered message callback, you will get all fullframe and segment point cloud messages.</p>
  </li>
  <li>
    <p>For multiScan100 and picoScan, point cloud messages can contain a scan segment (i.e. a part of the full scan) or a fullframe point cloud  (i.e. all scan points of a 360 degree scan). The type can be determined by the topic (default: “/cloud_unstructured_segments” for segments, “/cloud_unstructured_fullframe” for fullframe point clouds) or by segment index (-1 for fullframe, 0 up to 11 for segment point clouds).</p>
  </li>
</ul>

<ol>
  <li>Close lidar and API by
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">SickScanApiDeregister&lt;MsgType&gt;Msg</code>-functions</li>
      <li>SickScanApiClose</li>
      <li>SickScanApiRelease</li>
    </ul>
  </li>
</ol>

<p>It is recommended to store a deep copy of the point cloud data in a fifo buffer (first in, first out) for further data processing. After the registered callback is executed, the point cloud memory will be released. Make sure to store a deep copy of the point cloud, not a shallow copy.</p>

<p>All functions named <code class="language-plaintext highlighter-rouge">SickScanApi</code> are implemented within the library file (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux). A small wrapper is provided (<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/src/sick_scan_xd_api/sick_scan_xd_api_wrapper.c">sick_scan_xd_api_wrapper.c</a> for C/C++, <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a> for python), which loads and unloads the library (functions <code class="language-plaintext highlighter-rouge">SickScanApiLoadLibrary</code> and <code class="language-plaintext highlighter-rouge">SickScanApiUnloadLibrary</code>) and delegates the function calls to the binary.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). Otherwise, please install numpy with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> if numpy is not yet installed.</p>
</blockquote>

<h4 id="minimalistic-usage-example-in-c">Minimalistic usage example in C</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/examples/c/minimum_sick_scan_api_client.c">minimum_sick_scan_api_client.c</a> shows a minimalistic example of a C client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the build and run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd examples/c
mkdir -p ./build
cd ./build
cmake -G "Unix Makefiles" ..
make -j4
cd ../..
export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH
./examples/c/build/minimum_sick_scan_api_client &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the build and run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REM Set environment for Visual Studio 2019 (VS 16)
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
REM Build the minimalistic C usage example
cd examples\c
mkdir %_cmake_build_dir%
cd %_cmake_build_dir%
cmake -G "%_cmake_string%" ..
cmake --build . --clean-first --config Debug
REM Set environment: add build folder to LD_LIBRARY_PATH, add python/api to PYTHONPATH
cd ..\..
set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
REM Run minimalistic C api example
.\examples\c\build\Debug\minimum_sick_scan_api_client.exe &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<h4 id="minimalistic-usage-example-in-c-1">Minimalistic usage example in C++</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/examples/cpp/minimum_sick_scan_api_client.cpp">minimum_sick_scan_api_client.cpp</a> shows a minimalistic example of a C++ client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the build and run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd examples/cpp
mkdir -p ./build
cd ./build
cmake -G "Unix Makefiles" ..
make -j4
cd ../..
export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH
./examples/cpp/build/minimum_sick_scan_api_client &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the build and run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REM Set environment for Visual Studio 2019 (VS 16)
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
REM Build the minimalistic C++ usage example
cd examples\cpp
mkdir %_cmake_build_dir%
cd %_cmake_build_dir%
cmake -G "%_cmake_string%" ..
cmake --build . --clean-first --config Debug
REM Set environment: add build folder to LD_LIBRARY_PATH, add python/api to PYTHONPATH
cd ..\..
set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
REM Run minimalistic C++ api example
.\examples\cpp\build\Debug\minimum_sick_scan_api_client.exe &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<h4 id="minimalistic-usage-example-in-python">Minimalistic usage example in Python</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/examples/python/minimum_sick_scan_api_client.py">minimum_sick_scan_api_client.py</a> shows a minimalistic example of a python client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export LD_LIBRARY_PATH=`pwd`:`pwd`/build:$LD_LIBRARY_PATH
export PYTHONPATH=`pwd`:`pwd`/python/api:$PYTHONPATH
python3 ./examples/python/minimum_sick_scan_api_client.py &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
set PYTHONPATH=.;.\python\api;%PATH%
python ./examples/python/minimum_sick_scan_api_client.py &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). Otherwise, please install numpy with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> if numpy is not yet installed.</p>
</blockquote>

<h4 id="complete-usage-example-in-c">Complete usage example in C++</h4>

<p>A complete C/C++ usage example is implemented in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a>. Note that the shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) has no dependencies to ROS. The usage example on the other hand supports both ROS 1, ROS 2 and native Linux or Windows. When build on ROS, it converts the SickScanApi-messages into ROS-messages. On ROS, they can be visualized by rviz. The following screenshot shows a point cloud published by <code class="language-plaintext highlighter-rouge">rosrun sick_scan_xd sick_scan_xd_api_test _sick_scan_args:="./src/sick_scan_xd/launch/sick_tim_7xx.launch"</code>:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_api/api_test_linux_ros1_tim7xx.png" alt="api_test_linux_ros1_tim7xx.png"></p>

<p>Without ROS, sick_scan_xd_api_test plots a jpeg-file to enable a simple visualization of a point cloud. E.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>firefox ./demo/image_viewer_api_test.html &amp;
./build_linux/sick_scan_xd_api_test ./launch/sick_tim_7xx.launch

</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_api/api_test_linux_tim7xx.png" alt="api_test_linux_tim7xx.png"></p>

<h4 id="complete-usage-example-in-python">Complete usage example in Python</h4>

<p>A complete python usage example is implemented in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a>. It is handy to test the sick_scan_xd library. Like its C++ counterpart <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a>, it just loads library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code>, starts a lidar and receives the lidar point cloud and messages via API. On ROS 1, the lidar point cloud and messages are converted to ROS and published. The lidar point cloud can be visualized by rviz using topic “/sick_scan_xd_api_test/api_cloud”.</p>

<p>Run <code class="language-plaintext highlighter-rouge">python3 sick_scan_xd_api_test.py &lt;launchfile&gt; hostname:=&lt;ip-address&gt;</code> to test the API against a lidar.
On Linux e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PYTHONPATH=`pwd`:`pwd`/src/sick_scan_xd/python/api:$PYTHONPATH
source /opt/ros/noetic/setup.bash # replace by noetic by your ros version
python3 ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_lms_1xx.launch hostname:=192.168.0.1

</code></pre></div></div>
<p>On Windows e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PYTHONPATH=.;.\src\sick_scan_xd\python\api;%PYTHONPATH%
python ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_lms_1xx.launch hostname:=192.168.0.1

</code></pre></div></div>

<p>The pthon usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> imports <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a>, which contains the python definitions of the sick_scan_xd API. Make sure that sick_scan_api.py can be imported, e.g. by including folder <code class="language-plaintext highlighter-rouge">python/api</code> in PYTHONPATH by:</p>

<p><code class="language-plaintext highlighter-rouge">export PYTHONPATH=</code>pwd<code class="language-plaintext highlighter-rouge">:</code>pwd<code class="language-plaintext highlighter-rouge">/src/sick_scan_xd/python/api:$PYTHONPATH</code> on Linux, resp. <br>
<code class="language-plaintext highlighter-rouge">set PYTHONPATH=.;.\src\sick_scan_xd\python\api;%PYTHONPATH%</code> on Windows</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  The shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) works standalone and does not have any ROS dependencies. The usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> converts API- to ROS-messages for visualization and is therefore dependent on ROS, if ROS is installed.</p>
</blockquote>

<p>If ROS is not installed, <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> uses matplotlib to visualize the pointcloud. The following screenshot shows a TiM-7xx point cloud on Linux without ROS:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_api/api_test_python_tim7xx.png" alt="api_test_python_tim7xx.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows without ROS, <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> requires numpy and matplotlib. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). These python distributions provide the necessary packages and tools. Otherwise, please install numpy and matplotlib with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> and <code class="language-plaintext highlighter-rouge">python -m pip install matplotlib</code> if not yet done.</p>
</blockquote>

<h4 id="diagnostic">Diagnostic</h4>

<p>The API provides the following functions for diagnostics:</p>

<ul>
  <li>SickScanApiRegisterDiagnosticMsg and SickScanApiDeregisterDiagnosticMsg: Register resp. deregister a callback to receive diagnostic messages. Diagnostic messages contain a status code and status message. The status code is one of the following numbers:
    <ul>
      <li>OK=0 (normal operation)</li>
      <li>WARN=1 (warning)</li>
      <li>ERROR=2 (error, should not occur)</li>
      <li>INIT=3 (initialization after startup or reconnection)</li>
      <li>EXIT=4 (sick_scan_xd exiting)</li>
    </ul>

    <p>The status message is descriptional C-string.</p>

    <p>A typical sequence of the status code is:</p>
    <ul>
      <li>INIT at startup, then</li>
      <li>after lidar initialization is completed: change to OK (normal operation) and run, and</li>
      <li>EXIT at shutdown.
 Diagnostic messages are generated whenever the status changed or an ERROR occured. Status code 2 (i.e. error) should not occur under normal operation.</li>
    </ul>
  </li>
  <li>
    <p>SickScanApiRegisterLogMsg and SickScanApiDeregisterLogMsg: Register resp. deregister a callback to receive log messages. This callback will receive all informational or error messages printed on console. The log messages contain a log level (Info=1, Warn=2, Error=3, Fatal=4) and the log message.</p>
  </li>
  <li>
    <p>SickScanApiGetStatus queries the current status. This function returns the current status code (OK=0 i.e. normal operation, WARN=1, ERROR=2, INIT=3 i.e. initialization after startup or reconnection or EXIT=4) and the descriptional status message.</p>
  </li>
  <li>SickScanApiSendSOPAS sends a SOPAS command (Cola-A) to the lidar and returns the response from the device.
    <ul>
      <li>C++ example:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     char sopas_response_buffer[1024] = { 0 };
     SickScanApiSendSOPAS(apiHandle, "sRN SCdevicestate", &amp;sopas_response_buffer[0], (int32_t)sizeof(sopas_response_buffer); // returns "sRA SCdevicestate \x00" in sopas_response_buffer
     
</code></pre></div></div>

<ul>
  <li>Python example:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     sopas_response = SickScanApiSendSOPAS(sick_scan_library, api_handle, "sRN SCdevicestate")` # returns "sRA SCdevicestate \x00".
      
</code></pre></div></div>
<p>See the telegram listing for valid SOPAS commands.</p>

<ul>
  <li>SickScanApiSetVerboseLevel and SickScanApiGetVerboseLevel sets resp. returns the verbose level. The verbose level can be 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR, 4=FATAL or 5=QUIET (equivalent to ros::console::levels). Default verbose level is 1 (INFO), i.e. sick_scan_xd prints informational, warnings and error messages on the console. Logging callbacks registered with SickScanApiRegisterLogMsg will receive all informational, warnings and error messages independent of the verbose level.</li>
</ul>

<p>To monitor sick_scan_xd resp. the lidar, it is recommended to register a callback for diagnostic messages using SickScanApiRegisterDiagnosticMsg and to display the error message in case for status code 2 (error). See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> for an example.</p>

<h4 id="simulation-and-unit-test">Simulation and unit test</h4>

<p>sick_scan_xd provides a tiny server for offline tests which simulates a basic lidar. It just accepts TCP connections, responds to sopas requests with predefined responses and sends lidar data from file. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CONTRIBUTING.md">Simulation</a> for further details. Note that the simulation does not emulate or replace a lidar, it just supports basic unit tests.</p>

<p>Open a new terminal and run the following steps to test the api against a TiM7xx simulation using the python example mentioned above:</p>

<ol>
  <li>Build library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> incl. emulator with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code>:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./src/build
   pushd ./src/build
   rm -rf ./*
   cmake -DROS_VERSION=0 -DCMAKE_ENABLE_EMULATOR=1 -G "Unix Makefiles" ../sick_scan_xd
   make -j4
   ls -al libsick_scan_xd_shared_lib.so sick_scan_xd_api_test sick_generic_caller sick_scan_emulator # list size and date of the binaries
   popd
   
</code></pre></div></div>
<p>Building sick_scan_xd with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code> requires jsoncpp. Install libjsoncpp by running “sudo apt-get install libjsoncpp-dev” on Linux resp. “vcpkg install jsoncpp:x64-windows” on Windows (vcpkg required). Run the following steps to install Visual Studios package manager vcpkg on Windows:
      * Download vcpkg-master.zip from https://github.com/microsoft/vcpkg/archive/master.zip and unzip to <code class="language-plaintext highlighter-rouge">c:\vcpkg</code>. Alternatively, run “git clone https://github.com/microsoft/vcpkg”
      * Install vcpkg by running the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        cd c:/vcpkg
        bootstrap-vcpkg.bat
        vcpkg integrate install
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  * Include vcpkg in your path:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        set PATH=c:\vcpkg\installed\x64-windows\bin;%PATH%
        
</code></pre></div></div>

<ol>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
  <li>
    <p>Build sick_scan_xd for ROS 1 on Linux, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-ros1">Build on Linux ROS 1</a></p>
  </li>
  <li>
    <p>Start the TiM7xx simulator:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cp -f ./src/sick_scan_xd/test/emulator/scandata/sopas_et_field_test_1_2_both_010.pcapng.json /tmp/lmd_scandata.pcapng.json
   ./src/build/sick_scan_emulator ./src/sick_scan_xd/test/emulator/launch/emulator_01_default.launch &amp;
   sleep 1
   
</code></pre></div></div>

<ol>
  <li>Run sick_scan_xd_api_test.py against the TiM7xx simulator on localhost:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   export PYTHONPATH=.:./src/sick_scan_xd/python/api:$PYTHONPATH
   python3 ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_tim_7xx.launch hostname:=127.0.0.1 port:=2111 sw_pll_only_publish:=False
   
</code></pre></div></div>

<ol>
  <li>Start rviz and visualize the point cloud on topic “/sick_scan_xd_api_test/api_cloud”.</li>
</ol>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) works standalone and does not have any ROS dependencies. The usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> uses ROS for visualization.</p>
</blockquote>

<h3 id="c-api">C-API</h3>

<p>The header file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/include/sick_scan_xd_api/sick_scan_api.h">sick_scan_api.h</a> defines the C-interface. It defines all datatypes, messages and functions of the generic sick_scan_xd API. To allow equal operations on all systems, the definition of datatypes and messages is as close as possible to their equivalents currently used on ROS.</p>

<p>Python file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/python/api/sick_scan_api.py">sick_scan_api.py</a> defines the same interface in python.</p>

<h3 id="useful-links">Useful links</h3>

<p><a href="https://docs.python.org/3/library/ctypes.html">ctypes</a> is used for data exchange and function calls between Python and C-libraries:</p>
<ul>
  <li>https://docs.python.org/3/library/ctypes.html</li>
  <li>https://docs.python.org/3/library/ctypes.html#structures-and-unions</li>
  <li>https://docs.python.org/3/library/ctypes.html#callback-functions</li>
</ul>

<h2 id="timestamps-and-synchronization-software-pll">Timestamps and synchronization (Software PLL)</h2>

<p>Often there is a requirement that the time stamp of the measurements should be calculated for each individual shot. This article explains some background information about the determination of these time stamps. Here the statements refer to the LMS511. However, they can be transferred to other lidars using the same logic.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/lms511_scan.png" alt="lms511_scan.png"></p>

<p>The lidar sends a pulsed beam onto a rotating mirror. Since the speed of rotation is relatively low, this mirror serves as transmitter and receiver. The direction of rotation can be seen in the drawing.</p>

<p>25 scans per second means that the mirror makes 25 360° rounds per second. The actual laser unit is only active during the 190°. Therefore the so-called duty cycle is 190/360. The rotation is unaccelerated, so that the lidar arrives at the same angular direction again after 40 ms (1/25). From the angular distance from shot to shot you can calculate the pulse rate of the laser. For example, if the angular difference from shot to shot is 0.1 degree, the so-called shot rate would be: 360/0.1 * 25 shots/second.</p>

<p>A scan means the group of all shots during one revolution. Just imagine the lidar as a lighthouse that rotates evenly and measures the distance values over time of flight in a certain sector (here 190°) with the above mentioned shot rate. Also you find some background material in the documentation of SICK.</p>

<p>In the transmission protocol of the lidar two points in time are given in so-called ticks (resolution in microseconds):
a) Start of the scans in ticks
b) Start of IP data transfer from lidar to PC in ticks</p>

<p>It is assumed that the transfer between lidar and PC is near latency-free.
The software PLL generates an assignment between the tick of the IP data transmission and the system time of the PC via an estimated line mapping. On the basis of this straight line equation, the start of the scan is then calculated relative to the system time. This generation time stamp is the time of the first shot of the scan. This timestamp is assigned to the point cloud timestamp. From there, the rotation speed and the angular distance from shot to shot can be used to approximately calculate the time for each shot.</p>

<p>A software pll is used to convert LiDAR timestamps in ticks to the ros system time.</p>

<p>Many sensor devices, e.g. lidar devices, provide sensor data with timestamps. These timestamps can be synchronized with the current system time by additional hardware, e.g. by GPS. But without specialized hardware, sensor timestamps and system time is normally unsynchronized. Sensor timestamps are often quite accurate, but have a different time base and a bias to the system time or to other sensor clocks. This difference is estimated and compensated by this Software PLL.</p>

<p>The scanner has an internal time base of microseconds since system startup. Against this “tick” time base all time stamps are made in the scanner. When sending messages from the scanner, two time stamps are added:</p>

<ol>
  <li>scan generation ticks–&gt; timestamp at the time of the first shot</li>
  <li>scan transmission ticks–&gt; time stamp for the transmission of the data</li>
</ol>

<p>When data packets are received, they are timestamped by the driver against the systemtime in ros::time format. See following Fig.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/timing_sync.png" alt="timing_syn.png"></p>

<p>The relationship between system time and ticks is then derived from the time stamps and kept synchronous.The time required for the transmission of data over the network is assumed to be short and constant and is therefore neglected. The function of the algorithms is shown in the following Fig.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sequence_time_pll.png" alt="sequence_time_pll.png"></p>

<p>To compensate the different time base and bias between sensor and system clock, the system time when receiving sensor data is gathered together with the sensor timestamp. While the system time is often measured in seconds resp. nanoseconds, the sensor timestamp is normally received in clock ticks. SoftwarePLL estimates the correlation between system time in secondsnanoseconds and sensor ticks, and computes a corrected time from ticks. This way you know at which time stamp the data
have been measured by your sensor.</p>

<p>SoftwarePLL is a generic module and independant from specific sensor types. It just uses the system timestamps and ticks, estimates their correlation and predicts the time from sensor ticks.SoftwarePLL computes a linear regression between ticks and system timestamps. The system time is measured immediately after receiving new sensor data, while sensor ticks represent the sensor clock at the time of measurement. Thus we have three different times for each measurement</p>

<ul>
  <li>The time when the system receives the sensor data (receive time t_rec), measured in seconds resp. nanoseconds.</li>
  <li>The sensor ticks (or just ticks) at the time of the measurement. These ticks are contained in the sensor data and
received later by the system.</li>
  <li>The time of the measurement (measurement time t_mea). We don’t know this time yet, but we estimate it from both the ticks
and their receive time t_rec using the SoftwarePLL.</li>
</ul>

<p>During initialization, ticks and system timestamps are stored in fifo buffer (first-in, first-out). After initialization,
typically after N=7 measurements, a regression line is computed, i.e. the slope <code class="language-plaintext highlighter-rouge">m</code> (gradient) of a function
<code class="language-plaintext highlighter-rouge">f(ticks) = m  ticks + c</code> is estimated from ticks <code class="language-plaintext highlighter-rouge">x(i)</code> and timestamps <code class="language-plaintext highlighter-rouge">y(i)</code> by a linear regression
<code class="language-plaintext highlighter-rouge">m = (N  sum(x(i)  y(i)) - sum(x(i))  sum(y(i)))  (N  sum(x(i)  x(i)) - sum(x(i))sum(x(i)))</code> with <code class="language-plaintext highlighter-rouge">0 = i  N</code> and
unbiased values <code class="language-plaintext highlighter-rouge">x(i) = tick(i) - tick(0)</code>, <code class="language-plaintext highlighter-rouge">y(i) = t_rec(i) - t_rec(0)</code>.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/pll_regression.png" alt="pll_regression.png"></p>

<p>The estimated system time <code class="language-plaintext highlighter-rouge">t_esti(i)</code> of a measurement can be computed from its sensor tick by <code class="language-plaintext highlighter-rouge">t_esti(i) = m  (ticks(i) - ticks(0)) + t_rec(0)</code>.
If the difference between estimated times <code class="language-plaintext highlighter-rouge">t_esti(i)</code> and the measured system timestamps <code class="language-plaintext highlighter-rouge">t_rec(i)</code> is small (typically
less than 100 milliseconds), the estimation can be considered to be valid. With a valid estimation of <code class="language-plaintext highlighter-rouge">m</code>, we can
get a corrected timestamp for new measurements by applying function <code class="language-plaintext highlighter-rouge">SoftwarePLLGetCorrectedTimeStamp</code>, which returns
the estimated system time of a measurement <code class="language-plaintext highlighter-rouge">t_esti  = m  (ticks - ticks(0)) + t_rec(0)</code>.</p>

<p>If the estimation is not valid (i.e. the difference between estimated times and measured system timestamps in the buffer is
significant), we can’t estimate system timestamps from sensor ticks. If this happens more than a given number of times
after initialization (typically 20 times), the fifo is reset and a new initialization is done.</p>

<p>Use the following code snippet as an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include softwarePLL.h

 Create an instance of SoftwarePLL
SoftwarePLL&amp; software_pll = SoftwarePLLInstance(Sensor1);

 Get system time t_rec in seconds and nanoseconds when receiving sensor data
rosTime t_rec = rosTimenow();
uint32_t sec = t_rec.nsec;
uint32_t nanosec = t_rec.nsec;

 Get sensor ticks from sensor data
uint32_t ticks = scanner_msg.ticks;

 Update SoftwarePLL
software_pll.UpdatePLL(sec, nanosec, ticks);

 Get corrected timestamp (time of measurement from ticks)
software_pll.GetCorrectedTimeStamp(sec, nanosec, ticks);

</code></pre></div></div>

<p><strong>Data buffering in MRS1000</strong></p>

<p>Due to their construction the MRS1000 scanners generate different layers at the same time which are output sequentially by the scanner firmware. In order to ensure that only point cloud messages that follow one another in time are sent, buffering can be activated in the driver.
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/scannbuffering.png" alt="scannbuffering.png"></p>

<h2 id="coordinate-transforms">Coordinate transforms</h2>

<p>Different lidars use different coordinate systems. sick_scan_xd transforms all points of the published pointclouds to the ROS coordinate system, independant of the lidar. The following figure shows the commonly used coordinate systems:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/3d_coordinate_system_comp.png" alt="3d_coordinate_system_comp.png"></p>

<p>An additional coordinate transform can be applied to the pointcloud. This optional transform can be used to transform the pointclouds into a user defined coordinate system. If the lidar is e.g. mounted on a vehicle, the pointclouds can be transformed into a vehicle coordinates.</p>

<p>An additional coordinate transform can be configured by a 6D pose (x, y, z, roll, pitch, yaw) with a translational part (x, y, z) in [m] and a rotational part (roll, pitch, yaw) in [rad].</p>

<p>If configured, it will transform the point cloud from its “cloud” coordinates into user defined “world” coordinate system:</p>

<p><code class="language-plaintext highlighter-rouge">T[world,cloud] with P_world = T[world,cloud] * P_cloud</code> (parent: world, child: cloud)</p>

<p>The final rotation is defined by: Rotation = Rot[yaw] * Rot[pitch] * Rot[roll] with roll = rotation about x-axis, pitch = rotation about y-axis and yaw = rotation about z-axis.</p>

<p>An additional transform can be configured in the launchfile, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- Apply an additional transform to the cartesian pointcloud, default: "0,0,0,0,0,0" (i.e. no transform) --&gt;
&lt;!-- &gt; **_NOTE:_** add_transform_xyz_rpy is specified by 6D pose x, y, z, roll, pitch, yaw in [m] resp. [rad] --&gt;
&lt;!-- It transforms a 3D point in cloud coordinates to 3D point in user defined world coordinates: --&gt;
&lt;!-- add_transform_xyz_rpy := T[world,cloud] with parent "world" and child "cloud", i.e. P_world = T[world,cloud] * P_cloud --&gt;
&lt;param name="add_transform_xyz_rpy" type="string" value="0,0,0,0,0,0" /&gt;

</code></pre></div></div>

<p>Default value is <code class="language-plaintext highlighter-rouge">"0,0,0,0,0,0"</code>, i.e. no additional transform will be applied.</p>

<p>The additional transform applies to cartesian lidar pointclouds and visualization marker (fields).
It is <strong>NOT</strong> applied to polar point clouds, radarscans, LD-MRS objects or other messages.</p>

<p>Note that sick_scan_xd configures an additional transform using (x, y, z, roll, pitch, yaw). In contrast, the ROS static_transform_publisher uses commandline arguments in order x, y, z, yaw, pitch, roll.</p>

<p>Example using ROS static_transform_publisher with x=0, y=0, z=0, roll=15, pitch=-10, yaw=5 [deg]:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source /opt/ros/noetic/setup.bash
# static_transform_publisher x y z yaw pitch roll frame_id child_frame_id period_in_ms
# tf_echo &lt;source_frame&gt; &lt;target_frame&gt;
# rot_x = 5 deg: 0.0872665, rot_y = -10 deg: -0.1745329, rot_z = 15 deg: 0.2617994
rosrun tf static_transform_publisher 0 0 0 0.2617994 -0.1745329 0.0872665 parent_frame child_frame 100
rosrun tf tf_echo parent_frame child_frame

</code></pre></div></div>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/doc/sick_scan_api/trafo_example.py">trafo_example.py</a> demonstrates how a transform can be computed.</p>

<p>For upside down mounted devices, the point cloud can be rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lrs_36x0_upside_down.launch">sick_lrs_36x0_upside_down.launch</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lrs_36x1_upside_down.launch">sick_lrs_36x1_upside_down.launch</a> show examples for compensating the point cloud of an upside down mounted device by a 180 deg rotation about the x axis.</p>

<h2 id="imu-support">IMU Support</h2>

<p>Devices of the MRS6xxx and MRS1xxx series are available with an optionally built-in IMU.</p>

<p>For the IMU support of multiScan100 and picoScan100 refer to the device specific section.</p>

<p>By setting the following config parameter in the launch file, the output of <a href="http://docs.ros.org/melodic/api/sensor_msgs/html/msg/Imu.html">imu messages</a> can be enabled with a compatible scanner. Currently the messages are published in the /imu Topic.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_enable"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">value=</span><span class="s">"True"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_topic"</span> <span class="na">type=</span><span class="s">"string"</span> <span class="na">value=</span><span class="s">"imu"</span><span class="nt">/&gt;</span>

</code></pre></div></div>
<p>The imu Messages contain covariance matrices, these are currently determined from empirical values and are not measured specifically for each scanner.
The laser scanner provides additional information (tick timestamp and confidence) to the Imu messages these can be activated by activating the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/msg/SickImu.msg">SickImu messages</a>.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_enable_additional_info"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">value=</span><span class="s">"True"</span> <span class="nt">/&gt;</span>

</code></pre></div></div>

<p>IMU messages are only supported in SOPAS binary mode. Due to the high data rate of the IMU messages (100 Hz and more) while sending the standard laser scanner messages at the same time, the ASCII mode is not supported. Please set the scanner to binary mode if you are using the IMU.</p>

<h2 id="encoders">Encoders</h2>

<p>If the device is mounted for mobile use or if the objects to be measured are in motion,the application will usually also need position data to further process the measured val‐ues.Encoders can be connected for this purpose. The encoder data is then available withthe other measured values in a single scan and at the same interface. A volume,for example, can be calculated by evaluating the measurement data. The input fre‐quency of the encoder signal must not exceed 50 kHz.The following encoders with push-pull output stage can be used:</p>
<ol>
  <li>Single-channel, only connected at encoder A, no direction detection.</li>
  <li>Dual-channel (phase), connected at encoder A and encoder B; the pulses have aphase shift of 90°, making direction detection possible. By definition, during for‐ward motion (CW = clockwise) phase A precedes phase B; conversely, duringreverse motion (CCW = counterclockwise) edge A rises before edge B.</li>
  <li>Dual-channel (level), connected at encoder A and encoder B; the pulses are atencoder A; at encoder B, the direction is indicated by level 0 or level 1 (rarely).</li>
</ol>

<h3 id="connecting-encoders">Connecting encoders</h3>
<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/lms4xxx_encoder_connection.png" alt="LMS4000 encoder connection" title="LMS4000 encoder connection">
See also <a href="https://cdn.sick.com/media/docs/0/90/790/Operating_instructions_LMS4000_2D_LiDAR_sensors_en_IM0079790.PDF">LMS4000 Manual</a></p>

<h3 id="example-circuit-to-trigger-encoder-counts">Example circuit to trigger encoder counts</h3>
<p>Whenever the switch is closed a potential of 24 V is applied to the encoder input A in mode (01 single-channel) this leads to an increase of the count by 1.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/circuit.png" alt="encoder trigger" title="encoder trigger"></p>

<h3 id="activation-of-encoder-information">Activation of encoder information</h3>
<p>If the parameter</p>
<pre><code class="language-encoder_mode">``` is set to 1-4 in the launch file, the encoder is activated in the laser scanner in the corresponding mode (see list above).

The following encoder modes can be configured in the launch file or by commandline parameter:
* `encoder_mode:=-1`: Default value, i.e. encoder configuration not set
* `encoder_mode:=0`: Encoder off (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=1`: Single increment (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=2`: Direction recognition phase (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=3`: Direction recognition level (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=4`: Fixed increment speed/ticks (supported by LMS4000 only)

Encoder messages are published on topic `/encoder` synchronously to the point cloud messages. They contain a timestamp and the encoder value, e.g.:

```console
foo@bar:~$rostopic echo /encoder
header:
  seq: 20700
  stamp:
    secs: 1570722972
    nsecs:  28866142
  frame_id: "Encoder"
enc_count: 836
---
header:
  seq: 20701
  stamp:
    secs: 1570722972
    nsecs:  30598181
  frame_id: "Encoder"
enc_count: 836
---
header:
  seq: 20702
  stamp:
    secs: 1570722972
    nsecs:  32138020
  frame_id: "Encoder"
enc_count: 836

</code></pre>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/Encoder_data.png" alt="Encoderdata in Sopas datagramm" title="Encoderdata in Sopas datagramm"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/set_encoder_settings.png" alt="Set encoder config" title="Set encoder config"></p>

<h2 id="field-evaluation-information">Field Evaluation Information</h2>

<p>The LMS1xx, LMS5xx, TiM7xx and TiM7xxS families support extensions for field monitoring.</p>

<h3 id="field-monitoring-messages">Field monitoring messages</h3>

<p>LMS1xx, LMS5xx, TiM7xx and TiM7xxS scanner support field monitoring. Fields can be configured by Sopas ET. Once they are configured, sick_scan_xd publishes ros messages containing the monitoring information from the lidar.</p>

<p>By default, field monitoring is enabled in the launch files <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lms_1xx.launch">sick_lms_1xx.launch</a>,  <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lms_5xx.launch">sick_lms_5xx.launch</a>,
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_tim_7xx.launch">sick_tim_7xx.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_tim_7xxS.launch">sick_tim_7xxS.launch</a> by following settings:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="activate_lferec" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lferec messages --&gt;
&lt;param name="activate_lidoutputstate" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lidoutputstate messages --&gt;
&lt;param name="activate_lidinputstate" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lidinputstate messages --&gt;

</code></pre></div></div>

<p>The driver queries the field configuration from the lidar and activates field monitoring by sending cola commands <code class="language-plaintext highlighter-rouge">"sEN LFErec 1"</code> and <code class="language-plaintext highlighter-rouge">"sEN LIDoutputstate 1"</code> at startup. Field monitoring is deactivated when driver exits. During runtime, it’s possible to query, activate or deactivate monitoring using ros service ColaMsg with the following command (see section <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#cola-commands">Cola commands</a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LFErec 1'}" # activate LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LFErec 0'}" # deactivate LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LFErec'}"   # query activation status of LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDoutputstate 1'}" # activate LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDoutputstate 0'}" # deactivate LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LIDoutputstate'}"   # query activation status of LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDinputstate 1'}"  # activate LIDinputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDinputstate 0'}"  # deactivate LIDinputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LIDinputstate'}"    # query activation status of LIDinputstate messages

</code></pre></div></div>

<p>LFErec and LIDoutputstate messages are defined in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/msg/LFErecMsg.msg">LFErecMsg.msg</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/msg/LFErecFieldMsg.msg">LFErecFieldMsg.msg</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/msg/LIDoutputstateMsg.msg">LIDoutputstateMsg.msg</a> and published on the following topics: <code class="language-plaintext highlighter-rouge">"/sick_tim_7xxS/lferec"</code> resp. <code class="language-plaintext highlighter-rouge">"/sick_tim_7xxS/lidoutputstate"</code>.</p>

<table>
  <thead>
    <tr>
      <th>** Lidar **</th>
      <th>** lferec topic **</th>
      <th>** lidoutputstate topic **</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>lms_1xx</td>
      <td>/sick_lms_1xx/lferec</td>
      <td>/sick_lms_1xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_5xx</td>
      <td>/sick_lms_5xx/lferec</td>
      <td>/sick_lms_5xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_7xx</td>
      <td>/sick_tim_7xx/lferec</td>
      <td>/sick_tim_7xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_7xxS</td>
      <td>/sick_tim_7xxS/lferec</td>
      <td>/sick_tim_7xxS/lidoutputstate</td>
    </tr>
  </tbody>
</table>

<p>To view the field monitoring messages, run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic echo "/sick_lms_1xx/lferec"
rostopic echo "/sick_lms_1xx/lidoutputstate"
rostopic echo "/sick_lms_5xx/lferec"
rostopic echo "/sick_lms_5xx/lidoutputstate"
rostopic echo "/sick_tim_7xx/lferec"
rostopic echo "/sick_tim_7xx/lidoutputstate"
rostopic echo "/sick_tim_7xxS/lferec"
rostopic echo "/sick_tim_7xxS/lidoutputstate"

</code></pre></div></div>
<p>or use rviz to visualize monitored fields and their status (see section <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#visualization-with-rviz">Visualization with rviz</a>)</p>

<p>The most important values of the field monitoring messages are</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">field_index</code> (uint8) and <code class="language-plaintext highlighter-rouge">field_result_mrs</code> (uint8) for each field of a LFErec message with result status<br>&lt;ul&gt;
    </li>
<li>0: invalid / incorrect,</li>
    <li>1: free / clear, or</li>
    <li>2: infringed.</li>
    <p>&lt;/ul&gt;</p>
  
  <li>
<code class="language-plaintext highlighter-rouge">output_state</code> (uint8) for each LIDoutputstate message with status 0 (not active), 1 (active) or 2 (not used).</li>
</ul>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Field monitoring currently supports binary cola messages only, which is the default. If cola ascii is activated, please switch back to cola binary for field monitoring.</p>
</blockquote>

<h3 id="visualization-with-rviz">Visualization with rviz</h3>

<p>The point cloud, the monitored fields and their status can be visualized using rviz. Use the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/emulator/config/rviz_emulator_cfg.rviz">rviz configuration file</a>
and run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz

</code></pre></div></div>

<p>Otherwise you can just add visualizations of type <code class="language-plaintext highlighter-rouge">/cloud/PointCloud2</code> and <code class="language-plaintext highlighter-rouge">/sick_tim_7xxS/marker</code> (resp. <code class="language-plaintext highlighter-rouge">/sick_tim_1xx/marker</code> for lms_1xx,  <code class="language-plaintext highlighter-rouge">/sick_tim_5xx/marker</code> for lms_5xx and  <code class="language-plaintext highlighter-rouge">/sick_tim_7xx/marker</code> for tim_7xx):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/tim7xxs_screenshot01.png" alt="tim7xxs_screenshot01.png"></p>

<p>The following screenshot shows a TiM781S example with 2 fields (the 3. field is not configured), the first field with status “Clear”, the second with status “Infringed”:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/tim7xxs_screenshot02.png" alt="tim7xxs_screenshot02.png"></p>

<p>The following screenshot shows a LMS511 example with a segmented field, two rectangular fields and a dynamic fields:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/lms511_screenshot01.png" alt="lms511_screenshot01.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Some combinations of rviz, OpenGL 3, VMware and graphic card drivers may cause visualization issues. In case of missing markers, try rviz with Open GL 2 using the command</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz --opengl 210

</code></pre></div></div>

<h3 id="cola-commands">Cola commands</h3>

<p>Cola commands can be sent for diagnosis and development using the ros service ColaMsg. This service is implemented in sick_scan_xd and started by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="start_services" type="bool" value="True"/&gt;

</code></pre></div></div>
<p>in the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_tim_7xxS.launch">sick_tim_7xxS.launch</a> (resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lms_1xx.launch">sick_lms_1xx.launch</a>, <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_lms_5xx.launch">sick_lms_5xx.launch</a>, <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_tim_7xx.launch">sick_tim_7xx.launch</a> ). The ros service sends the given cola command to the lidar and returns its response.</p>

<p>Example for cola command <code class="language-plaintext highlighter-rouge">"sRN SCdevicestate"</code> and response <code class="language-plaintext highlighter-rouge">"sRA SCdevicestate \\x00"</code> with error status 0 (no error):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN SCdevicestate'}"
response: "sRA SCdevicestate \\x00"

</code></pre></div></div>

<h3 id="tools-emulation-and-unittests">Tools, emulation and unittests</h3>

<p>Package sick_scan_xd implements some tools to support unittests, development and emulation of Tim781S devices:</p>

<ul>
  <li>sick_scan_emulator to emulate lidar devices and enable unittests (currently for Tim781S only)</li>
  <li>pcap_json_converter to convert pcapng-files to json.</li>
</ul>

<h4 id="lms-and-tim-emulation">LMS and TiM emulation</h4>

<p>sick_scan_emulator implements a simple test server for cola commands. It rececives Cola-commands, returns Tim781S-like responses and sends Scandata from a json-file. Run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_01_default.launch

</code></pre></div></div>
<p>to emulate a local Tim781S device. Then start and connect the sick_scan_xd driver by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>Note that sick_scan_emulator just implements a simple server for offline tests. It does not emulate a lidar device completely and should only be used for development and testing.</p>

<p>Scandata messages are parsed from json-file(s). These json-files are configured in the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/emulator/launch/emulator_01_default.launch">emulator.launch</a> and converted form wireshark-records (pcapng-files) using pcap_json_converter.py (see section Pcapng converter tool](#pcapng-converter-tool)).</p>

<p>A LMS111 device can be emulated by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_lms1xx.launch &amp;
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms1xx.rviz &amp;
roslaunch sick_scan_xd sick_lms_1xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>A LMS511 device can be emulated by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_lms5xx.launch &amp;
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms5xx.rviz &amp;
roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<h4 id="unittests">Unittests</h4>

<p>Folder <code class="language-plaintext highlighter-rouge">test/emulator/scandata</code> contains scandata examples for unittests. To run an offline unittest for LMS111, LMS511, TiM781, TiM781S enter the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd test/scripts
./run_simu_lms1xx.bash
./run_simu_lms5xx.bash
./run_simu_tim7xx_tim7xxS.bash

</code></pre></div></div>
<p>or start emulator, driver and rviz by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1
# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz --opengl 210 &amp;
sleep 1
# Start sick_scan_xd driver for TiM871S
roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<h4 id="pcapng-converter-tool">Pcapng converter tool</h4>

<p>The pcapng converter tool <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/pcap_json_converter/pcap_json_converter.py">pcap_json_converter.py</a> converts pcapng-files to json-files. Run the following steps to create a json-file with scandata for the emulator:</p>

<ol>
  <li>Start wireshark and filter the tcp traffic on port 2112 with the filter expression <code class="language-plaintext highlighter-rouge">tcp and tcp.port==2112</code>.</li>
  <li>Start TiM781S and run the sick_scan_xd driver.</li>
  <li>Capture the network traffic for some time.</li>
  <li>Stop capturing and save the network traffic in a pcapng-file.</li>
  <li>Convert the pcapng-file to json by <code class="language-plaintext highlighter-rouge">python pcap_json_converter.py --pcap_filename=&lt;filepath&gt;.pcapng</code>. Result is a jsonfile <code class="language-plaintext highlighter-rouge">&lt;filepath&gt;.pcapng.json</code>
</li>
  <li>Set the resulting json-file in the emulator configuration <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/test/emulator/launch/emulator_01_default.launch">emulator.launch</a> by <code class="language-plaintext highlighter-rouge">&lt;arg name="scandatafiles" default="&lt;filepath&gt;.pcapng.json"/&gt;</code>
</li>
</ol>

<h2 id="slam-support">SLAM Support</h2>

<h3 id="introduction">Introduction</h3>

<p>In robotic mapping and navigation, simultaneous localization and mapping (SLAM) is the computational problem of constructing or updating a map of an unknown environment while simultaneously keeping track of an agent’s location within it. For further details please refer to https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping .</p>

<h3 id="measuring-principle">Measuring Principle</h3>

<p>The following assumes that the SLAM algorithm works with a laser scanner mounted on a mobile base. The mobile base (e.g. a robot) records the environment while driving and creates the map from it. The mobile base usually has a so-called intertial measurement unit (IMU). In principle, however, it is also possible to estimate the direction of movement from the chronological sequence of the laser scans by means of correlation observations. The laser scanner then virtually takes over the task of the IMU and other components (e.g. counting the wheel revolutions). The method of estimating the position and orientation (position estimation) of a mobile system based on data from its driving system is called odometry (cf. https://en.wikipedia.org/wiki/Odometry).</p>

<p>The SLAM algorithm hector_slam (http://wiki.ros.org/hector_slam) supports odometry estimation directly from the laser scans and is therefore used as a reference implementation in the following.</p>

<p>Other widely used SLAM algorithms such as gmapping (cf. http://wiki.ros.org/gmapping ) do not have this option. They depend on the data of an IMU. One possibility to use Gmapping nevertheless is the integration of the project laser_scan_matcher (https://answers.ros.org/question/63457/gmapping-without-odom/ and http://wiki.ros.org/laser_scan_matcher ).  Here, however, the pose must still be converted into an odometry message (see https://answers.ros.org/question/12489/obtaining-nav_msgsodometry-from-a-laser_scan-eg-with-laser_scan_matcher/ ).</p>

<h3 id="nav350-ros-1-slam-example">NAV350 ROS 1 SLAM example</h3>

<p>Build hector_slam and sick_scan_xd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd src
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
git clone https://github.com/tu-darmstadt-ros-pkg/hector_slam.git
cd ..
catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DCMAKE_ENABLE_EMULATOR=1 -Wno-dev

</code></pre></div></div>

<p>Run rviz, sick_scan_xd with NAV350 and hector_slam:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./devel_isolated/setup.bash
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_slam_nav350.rviz &amp;
roslaunch sick_scan sick_nav_350.launch hostname:=192.168.0.1 tf_publish_rate:=0 &amp;
roslaunch sick_scan test_200_slam_ros1_hector.launch scan_topic:=/scan scan_layer_0_frame_id:=cloud_POS_000_DIST1 cloud_frame_id:=cloud &amp;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  By default, sick_scan_xd publishes transform (TF) messages, which map frame id “map” to the point cloud frame id. To avoid conflicts with hector SLAM, it is recommended to disable these TF messages by commandline parameter <strong><code class="language-plaintext highlighter-rouge">tf_publish_rate:=0</code></strong> or by setting <code class="language-plaintext highlighter-rouge">&lt;param name="tf_publish_rate" type="double" value="0"/&gt;</code> in the launchfile.</p>
</blockquote>

<p>The following rviz screenshot shows an example of a NAV350 pointcloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/slam_example_ros1_nav350.png" alt="slam_example_ros1_nav350.png"></p>

<h3 id="nav350-ros-2-slam-example">NAV350 ROS 2 SLAM example</h3>

<p>Install ths ROS 2 slam-toolbox with <code class="language-plaintext highlighter-rouge">sudo apt install ros-foxy-navigation2 ros-foxy-nav2-bringup ros-foxy-slam-toolbox</code> (replace <code class="language-plaintext highlighter-rouge">foxy</code> by your ros distribution).</p>

<p>Build sick_scan_xd for ROS 2 as described in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#install-on-ros-2">INSTALL ROS 2</a></p>

<p>Run rviz2, sick_scan_xd, slam_toolbox and static transforms:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
ros2 run rviz2 rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_slam_nav350.rviz &amp;
ros2 launch sick_scan sick_nav_350.launch.py hostname:=192.168.0.1 tf_publish_rate:=0 &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 base_link cloud  &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 base_footprint base_link  &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 odom base_footprint  &amp;
ros2 launch nav2_bringup navigation_launch.py &amp;
ros2 launch slam_toolbox online_async_launch.py &amp;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Laserscan messages need to be remapped to topic <code class="language-plaintext highlighter-rouge">/scan</code> (default is <code class="language-plaintext highlighter-rouge">/sick_nav_350/scan</code>). Use <code class="language-plaintext highlighter-rouge">remappings=[ ('/sick_nav_350/scan', '/scan'), ]</code> in the launchfile, e.g.:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node = Node(
    package='sick_scan',
    executable='sick_generic_caller',
    output='screen',
    remappings=[ ('/sick_nav_350/scan', '/scan'), ], # remap laserscan messages to topic /scan
)

</code></pre></div></div>

<p>The following rviz2 screenshot shows an example of a NAV350 laserscan created by sick_scan_xd and its map generated by slam_toolbox on ROS 2:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/slam_example_ros2_nav350.png" alt="slam_example_ros2_nav350.png"></p>

<h3 id="picoscan100-ros-1-slam-example">picoScan100 ROS 1 SLAM example</h3>

<p>Run rviz, sick_scan_xd with picoScan100 and hector_slam:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./devel_isolated/setup.bash
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_slam_multiscan.rviz &amp;
roslaunch sick_scan sick_nav_350.launch hostname:=192.168.0.1 hostname:=127.0.0.1 udp_receiver_ip:=192.168.0.100 tf_publish_rate:=0 &amp;
roslaunch sick_scan test_200_slam_ros1_hector.launch scan_topic:=/sick_picoscan/scan_fullframe scan_layer_0_frame_id:=world_1 cloud_frame_id:=world &amp;

</code></pre></div></div>
<p>Replace ip address <code class="language-plaintext highlighter-rouge">192.168.0.100</code> with the ip address of your local machine running sick_scan_xd.</p>

<p>The following rviz screenshot shows an example of a picoScan100 point cloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/slam_example_ros1_picoscan.png" alt="slam_example_ros1_picoscan.png"></p>

<h3 id="mrs1104-slam-support">MRS1104 SLAM support</h3>

<p>MRS1104 provides 4 layers covering elevation angles at -2.5°, 0.0°, 2.5° and 5.0°. The layer with 0.0° is used for SLAM by default. The following rviz screenshot shows an example of a MRS1104 point cloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/slam_example_ros1_mrs1104.png" alt="slam_example_ros1_mrs1104.png"></p>

<p>Since Hector-Slam expects only one laser scan frame with a unique identifier for the laser scans, the following parameters were added to the driver.</p>

<p>slam_echo: The name of the echo is entered here, which is filtered out of all possible 12 echoes. This should be “laser_POS_000_DIST1”. This exports the first hit in the position with an elevation angle of 0°. If you want to use the layers with elevation angles -2.5°, 2.5° and 5.0°, you can set another flag with the name slam_bundle to True. If this flag is set, the oblique distances are multiplied by the cosine in this direction to obtain the projection onto the XY plane. This quadruples the number of points and increases the scan rate from 12.5 Hz to 50 Hz. However, for oblique impact surfaces (i.e. no vertical walls) this method can lead to larger estimation errors. In this case slam_bundle should be set to false.</p>

<h3 id="google-cartographer">Google Cartographer</h3>

<p>The support of Google Cartographer was made possible by a number of extensions to the driver. On the driver side, the MRS1104 is prepared to support the Google Cartographer. The Google Cartographer expects data packets at a high recording density (several hundred packets per second) to perform the SLAM algorithm. For this reason, an option has been introduced that allows the scans to be chopped into small angular ranges. The time stamps for these small ranges were converted accordingly.</p>

<p>Setup Google Cartographer (these steps are for illustration only, you must adapt these lines to your local directory names)</p>

<ol>
  <li>Login to Ubuntu.</li>
  <li>Open multiple terminals.</li>
  <li>Terminal 1:
. ros1_start.sh
roscore</li>
  <li>Terminal 2:
  . ros1_start.sh
cd ~/ros_catkin_ws
source ./devel/setup.bash</li>
  <li>Terminal 3:
roslaunch sick_scan_xd sick_mrs_1xxx_cartographer.launch cloud_topic:=horizontal_laser_3d frame_id:=horizontal_vlp16_link</li>
  <li>Terminal 4:
roslaunch sick_scan_xd sick_tim_5xx.launch cloud_topic:=vertical_laser_3d frame_id:=vertical_vlp16_link hostname:=192.168.0.71</li>
  <li>
    <p>Terminal 5:</p>

    <ul>
      <li>. ros1_start.sh</li>
      <li>cd ~/ros_cartographer_ws</li>
      <li>source ./install_isolated/setup.bash</li>
      <li>catkin_make_isolated</li>
      <li>roslaunch cartographer_ros live_demo_backpack_3d.launch</li>
    </ul>
  </li>
</ol>

<p><strong>Example output</strong></p>

<p>The following figure shows an example of an outdoor slam result using a MRS1104:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/slam_example.png" alt="slam_example"></p>

<h3 id="octomap">OctoMap</h3>

<p><a href="https://github.com/OctoMap">OctoMap</a> models a 3D occupancy map. The octomap_server builds and distributes volumetric 3D occupancy maps from a 3D point cloud. Tutorials and examples can be found e.g. in <a href="https://www.arminhornung.de/Research/pub/hornung13roscon.pdf">3D Mapping with OctoMap</a>, <a href="https://github.com/tejalbarnwal/octomap_tutorial">octomap_tutorial</a> and <a href="https://www.youtube.com/watch?v=dF2mlKJqkUg">Basic usage of octomap_mapping</a>. Note that OctoMap is not a fully SLAM algorithm, but it can create 2D and 3D maps from point clouds.</p>

<p>Run the following steps to build and run OctoMap and sick_scan_xd with a multiScan100 lidar on ROS 1:</p>
<ol>
  <li>Clone OctoMap + sick_scan_xd:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone https://github.com/SICKAG/sick_scan_xd.git
    git clone https://github.com/OctoMap/octomap_ros.git
    git clone https://github.com/OctoMap/octomap_msgs.git
    git clone https://github.com/OctoMap/octomap_mapping.git
    popd
    
</code></pre></div></div>
<ol>
  <li>Set topic and frame_id for multiScan100 in octomap_mapping.launch:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="frame_id" type="string" value="world" /&gt;
    &lt;remap from="cloud_in" to="/cloud_unstructured_fullframe" /&gt;
    
</code></pre></div></div>
<ol>
  <li>Build:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
    
</code></pre></div></div>
<ol>
  <li>Run OctoMap + sick_scan_xd:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Run sick_scan_xd + multiScan100
    roslaunch sick_scan_xd sick_multiscan.launch hostname:="192.168.0.1" udp_receiver_ip:=" 192.168.0.100"
    # Run octomap_server
    roslaunch octomap_server octomap_mapping.launch
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Replace parameter "hostname" with the ip address of the multiScan100 lidar and "udp_receiver_ip" with the ip address of the PC running sick_scan_xd. 5. Visualize OctoMap with rviz:
* Add MarkerArray topic "/occupied_cells_vis_array“ (colored voxels)
* Add Map topic "/projected_map“ (gray 2D Projection) 6. Save the OctoMap:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rosrun octomap_server octomap_saver -f ./octomap_multiscan.bt
    
</code></pre></div></div>
<ol>
  <li>Publish the saved OctoMap:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rosrun octomap_server octomap_server_node ./octomap_multiscan.bt
    
</code></pre></div></div>
<p>The following screenshot shows an example of an octomap created from a multiScan100 point cloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/octomap_example_ros1_multiscan.png" alt="octomap_example_ros1_multiscan"></p>

<h3 id="rtab-map">RTAB-Map</h3>

<p><a href="https://introlab.github.io/rtabmap/">RTAB-Map</a> (Real-Time Appearance-Based Mapping) is a RGB-D, Stereo and Lidar Graph-Based SLAM approach, which can be used for 3D-SLAM in combination with multiScan100 or other SICK lidars. sick_scan_xd provides a 3D-SLAM example using RTAB-Map with the multiScan100 lidar. The following section describes how to install and run RTAB-Map with sick_scan_xd and a multiScan.</p>

<h4 id="install-on-ros-1">Install on ROS 1</h4>

<p>Run the following steps to build rtabmap and sick_scan_xd with on ROS 1:</p>

<ol>
  <li>Build the prerequisites for RTAB-Map:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo apt-get install libboost-all-dev
    sudo apt-get install libeigen3-dev
    sudo apt-get install libsdl-image1.2-dev
    sudo apt-get install libsdl-dev
    sudo apt-get install ros-noetic-nav-msgs
    sudo apt-get install ros-noetic-tf2-sensor-msgs
    sudo apt-get install ros-noetic-imu-filter-madgwick
    sudo apt-get install python3-wstool
    sudo apt-get install ros-noetic-scan-tools
    pushd /tmp
    mkdir -p libnabo/build &amp;&amp; pushd libnabo/build
    cmake ..
    cmake --build .
    sudo cmake --build . --target install
    popd
    mkdir -p libpointmatcher/build &amp;&amp; pushd libpointmatcher/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    mkdir -p rtabmap/build &amp;&amp; pushd rtabmap/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    popd
    
</code></pre></div></div>
<ol>
  <li>Build RTAB-Map and sick_scan_xd in your workspace:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone https://github.com/ros-planning/navigation.git
    git clone https://github.com/ros-planning/navigation_msgs.git
    git clone https://github.com/introlab/rtabmap_ros.git
    git clone https://github.com/SICKAG/sick_scan_xd.git
    popd
    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
    sudo ldconfig
    
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">sudo ldconfig</code> if you encounter errors while loading shared libraries.</p>

<p>Note that building rtabmap with libpointermatch is highly recommended.</p>

<h4 id="run-rtab-map-and-multiscan100-on-ros-1">Run RTAB-MAP and multiScan100 on ROS 1</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan_rtabmap.launch">sick_multiscan_rtabmap.launch</a> provides a launch file to run 3D-SLAM using rtabmap and sick_scan_xd with a multiScan100 lidar. The SLAM parameters are just examples taken from <a href="https://github.com/introlab/rtabmap_ros/blob/master/rtabmap_examples/launch/test_ouster.launch">rtabmap_examples/launch/test_ouster.launch</a>. Run <code class="language-plaintext highlighter-rouge">rosrun rtabmap_slam rtabmap --params</code> to see all RTAB-Map options, parameters and their meaning and adopt launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan_rtabmap.launch">sick_multiscan_rtabmap.launch</a> if required.</p>

<p>Run the following command to start rtabmap and sick_scan_xd with a multiScan100 lidar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install_isolated/setup.bash
roslaunch sick_scan_xd sick_multiscan_rtabmap.launch hostname:="191.168.0.1" udp_receiver_ip:=" 191.168.0.100"

</code></pre></div></div>
<p>Replace parameter “hostname” with the ip address of the multiScan100 lidar and “udp_receiver_ip” with the ip address of the PC running sick_scan_xd. The following screenshot shows an example of RTAB-MAP and a multiScan100 point cloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/rtabmap_example_ros1_multiscan.png" alt="rtabmap_example_ros1_multiscan"></p>

<p>To visualize SLAM results, add e.g. topics <code class="language-plaintext highlighter-rouge">/rtabmap/grid_map</code>, <code class="language-plaintext highlighter-rouge">/rtabmap/localization_pose</code> and <code class="language-plaintext highlighter-rouge">/rtabmap/odom</code> in rviz.</p>

<p>rtabmap provides services to switch to mapping or localization mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /rtabmap/resume                # resume after pause
rosservice call /rtabmap/trigger_new_map       # start a new map
rosservice call /rtabmap/set_mode_mapping      # set mapping mode
rosservice call /rtabmap/set_mode_localization # set localization mode

</code></pre></div></div>

<p>Alternatively, you can use the options in rtabmap-viz:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/rtabmap_viz_options.png" alt="rtabmap_viz_options"></p>

<h4 id="install-on-ros-2">Install on ROS 2</h4>

<p>Building rtabmap and sick_scan_xd on ROS 2 is similar to ROS 1. Run the following steps to build rtabmap and sick_scan_xd with on ROS 2:</p>

<ol>
  <li>Build the prerequisites for RTAB-Map:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo apt-get install libboost-all-dev
    sudo apt-get install libeigen3-dev
    sudo apt-get install libsdl-image1.2-dev
    sudo apt-get install libsdl1.2-dev
    sudo apt-get install ros-humble-nav-msgs
    sudo apt-get install ros-humble-tf2-sensor-msgs
    sudo apt-get install ros-humble-imu-filter-madgwick
    sudo apt-get install python3-wstool
    sudo apt-get install ros-humble-scan-tools
    sudo apt install ros-humble-pcl-ros
    pushd /tmp
    git clone https://github.com/introlab/rtabmap.git rtabmap
    git clone https://github.com/ethz-asl/libnabo.git libnabo
    git clone https://github.com/ethz-asl/libpointmatcher.git libpointmatcher
    mkdir -p libnabo/build &amp;&amp; pushd libnabo/build
    cmake ..
    cmake --build .
    sudo cmake --build . --target install
    popd
    mkdir -p libpointmatcher/build &amp;&amp; pushd libpointmatcher/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    mkdir -p rtabmap/build &amp;&amp; pushd rtabmap/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    popd
    
</code></pre></div></div>
<ol>
  <li>Build RTAB-Map and sick_scan_xd in your workspace:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone --branch ros2 https://github.com/introlab/rtabmap_ros.git rtabmap_ros
    git clone https://github.com/SICKAG/sick_scan_xd.git
    popd
    rosdep update &amp;&amp; rosdep install --from-paths src --ignore-src -r -y
    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    colcon build --symlink-install --cmake-args " -DROS_VERSION=2" " -DCMAKE_ENABLE_EMULATOR=1" "-DCMAKE_BUILD_TYPE=Release" --event-handlers console_direct+
    sudo ldconfig
    
</code></pre></div></div>

<h4 id="run-rtab-map-and-multiscan100-on-ros-2">Run RTAB-MAP and multiScan100 on ROS 2</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan_rtabmap.launch.py">sick_multiscan_rtabmap.launch.py</a> provides a launch file to run 3D-SLAM using rtabmap and sick_scan_xd with a multiScan100 lidar. The SLAM parameters are examples taken from <a href="https://github.com/introlab/rtabmap_ros/blob/master/rtabmap_examples/launch/test_ouster.launch">rtabmap_examples/launch/test_ouster.launch</a>.</p>

<p>Run the following command to start rtabmap and sick_scan_xd with a multiScan100 lidar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
ros2 launch sick_scan_xd sick_multiscan_rtabmap.launch.py hostname:="191.168.0.1" udp_receiver_ip:=" 191.168.0.100"

</code></pre></div></div>
<p>Replace parameter “hostname” with the ip address of the multiScan100 lidar and “udp_receiver_ip” with the ip address of the PC running sick_scan_xd.</p>

<p>rtabmap provides services to switch to mapping or localization mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /rtabmap/resume std_srvs/srv/Empty                # resume after pause
ros2 service call /rtabmap/trigger_new_map std_srvs/srv/Empty       # start a new map
ros2 service call /rtabmap/set_mode_mapping std_srvs/srv/Empty      # set mapping mode
ros2 service call /rtabmap/set_mode_localization std_srvs/srv/Empty # set localization mode

</code></pre></div></div>

<h2 id="raspberry-pi-support">Raspberry Pi Support</h2>

<p>sick_scan_xd supports Linux on Raspberry Pi 4. Follow the build instructions for Linux to run sick_scan_xd on a Raspberry:</p>
<ul>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-generic-without-ros">Build on Linux generic without ROS</a></li>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-ros-1">Build on Linux ROS 1</a></li>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#build-on-linux-ros-2">Build on Linux ROS 2</a></li>
</ul>

<p>Cmake option “ -DRASPBERRY=1” activates compiler settings for the Raspberry. Laserscan messages and polar pointclouds are not published on the Raspberry due to performance reasons.</p>

<h3 id="multiscan100-example">multiScan100 example</h3>

<p>The following screenshot shows sick_scan_xd running under ROS 1 on a Raspberry Pi 4 connected to a multiScan100 lidar. A Linux-PC uses rviz to display the fullframe point cloud generated on the Raspberry. The ssh-terminal shows the sick_scan_xd log messages on the Raspberry:
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/raspberry-perftest-04.png" alt="screenshot raspberry performance test"></p>

<p>On a Raspberry Pi 4, sick_scan_xd processes 240 messages/second with a mean latency of 2.7 milliseconds/message.</p>

<h3 id="performance">Performance</h3>

<p>Due to the low power consumption of a Raspberry Pi, performance is critical for applications using sick_scan_xd, especially for multiScan100 lidars.</p>

<p>Symptoms for performance problems can be e.g.:</p>
<ul>
  <li>sick_scan_xd reports the loss of UDP packets or message drops</li>
  <li>sick_scan_xd does not publish the fullframe pointcloud</li>
  <li>rviz shows flickering segment pointclouds even with increased decay time</li>
  <li>low frequency of segment or fullframe pointcloud messages</li>
  <li>generally high system load</li>
</ul>

<p>Performance problems can have very different reasons. Notes to help with the elimination of performance issues:</p>

<ol>
  <li>
    <p>Use the latest Raspberry Pi 4. Previous Raspberry Pi models may work with sick_scan_xd, but are not supported officially.</p>
  </li>
  <li>
    <p>Eliminate multiple echos. For most lidars, the echo filter is activated by default and only the last echo is transmitted. Check the launch file configuration and set parameter <code class="language-plaintext highlighter-rouge">filter_echos</code> if not yet done:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="filter_echos" type="int" value="2"/&gt; &lt;!-- FREchoFilter settings: 0: first echo, 1: all echos, 2: last echo --&gt;
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For multican lidars, the echo filter is activated in the launch file by parameter `host_FREchoFilter`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="host_FREchoFilter" type="int" value="2" /&gt;          &lt;!-- Optionally set FREchoFilter with 0 for FIRST_ECHO (default, EchoCount=1), 1 for ALL_ECHOS (EchoCount=3), or 2 for LAST_ECHO (EchoCount=1) --&gt;
    &lt;param name="host_set_FREchoFilter" type="bool" value="True" /&gt;  &lt;!-- If true, FREchoFilter is set at startup (default: false) --&gt;
    
</code></pre></div></div>

<ol>
  <li>Run a basic performance test on ROS 2 using a tiny sopas test server and a udp player to emulate a multiscan:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Start multiScan100 emulator (sopas test server)
    python3 ./src/sick_scan_xd/test/python/multiscan_sopas_test_server.py --tcp_port=2111 --cola_binary=0 &amp;
    # Start rviz
    ros2 run rviz2 rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_cfg_multiscan_emu_360_perftest.rviz &amp;
    sleep 1
    # Start sick_generic_caller with sick_scansegment_xd
    ros2 launch sick_scan sick_multiscan.launch.py hostname:=127.0.0.1 udp_receiver_ip:="127.0.0.1" &amp;
    sleep 3
    # Play udp packets to emulate multiScan
    python3 ./src/sick_scan_xd/test/python/multiscan_perftest_player.py --udp_port=2115 --repeat=100 --send_rate=100 --verbose=0 --prompt=0
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The result should look like the follwing screenshot:
![screenshot raspberry performance test](doc/screenshots/raspberry-perftest-01.png)
If you otherwise observe the loss of UDP packets, message drops, missing pointclouds or mean latency times significantly higher than 6 milliseconds/message, check the system load of your Raspberry and try to eliminate cpu or network intensive processes.
</code></pre></div></div>

<ol>
  <li>Start sick_scan and the sopas test server on the Raspberry as above, but run the udp player <code class="language-plaintext highlighter-rouge">multiscan_perftest_player.py</code> on another PC in your local subnet, e.g.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    python3 multiscan_perftest_player.py --dst_ip=192.168.1.27 --udp_port=2115 --repeat=1000 --send_rate=0 --force_delay=3.0e-3 --verbose=0 --prompt=0
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Replace the example ip adress `192.168.1.27` by the ip adress of your Raspberry. The result should look like the follwing screenshot:
![screenshot raspberry performance test](doc/screenshots/raspberry-perftest-02.png)
If you otherwise observe the loss of UDP packets, message drops, missing pointclouds or mean latency times significantly higher than 6 milliseconds/message, check the system load of your Raspberry and try to eliminate cpu or network intensive processes. sick_scan_xd (i.e. process sick_generic_caller) should consume ca. 80% of one core resp. cause ca. 20% of the total cpu load.
</code></pre></div></div>

<h3 id="troubleshooting">Troubleshooting</h3>

<h4 id="endianess">Endianess</h4>

<p>ARM processors support both little and big endian mode. sick_scan_xd has been tested on Raspberry Pi 4 using ROS 1 and ROS 2 on Linux in little endian mode. You can check the endianess of your system with <code class="language-plaintext highlighter-rouge">lscpu</code>.</p>

<h4 id="build-sick_scan_xd-on-a-raspberry-without-internet-or-github-access">Build sick_scan_xd on a Raspberry without internet or github access</h4>

<p>Checkout sick_scan_xd and use <code class="language-plaintext highlighter-rouge">scp -rp</code> to copy files and directories recursively from local host to a Raspberry, e.g.:</p>

<p>On your local Linux PC (Raspberry IP-address is 192.168.178.52 in this example):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p ./sick_scan_xd_raspberry_pi_pretest/src
pushd ./sick_scan_xd_raspberry_pi_pretest/src
git clone https://github.com/SICKAG/libsick_ldmrs.git
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
popd
scp -rp ./sick_scan_xd_raspberry_pi_pretest 192.168.178.52:/home/rostest/sick_scan_xd_raspberry_pi_pretest

</code></pre></div></div>

<p>On your Raspberry Pi (ROS 1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /home/rostest/sick_scan_xd_raspberry_pi_pretest
pushd ./src/sick_scan_xd/test/scripts
chmod a+x ./*.bash
./makeall_ros1.bash
popd
source ./devel_isolated/setup.bash

</code></pre></div></div>

<p>To view the pointcloud on your local Linux PC (with Raspberry IP-address is 192.168.178.52 in this example):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export ROS_MASTER_URI=http://192.168.178.52:11311/
rviz

</code></pre></div></div>

<h2 id="more-tools">More Tools</h2>

<p>Various tools exist in the repository to improve the operation of the scanners. It is also recommended to read the section <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#Troubleshooting">Troubleshooting</a>.
Overview of the tools:</p>

<ul>
  <li>Search for scanner in the network:
Use the Python3 tool “sick_generic_device_finder.py” in the tools/sick_generic_device_finder directory.
The tools will output the IP addresses of the connected scanners and some more information about the scanner.
Call it with python3, i.e.
<code class="language-plaintext highlighter-rouge">
python3 sick_generic_device_finder.py
</code>
</li>
  <li>Setting new IP address: With the help of the parameter “new_IP” a new IP address can be assigned when calling the node sick_scan_xd.
The launch file sick_new_ip.launch in the launch directory shows an example of how to use this parameter.</li>
  <li>Converting of pointclouds to images: With the tool pcl_converter.cpp one can convert pointcloud2-data
to image. That is especial convenient for 24-layers scanners like the MRS6124.</li>
  <li>Setting up a brand new scanner: To set up a brand new scanner,
it is recommended to use the two tools “sick_generic_device_finder.py” to find the scanner in the network
and the launch file sick_new_ip.launch to set a new IP address. If further settings are to be saved that cannot be made via ROS   parameters, we recommend using the Windows tool “Sopas ET” from SICK.</li>
  <li>Unit tests: For a quick unit test after installation without the sensor hardware, a test server is provided to simulate a scanner. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CONTRIBUTING.md">Simulation</a> for further details.</li>
  <li>Testing: The sick_scan_test program was developed for testing the driver. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/./CONTRIBUTING.md">Testing</a> for details.</li>
</ul>

<h1 id="device-specific-information">Device specific information</h1>

<h2 id="picoscan100multiscan100">picoScan100/multiScan100</h2>

<p>The multiScan100 and picoScan100 are new lidars from Sick. multiScan100 has a total of 16 lidar units rotating around a vertical axis. The rotation speed is 20 rounds per second.</p>

<p>Scan data are transmitted in msgpack or compact format over UDP.</p>

<p>multiScan100/picoScan100 lidars are supported by sick_scan_xd.
The following describes the configuration, validation and test in more detail.</p>

<h3 id="configuration">Configuration</h3>

<p>multiScan100 is configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan.launch">sick_multiscan.launch</a>.
picoScan100 is configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_picoscan.launch">sick_picoscan.launch</a>.</p>

<p>Modify file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan.launch">sick_multiscan.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_picoscan.launch">sick_picoscan.launch</a> to change configuration. Note that the ip address of the udp receiver <strong>must</strong> be configured on each system. This is the ip address of the computer running sick_scan_xd.</p>

<p>The ip address of the lidar and the udp receiver can be configured in the launch file by e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;arg name="hostname" default="192.168.0.1"/&gt;
&lt;arg name="udp_receiver_ip" default="192.168.0.100"/&gt;

</code></pre></div></div>
<p>or by command line by e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Run sick_scansegment_xd generic without ROS:
sick_generic_caller ./launch/sick_multiscan.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100
# Run sick_scansegment_xd on ROS 1:
roslaunch sick_scan_xd sick_multiscan.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100
# Run sick_scansegment_xd on ROS 2:
ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100

</code></pre></div></div>

<h3 id="imu-support-1">IMU support</h3>

<p>IMU support for multiScan100 and picoScan100 is enabled by default and can be configured in the launchfile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="imu_enable" type="bool" value="True"/&gt;  &lt;!-- Enable inertial measurement unit IMU, compact format only --&gt;
&lt;param name="imu_udp_port" type="int" value="7503"/&gt; &lt;!-- udp port for multiScan100 imu data (if imu_enable is true) --&gt;
&lt;param name="imu_topic" type="string" value="imu"/&gt;  &lt;!-- topic of ros IMU messages --&gt;

</code></pre></div></div>

<p>sick_scan_xd receives IMU data by UDP and publishes <a href="https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/Imu.html">ROS 1 sensor_msgs/Imu</a> resp. <a href="https://docs.ros2.org/latest/api/sensor_msgs/msg/Imu.html">ROS 2 sensor_msgs/msg/Imu</a> messages.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> IMU support requires compact format, which is the default. If msgpack communication is configured, imu support is automatically disabled.</p>
</blockquote>

<p>IMU support for picoScan100 requires firmware version 1.1 or newer, see https://www.sick.com/de/en/downloads/media/swp680096 for firmware downloads.</p>

<h3 id="sopas-support">SOPAS support</h3>

<p>On ROS 1 and ROS 2, service <code class="language-plaintext highlighter-rouge">ColaMsg</code> is provided to send CoLa commands to the lidar. Using this service, filters can be applied during runtime.</p>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#sopas-support-for-sick_scan_segment_xd">See</a> here for examples.</p>

<p>See the manual for further information of filter settings and parameter.</p>

<p>The driver sends the following SOPAS start and stop sequence at program start resp. exit (example with default ip address 192.168.0.1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Prerequirement: measurement is active, but no UDP data is sent
// Start sending scan data output
sMN SetAccessMode 3 F4724744  // set authorization level for writing settings
sWN ScanDataEthSettings 1 +192 +168 +0 +1 +2115  // configure destination scan data output destination to 192.168.0.52 port 2115
sWN ScanDataFormat 1   // set scan data output format to MSGPACK
sWN ScanDataPreformatting 1 // for multiscan136 only
sWN ScanDataEnable 1   // enable scan data ouput
sMN LMCstartmeas       // start measurement
sMN Run                // apply the settings and logout
// ...
// UDP data is sent
// ...
// Stop sending scan data output
sMN SetAccessMode   3 F4724744   // set authorization level for writing settings
sWN ScanDataEnable 0   // disable scan data output
sMN Run   // apply the settings and logout
// No UDP data is sent anymore

</code></pre></div></div>

<h3 id="run-multiscan100-and-picoscan100-simultaneously">Run multiScan100 and picoScan100 simultaneously</h3>

<p>The following example shows a multiScan100 and a picoScan100 device running simultaneously on ROS 1. The ip address of the multiScan100 is <code class="language-plaintext highlighter-rouge">192.168.0.1</code> (default), the ip address of the picoScan100 has been set to <code class="language-plaintext highlighter-rouge">192.168.0.2</code>. The Linux-PC running sick_scan_xd uses ip address <code class="language-plaintext highlighter-rouge">192.168.0.100</code>. <code class="language-plaintext highlighter-rouge">fping -a -q -g 192.168.0.0/24</code> shows all available devices in subnet <code class="language-plaintext highlighter-rouge">192.168.0.x</code>:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_01.png" alt="multiple_lidars_01.png"></p>

<table>
  <thead>
    <tr>
      <th>device</th>
      <th>ip</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>192.168.0.1</td>
      <td>multiScan100</td>
    </tr>
    <tr>
      <td>192.168.0.2</td>
      <td>picoScan100</td>
    </tr>
    <tr>
      <td>192.168.0.100</td>
      <td>Linux-PC</td>
    </tr>
  </tbody>
</table>

<p>Open 192.168.0.1 and 192.168.0.2 in a browser to view the network settings with SOPAS Air:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_02.png" alt="multiple_lidars_02.png"></p>

<p>The frame ids and ros topics of both lidars should be configured differently. Copy both launchfiles (sick_multiscan.launch and sick_piocscan.launch in this example) e.g. to lidar1.launch and lidar2.launch and replace ros topics and frame ids, e.g.
    * replace all “topic=/cloud_” by “topic=/cloud1<em>” in lidar1.launch
    * replace all “topic=/cloud</em>” by “topic=/cloud2_” in lidar2.launch
    * replace all “frameid=world” by “frameid=world1” in lidar1.launch
    * replace all “frameid=world” by “frameid=world2” in lidar2.launch</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_03.png" alt="multiple_lidars_03.png"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_04.png" alt="multiple_lidars_04.png"></p>

<p>Provide the launchfiles with <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1</code>.</p>

<p>Then launch sick_scan_xd twice with two different launchfiles, ip addresses, node names, udp ports, topic and frame ids.</p>

<p>Example:</p>

<p>`
roslaunch sick_scan_xd lidar1.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100 nodename:=lidar1 udp_port:=2115 imu_udp_port:=7503 publish_frame_id:=world1 publish_laserscan_segment_topic:=scan1_segment publish_laserscan_fullframe_topic:=scan1_fullframe imu_topic:=imu1 &amp;
`</p>

<p>`
roslaunch sick_scan_xd lidar2.launch hostname:=192.168.0.2 udp_receiver_ip:=192.168.0.100 nodename:=lidar2 udp_port:=2116 imu_udp_port:=7504 publish_frame_id:=world2 publish_laserscan_segment_topic:=scan2_segment publish_laserscan_fullframe_topic:=scan2_fullframe imu_topic:=imu2 &amp;
`</p>

<p>Rviz shows the point clouds of both lidars running simultaneously, with frame id <code class="language-plaintext highlighter-rouge">world1</code> for lidar1 (multiScan) and frame id <code class="language-plaintext highlighter-rouge">world2</code> for lidar2 (picoScan):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_05.png" alt="multiple_lidars_05.png"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_06.png" alt="multiple_lidars_06.png"></p>

<p>If the 6D poses of the lidars are known, their coordinates can be transformed to a common frame by a static_transform_publisher. Example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun tf static_transform_publisher 0 0 0 0 0 0 world world1 100 &amp;
rosrun tf static_transform_publisher 0 0 0 0 0 0 world world2 100 &amp;

</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/multiple_lidars_07.png" alt="multiple_lidars_07.png"></p>

<p>The big purple dots show the picoScan100 pointcloud, the other points are the multiScan100 point clouds. Both are transformed to the common frame id <code class="language-plaintext highlighter-rouge">world</code>. Note that both point clouds do not match exactly, because the 6D poses are just assumed to be (x=0, y=0, z=0, yaw=0, pitch=0, roll=0) in this example.</p>

<h3 id="visualization">Visualization</h3>

<p>The multiScan100 and picoScan100 scans can be visualized by rviz. The following screenshots show two examples of a multiScan100 pointcloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/20210929-tokenized-msgpacks-emulator-rviz.png" alt="msgpacks-emulator-rviz">
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/20210929-tokenized-msgpacks-multiScan-rviz.png" alt="msgpacks-emulator-rviz"></p>

<p>Note that sick_scan_xd publishes 2 pointclouds:</p>
<ul>
  <li>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud</code> is published for each scan segment.</li>
  <li>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_fullframe</code> collects all segments for a complete 360 degree full scan (360 degree for multiScan100, 276 degree for picoscan100).</li>
</ul>

<p>Pointcloud callbacks defined in the <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#generic-driver-api">API</a> are called the same way: A callback registered with SickScanApiRegisterPolarPointCloudMsg is called</p>
<ul>
  <li>with a segment_idx &gt;= 0 for each scan segment, and</li>
  <li>with segment_idx := -1 for the complete 360 degree full scan.</li>
</ul>

<h3 id="pointcloud-memory-layout">PointCloud memory layout</h3>

<p>The Multiscan136 scans with 12 segments and 16 layer. For test, development and debugging, knowledge the internal memory layout of the pointclouds can be helpful.</p>

<p>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_unstructured_segments</code> (topic <code class="language-plaintext highlighter-rouge">/cloud</code> for sick_scan_xd version 2.10 or earlier) is published for each scan segment. Each pointcloud concatenates the layer of that segment. Each layer concatenates the points of that layer and segment. Each point concatenates the cartesian position (x, y, z) and the intensity i of a scan point. Each value of a point (x, y, z, i) is represented by a 4 byte float value. The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_unstructured_fullframe</code> (topic <code class="language-plaintext highlighter-rouge">/cloud_fullframe</code> for sick_scan_xd version 2.10 or earlier) collects all segments of a complete 360 degree full scan. Therefore, a total of 13 cartesian pointclouds are published for a 360 degree full scan:</p>

<ul>
  <li>
    <p>12 segment pointclouds. Each segment pointcloud concatenates the points of each layer in this segment in a flat memory layout:<br>
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_segment_xd_01.png" alt="sick_scan_segment_xd_01.png"></p>
  </li>
  <li>
    <p>1 full scan pointcloud concatenating all 12 segments:<br>
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/sick_scan_segment_xd_02.png" alt="sick_scan_segment_xd_02.png"></p>
  </li>
</ul>

<p>Note that segments and layer are not sorted in ascending order. They are published in the same order as they are received from the lidar.</p>

<h3 id="customized-point-clouds">Customized point clouds</h3>

<p>Pointclouds can be customized, i.e. the fields and points can be configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan.launch">sick_multiscan.launch</a>.</p>

<p>Parameter “custom_pointclouds” lists all customized pointclouds to be published. Each pointcloud is given by its name, e.g:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="custom_pointclouds" type="string" value="cloud_unstructured_segments cloud_unstructured_fullframe cloud_polar_unstructured_segments cloud_polar_unstructured_fullframe cloud_all_fields_fullframe"/&gt;

</code></pre></div></div>
<p>This example publishes 5 types of pointclouds:</p>
<ul>
  <li>Pointcloud for each segment in cartesian coordinates (x,y,z,i), named “cloud_unstructured_segments”</li>
  <li>Pointcloud for each fullframe in cartesian coordinates (x,y,z,i), named “cloud_unstructured_fullframe”</li>
  <li>Pointcloud for each segment in polar coordinates (azimuth,elevation,range,i), named “cloud_polar_unstructured_segments”</li>
  <li>Pointcloud for each fullframe in polar coordinates (azimuth,elevation,range,i), named “cloud_polar_unstructured_fullframe”</li>
  <li>Pointcloud for each fullframe with all available fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), named “cloud_all_fields_fullframe”</li>
</ul>

<p>These 5 pointclouds are published by default.</p>

<p>The properties of the pointcloud, i.e. their fields and points, are configured by the pointcloud name, e.g. pointcloud “cloud_unstructured_segments” (i.e. the segment pointcloud in cartesian coordinates):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_unstructured_segments: cartesian coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_unstructured_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_segments frameid=world publish=1"/&gt;

</code></pre></div></div>
<p>The cloud property configuration is a list of key-value-pairs, where each key-value-pair specifies a property and its value. E.g. <code class="language-plaintext highlighter-rouge">topic=/cloud_unstructured_segments frameid=world</code> defines ros topic “/cloud_unstructured_segments” and frame id “world” for the pointcloud named “cloud_unstructured_segments”.</p>

<p>The following key-value-pairs of a customized pointcloud are currently supported:</p>

<ul>
  <li>Parameter “coordinateNotation” is an enum to configure pointcloud coordinates:
    <ul>
      <li>coordinateNotation=0: cartesian (default, pointcloud has fields x,y,z,i), identical to customized with fields=x,y,z,i</li>
      <li>coordinateNotation=1: polar (pointcloud has fields azimuth,elevation,r,i), identical to customized with fields=azimuth,elevation,range,i</li>
      <li>coordinateNotation=2: both cartesian and polar (pointcloud has fields x,y,z,azimuth,elevation,r,i), identical to customized with fields=x,y,z,azimuth,elevation,range,i</li>
      <li>coordinateNotation=3: customized pointcloud fields, i.e. the pointcloud has fields configured by parameter “fields”</li>
    </ul>
  </li>
  <li>Parameter “updateMethod” is an enum to configure fullframe pointclouds versus segmented pointcloud:
    <ul>
      <li>updateMethod=0: fullframe pointcloud (default)</li>
      <li>updateMethod=1: segmented pointcloud</li>
    </ul>
  </li>
  <li>Parameter “fields” defines the fields of the pointcloud for coordinateNotation == 3 (customized pointcloud fields), e.g.
    <ul>
      <li>fields=x,y,z,i: cartesian pointcloud</li>
      <li>fields=range,azimuth,elevation: polar pointcloud</li>
      <li>or any other combination of x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector</li>
    </ul>

    <p>These fields have the following meaning:</p>
    <ul>
      <li>field “x”: cartesian x coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “y”: cartesian y coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “z”: cartesian z coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “i”: intensity  (4 byte, float32)</li>
      <li>field “range”: polar coordinate range in meter (4 byte, float32)</li>
      <li>field “azimuth”: polar coordinate azimuth in radians  (4 byte, float32)</li>
      <li>field “elevation”: polar coordinate elevation in radians  (4 byte, float32)</li>
      <li>field “t”:  time offset in nano seconds relative to the header timestamp in the point cloud (4 byte, uint32), used by rtabmap for deskewing</li>
      <li>field “ts”: time offset in seconds relative to the header timestamp (4 byte, float32)</li>
      <li>field “lidar_sec”: uint32 seconds part of the lidar timestamp in microseconds (lidar time), lidar_sec = (uint32_t)(lidar_timestamp_microsec / 1000000)</li>
      <li>field “lidar_nsec”: uint32nano seconds part of the lidar timestamp in microseconds (lidar time), lidar_nsec = (uint32_t)(1000 * (lidar_timestamp_microsec % 1000000))</li>
      <li>field “ring”:  layer id (1 byte, int8), identical to field “layer”</li>
      <li>field “layer”: layer (group) index (4 byte, int32), 0 &lt;= layer &lt; 16 for multiScan100 (16 layer), 0 for picoScan100 (1 layer)</li>
      <li>field “echo”: echo index (4 byte, int32)</li>
      <li>field “reflector”: optional reflector bit (1 byte, uint8), 0 or 1, default: 0</li>
    </ul>
  </li>
  <li>Parameter “echos” defines which echos are included in the pointcloud, e.g.
    <ul>
      <li>echos=0,1,2: all echos</li>
      <li>echos=2: last echo
 or any other combination of 0,1,2</li>
    </ul>
  </li>
  <li>Parameter “layers” defines which echos are included in the pointcloud, e.g
    <ul>
      <li>layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 for all layers</li>
      <li>layers=5 for the 0 degree layer
 or any other combination of 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</li>
    </ul>
  </li>
  <li>Parameter “reflectors” filters the points by the reflector bit, i.e.
    <ul>
      <li>reflectors=0,1 for points with reflector bit set or not set</li>
      <li>reflectors=0 for points with reflector bit not set</li>
      <li>reflectors=1 for points with reflector bit set</li>
    </ul>
  </li>
  <li>Parameter “infringed” defines filters the points by infringement, i.e.
    <ul>
      <li>infringed=0,1 for points with infringement bit set or not set</li>
      <li>infringed=0 for points with infringement bit not set</li>
      <li>infringed=1 for points with infringement bit set
 Parameter “infringed” is currently not supported (reserved for future use)</li>
    </ul>
  </li>
  <li>
    <p>Parameter “topic” defines the ros topic, e.g. topic=/cloud_fullframe for cartesian fullframe pointclouds</p>
  </li>
  <li>
    <p>Parameter “frameid” defines the ros frame of the pointcloud, e.g. frameid=world, frameid=map or frameid=base_link</p>
  </li>
  <li>Parameter “publish” activates or deactivates the pointcloud, e.g. publish=1 to generate and publish, or publish=0 to deactivate that pointcloud</li>
</ul>

<p>To add a new pointcloud, define a pointcloud name (e.g. “cloud_layer7_cartesian”), add “cloud_layer7_cartesian” in parameter “custom_pointclouds” and specify a new parameter “cloud_layer7_cartesian” with the new cloud properties, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_layer7_cartesian: cartesian coordinates, fullframe, first echo, layer7 --&gt;
&lt;param name="cloud_layer7_cartesian" type="string" value="coordinateNotation=0 updateMethod=0 echos=0 layers=7 reflectors=0,1 infringed=0,1 topic=/cloud_layer7_cartesian frameid=world publish=1"/&gt;

</code></pre></div></div>

<p>The following pointclouds are currently predefined in launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan.launch">sick_multiscan.launch</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_unstructured_segments: cartesian coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_unstructured_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_fullframe: cartesian coordinates, fullframe, all echos, all layers, max. 32400 points, mean ca. 10000 points per cloud --&gt;
&lt;param name="cloud_unstructured_fullframe" type="string" value="coordinateNotation=0 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_fullframe frameid=world publish=1"/&gt;

&lt;!-- cloud_polar_unstructured_segments: polar coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_polar_unstructured_segments" type="string" value="coordinateNotation=1 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_polar_unstructured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_polar_unstructured_fullframe: polar coordinates, fullframe, all echos, all layers --&gt;
&lt;param name="cloud_polar_unstructured_fullframe" type="string" value="coordinateNotation=1 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_polar_unstructured_fullframe frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo1: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo1" type="string" value="coordinateNotation=0 updateMethod=0 echos=0 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo1 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo1_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo1_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo1_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo2: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo2" type="string" value="coordinateNotation=0 updateMethod=0 echos=1 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo2 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo2_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo2_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=1 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo2_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo3: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo3" type="string" value="coordinateNotation=0 updateMethod=0 echos=2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo3 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo3_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo3_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_echo3_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_reflector: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_reflector" type="string" value="coordinateNotation=0 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_reflector frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_reflector_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_reflector_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_reflector_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires0: cartesian and polar coordinates, fullframe, all echos, high resolution layer 5, fields=x,y,z,i,range,azimuth,elevation, 12*2880x3=103680 points per cloud --&gt;
&lt;param name="cloud_structured_hires0" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=5 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires0 frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires0_segments: cartesian and polar coordinates, segments, all echos, high resolution layer 5, fields=x,y,z,i,range,azimuth,elevation, 2880x3=8640 points per cloud --&gt;
&lt;param name="cloud_structured_hires0_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=5 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires0_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires1: cartesian and polar coordinates, fullframe, all echos, high resolution layer 13, fields=x,y,z,i,range,azimuth,elevation, 12*2880x3=103680 points per cloud --&gt;
&lt;param name="cloud_structured_hires1" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=13 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires1 frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires1_segments: cartesian and polar coordinates, segments, all echos, high resolution layer 13, fields=x,y,z,i,range,azimuth,elevation, 2880x3=8640 points per cloud --&gt;
&lt;param name="cloud_structured_hires1_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=13 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires1_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured: cartesian and polar coordinates, fullframe, all echos, low resolution layers 0,1,2,3,4,6,7,8,9,10,11,12,14,15, fields=x,y,z,i,range,azimuth,elevation, 12*360*14*3=181440 points per cloud --&gt;
&lt;param name="cloud_structured" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=0,1,2,3,4,6,7,8,9,10,11,12,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_structured frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_segments: cartesian and polar coordinates, segments, all echos, low resolution layers 0,1,2,3,4,6,7,8,9,10,11,12,14,15, fields=x,y,z,i,range,azimuth,elevation, 360*14*3=15120 points per cloud --&gt;
&lt;param name="cloud_structured_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=0,1,2,3,4,6,7,8,9,10,11,12,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_structured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_all_fields_segments: all fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), segments, all echos, all layers --&gt;
&lt;param name="cloud_all_fields_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_all_fields_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_all_fields_fullframe: all fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), fullframe, all echos, all layers --&gt;
&lt;param name="cloud_all_fields_fullframe" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_all_fields_fullframe frameid=world publish=1"/&gt;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  The sick_scan_xd API callback functions <code class="language-plaintext highlighter-rouge">SickScanApiRegisterCartesianPointCloudMsg</code> and <code class="language-plaintext highlighter-rouge">SickScanApiRegisterPolarPointCloudMsg</code> provide cartesian and polar pointclouds, i.e. pointclouds configured with <code class="language-plaintext highlighter-rouge">coordinateNotation=0</code> (cartesian) or <code class="language-plaintext highlighter-rouge">coordinateNotation=1</code> (polar). Pointclouds with <code class="language-plaintext highlighter-rouge">coordinateNotation=2</code> (cartesian + polar) or <code class="language-plaintext highlighter-rouge">coordinateNotation=3</code> (customized fields) are currently not supported by the generic API.</p>
</blockquote>

<h3 id="customized-point-clouds-on-a-raspberry-pi">Customized point clouds on a Raspberry Pi</h3>

<p>Performance is critical on a Raspberry. To reduce the cpu load, you may restrict the number of pointclouds to the minimum required for your application. E.g. if you just need the cartesian fullframe pointcloud, you can use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="custom_pointclouds" type="string" value="cloud_unstructured_fullframe"/&gt;

</code></pre></div></div>
<p>to decrease the cpu usage.</p>

<h3 id="msgpack-validation">MSGPACK validation</h3>

<p>A msgpack validation can be activated. This validation checks</p>
<ol>
  <li>each incoming msgpack for scan data out of the expected values, and</li>
  <li>missing scandata after collecting the msgpack data for a full scan (360 degree for multiScan100, 276 degree for picoScan100)</li>
</ol>

<p>If a msgpack contains scan data out of expected values, the msgpack is discarded and an error message is printed. This should not happen in normal operation mode. If scan data are missing after a full 360 degree scan, an error message is printed. This might happen in case of udp packet drops.</p>

<p>By default, the full range of scan data is expected, i.e. all echos, all segments, all layers and azimuth values covering -180 up to +180 degree. If filters are activated (echo-, layer- or angle-range-filter to reduce network traffic), the msgpack validation should currently be deactivated or configured thoroughly to avoid error messages. In the next release, the filter configuration is queried from  multiScan136 Beta and validation settings are adopted to the multiScan136 Beta filter settings.</p>

<p>The msgpack validation is configured in file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_multiscan.launch">sick_multiscan.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_picoscan.launch">sick_picoscan.launch</a>. To activate or deactivate msgpack validation, set <code class="language-plaintext highlighter-rouge">msgpack_validator_enabled</code> to True (activated) resp. False (deactivated).</p>

<p>Msgpack validation leads to error messages in case of udp packet drops. Increase the value <code class="language-plaintext highlighter-rouge">msgpack_validator_check_missing_scandata_interval</code> to tolerate udp packet drops. Higher values increase the number of msgpacks collected for verification.</p>

<h3 id="firewall-configuration">Firewall configuration</h3>

<p>By default, UDP communication is allowed on localhosts. To enable udp communication between 2 different machines, firewalls have to be configured.</p>

<p>On Windows: Setup the windows firewall to allow sick_scan_xd to receive udp packages on port 2115.
To pass udp packages from a remote sender, the default rule for incoming udp packages has to be configured in the windows firewall:</p>
<ol>
  <li>Run “wf.msc” as admin,</li>
  <li>Click Inbound Rules and locate the rule(s) for lidar3d_msr100_recv (resp. python to allow python test scripts), and</li>
  <li>Deactivate the UDP-rule for this process(es) or configure exceptions for remote computers.</li>
  <li>Alternatively, you can create a new rule allowing udp communication on port 2115.</li>
</ol>

<p>On Linux: Run the following commands to allow any udp communication on port 2115:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo iptables -A INPUT -p udp -m udp --dport 2115 -j ACCEPT
sudo iptables -A OUTPUT -p udp -m udp --sport 2115 -j ACCEPT
sudo iptables-save

</code></pre></div></div>
<p>Alternatively, you can also use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ufw allow from any to any port 2115 proto udp

</code></pre></div></div>
<p>to allow all udp traffic on port 2115.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  If Linux or Windows is running in a virtual machine, make sure UDP port 2115 is forwarded. With VMware Workstation Pro, you can configure port forwarding
using the Virtual Network Editor. Udp echos, delays, drops and other unexpected errors might occur when more than one network card is configured in VMware.
Make sure you have only one network adapter activated with custom NAT:</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/vmware_network_settings.png" alt="vmware_network_settings"></p>

<h3 id="sopas-support-for-sick_scan_segment_xd">SOPAS support for sick_scan_segment_xd</h3>

<p>On ROS 1 and ROS 2, sick_scan_segment_xd provides ros service <code class="language-plaintext highlighter-rouge">ColaMsg</code> to send CoLa commands to the lidar. Using this service, filters can be applied to multiScan136 and picoScan150 lidars during runtime.</p>

<p>Examples on ROS 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice list
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN IsSystemReady'}"                             # response: "sAN IsSystemReady 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"                  # response: "sAN SetAccessMode 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataEthSettings 1 +127 +0 +0 +1 +2115'}" # response: "sWA ScanDataEthSettings"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataFormat 1'}"                          # response: "sWA ScanDataFormat"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataPreformatting 1'}"                   # response: "sWA ScanDataPreformatting"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataEnable 1'}"                          # response: "sWA ScanDataEnable"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN LMCstartmeas'}"                              # response: "sAN LMCstartmeas"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN Run'}"                                       # response: "sAN Run 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"                                    # response: "sAN SetAccessMode 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN FREchoFilter 1'}"                                              # response: "sWA FREchoFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1'}" # response: "sWA LFPangleRangeFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'}"            # response: "sWA LFPlayerFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN Run'}"                                                         # response: "sAN Run 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LFPlayerFilter is not supported by picoscan150.</p>
</blockquote>

<p>Examples on ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service list
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN IsSystemReady'}"                             # response: "sAN IsSystemReady 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN SetAccessMode 3 F4724744'}"                  # response: "sAN SetAccessMode 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataEthSettings 1 +127 +0 +0 +1 +2115'}" # response: "sWA ScanDataEthSettings"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataFormat 1'}"                          # response: "sWA ScanDataFormat"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataPreformatting 1'}"                   # response: "sWA ScanDataPreformatting"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataEnable 1'}"                          # response: "sWA ScanDataEnable"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN LMCstartmeas'}"                              # response: "sAN LMCstartmeas"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN Run'}"                                       # response: "sAN Run 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN SetAccessMode 3 F4724744'}"                                    # response: "sAN SetAccessMode 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN FREchoFilter 1'}"                                              # response: "sWA FREchoFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1'}" # response: "sWA LFPangleRangeFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'}"            # response: "sWA LFPlayerFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN Run'}"                                                         # response: "sAN Run 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LFPlayerFilter is not supported by picoscan150.</p>
</blockquote>

<h2 id="tim781-and-tim781s">TiM781 and TiM781S</h2>

<p>For TiM781S lidars, the initial lidar configuration can be deactivated using optional argument initialize_scanner:=0.
Note that this mode does not initialize the lidar. The mode assumes that the scanner is in an appropriate state corresponding to the properties configured in the launchfile. It is not recommended to use this option unless for specific tasks in a controlled environment.</p>

<p><strong>Do not use this mode except the lidar has been configured properly and initialized successfully and is in the same state as after initialization by the launchfile! This option is for advanced users only!</strong></p>

<p>Example: <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=192.168.0.1 initialize_scanner:=0</code></p>

<h3 id="field-evaluation-tim7xx">Field evaluation TiM7xx</h3>

<p>The field evaluation for TiM7xx lidars support two additional options to configure the active field set: FieldSetSelectionMethod and ActiveFieldSet. These options allow to set the active field set during runtime, see the operation manual for details.</p>

<p>Options FieldSetSelectionMethod and ActiveFieldSet can be configured in the launch file and by ros services “FieldSetRead” and “FieldSetWrite”.</p>

<p>Initial values for FieldSetSelectionMethod and ActiveFieldSet can be configured in the launch file, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="active_field_set" type="int" value="-1"/&gt; &lt;!-- set ActiveFieldSet at startup: -1 = do not set (default), index of active field otherwise --&gt;
&lt;param name="field_set_selection_method" type="int" value="-1"/&gt; &lt;!-- set FieldSetSelectionMethod at startup: -1 = do not set (default), 0 = active field selection by digital inputs, 1 = active field selection by telegram --&gt;

</code></pre></div></div>
<p>By default, options FieldSetSelectionMethod and ActiveFieldSet are not written by the driver, i.e. the default values apply (factory defaults or settings by SOPAS ET).</p>

<p>Example service call for ROS1 to read resp. write options FieldSetSelectionMethod and ActiveFieldSet:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/FieldSetRead "{}" # returns field_set_selection_method and active_field_set
rosservice call /sick_tim_7xx/FieldSetWrite "{field_set_selection_method_in: -1, active_field_set_in: 1}" # write active_field_set

</code></pre></div></div>
<p>Example service call for ROS1 to read resp. write options FieldSetSelectionMethod and ActiveFieldSet:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /FieldSetRead sick_scan_xd/srv/FieldSetReadSrv "{}" # returns field_set_selection_method and active_field_set
ros2 service call /FieldSetWrite sick_scan_xd/srv/FieldSetWriteSrv "{field_set_selection_method_in: -1, active_field_set_in: 1}" # write active_field_set

</code></pre></div></div>

<p>Parameter active_field_set &lt; 0: do not set (default), active_field_set &gt; 0: index of active field otherwise (see operation manual for details about ActiveFieldSet telegram)</p>

<p>Parameter field_set_selection_method &lt; 0: do not set (default), field_set_selection_method = 0: active field selection by digital inputs, field_set_selection_method = 1: active field selection by telegram</p>

<p>Note that FieldSetSelectionMethod (parameter field_set_selection_method) requires a higher authorization level and should be configured in the launch file. It is therefore recommended to set <code class="language-plaintext highlighter-rouge">field_set_selection_method_in: -1</code> when using ros service FieldSetWrite.</p>

<h2 id="tim240">TiM240</h2>

<p>The TiM240 is a new scanner that fits seamlessly into the family of other TiM devices. The TiM240 has an opening angle of 240 degrees. In contrast to the previous scanners from SICK, the coordinate system used corresponds directly to the ROS convention. For this reason, this scanner does not require a coordinate conversion of 90 degrees around the Z-axis. However, this is taken into account in the driver code, so that the user will not notice any difference in the setting of the angular ranges during use.
The angular position according to the data sheet can be taken from the drawings below.</p>

<p>The following figures show the difference between the TiM5xx family and the TiM240 device.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/tim240/tim_5xx_scanarea.jpg" alt="TiM5xx scan area"></p>

<p>TiM5xx scanning area</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/tim240/tim_240_scanarea.jpg" alt="TiM240 scan area"></p>

<p>TiM240 scanning area</p>

<h2 id="nav350">NAV350</h2>

<p>NAV350 devices are supported by sick_scan_xd since 2023. Since they support navigation and use a different communication mode, this chapter gives an overview of the NAV350 support in sick_scan_xd. Please refer to the manuals for further information.</p>

<h3 id="process-loop">Process loop</h3>

<p>Scan data, landmarks and poses of NAV350 devices are queried by SOPAS commands with polling. Therefore the sick_scan_xd process loop runs as followed:</p>

<ol>
  <li>Initialization and setup</li>
  <li>Main loop (polling):
1 . Send data request “sMN mNPOSGetData 1 2”
2 . Receive and parse response
3 . Convert and publish pointcloud, laserscan, landmarks, pose and transform
4 . API: notify listeners and run their callback functions
5 . Repeat from step 1</li>
  <li>In case of incoming odometry messages (asynchron):
1 . Convert to SOPAS command
2 . Send “sMN mNPOSSetSpeed <odom_data>" to NAV350</odom_data>
</li>
</ol>

<h3 id="initialization-and-setup">Initialization and setup</h3>

<p>After initialization, sick_scan_xd switches to navigation mode by default. Navigation requires mapping (i.e. a valid landmark layout), which can be done by</p>
<ul>
  <li>SOPAS ET (recommended), or</li>
  <li>optional mapping with parameter <code class="language-plaintext highlighter-rouge">nav_do_initial_mapping:=True</code> using the landmarks detected at start, or</li>
  <li>using an optional imk-file.</li>
</ul>

<p>Configuration and setup using SOPAS ET is most powerful and recommended.</p>

<p>The default sopas initialization sequence runs as followed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"sMN SetAccessMode 3 F4724744"     # switch to access level authorized client
"sMN mNEVAChangeState 1"           # switch to operation mode standby
"sWN NEVACurrLayer &lt;layer&gt;"        # set layer configured by launchfile
"sWN NLMDLandmarkDataFormat 0 1 1" # set result format (landmark data)
"sWN NAVScanDataFormat 1 1"        # set result format (scan data)
"sWN NPOSPoseDataFormat 1 1"       # set result format (pose data)
"sMN mNEVAChangeState 4"           # switch to navigation mode
"sMN mNPOSGetData 1 2"             # query pose, landmark and scan data

</code></pre></div></div>

<p>If optional parameter <code class="language-plaintext highlighter-rouge">nav_do_initial_mapping</code> is true, a landmark layout is initialized using the reflectors detected at startup (sopas command “sMN mNMAPDoMapping”). The sopas initialization sequence for an initial mapping runs as followed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"sMN SetAccessMode 3 F4724744"     # switch to access level authorized client
"sMN mNEVAChangeState 1"           # switch to operation mode standby
"sWN NEVACurrLayer &lt;layer&gt;"        # set layer configured by launchfile
"sWN NLMDLandmarkDataFormat 0 1 1" # set result format (landmark data)
"sWN NAVScanDataFormat 1 1"        # set result format (scan data)
"sWN NPOSPoseDataFormat 1 1"       # set result format (pose data)
"sMN mNEVAChangeState 2"           # switch to mapping mode
"sMN mNLAYEraseLayout 1"           # clear landmark layout
"sWN NMAPMapCfg ..."               # configure mapping parameter
"sWN NLMDReflSize &lt;size&gt;"          # set reflector size configured by launchfile
"sMN mNMAPDoMapping"               # detect landmarks and run mapping
"sMN mNLAYAddLandmark ..."         # add all detected landmarks to the layout
"sMN mNLAYStoreLayout"             # store landmark layout
"sMN mNEVAChangeState 4"           # switch to navigation mode
"sMN mNPOSGetData 1 2"             # query pose, landmark and scan data

</code></pre></div></div>

<p>The landmark layout stored in an imk-file can optionally loaded at startup with optional parameter. See the NAV350 manual for details about imk-files.</p>

<p>The settings are configured in launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/launch/sick_nav_350.launch">sick_nav_350.launch</a>.</p>

<h3 id="messages">Messages</h3>

<p>sick_scan_xd polls the NAV350 scan data, reflectors and poses in its main loop. Scan data are published by pointcloud messages (in topic “cloud” by default). Reflectors are published by type <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVLandmarkData</code> on topic “/sick_nav_350/nav_landmark” and as MarkerArray on topic “/sick_nav_350/nav_reflectors” for easy visualization using rviz. Poses are published by type <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVPoseData</code> on topic “/sick_nav_350/nav_pose” and as ros transform on topic “/tf”.</p>

<p>The following rviz-screenshot shows the pointcloud, landmarks and pose of a NAV350:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/nav350_ros1_screenshot2.jpg" alt="nav350_ros1_screenshot2.jpg"></p>

<h3 id="odometry-messages">Odometry messages</h3>

<p>Odometry messages can be sent to the NAV350 device using ROS messages <code class="language-plaintext highlighter-rouge">nav_msgs/Odometry</code> on topic “/sick_nav_350/odom” or <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVOdomVelocity</code> on topic “/sick_nav_350/nav_odom_velocity”. Odometry messages <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVOdomVelocity</code> specify the velocity (vx, vy) in m/s in lidar coordinates. Odometry messages <code class="language-plaintext highlighter-rouge">nav_msgs/Odometry</code> specify the velocity (vx, vy) in m/s in ros coordinates. The angular velocity is expected in radians/s.</p>

<p>Example odometry messages with vx = 1 m/s, vy = -1 m/s and omega: 0.5 rad/s:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic pub --rate 10 /sick_nav_350/nav_odom_velocity sick_scan_xd/NAVOdomVelocity '{vel_x: 1.0, vel_y: -1.0, omega: 0.5, timestamp: 123456789, coordbase: 0}�
rostopic pub --rate 10 /sick_nav_350/odom nav_msgs/Odometry '{twist: { twist: { linear: {x: 1.0, y: -1.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.5}}}}'

</code></pre></div></div>

<h3 id="angle-compensation">Angle compensation</h3>

<h4 id="introduction-1">Introduction</h4>

<p>For measurements with the highest demands on the accuracy of the angle measurement, the devices of the NAV series allow compensation of slight angle deviations during a rotation. The compensation is determined by the three parameters.</p>
<ul>
  <li>Additive compensation by an angle offset</li>
  <li>Sinusoidal correction by specifying the amplitude and phase of compensation</li>
</ul>

<p>The three parameters are then used to calculate the compensation as follows:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/angle_compensation/angle_compensation_000.png" alt="Formula for angle compensation"></p>

<p>Offset and phase are given in [deg]</p>

<h4 id="example">Example</h4>

<p>The information is read from lidar by using the command <code class="language-plaintext highlighter-rouge">sRN MCAngleCompSin</code>.
The answer gives one amplitude, phase and offset compensation in tens of thousands.</p>

<p>The function reads</p>
<ul>
  <li>Amplitude-Parameter: +1893</li>
  <li>Phase-Parameter: -210503</li>
  <li>Offset-Parameter: -245</li>
</ul>

<p>These corresponds to:</p>
<ul>
  <li>Amplitude-compensation: +0.1893</li>
  <li>Phase-Compensation: -21.0503 [deg]</li>
  <li>Offset-Compensation: -0.0245 [deg]</li>
</ul>

<p><strong>Compensation formula for example for NAV210/NAV245</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Angle[comp.] = Angle[Raw] - 0.189300 * sin(Angle[Raw] + -21.050300 [deg]) -  -0.024500

</code></pre></div></div>

<p><strong>Compensation formula for example for NAV310</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Angle[comp.] = Angle[Raw] + 0.189300 * sin(Angle[Raw] - -21.050300 [deg]) +  -0.024500

</code></pre></div></div>
<p><strong>Example lookup values for NAV310 for this example (first entries)</strong></p>

<table>
  <thead>
    <tr>
      <th>IN [Deg]</th>
      <th>Out [Deg]</th>
      <th>Correction [Deg]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0.000000</td>
      <td>0.043494</td>
      <td>0.043494</td>
    </tr>
    <tr>
      <td>1.000000</td>
      <td>1.046567</td>
      <td>0.046567</td>
    </tr>
    <tr>
      <td>2.000000</td>
      <td>2.049618</td>
      <td>0.049618</td>
    </tr>
    <tr>
      <td>3.000000</td>
      <td>3.052647</td>
      <td>0.052647</td>
    </tr>
    <tr>
      <td>4.000000</td>
      <td>4.055652</td>
      <td>0.055652</td>
    </tr>
    <tr>
      <td>5.000000</td>
      <td>5.058633</td>
      <td>0.058633</td>
    </tr>
    <tr>
      <td>6.000000</td>
      <td>6.061588</td>
      <td>0.061588</td>
    </tr>
    <tr>
      <td>7.000000</td>
      <td>7.064518</td>
      <td>0.064518</td>
    </tr>
    <tr>
      <td>8.000000</td>
      <td>8.067420</td>
      <td>0.067420</td>
    </tr>
    <tr>
      <td>9.000000</td>
      <td>9.070294</td>
      <td>0.070294</td>
    </tr>
    <tr>
      <td>10.000000</td>
      <td>10.073139</td>
      <td>0.073139</td>
    </tr>
  </tbody>
</table>

<h4 id="comparing-compensated-vs-raw-values">Comparing compensated vs. raw values</h4>

<p>For the example the compensation function looks like this (X-Axis: measured angle [deg], Y-Axis: compensation in [deg])</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/angle_compensation/angle_compensation_001.png" alt="Plot of compensation function (example)"></p>

<h4 id="coordinate-systems">Coordinate systems</h4>

<p>For a better understanding of the data sheets of the different lidar systems the following drawings compare the different coordinate systems. Usually the scanners rotate counter-clockwise. The scanners of the NAV3xx series rotate clockwise. All coordinate systems following the right-hand rule, if the axis definition as shown in the picture is used.
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/angle_compensation/3d_coordinate_system_comp.png" alt="Used coordinate systems"></p>

<p>By means of simple matrix operations all axis orientations can be transformed into each other. But since we are only interested in the angle around the Z-axis, the conversions can be done as follows (CS = Coordinate System):</p>

<table>
  <thead>
    <tr>
      <th>IN From</th>
      <th>Out To</th>
      <th>Operation</th>
      <th>Additional info</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ROS</td>
      <td>NAV3xx</td>
      <td>Out=-In+180°</td>
      <td>maps [-180°…180°] to [360°…0°]</td>
    </tr>
    <tr>
      <td>NAV3xx</td>
      <td>ROS</td>
      <td>Out=-In+180°</td>
      <td>maps [0°…360°] to [180°…-180°]</td>
    </tr>
    <tr>
      <td>ROS</td>
      <td>NAV2XX</td>
      <td>Out=In+90°</td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV2xx</td>
      <td>ROS</td>
      <td>Out=In-90°</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="check-compensation-function">Check compensation function</h4>

<p>By using <code class="language-plaintext highlighter-rouge">Octave</code> ones can check the compensation function against the given values by exporting the value via a testbed function.</p>

<!--
   40 a = dlmread("angle_compensation_debug.csv",';',1,0);
   41 size(a)
   42 a
   43 mean(a(:,3))
   44 a3 = a(:,3)-mean(a(:,3))
   45 mean(a3)
   46 S3 = fft(a3)
   47 plot(abs(S3))
   48 abs(S3)
   49 S3(1)
   50 S3(2)
   51 abs(S3(2))/360
   52 abs(S3(2))/360*2
   53 angle(S3(2))
   54 angle(S3(2))/pi*180
   55 angle(S3(2))/pi*180 - 90
   56 angle(S3(2))/pi*180 + 90
   57 plot(a(:,1),a(:,3))
   58 title "compensation example"
-->

<h2 id="mrs6124">MRS6124</h2>

<h3 id="timing-between-layers">Timing between Layers</h3>

<p>The layers are taken up by the scanner in packs of 6. The scanner delivers at an output data rate of 10 Hz and 24 layers 24/6*10=40 scan packets of 6 layers per second. The following table shows an example of the timing for a complete 24 layer recording</p>

<table>
  <thead>
    <tr>
      <th>Raw Time /µs</th>
      <th style="text-align: center">Delta Time /µs</th>
      <th style="text-align: right">Elevation Angle /Deg</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">13.19</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">12.565</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">11.940</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">11.315</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">10.690</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">10.065</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">9.440</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">8.815</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">8.190</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">7.565</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">6.940</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">6.315</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">5.690</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">5.065</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">4.440</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">3.815</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">3.190</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">2.565</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">1.940</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">1.315</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">0.690</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">0.065</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">-0.560</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">-1.185</td>
    </tr>
    <tr>
      <td>NEW SCAN</td>
      <td style="text-align: center"> </td>
      <td style="text-align: right"> </td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">13.190</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">12.565</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">11.940</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">11.315</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">10.690</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">10.065</td>
    </tr>
    <tr>
      <td>2551832862</td>
      <td style="text-align: center">126514</td>
      <td style="text-align: right">9.440</td>
    </tr>
  </tbody>
</table>

<p>The time stamps between the layers are interpolated by the scanner. The time stamps of the first layer (Ang.=13.19°) are measured and show jitter accordingly.</p>

<h3 id="mrs600-with-rms1000">MRS600 with RMS1000</h3>

<ol>
  <li>Setup environment and power supply</li>
  <li>roslaunch sick_scan_xd test_0002_combi_live.launch</li>
  <li>Check setup using rviz</li>
  <li>Close all applications, which are not necessary (like IDE, browser, git client)</li>
  <li>Setup Tracking algorithm</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>top

</code></pre></div></div>
<ol>
  <li>Record data</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rosbag record record -o combi -a

</code></pre></div></div>

<h2 id="rms1000">RMS1000</h2>

<p>This driver supports the radar type RMS1000. This radar records raw targets and tracking objects. The tracking objects are determined on the basis of the raw targets. Two variants of a tracking method are already installed in the radar, which enables the radar to be put into operation quickly.</p>

<p>The RMS1000 is based on FMCW radar. With frequency-modulated continuous wave radar (FMCW radar), the transmission frequency is changed periodically. Triangle functions are usually used for distance measurement. While the transmission frequency changes as linearly as possible to the target object and back during the propagation time of the signal, the signal reflected by the object and received by the radar is time-shifted to the original transmitted frequency. By mixing the transmitted signal with the received signal, the frequency shift and thus the time shift can be determined. Based on the known modulation parameters of the transmitter, the propagation time of the signal can be determined, which in turn is proportional to the distance of the object. For precise distance measurement, therefore, the transmission frequency must be modulated as precisely as possible in linear fashion, since any non-linearity impairs the distance accuracy of the radar.</p>

<p>Through this indirect time measurement via the frequency change of the transmitter, even very close targets can be measured with high accuracy and cost-efficiency using the FMCW method, provided that the modulation parameters are selected appropriately. The distance resolution is determined by the bandwidth of the transmitted signal.</p>

<h3 id="raw-targets">Raw Targets</h3>

<p>Raw targets correspond to individual reflectors that are detected by the radar. Each individual reflector carries the following information:</p>
<ul>
  <li>Range</li>
  <li>Horizontal angle (azimuth)</li>
  <li>Doppler speed</li>
  <li>Reflectivity of the target (aka rcs - radar cross section)</li>
</ul>

<p>The radar RMSxxxx does not resolve elevation angles.  Therefore, the radar assumes the elevation values (z values) with 0.0. The error in distance estimation is usually negligible and is 0.4% (1.0 - cos(5°)) at an elevation angle of 5° compared to horizontal.</p>

<h3 id="tracking-objects">Tracking Objects</h3>

<p>Tracking objects are determined from the raw targets via a tracking procedure over the spatial and temporal
distribution of the raw targets. The track method estimates the location, direction and speed of the object based on an initial estimate.  After initialization, new raw targets are assigned to the track if they “fit” to the track.  This process is called “gating”. Once these raw targets have been assigned to the track,
the track is updated and the new estimate is used for further processing.</p>

<p>The distribution of raw targets over the object also determines the object length during the tracking process.</p>

<p>The tracking object therefore has the following properties:</p>
<ul>
  <li>Distance from radar in Cartesian coordinates</li>
  <li>Direction vector in Cartesian coordinates</li>
  <li>Direction of travel as an angle in the X/Y plane</li>
  <li>Vehicle speed</li>
  <li>Vehicle length</li>
</ul>

<h3 id="ros-message-for-radar">ROS message for Radar</h3>

<p>After parsing the telegram, the driver sends an ROS message of type RadarScan. RadarScan consists of the following components:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Header header
RadarPreHeader radarPreHeader
sensor_msgs/PointCloud2 targets
sick_scan_xd/RadarObject[] objects

</code></pre></div></div>
<h4 id="radarpreheader">RadarPreHeader</h4>
<p>The radar preheader contains information that provides general information about the radar. This data record can usually be ignored for object recognition with regard to raw targets and tracking objects.
For details please refer to the message specification of Sick.</p>

<h4 id="targets">targets</h4>

<p>The list with the raw targets of type sick_scan_xd/targets contains the information about the raw targets.
Each raw target contains the following data fields in a pointcloud2-message (height: 1, width: number of raw targets):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> std::string channelRawTargetId[] = { "x", "y", "z", "vrad","amplitude" };

</code></pre></div></div>
<p>This raw target contains cartesian coordinates, which are derived from range and azimuth angle (horizontal angle) in the following way (code snippet):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valSingle[0] = rawTargetList[i].Dist() cos(angle);    // x
valSingle[1] = rawTargetList[i].Dist() * sin(angle);  // y
valSingle[2] = 0.0;                                   // z
valSingle[3] = rawTargetList[i].Vrad();               // vrad
valSingle[4] = rawTargetList[i].Ampl();               // amplitude

</code></pre></div></div>

<h4 id="objects">objects</h4>

<p>The list with the objects of type sick_scan_xd/RadarObject[] contains the information about the track objects.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int32 id

time tracking_time                          // valid
time last_seen                              // not set

geometry_msgs/TwistWithCovariance velocity  // valid

geometry_msgs/Pose bounding_box_center      // valid
geometry_msgs/Vector3 bounding_box_size     // valid

geometry_msgs/PoseWithCovariance object_box_center // valid
geometry_msgs/Vector3 object_box_size              // valid

geometry_msgs/Point[] contour_points        // not set

</code></pre></div></div>

<p>Please note that not all fields are filled in the object messages. The message specification contains valid ones in the areas marked here in the code section.</p>

<p>The corresponding code fills the object list in the following manner:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        float heading = atan2( objectList[i].V3Dy(), objectList[i].V3Dx());

        radarMsg_.objects[i].velocity.twist.linear.x = objectList[i].V3Dx();
        radarMsg_.objects[i].velocity.twist.linear.y = objectList[i].V3Dy();
        radarMsg_.objects[i].velocity.twist.linear.z = 0.0;

        radarMsg_.objects[i].bounding_box_center.position.x = objectList[i].P3Dx();
        radarMsg_.objects[i].bounding_box_center.position.y = objectList[i].P3Dy();
        radarMsg_.objects[i].bounding_box_center.position.z = 0.0;
        radarMsg_.objects[i].bounding_box_center.orientation.x = cos(heading);
        radarMsg_.objects[i].bounding_box_center.orientation.y = sin(heading);
        radarMsg_.objects[i].bounding_box_center.orientation.z = 0.0;
        radarMsg_.objects[i].bounding_box_center.orientation.w = 1.0; // homogeneous coordinates


        radarMsg_.objects[i].bounding_box_size.x = objectList[i].ObjLength();
        radarMsg_.objects[i].bounding_box_size.y = 1.7;
        radarMsg_.objects[i].bounding_box_size.z = 1.7;
        for (int ii = 0; ii &lt; 6; ii++)
        {
          int mainDiagOffset = ii * 6 + ii;  // build eye-matrix
          radarMsg_.objects[i].object_box_center.covariance[mainDiagOffset] = 1.0;  // it is a little bit hacky ...
          radarMsg_.objects[i].velocity.covariance[mainDiagOffset] = 1.0;
        }
        radarMsg_.objects[i].object_box_center.pose = radarMsg_.objects[i].bounding_box_center;
        radarMsg_.objects[i].object_box_size= radarMsg_.objects[i].bounding_box_size;


</code></pre></div></div>
<p>As you can see there are default values for object height and object width of 1.7 (typical private vehicle)</p>

<!---

## Visualization

For the visualization a ROS node was developed, which receives
the radar messages and exports them as boxes for the objects and as arrows for the raw data.
The ROS node **radar_object_marker** receives the radar data and exports marker arrays that can be visualized in rviz.

The visualization could be controlled by the following parameters:

| Parameters                 | Description                                        |
| -------------------------- | -------------------------------------------------- |
| rawtarget_sphere_radius    | radius of the sphere for the raw data display      |
| rawtarget_arrow_scale      | Scaling factor for the arrow at the raw targets    |
| rawtarget_palette_name     | name of the color palette                          |
| rawtarget_palette_min_ampl | Minimum amplitude value mapped to color idx 0.     |
| rawtarget_palette_max_ampl | Maximum amplitude value mapped to color index 255. |
| object_arrow_scale         | Scaling factor for the arrow at the raw targets    |

The scaling values can be interpreted as the time an object or a raw target moves during this period. Using the distance/time equation, the distance corresponding to the arrow length is calculated from the product of this time period and the object speed or Doppler speed.

Example: Doppler speed: 20[m/s], rawtarget_arrow_scale: 0.4
An arrow of length 0.4 * 20[m] = 8[m] is displayed in rviz.

-->

<h3 id="launch-files">Launch Files</h3>

<p>The following launch files serve as examples for use:</p>

<ul>
  <li>sick_rms_xxxx.launch: Communication with the RMSxxxx and sending of radar ROS messages after successful parsing of SOPAS telegrams coming directly from the radar.</li>
  <li>radar_object_marker.launch : Conversion of radar messages to visualization messages</li>
</ul>

<h4 id="data-visualization-example-video">Data visualization example video</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/doc/200326_5_video_track.mp4">A video example can be found here</a>.</p>

<p>The following figure shows a viz-screenshot of the pointcloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/radar_rviz.png" alt="radar_rviz"></p>

<h3 id="parameter-for-radar-usage">Parameter for Radar Usage</h3>

<p>The following parameters are support by the node <strong>sick_generic_caller</strong> in combination with the RADAR RMS1000 / RMS2000:</p>

<ul>
  <li>scanner_type (string, default: “”) –&gt; Must be set to <strong>sick_rms_xxxx</strong>
</li>
  <li>range_max (double, default: 25.0)</li>
  <li>Maximum range</li>
  <li>hostname</li>
  <li>port</li>
  <li>timelimit</li>
  <li>tracking_mode
0: BASIC-Tracking - use for tracking smaller objects
1: TRAFFIC-Tracking - use for tracking larger objects like vehicles</li>
  <li>transmit_raw_targets (bool, default: true)</li>
  <li>transmit_objects (bool, default: true)</li>
  <li>emul_sensor (bool, default: false)</li>
</ul>

<h3 id="radar-datagram">Radar Datagram</h3>

<p>The message sick_scan_xd/RadarScan consists of four parts:</p>
<ul>
  <li>Header in standard format</li>
  <li>radarPreHeader with higher-level information</li>
  <li>targets: Raw targets output from radar</li>
  <li>objects: Tracking objects that are determined based on the raw targets using the internal tracking algorithm.</li>
</ul>

<p>The complete structure can be determined using the command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosmsg show sick_scan_xd/RadarScan'

</code></pre></div></div>

<p>The following is a short datagram showing the structure of the radar datagram.
The position of the individual elements for the data of the PreHeader is explained below.
See the documenation on https://www.sick.com/de/en/radar-sensors/c/g575803?q=:Def_Type:ProductFamily
for further information.</p>

<p><strong>Example of very short radar datagram</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sSN LMDradardata 1 1 112F6E9 0 0 BCC DC0C 730E9D16 730EA06D 0 0 0 0 0 0 1 0 0 4 DIST1 42200000 00000000 0 AZMT1 3C23D70A 00000000 0 VRAD1 3C23D70A 00000000 0 AMPL1 3DCCCCCD 00000000 0 1 MODE1 3F800000 00000000 0 0 0 0 0 0

</code></pre></div></div>

<p>In the following, the individual tokens are numbered one after another and their meaning is explained:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0: sSN
  1: LMDradardata

  MeasurementData
  ===============
  2: 1             MeasurementData.uiVersionNo  : Version Information for this while structureValue
                   Value   Range: 0 ... 65535
  DeviceBlock
  ===========
  3: 1             DeviceBlock.uiIdent      : Logical number of the device
                   Value   Range: 0 ... 65535
  4: 112F6E9       DeviceBlock.udiSerialNo  : Serial number of the device
                   Value Range  : 0..4294967295


  5: 0             DeviceBlock.xbState      : State of the device
                   Bit length   : 16

                   0.0 Bool     : Value Range False, True
                   Initialisation: False
                   Meaning       : bDeviceError

                   0.1 Bool      : Value Range False, True
                   Initialisation: False
                   Meaning       : bContaminationWarning

                   0.2 Bool      : Value Range False, True
                   Initialisation: False
                   Meaning       : bContaminationError

                   0.3 ...  0.7
  6: 0             1.0 ...  1.7 Bool      : Value Range False, True
                                           Reserved

StatusBlock
===========
  7: BCC            uiTelegramCount
  8: DC0C           uiCycleCount (or uiScanCount???)
  9: 730E9D16       udiSystemCountScan
 10: 730EA06D       udiSystemCountTransmit
 11: 0              xbInputs (Bit 0.0 .. 0.7)
 12: 0              xbInputs (Bit 1.0 .. 1.7)
 13: 0              xbOutputs (Bit 0.0 .. 0.7)
 14: 0              xbOutputs (Bit 1.0 .. 1.7)

MeasurementParam1Block
======================
 15: 0              MeasurementParam1Block.uiCycleDuration
 16: 0              MeasurementParam1Block.uiNoiseLevel

aEncoderBlock
=============
 17: 1              Number of aEncoderBlocks


 18: 0              aEncoderBlock[0].udiEncoderPos
 19: 0              aEncoderBlock[0].iEncoderSpeed

 20: 4              Number of following data channels
 21: DIST1
 22: 42200000
 23: 00000000
 24: 0
 25: AZMT1
 26: 3C23D70A
 27: 00000000
 28: 0
 29: VRAD1
 30: 3C23D70A
 31: 00000000
 32: 0
 33: AMPL1
 34: 3DCCCCCD
 35: 00000000
 36: 0
 37: 1
 38: MODE1
 39: 3F800000
 40: 00000000
 41: 0
 42: 0
 43: 0
 44: 0
 45: 0
 46: 0

</code></pre></div></div>

<h2 id="rms1000-and-lms1000-combination">RMS1000 and LMS1000 combination</h2>

<p>This tutorial shows how to combine a RMS1000radar with a LMS1000 lidar.</p>

<p>To demonstrate the lidar/radar combination, a RMS1000and a LMS1000 device were put into operation. The sick_scan_xd driver and rviz were started on ROS 1 Linux. Bagfiles have been recorded to demonstrate the required transform (rms_1xxx_lms_1xx_movement_off.bag and rms_1xxx_lms_1xx_movement_on.bag).</p>

<p>Run the following steps:</p>

<ol>
  <li>Connect RMS1000and LMS1000 and start sick_scan_xd with launchfiles sick_lms_1xxx.launch and sick_rms_xxxx.launch:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   roslaunch sick_scan_xd sick_lms_1xxx.launch
   roslaunch sick_scan_xd sick_rms_xxxx.launch
   
</code></pre></div></div>
<p>Make sure, that different ros node names and different IP-addresses are used.</p>

<p>The following rviz screenshot shows both pointclouds:
   <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/combination_rms_1xxx_lms_1xx/rms_1xxx_lms_1xx_combi_screenshot01.png" alt="rms_1xxx_lms_1xx_combi_screenshot01.png"></p>

<p>Note that each sensor has its own frame id and coordinate system. The RMS1000uses the frame id “radar”, the LMS1000 uses the frame id “cloud”. To combine both sensor, we have to transform the radar frame and coordinates to the lidar frame and coordinates.
   Radar targets have multiple echos due to reflection.</p>

<ol>
  <li>Start a ros static_transform_publisher to convert radar frames (frame id <code class="language-plaintext highlighter-rouge">/radar</code>) to lidar frames (frame id <code class="language-plaintext highlighter-rouge">/cloud</code>):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   rosrun tf static_transform_publisher 0 0 0 0 0 0 /cloud /radar 100
   
</code></pre></div></div>
<p>Using this transform, rviz displays both the radar and lidar pointcloud:
   <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/combination_rms_1xxx_lms_1xx/rms_1xxx_lms_1xx_combi.png" alt="rms_1xxx_lms_1xx_combi.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  If you use this example with a playback of bagfiles (e.g. <code class="language-plaintext highlighter-rouge">rosbag play --loop ./rms_1xxx_lms_1xx_movement_off.bag</code>), you might encounter errors due to different timestamps (the recorded timestamps in the bagfiles are different from the timestamps by the static_transform_publisher).</p>
</blockquote>

<p>Alternatively, the radar frame id and an optional transform can be configured in the radar launch file (parameter “frame_id” and “add_transform_xyz_rpy”).</p>

<h2 id="lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</h2>

<p>Most lidars create non interlaced scan data by default, i.e. a scan data telegram contains all scan points measured during a full 360 degree circulation. For MRS1xxx and LMS1000 lidars, parameter <code class="language-plaintext highlighter-rouge">ang_res</code> can be configured to increase the angular resolution. In this case, the scan data and point clouds are measured and published interlaced.</p>

<p>The following table shows valid combinations of the angular resolution (parameter <code class="language-plaintext highlighter-rouge">ang_res</code>) and scan frequency (parameter <code class="language-plaintext highlighter-rouge">scan_freq</code>) for MRS1000 and LMS1000 lidars:</p>

<table>
  <thead>
    <tr>
      <th>lidar</th>
      <th>ang_res [deg]</th>
      <th>scan_freq [Hz]</th>
      <th>interlacing</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MRS1000</td>
      <td>0.25</td>
      <td>50</td>
      <td>non-interlaced</td>
    </tr>
    <tr>
      <td>MRS1000</td>
      <td>0.125</td>
      <td>25</td>
      <td>2 x interlaced</td>
    </tr>
    <tr>
      <td>MRS1000</td>
      <td>0.0625</td>
      <td>12.5</td>
      <td>4 x interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.75</td>
      <td>150</td>
      <td>non-interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.375</td>
      <td>75</td>
      <td>2 x interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.1875</td>
      <td>37.5</td>
      <td>4 x interlaced</td>
    </tr>
  </tbody>
</table>

<p><strong>MRS1000 angular resolution</strong></p>

<p>By default, MRS1000 lidars create non-interlaced scans with an angular resolution 0.25 deg.
Using higher resolutions, the MRS1000 sends scan data interlaced.</p>

<p>MRS1000 lidars measure 4 consecutive scans with identical starting angles for each of its 4 layers, where each layer has a different elevation angle. This results in (12.5 Hz) * (4 layers) * (360 deg / 0.25 deg) * (275 deg / 360 deg) = 55000 shots per second.</p>

<p>With default configuration ang_res=0.25, the angular resolution of each scan is 0.25 [deg] and scans and point clouds are non-interlaced. The sequence of scan data telegrams is repeating with 4 consecutive telegrams (resp. 4 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5 deg, angle inc = 0.25 deg</li>
</ul>

<p>With configuration ang_res=0.125, the angular resolution of each scan is 0.125 [deg] and scans and point clouds are 2 x interlaced. The sequence of scan data telegrams is repeating with 8 consecutive telegrams (resp. 8 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.625 deg, angle inc = 0.25 deg</li>
</ul>

<p>With configuration ang_res=0.0625, the angular resolution of each scan is 0.0625 [deg] and scans and point clouds are 4 x interlaced. The sequence of scan data telegrams is repeating with 16 consecutive telegrams (resp. 16 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.6250 deg, angle inc = 0.25 deg</li>
</ul>

<p>To use the full angular resolution of one 360 degree circulation, the point cloud must be accumulated by 8 resp. 16 messages in interlaced mode.</p>

<p><strong>LMS1000 angular resolution</strong></p>

<p>By default, LMS1000 lidars create non-interlaced scans with an angular resolution 0.75 deg.
Using higher resolutions, the LMS1000 sends scan data interlaced.</p>

<p>With configuration ang_res=0.75, the angular resolution of each scan is 0.75 [deg]. This means that each point cloud message also has a resolution of 0.75 [deg]. With configuration ang_res=0.375, the scan is generated interlaced: Each scan still has 0.75 [deg] resolution, but 2 x 4 = 8 consecutive scans are rotated by 0.375 [deg] against each other. I.e. 8 consecutive point cloud messages each have an angular resolution of 0.375 [deg] at half the frequency. Within a point cloud message the angular resolution is still 0.75 [deg].</p>

<p>With ang_res=0.375, scan data are two times interlaced. The sequence of scan data telegrams is repeating with 8 consecutive telegrams:</p>
<ul>
  <li>4 scans starting at -138.000 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.375 deg, angle inc = 0.75 deg</li>
</ul>

<p>Thus the start angles of the received scan data telegrams are
{ …, -138.375, -138.375, -138.375, -138.375, -138.000, -138.000, -138.000, -138.000, … }</p>

<p>With ang_res=0.1875 the scan is generated quadruple interlaced, i.e. 4 x 4 = 16 consecutive scans are each rotated by 0.1875 [deg]. Each scan is resolved with 0.75 [deg]; 4 x 4 = 16 scans resp. 16 pointclouds together (accumulated) result in a resolution of 0.1875 [deg] at a quarter of the frequency.</p>

<p>With ang_res=0.1875, scan data are four times interlaced. The sequence of scan data telegrams is repeating with 16 consecutive telegrams:</p>
<ul>
  <li>4 scans starting at -137.8125 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.0000 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.1875 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.3750 deg, angle inc = 0.75 deg, then</li>
</ul>

<p>Thus the start angles of the received scan data telegrams are
{ …, -137.8125, -137.8125, -137.8125, -137.8125, -138.0000, -138.0000, -138.0000, -138.0000, -138.1875, -138.1875, -138.1875, -138.1875, -138.3750, -138.3750, -138.3750, -138.3750, … }</p>

<p>You can see this in rviz by increasing the decay time to e.g. 4/75=0.054 or higher. The screenshot shows an example with the default setting ang_res=0.75:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/LMS1xxx_0.7500_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>The angular resolution is (just roughly measured) about atan(0.11/0.9) / 9 points = 0.77 [deg]. With ang_res=0.375 and decay=0.1 rviz shows twice the resolution:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/LMS1xxx_0.3750_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>Correspondingly, rviz shows four times the resolution with ang_res=0.1875 and decay=0.1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/LMS1xxx_0.1875_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>To use the full angular resolution of one 360 degree circulation, the pointcloud must be accumulated by 8 resp. 16 messages.</p>

<p>The active configuration can be seen in the log output during scanner initialization, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ INFO] [1669294673.078608968]: sRA LMPscancfg: scan frequency = 75 Hz, angular resolution = 0.375 deg.

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LMS creates 4 consecutive scans with identical starting angles for each of its 4 laser LEDs. The 4 laser LEDs are mounted in one plane. All together, this gives you (4 scans) * (37.5 Hz) * (1 layer) * (360 deg / 0.75 deg) * (275 deg / 360 deg) = 55000 shots per second.</p>

</blockquote>

<h1 id="faq">FAQ</h1>

<h2 id="general">General</h2>

<p><strong>How to run multiple sensors concurrently?</strong></p>

<p>:question: How can I run multiple sensors concurrently with sick_scan_xd ?</p>

<p>:white_check_mark: To support multiple sensors, sick_scan_xd has to be started multiple times, with one sick_scan_xd-node for each sensor. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#start-multiple-nodes">start multiple nodes</a> for details.</p>

<p><strong>Driver restarts again and again after “sFA” message</strong></p>

<p>:question: The sick_scan_xd driver restarts again and again after an error message “sFA”.</p>

<p>:white_check_mark: The behaviour is intentional. The error message “sFA” can be caused by faulty configuration or errors in the lidar. Correct operation after this error message is not guaranteed. In this case, the driver restarts itself. It is recommended to identify and correct the error using its error number (“<code class="language-plaintext highlighter-rouge">sFA&lt;hexcode&gt;</code>”). The SOPAS error codes are listed in the manual.</p>

<p><strong>Driver restarts after timeout error</strong></p>

<p>:question: The sick_scan_xd driver changes the communication protocol and restarts after a timeout error.</p>

<p>:white_check_mark: The use of binary communication (Cola-B) is highly recommended due to better compatibility, lower network traffic and general support.
Recommendation:</p>
<ol>
  <li>Set parameter “use_binary_protocol” to “true” in the launch file, and</li>
  <li>Set the lidar communication mode with the SOPAS ET software to binary and save this setting in the scanner’s EEPROM.</li>
</ol>

<p><strong>Changes in launchfiles are ignored</strong></p>

<p>:question: roslaunch still uses an old version after modifying the launch-file.</p>

<p>:white_check_mark: After modifying a launch-file, it has to be installed by running <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1</code>
to be located and used by <code class="language-plaintext highlighter-rouge">roslaunch</code>.</p>

<p><strong>ROS 2 launch file support</strong></p>

<p>:question: How can I create a ROS 2 node in python to run sick_generic_caller from a launch.py-file in ROS 2?</p>

<p>:white_check_mark: Example to launch a TiM-7xx node in ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sick_scan_pkg_prefix = get_package_share_directory('sick_scan_xd')
    tim_launch_file_path = os.path.join(sick_scan_pkg_prefix, 'launch/sick_tim_7xx.launch')
    tim_top_node = Node(
        package='sick_scan_xd',
        executable='sick_generic_caller',
        output='screen',
        arguments=[
            tim_launch_file_path,
            'nodename:=/lidars/tim_top',
            'hostname:=192.168.0.110',
            'cloud_topic:=/lidars/tim_top/cloud',
            'frame_id:=tim_top'
        ]
    )

</code></pre></div></div>
<p>Thanks to user JWhitleyWork.</p>

<p><strong>Timestamps</strong></p>

<p>:question: What timestamp is provided in the pointcloud and laserscan messages?</p>

<p>:white_check_mark: Details about timestamps are given in <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#time-synchronization">timing</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#software-pll">software_pll</a>.</p>

<p>In a nutshell:
The lidars do not work with absolute time stamps but with “ticks”. There are two types of tick timestamps:</p>
<ul>
  <li>Tick timestamps for the generation</li>
  <li>Tick timestamps for sending the message
To match the tick timestamps against the system time, a straight line equation is estimated via the so-called software PLL, which can be used to calculate from the system time to the ticks in the lidar (and vice versa). The assumption is that the tick timestamp for sending the message corresponds to the system time when receiving the message. In reality there will be a tiny delay here. This delay can be ignored.</li>
</ul>

<p>With the help of this straight line equation, one can now calculate the system time at which the data is generated in the lidar.</p>

<p>Summary:</p>
<ol>
  <li>lidar: stamp with ticks the generation (first shot in the scan) (TICK_GEN)</li>
  <li>lidar: stamp with ticks the sending of the scan message (TICK_TRANSMIT)</li>
  <li>PC: Stamp with system time the receiving of the message</li>
  <li>PC: Calculate back to system time of generation:
System time of generation = System time of receiving - (TICK_TRANSMIT - TICK_GEN)/TICK_FREQUENCY</li>
</ol>

<p><strong>Laserscan messages with multiple frame ids</strong></p>

<p>:question: sick_scan_xd publishes laserscan messages for multiScan100 and picoScan100 with multiple frame ids and possibly inconsistent data. Which frame id is correct?</p>

<p>:white_check_mark: By default, an echo filter is activated in the multiScan100 and picoScan100 launchfile. This echo filter suppresses multiple echos, e.g. echos from an object and a protective glass pane. The default configuration is “last echo only”. In this case (i.e. one echo only), the fullframe laserscan messages on topic scan_fullframe all have identical frame ids for each layer, i.e. “world_&lt;layer&gt;”. For the multiScan100 lidars with 16 layers, sick_scan_xd publishes laserscan messages with frame ids “world_1”, “world_2” up to “world_16”. For picoScan100 lidars with 1 layer, there is just one frame id “world_1”.</p>

<p>In case of multiple echos (i.e. echo filter is deactivated), each echo is published by a laserscan message with different frame ids “world_&lt;layer&gt;_&lt;echo_idx&gt;”. For picoScan100 lidars with 3 echos, there are 3 frame ids “world_1_0”, “world_1_1”, “world_1_2” published. For multiScan100 lidars with 16 layers and 3 echos, there are 48 different frame ids published “world_1_0”, “world_1_1”, “world_1_2”, “world_2_0”, “world_2_1”, “world_2_2”, … , “world_16_0”, “world_16_1”, “world_16_2”.</p>

<p>This behaviour is intended, since a laserscan message can not contain multiple ranges for a single scan point at one azimuth angle. Therefore, there have to be different laserscan messages for each layer and each echo. Layer and echo of a laserscan message are identified by the frame id.</p>

<p><strong>Compilation errors</strong></p>

<p>:question: Compiler reports errors in file <code class="language-plaintext highlighter-rouge">/opt/ros/&lt;distro&gt;/include/sick_scan</code></p>

<p>:white_check_mark: If sick_scan was previously installed using <code class="language-plaintext highlighter-rouge">apt-get install ros-&lt;distro&gt;-sick-scan</code>, you have to remove previous versions using <code class="language-plaintext highlighter-rouge">apt-get purge ros-&lt;distro&gt;-sick-scan</code>. Run the following steps for a complete rebuild:</p>
<ol>
  <li>Run <code class="language-plaintext highlighter-rouge">sudo apt-get purge ros-&lt;distro&gt;-sick-scan</code> (e.g. <code class="language-plaintext highlighter-rouge">sudo apt-get purge ros-noetic-sick-scan</code>) to remove previously installed sick_scan-packages</li>
  <li>Remove the folders sick_scan_xd/build, sick_scan_xd/build_isolated, sick_scan_xd/devel, sick_scan_xd/devel_isolated, sick_scan_xd/install and sick_scan_xd/install_isolated</li>
  <li>Rebuild</li>
</ol>

<p>:question: cmake cannot find diagnostic_updater</p>

<p>:white_check_mark: On ROS 2 foxy, package diagnostic_updater needs to be installed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get update
sudo apt-get install ros-$ROS_DISTRO-diagnostic-updater # install diagnostic_updater
# E.g. to install diagnostic_updater on foxy, run
# sudo apt-get install ros-foxy-diagnostic-updater

</code></pre></div></div>

<p>:question: catkin gives me the following error message:
<code class="language-plaintext highlighter-rouge">By not providing "FindSICKLDMRS.cmake" in CMAKE_MODULE_PATH this project ..., but CMake did not find one."</code></p>

<p>:white_check_mark:  One problem with ROS is that it doesn’t automatically rebuild everything if you just append “-DLMRRS=0”.
If you accidentally did the following call before</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catkin_make_isolated --install --cmake-args -DROS_VERSION=1

</code></pre></div></div>
<p>you must remove the build/devel/install-directories created by the ROS build process.
For this please run the following commands to remove the directories, which holds the previous build results:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~/ros_catkin_ws
rm -rf build_isolated
rm -rf devel_isolated
rm -rf install_isolated
rm -rf devel

</code></pre></div></div>
<p>It is possible that not all directories are present in this list. But that does not matter.
The only subdirectory left should be “src”.
You can check this with the following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls */ -d

</code></pre></div></div>
<p>The output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/

</code></pre></div></div>
<p>After doing this please rerun the command
catkin_make_isolated –install –cmake-args -DROS_VERSION=1 -DLDMRS=0</p>

<p><strong>rviz or rviz2 do not work as expected</strong></p>

<p>:question: rviz shows a grey point cloud. The size of points can be adjusted.</p>

<p>:white_check_mark: Check in the launch file that the intensity flag is set to True.</p>

<p>:question: rviz shows a grey point cloud and the size of points can not be adjusted.</p>

<p>:white_check_mark: Probably in this case you are running Linux in a virtual machine. In this case, OpenGL may not work correctly in the VM. rviz then chooses a kind of “fallback solution” and deactivates the colors.
Also, changing the “Size” and “Style” display in rviz has no effect on the display of the pointcloud data.</p>

<p>The problem can be avoided by starting rviz with the following sequence:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export LIBGL_ALWAYS_SOFTWARE=1
rosrun rviz rviz

</code></pre></div></div>

<p>:question: rviz2 on Ubuntu 24 with ROS 2 jazzy crashes immediately after start</p>

<p>:white_check_mark: This can be a wayland vs. X11 problem. Try <code class="language-plaintext highlighter-rouge">export QT_QPA_PLATFORM=xcb</code> before starting rviz2. See https://github.com/ros-visualization/rviz/issues/1442#issuecomment-553900795 and https://blog.martin-graesslin.com/blog/2015/07/porting-qt-applications-to-wayland/ for further information.</p>

<p><strong>Angular resolution and scan frequency</strong></p>

<p>:question: The angular resolution/ number of shots is too small</p>

<p>:white_check_mark: Possibly Mean or Median filters are activated. Use Sopas ET to deactivate them and store this settings permanent on the device, see picture.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/tim5xxx_filter.PNG" alt="Sopas_filter"></p>

<p>Further information can be found at http://wiki.ros.org/rviz/Troubleshooting .</p>

<p>:question: The scanner and message frequency is lower than expected</p>

<p>:white_check_mark: Mean or median filters decrease the scanner frequency. Check and configure filter settings with SOPAS ET or deactivate them in the launch file (MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx only):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="lfp_meanfilter" type="int" value="-1" /&gt; &lt;!-- MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx: lfp_meanfilter&lt;0: do not apply, lfp_meanfilter==0: deactivate LFPmeanfilter, lfp_meanfilter&gt;0: activate LFPmeanfilter with lfp_meanfilter = number of scans --&gt;
&lt;param name="lfp_medianfilter" type="int" value="-1" /&gt; &lt;!-- MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx: lfp_medianfilter&lt;0: do not apply, lfp_medianfilter==0: deactivate LFPmedianfilter, lfp_medianfilter==1: activate LFPmedianfilter --&gt;

</code></pre></div></div>
<p>By default, filter settings are not overwritten, i.e. the filter settings stored in the lidars EEPROM apply (factory defaults resp. SOPAS ET filter settings).</p>

<p><strong>LMS1xxx angular resolution</strong></p>

<p>:question: Independent of the configuration, the LMS1xxx pointcloud always displays 0.75 [deg] angular resolution</p>

<p>:white_check_mark: Using higher resolutions, the LMS1xxx sends scan data interlaced. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</a> for details.</p>

<p><strong>“ERROR: Tcp::open: Failed to open TCP connection to 192.168.0.1, aborting.”</strong></p>

<p>:question: Question:
sick_generic_caller gives you an answer like:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"ERROR: Tcp::open: Failed to open TCP connection to 192.168.0.1, aborting."</span>

</code></pre></div></div>

<p>:white_check_mark: Answer: See FAQ for network diagnosis and recommended configuration.</p>

<p><strong>IP Address of Lidar</strong></p>

<p>:question: Question:
My scanner does not use the default ip address. What shall I do?</p>

<p>:white_check_mark: Answer:
There are two options doing this:</p>

<ul>
  <li>Permanently:
Replace the following entry with your ip address.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;param <span class="nv">name</span><span class="o">=</span><span class="s2">"hostname"</span> <span class="nb">type</span><span class="o">=</span><span class="s2">"string"</span> <span class="nv">value</span><span class="o">=</span><span class="s2">"192.168.0.1"</span> /&gt;

</code></pre></div></div>
<ul>
  <li>Temporarily
Use a command line argument in addition to the launch file argument:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nb">hostname</span>:<span class="o">=</span>192.168.0.2

</code></pre></div></div>

<p><strong>Timeout Warning</strong></p>

<p>:question: Question:
During start phase the are warning/error message like</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>no answer received after 5000 ms. Maybe sopas mode is wrong.

</code></pre></div></div>
<p>and some more warning/error messages:</p>

<p>:white_check_mark: Answer:
In this case the driver tries to start the scanner in binary mode. If this is not possible, warnings and error messages are generated.
The driver switches the scanner from ASCII mode to binary mode and then restarts communication. The messages can therefore be ignored.
For a long-term solution, we recommend switching from ASCII to binary communication with SOPAS ET under Windows.</p>

<p><strong>Own Data Handling</strong></p>

<p>:question: Question:
I would like to process data with my own methods.</p>

<p>:white_check_mark: Answer:
Search for keyword “PUBLISH_DATA:” in the code and replace the code for writing
jpeg-files and CSV-files with your own source code.</p>

<p><strong>Occasionally missing scan data</strong></p>

<p>:question: Question:
Occasionally, no scan data appear, but the scanner is still reachable using <code class="language-plaintext highlighter-rouge">ping &lt;ip-address&gt;</code> or <code class="language-plaintext highlighter-rouge">nc -z -v &lt;ip-address&gt; &lt;port&gt;</code></p>

<p>:white_check_mark: Answer:
This is likely to be a data capture issue. In any case it’s recommend (if not already set) to use SOPAS-Binary instead of SOPAS-ASCII, because here the data rate is lower.</p>

<p>In addition, the following measures can help to determine the source of the problems:
a) Exchange the cables to the lidar(s) incl. the network cables
b) Exchange the power supply to the lidar(s)
c) avoidance of interconnection of other components (like switch etc.)
d) upgrade hardware and firmware of devices (if new versions available)</p>

<p>If it is not a hardware problem (e.g. cable), check if there are other software components using the network interface.</p>

<p>If there are still problems, use Wireshark to see if there are any communication problems reported. Wireshark can export the recorded network traffic as text (see screenshot). Search for entries like “LMDscandata” in the generated text file. This marks the beginning of a new scan message. You can then compare the order of the timestamps of these packets to see if there were any failures.</p>

<p><img src="https://user-images.githubusercontent.com/33296049/124088216-01aa2280-da53-11eb-91ae-2b88b37e08eb.png" alt="Wireshark screenshot"></p>

<p><strong>python_d.exe not found</strong></p>

<p>:question: Question:
On Windows with ROS, cmake complains “python_d.exe not found” when running rosidl generator</p>

<p>:white_check_mark: Answer:
Workaround: Copy python.exe to python_d.exe in the python folder.</p>

<p><strong>Debugging</strong></p>

<p>:question: Question:
How can I debug sick_generic_caller on ROS 1?</p>

<p>:white_check_mark: Answer:
Build with compiler option <code class="language-plaintext highlighter-rouge">-g</code> and run sick_generic_caller as described using a launchfile. Stop sick_generic_caller (Ctrl-C or kill) and save the current ros parameter using <code class="language-plaintext highlighter-rouge">rosparam dump &lt;dumpfile&gt;.yaml</code>. Load these parameter with <code class="language-plaintext highlighter-rouge">rosparam load &lt;dumpfile&gt;.yaml</code> and restart sick_generic_caller in gdb or in your IDE.</p>

<p><strong>Curved lines on a straight wall</strong></p>

<p>:question: Question:
The X,Y points of the lidar show a curved line even though the lidar is scanning a straight wall. How can this be?</p>

<p>:white_check_mark: Answer:
This effect occurs when the lidar has multiple planes that are tilted up or down. In this case, the laser beams of this plane do not lie on a flat plane. Rather, the beams lie on a cone. If the laser beams then hit a wall, the result is a curved course of the lidar points. If the lidar is horizontal and the wall is vertical, this is a hyperbola (see following figure):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/cone_section.png" alt="cone_section"></p>

<p>This image is generated using the website https://www.intmath.com/plane-analytic-geometry/conic-sections-summary-interactive.php.
Thus, the mathematical laws for a conic section apply, as they are explained e.g. at Wikipedia at https://en.wikipedia.org/wiki/Conic_section.</p>

<p><strong>Interlacing</strong></p>

<p>:question: Question:
How should I interpret the scan rate and lidar resolution from the manual? What is the relationship between ROS point cloud publishing rate and scan frequency here?</p>

<p>:white_check_mark: Answer:</p>

<p>The angular resolution and scan frequency is configurable in many lidars such as the LRS-4xxx or MRS1000. Depending on the lidar type, angular resolution and scan frequency can be set in the launch file either via the parameter “scan_cfg_list_entry” or the parameters “ang_res” and “scan_freq”. Angular resolution and scan frequency are not independent of each other. If no default settings are used, the values must be selected according to the manual for the respective lidar and set in launch file.</p>

<p>An increase in resolution is achieved by interlacing by a factor of N. This means that N consecutive scans are rotated by a constant angular offset. Each scan in itself still has the physically given angular resolution and frequency. By concatenating N interlaced scans, the angular resolution is increased by the factor N.</p>

<p>Example: The default setting of an MRS1000 is 0.25 degrees horizontal angular resolution at 50 Hz scan frequency without interlacing and an angular range of 275 degrees in total. I.e. each scan measures the distance at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ].</p>

<p>If 0.125 degrees horizontal angular resolution is configured at 25 Hz scan frequency, the scans are performed with 2 times interlacing (N=2). Every 2nd scan is horizontally shifted by 0.125 degrees. I.e. each scan measures alternately at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ] and [ … , 0.125, 0.375, 0.625, 0.875 … ]. 50 single scans per second resp. 25 interlaced scans per second are sent.</p>

<p>If 0.0625 degrees horizontal angular resolution at 12.5 Hz scan frequency is configured, the scans are performed with 4 times interlacing (N=4). Successive scans are shifted horizontally by 0.0625 degrees each. That is, each scan measures alternately at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ], [… , 0.0625, 0.3125, 0.5625, 0.8125 … ], [… , 0.125, 0.375, 0.625, 0.875 … ] and [… , 0.1875, 0.4375, 0.6875, 0.9375 … ]. 50 single scans per second resp. 12.5 interlaced scans per second are sent.</p>

<p>In interlacing mode, laser scan and point cloud messages are published interlaced, too. In rviz, the higher angular resolution is clearly visible when the decay time is increased.</p>

<p>With a scan frequency of 50 Hz and 4 active layers, the lidar will send a new scan line each 0.02 seconds. Each layer is scanned after 0.08 seconds resp. with 12.5 Hz (4 layers multiplied by 12.5 Hz = 50 Hz scan frequency). The point cloud accumulates all active layers and is therefore published with 12.5 Hz (i.e. scan frequency divided by number of layers).</p>

<p>If you check the publishing rate of the point cloud messages of a MRS-1104, you will measure 12.4 Hz, since the scans of 4 layers are accumulated in 1 point cloud message (50 hz scan frequency divided by 4 layers = 12.5 Hz point cloud publishing frequency). The resolution of each single point cloud message is 0.125 [deg]. Only by interleaving 4 consecutive messages you get the high resolution of 0.0625 [deg].</p>

<p>See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</a> for further informations.</p>

<h2 id="networking">Networking</h2>

<p>A TCP connection is needed to receive scan data from a lidar, which requires an appropriate network setup.</p>

<p>Common errors when establishing the TCP connection and possible solutions are described below. If you encounter network errors like “Failed to open TCP connection” when running sick_scan_xd, follow these recommendations.</p>

<p><strong>Static IP addresses</strong></p>

<p>Most lidars have the default IP address 192.168.0.1. It is highly recommended to use a static IPv4 network with IP addresses 192.168.x.y. PC and lidar should use the same subnet. <strong>Avoid using DHCP.</strong></p>

<p>Example IP address of the lidar: 192.168.0.1 (default)</p>

<p>Example IP address of the PC running sick_scan_xd: 192.168.0.100</p>

<p>The IP address of the PC running sick_scan_xd and the lidar must not be identical!</p>

<p>Use <code class="language-plaintext highlighter-rouge">ifconfig -a</code> on Linux resp. <code class="language-plaintext highlighter-rouge">ipconfig /all</code> on Windows to view network settings and lcoal IP addresses.</p>

<ol>
  <li>Try to ping your device:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>
<ol>
  <li>Disconnect your scanner and retry ping</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>
<p>The result of ping contains a pattern like</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ... Destination Host Unreachable
   
</code></pre></div></div>
<ol>
  <li>Reconnect your device and try to ping:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>

<p>If you do not know the IP addresses, try to find the IP addresses of your PC and your lidar in your subnet:</p>

<ol>
  <li>
    <p>Install fping: <code class="language-plaintext highlighter-rouge">apt-get install fping</code></p>
  </li>
  <li>
    <p>Scan your network (for example, subnet 192.168.10.0/24): <code class="language-plaintext highlighter-rouge">fping -a 192.168.0.1\24</code> to
search for all IP addresses from 192.168.0.0 to 192.168.0.255.</p>
  </li>
</ol>

<p>The result is similar to:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.0.4 is alive
192.168.0.22 is alive

</code></pre></div></div>
<p>and a lot of unreachable entries.
In the example the IP address 192.168.0.4 is the laserscanner MRS1104 and the IP address 192.168.0.22 is the computer running linux. Check this with <code class="language-plaintext highlighter-rouge">ifconfig|grep 192.168.0.22</code>.</p>

<p>We recommend to use wired Ethernet. On Ubuntu, use the “Wired Settings” menu to check the network profile. Network profiles sometimes change automatically when multiple profiles are in use or the lidar has been switched off and on.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/screenshots/network_setup_02.png" alt="network_setup_02.png"></p>

<p><strong>Network configuration with SOPAS ET</strong></p>

<p>The <a href="https://www.sick.com/de/en/catalog/digital-services-and-solutions/software/sopas-engineering-tool/p/p367244">SOPAS Engineering Tool</a> (SOPAS ET) allows a detailed lidar configuration incl. network settings. We recommend to use SOPAS ET in case of network problems or to change the lidars network configuration. The operation manual contains further details.</p>

<p><strong>Diagnostic tools</strong></p>

<p>Network tools can help in case of connection errors. Examples are:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">ping &lt;lidar-ip-address&gt;</code> to check if the lidar is reachable</li>
  <li>
<code class="language-plaintext highlighter-rouge">fping -a 192.168.0.1\24</code> to see ip addresses available in the subnet</li>
  <li>
<code class="language-plaintext highlighter-rouge">netcat &lt;lidar-ip-address&gt; &lt;lidar-tcp-port&gt;</code> to read or write network data</li>
  <li>
<code class="language-plaintext highlighter-rouge">wireshark</code> to monitor and record the network traffic between PC and lidar.</li>
  <li>
<code class="language-plaintext highlighter-rouge">sudo ufw status</code> to see if a firewall is active. If active, disable firewalls with <code class="language-plaintext highlighter-rouge">sudo ufw disable</code>.</li>
</ul>

<h2 id="multiscan100--picoscan100">multiScan100 / picoScan100</h2>

<p><strong>Visual Studio: Breakpoints in Debug Mode disabled</strong></p>

<p>:question: In Windows debug version the compiler does not stop at breakpoints.</p>

<p>:white_check_mark: Check, that you are using the Debug Version. At ‘/Zi’ to compiler settings. Disable optimization.
(see <code class="language-plaintext highlighter-rouge">https://stackoverflow.com/questions/865546/generating-symbols-in-release-binaries-with-visual-studio</code> for details).</p>

<p><strong>Packages lost in benchmark</strong></p>

<p>:question: sick_scan_xd seems to drop packages, when sending 10000 msgpacks with polarscan_sender_test.py from another computer</p>

<p>:white_check_mark: There can be a number of reasons for dropped messages (udp or msgpacks). Besides slow network connection, there can be other pitfalls depending on the system:</p>

<ul>
  <li>
    <p>If Linux or Windows is running in a virtual machine, make sure UDP port 2115 is forwarded. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#firewall-configuration">Firewall configuration</a>.</p>
  </li>
  <li>
    <p>Depending on ROS 2 system settings, log messages might be buffered. To really see all log messages of sick_generic_caller, terminate sick_scan_xd/sick_generic_caller (Ctrl-C or kill) and view the ros logfile by <code class="language-plaintext highlighter-rouge">cat ~/.ros/log/sick_scan_*.log</code></p>
  </li>
</ul>

<p><strong>Convert pcapng-files to msgpack or json</strong></p>

<p>:question: How can I convert a pcapng-file with scandata to a msgpack- or json-file?</p>

<p>:white_check_mark: Run the following steps:</p>
<ul>
  <li>Install python msgpack package with <code class="language-plaintext highlighter-rouge">pip install msgpack</code>
</li>
  <li>Play the pcapng-file using multiscan_pcap_player.py</li>
  <li>Receive and convert to msgpack using multiscan_receiver.py</li>
  <li>Convert to json using online-converter https://toolslick.com/conversion/data/messagepack-to-json</li>
</ul>

<p>Linux example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pushd sick_scan_xd/test/python
python3 python multiscan_receiver.py &amp;
python3 multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20210929_multiscan_token_udp.pcapng
mv ./multiscan_dump_12472.msgpack     20210929_multiscan_token_udp.msgpack
mv ./multiscan_dump_12472.msgpack.hex 20210929_multiscan_token_udp.msgpack.hex
popd

</code></pre></div></div>
<p>Then paste the content of file <code class="language-plaintext highlighter-rouge">20210929_multiscan_token_udp.msgpack.hex</code> in https://toolslick.com/conversion/data/messagepack-to-json and save the json-output.</p>

<p>Windows example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pushd sick_scan_xd\test\python
python --version
REM Convert 20220915_multiscan_msgpack_output.pcapng (16-bit RSSI record) to msgpack resp. json
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
start python multiscan_receiver.py
python multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20220915_multiscan_msgpack_output.pcapng --udp_port=2115
move /y .\multiscan_dump_23644.msgpack     20220915_multiscan_msgpack_output.msgpack
move /y .\multiscan_dump_23644.msgpack.hex 20220915_multiscan_msgpack_output.msgpack.hex
REM Convert 20210929_multiscan_token_udp.pcapng (8-bit RSSI record) to msgpack resp. json
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
start python multiscan_receiver.py
python multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20210929_multiscan_token_udp.pcapng --verbose=0
move /y .\multiscan_dump_12472.msgpack     20210929_multiscan_token_udp.msgpack
move /y .\multiscan_dump_12472.msgpack.hex 20210929_multiscan_token_udp.msgpack.hex
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
popd

</code></pre></div></div>
<p>Then paste the content of files <code class="language-plaintext highlighter-rouge">20220915_multiscan_msgpack_output.msgpack.hex</code> resp. <code class="language-plaintext highlighter-rouge">20210929_multiscan_token_udp.msgpack.hex</code> in https://toolslick.com/conversion/data/messagepack-to-json and save the json-output.</p>

<h1 id="troubleshooting-and-technical-support">Troubleshooting and technical support</h1>

<p>The software is based on the ROS drivers sick_scan, sick_scan_base and sick_scan2. For FAQ and troubleshooting please also have a look at https://github.com/SICKAG/sick_scan , https://github.com/SICKAG/sick_scan_base and https://github.com/SICKAG/sick_scan2 .
Common problems might be solved in closed issues.</p>

<ol>
  <li>Check Scanner IP in the launch file.</li>
  <li>Check Ethernet connection to scanner with netcat e.g.
<code class="language-plaintext highlighter-rouge">nc -z -v -w5 $SCANNERIPADDRESS 2112
</code>.
For further details about setting up the correct ip settings see <a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#ip-address-configuration">IP configuration</a>)</li>
  <li>View node startup output wether the IP connection could be established</li>
  <li>Check the scanner status using the LEDs on the device. The LED codes are described in the above mentioned operation manuals.</li>
  <li>Further testing and troubleshooting informations can found in the file test/readme_testplan.txt</li>
  <li>If you stop the scanner in your debugging IDE or by other hard interruption (like Ctrl-C), you must wait until 60 sec. before
the scanner is up and running again. During this time the MRS6124 reconnects twice.
If you do not wait this waiting time you could see one of the following messages:
    <ul>
      <li>TCP connection error</li>
      <li>Error-Message 0x0d</li>
    </ul>
  </li>
  <li>Amplitude values in rviz: If you see only one color in rviz try the following:
Set the min/max-Range of intensity display in the range [0…200] and switch on the intensity flag in the launch file</li>
  <li>In case of network problems check your own ip address and the ip address of your laser scanner (by using SOPAS ET).
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>List of own IP-addresses: ifconfig</td>
              <td>grep “inet addr”</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Try to ping scanner ip address (used in launch file)</li>
    </ul>
  </li>
  <li>If the driver stops during init phase please stop the driver with ctrl-c and restart (could be caused due to protocol ASCII/Binary cola-dialect)</li>
</ol>

<p>In case of technical support please open a new issue. For optimal support, add the following information to your request:</p>

<ol>
  <li>Scanner model name,</li>
  <li>Ros node startup log,</li>
  <li>Sopas file of your scanner configuration. The instructions at https://sickconnect.com/create-and-download-a-sopas-file/ show how to create the Sopas file.</li>
</ol>

<p>In case of application support please use <a href="https://support.sick.com">https://support.sick.com</a>.</p>

<h1 id="creators-and-contribution">Creators and contribution</h1>

<p>Michael Lehning (http://www.lehning.de) on behalf of SICK AG (https://www.sick.com/)</p>

<p>This <a href="https://github.com/SICKAG/sick_scan_xd/tree/master//CONTRIBUTING.md">documentation</a> is intended to provide background information on the maintenance and extension of the repository.</p>

<h1 id="keywords">Keywords</h1>

<p>MRS1000, MRS1104, LMS1000, LMS1104, MRS6000, MRS6124, RMS1xxx, RMS1000, RMSxxxx, ROS LiDAR, SICK LiDAR, SICK Laser, SICK Laserscanner, SICK Radar, LMS1xx, MRS1xxx, LMS1xxx, MRS6xxx, TiM5xx, TiM551, TiM561, TiM571, TiM781, TiM781S, LMS5xx, LMS511, NAV210, NAV245, NAV310, LD-MRS, LRS4000, LD-LRS3600, LD-LRS3601, LD-LRS3611, LD-OEM1500, LD-OEM1501, multiScan100, multiScan, picoScan100, picoScan150, picoScan120, multiScan136, multiScan165</p>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<p><img align="right" width="200" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Logo_SICK_AG_2009.svg/1200px-Logo_SICK_AG_2009.svg.png"></p>

<h2 id="executive-summary">Executive Summary</h2>

<p>This documentation is intended to provide background information on the maintenance and extension of the repository.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#adding-a-new-device-to-the-driver">Adding a new device to the driver</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#naming-convention">Naming Convention</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#launch-files">Launch Files</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#code-modification">Code Modification</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#bloom-release">Bloom release</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#first-time-installation-of-toolchain">First time installation of toolchain</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#release-build-for-ros-1">Release build for ROS 1</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#release-build-for-ros-2">Release build for ROS 2</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#check-status">Check status</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#useful-links-and-information">Useful links and information</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#testing">Testing</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#unit-tests">Unit tests</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#examples">Examples</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#simulation">Simulation</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#windows">Windows</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#linux">Linux</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#profiling">Profiling</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#installation">Installation</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/master/#usage">Usage</a></li>
    </ul>
  </li>
</ul>

<h1 id="adding-a-new-device-to-the-driver">Adding a new device to the driver</h1>

<p>This driver is designed to support several different scanner types (including radar) from Sick. This documentation describes how to add additional devices to the driver.</p>

<h2 id="naming-convention">Naming Convention</h2>

<p>For each device type a name pattern is assigned as follows:
<code class="language-plaintext highlighter-rouge">
sick_&lt;device family&gt;_&lt;identifier&gt;
</code></p>

<p>The name type is used in the code to decide which scanner-specific parameters are set.
The name type is passed as a parameter as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="scanner_type" type="string" value="sick_lms_5xx" /&gt;

</code></pre></div></div>

<h2 id="launch-files">Launch Files</h2>

<p>A launch file is created for each device type,
which usually has the same naming convention as the scanner type.
To create a new device, it is recommended to copy, rename and edit an existing launch file.</p>

<h2 id="code-modification">Code Modification</h2>

<ol>
  <li>Hint: Construction of parser:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sick_scan_xd::SickGenericParser *parser = new sick_scan_xd::SickGenericParser(scannerName);
    
</code></pre></div></div>
<ol>
  <li>
    <p>Add string constant like the constant SICK_SCANNER_RMS_XXXX_NAME</p>
  </li>
  <li>
    <p>Append this constant to allowedScannerNames
like allowedScannerNames.push_back(SICK_SCANNER_RMS_XXXX_NAME);
in the file sick_generic_parser.cpp</p>
  </li>
  <li>
    <p>Add new parameter block like</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	if (basicParams[i].getScannerName().compare(SICK_SCANNER_MRS_1XXX_NAME) == 0)
	{...
	} in the file sick_generic_parser.cpp
	
</code></pre></div></div>

<ol>
  <li>Copy the file sick_generic_radar.cpp and add a new class following the structure
of this file.</li>
</ol>

<h1 id="bloom-release">Bloom release</h1>

<h2 id="first-time-installation-of-toolchain">First time installation of toolchain</h2>

<ol>
  <li>Install on Linux:
    <ul>
      <li>Install bloom:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        sudo apt-get update
        sudo apt-get install python3-bloom python3-catkin-pkg
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Install docker:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        pushd /tmp
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        sudo usermod -aG docker $USER
        popd
        shutdown -r now # reboot
        # short quicktest
        docker --version
        docker info
        docker run hello-world
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Install ros-buildfarm:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        # sudo apt-get install python3-ros-buildfarm # not successfully, unable to locate
        pip3 install ros-buildfarm # installs ros-buildfarm 3.0 successfully
        
</code></pre></div></div>

<ol>
  <li>Build the prerelease:
    <ul>
      <li>Short version to build a prerelase:
        <ul>
          <li>Run the following commands:</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            mkdir -p ./ws_sick_scan_xd_bloom/src
            cd ./ws_sick_scan_xd_bloom/src
            git clone -b master https://github.com/SICKAG/sick_scan_xd.git
            cd ./sick_scan_xd/test/scripts
            ./run_linux_ros1_bloom.bash
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * Fix any errors during the prerelease build and check in
    * Repeat `./run_linux_ros1_bloom.bash` until the the prerelease build finishes without errors
* Alternative version:
    * Open http://prerelease.ros.org/noetic in the brower
    * Add a custom repository: `sick_scan_xd` , `https://github.com/SICKAG/sick_scan_xd` , `master` (or `feature/bloom_pretest` or any other branch to test)
    * Add a custom repository: `msgpack11` , `https://github.com/SICKAG/msgpack11` , `master`
    * Add a custom repository: `libsick_ldmrs` , `https://github.com/SICKAG/libsick_ldmrs` , `master`
    * Confirm next steps (i.e. URL of build farm: https://raw.githubusercontent.com/ros-infrastructure/ros_buildfarm_config/production/index.yaml, Ubuntu focal)
    * Click on `Generate command`
    * Run the generated command, i.e.:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            source /opt/ros/noetic/setup.bash
            mkdir -p /tmp/prerelease_job
            cd /tmp/prerelease_job
            generate_prerelease_script.py \
              https://raw.githubusercontent.com/ros-infrastructure/ros_buildfarm_config/production/index.yaml \
              noetic default ubuntu focal amd64 \
              --custom-repo \
                sick_scan_xd:git:https://github.com/SICKAG/sick_scan_xd:master \
                msgpack11:git:https://github.com/SICKAG/msgpack11:master \
                libsick_ldmrs:git:https://github.com/SICKAG/libsick_ldmrs:master \
              --level 1 \
              --output-dir ./
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * Run `printf "\033c" ; rm -rf ~/.ccache ; mkdir -p ~/.ccache ; ./prerelease.sh` in folder `/tmp/prerelease_job`
    * In case of error message `/usr/lib/ccache/cc is not able to compile a simple test program`:
        * Remove folder `~/.ccache` before running `./prerelease.sh`
        * See https://answers.ros.org/question/347063/error-pre-release-melodic/
    * Fix any errors during the prerelease build and check in
    * Remove the temporary build folder by `rm -rf /tmp/prerelease_job`
    * Repeat until `prerelease.sh` finishes without errors.
</code></pre></div></div>

<ol>
  <li>Submit package sick_scan_xd for indexing (noetic)
    <ul>
      <li>Fork <code class="language-plaintext highlighter-rouge">https://github.com/ros/rosdistro</code> -&gt; <code class="language-plaintext highlighter-rouge">https://github.com/&lt;username&gt;/rosdistro.git</code>
</li>
      <li><code class="language-plaintext highlighter-rouge">git clone https://github.com/&lt;username&gt;/rosdistro.git</code></li>
      <li>Edit file <code class="language-plaintext highlighter-rouge">rosdistro/noetic/distribution.yaml</code> and add after <code class="language-plaintext highlighter-rouge">sick_scan</code>:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        sick_scan_xd:
          doc:
            type: git
            url: https://github.com/SICKAG/sick_scan_xd.git
            version: master
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* `cd rosdistro ; source /opt/ros/noetic/setup.bash ; rosdistro_reformat file://"$(pwd)"/index.yaml`
* git commit: `git commit -m "Adding sick_scan_xd to documentation index for distro noetic" distribution.yaml`
* git push: `git push origin master`
* Submit a pull request on `https://github.com/&lt;username&gt;/rosdistro`
</code></pre></div></div>

<ol>
  <li>For ROS 2 humble: Follow instructions on https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html</li>
</ol>

<p><strong><em>NOTE:</em></strong> Bloom releases for ROS 2 foxy are not longer supported (Pull request failed, “This pull request changes files for a ROS distribution that is no longer supported (End Of Life)”)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Submit package sick_scan_xd for indexing (ROS 2 humble)
    * Reset fork `https://github.com/&lt;username&gt;/rosdistro.git` to origin/master or delete the fork and create a new one -&gt; `https://github.com/&lt;username&gt;/rosdistro.git`
    * `git clone https://github.com/&lt;username&gt;/rosdistro.git`
    * Edit file `rosdistro/humble/distribution.yaml` and add after `sick_safevisionary_ros2`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            sick_scan_xd:
              doc:
                type: git
                url: https://github.com/SICKAG/sick_scan_xd.git
                version: develop
              status: developed
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * git commit and push ("Adding sick_scan_xd to documentation index for distro humble")
    * Submit a pull request on `https://github.com/&lt;username&gt;/rosdistro`
    * Do the same for any new ROS 2 version, e.g. iron and jazzy (`rosdistro/iron/distribution.yaml`, `rosdistro/jazzy/distribution.yaml`)
* [Start a new release team](https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&amp;labels=&amp;template=new_release_team.md&amp;title=Add+release+team)
    * ROS 2 sick_scan_xd team: https://github.com/orgs/ros2-gbp/teams/sick_scan_xd
    * ROS 2 sick_scan_xd release repository: https://github.com/ros2-gbp/sick_scan_xd-release
</code></pre></div></div>

<h2 id="release-build-for-ros-1">Release build for ROS 1</h2>

<ul>
  <li>Build a prerelease (dry run in a docker container):
    <ul>
      <li>Run the following commands:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        git clone -b master https://github.com/SICKAG/sick_scan_xd.git
        cd ./sick_scan_xd/test/scripts
        sudo dos2unix ./*.bash ; sudo chmod a+x ./*.bash
        ./run_linux_ros1_bloom.bash
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Fix any errors during the prerelease build and check in
* Repeat `./run_linux_ros1_bloom.bash` until the the prerelease build finishes without errors
</code></pre></div></div>

<ul>
  <li>Build a binary release: follow https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease
    <ul>
      <li>Update version number in package.xml, minor version number should be incremented at least</li>
      <li>Create resp. update CHANGELOG.rst:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        cd ./src/sick_scan_xd
        rm ./CHANGELOG.rst
        catkin_generate_changelog --all # create CHANGELOG.rst
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Commit and pull all changes incl. CHANGELOG.rst and package.xml:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        git add CHANGELOG.rst package.xml
        git commit -m "Update CHANGELOG.rst and package version"
        git push
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Run `catkin_prepare_release` and `bloom-release` in folder `src/sick_scan_xd`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        catkin_prepare_release -y
        bloom-release --rosdistro noetic --track noetic sick_scan_xd # at first time: call with option --edit for configuration
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* For the initial release (first time): Run `bloom-release` in folder `src/sick_scan_xd` with option `--edit`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        catkin_prepare_release -y
        bloom-release --rosdistro noetic --track noetic sick_scan_xd --edit
        Release repository url: https://github.com/SICKAG/sick_scan_xd-release.git
        upstream: &lt;default, i.e. press ENTER&gt;
        Upstream Repository URI: https://github.com/SICKAG/sick_scan_xd.git
        Upstream VCS Type: &lt;default: git, i.e. press ENTER&gt;
        Version: &lt;default: auto, i.e. press ENTER&gt;
        Release Tag: &lt;default: version, i.e. press ENTER&gt;
        Upstream Devel Branch: feature/bloom_pretest
        ROS Distro: noetic
        Patches Directory: &lt;default: none, i.e. press ENTER&gt;
        Release Repository Push URL:  &lt;default: none, i.e. press ENTER&gt;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Check status: https://index.ros.org/p/sick_scan_xd/#noetic
* Install binary release: `sudo apt update ; sudo apt-get install ros-noetic-sick-scan-xd`. Note from https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease : Packages built are periodically synchronized over to the shadow-fixed and public repositories, so it might take as long as a month before your package is available on the public ROS debian repositories (i.e. available via apt-get).
</code></pre></div></div>

<h2 id="release-build-for-ros-2">Release build for ROS 2</h2>

<p>For ROS 2 follow the instructions on https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html :</p>
<ul>
  <li>Checkout the sick_scan_xd version to be released and run:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    git clone -b master https://github.com/SICKAG/sick_scan_xd.git
    cd ./sick_scan_xd
    rm ./CHANGELOG.rst
    catkin_generate_changelog --all # create CHANGELOG.rst
    
</code></pre></div></div>
<ul>
  <li>Commit CHANGELOG.rst and optional modifications:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    git add CHANGELOG.rst
    git commit -m "Update CHANGELOG.rst"
    git push
    
</code></pre></div></div>
<ul>
  <li>Run <code class="language-plaintext highlighter-rouge">catkin_prepare_release</code> and <code class="language-plaintext highlighter-rouge">bloom-release</code>:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    bloom-release --rosdistro humble --track humble sick_scan_xd # at first time: call with option --new-track
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For the initial release (i.e. at the first time): Run bloom-relase configuration with option --new-track:
`bloom-release --new-track --rosdistro humble --track humble sick_scan_xd`
* Release repository url: https://github.com/ros2-gbp/sick_scan_xd-release.git
* Upstream: &lt;default&gt;
* Upstream Repository URI: https://github.com/SICKAG/sick_scan_xd.git
* Upstream Devel Branch: develop
* ROS Distro: humble
After the initial release has been approved: Run
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo rosdep init
    rosdep update
    
</code></pre></div></div>

<h2 id="check-status">Check status</h2>
<p>Jenkins build status:</p>
<ul>
  <li>ROS 1 noetic jenkins build status: https://build.ros.org/job/Ndev__sick_scan_xd__ubuntu_focal_amd64/lastBuild/</li>
  <li>ROS 2 humble jenkins build status: https://build.ros2.org/job/Hdev__sick_scan_xd__ubuntu_jammy_amd64/lastBuild/</li>
  <li>ROS 2 iron   jenkins build status: https://build.ros2.org/job/Idev__sick_scan_xd__ubuntu_jammy_amd64/lastBuild/</li>
  <li>ROS 2 jazzy  jenkins build status: https://build.ros2.org/job/Jdev__sick_scan_xd__ubuntu_noble_amd64/lastBuild/</li>
  <li>ROS 1 jenkins: https://build.ros.org/search/?q=sick_scan_xd</li>
  <li>ROS 2 jenkins: https://build.ros2.org/search/?q=sick_scan_xd</li>
</ul>

<p>Release repositories:</p>
<ul>
  <li>ROS 1 release repository: https://github.com/SICKAG/sick_scan_xd-release</li>
  <li>ROS 2 release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git</li>
</ul>

<p>Show version and list information about prebuilt binaries:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt show ros-noetic-sick-scan-xd
sudo apt show ros-humble-sick-scan-xd
sudo apt show ros-iron-sick-scan-xd
sudo apt show ros-jazzy-sick-scan-xd

</code></pre></div></div>

<p>Installation of prebuilt binaries:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-noetic-sick-scan-xd
sudo apt-get install ros-humble-sick-scan-xd
sudo apt-get install ros-iron-sick-scan-xd
sudo apt-get install ros-jazzy-sick-scan-xd
sudo apt-get remove ros-noetic-sick-scan-xd
sudo apt-get remove ros-humble-sick-scan-xd
sudo apt-get remove ros-iron-sick-scan-xd
sudo apt-get remove ros-jazzy-sick-scan-xd

</code></pre></div></div>

<h2 id="useful-links-and-information">Useful links and information</h2>

<ul>
  <li>http://wiki.ros.org/bloom</li>
  <li>https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease</li>
  <li>https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html</li>
</ul>

<p><strong>Bloom builds an old sick_scan_xd version (ROS 1)</strong></p>

<p>Check <code class="language-plaintext highlighter-rouge">devel_branch</code> in https://github.com/SICKAG/sick_scan_xd-release/blob/master/tracks.yaml . If devel_branch is an old branch, replace it with e.g. <code class="language-plaintext highlighter-rouge">develop</code> or <code class="language-plaintext highlighter-rouge">master</code>, or update the <code class="language-plaintext highlighter-rouge">&lt;devel_branch&gt;</code> to a new version.</p>

<p><strong>Bloom builds an old sick_scan_xd version (ROS 2)</strong>
Check <code class="language-plaintext highlighter-rouge">devel_branch</code> in https://github.com/ros2-gbp/sick_scan_xd-release/blob/master/tracks.yaml . If devel_branch is an old branch, replace it with e.g. <code class="language-plaintext highlighter-rouge">develop</code> or <code class="language-plaintext highlighter-rouge">master</code>, or update the <code class="language-plaintext highlighter-rouge">&lt;devel_branch&gt;</code> to a new version.</p>

<p><strong>Bloom builds a new sick_scan_xd version, but apt still installs an old version</strong></p>

<ul>
  <li>Check the sick_scan_xd version in the release repositories https://github.com/SICKAG/sick_scan_xd-release.git (ROS 1) and https://github.com/ros2-gbp/sick_scan_xd-release.git (ROS 2)</li>
  <li>Install bloom (if not yet done) using <code class="language-plaintext highlighter-rouge">sudo apt-get install python-bloom</code> on Linux or <code class="language-plaintext highlighter-rouge">pip install -U bloom</code> on Windows</li>
  <li>Run</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        bloom-release --rosdistro noetic -d sick_scan_xd # release repository: https://github.com/SICKAG/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro humble -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro iron   -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro jazzy  -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        
</code></pre></div></div>
<ul>
  <li>In case of github 2FA errors: Follow http://wiki.ros.org/bloom/Tutorials/GithubManualAuthorization to create a 2FA token and configure the token in file <code class="language-plaintext highlighter-rouge">~/.config/bloom</code>.</li>
  <li>Note: Updates of release repository https://github.com/SICKAG/sick_scan_xd-release.git require github authentification via ssh. See https://docs.github.com/en/authentication/connecting-to-github-with-ssh and https://wiki.ros.org/bloom/Tutorials/GithubManualAuthorization for details.</li>
</ul>

<h1 id="testing">Testing</h1>

<h2 id="unit-tests">Unit tests</h2>

<p>For a quick unit test after installation without the sensor hardware, a test server is provided to simulate a scanner. It implements a simple tcp server, which responds to binary cola messages and sends predefined LMDscandata to a tcp-client. The sick_scan_xd driver can connect to the local test server instead of the lidar device for offline-tests. Please note, that this test server does not emulate a Lidar sensor. It just sends some simple scan data and response messages to a tcp client. It can be used for a quick unit test after build and install.</p>

<p>To build the test server, activate cmake option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> in CMakeLists.txt and rebuild sick_scan_xd. By default, option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> is switched off.</p>

<p>For a unit test of LMS1xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_lms1xx.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms1xx.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_lms_1xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS5xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_lms5xx.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms5xx.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS7xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_tim_7xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS7xxS, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>Alternatively, you can just run the test scripts provided in folder <code class="language-plaintext highlighter-rouge">sick_scan_xd/test/scripts</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd/test/scripts
./makeall.bash
./run_simu_lms1xx.bash
./run_simu_lms5xx.bash
./run_simu_tim7xx_tim7xxS.bash

</code></pre></div></div>

<p>Make sure to finish all sick_scan_xd nodes after a test. All nodes can be killed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosnode kill -a ; sleep 1
killall sick_generic_caller ; sleep 1
killall sick_scan_emulator ; sleep 1

</code></pre></div></div>

<h2 id="examples">Examples</h2>

<p>rviz example screenshots using sick_scan_xd with LMS1xx and LMS5xx test server:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/emulator_lms1xx_screenshot.png" alt="emulator_lms1xx_screenshot.png"></p>

<p>rviz example screenshots using sick_scan_xd with LMS7xx and LMS7xxS test server:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/emulator_lms7xx_screenshot.png" alt="emulator_lms1xx_screenshot.png"></p>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h1 id="simulation">Simulation</h1>

<p>For unittests without sensor hardware, a simple test server is provided. To build the test server, call either cmake with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code>, or activate cmake option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> in CMakeLists.txt. Then rebuild sick_scan_xd. By default, option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> is switched off.</p>

<p>Please note that this just builds a simple test server for basic unittests of sick_scan_xd drivers. Its purpose is to run basic tests and to help with diagnosis in case of issues. It does not emulate a real scanner!</p>

<p>Simulation requires jsoncpp. Install with <code class="language-plaintext highlighter-rouge">sudo apt-get install libjsoncpp-dev</code> on Linux and with <code class="language-plaintext highlighter-rouge">vcpkg install jsoncpp:x64-windows</code> on Windows.</p>

<p>You can find examples to test and run sick_scan_xd in offline mode in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>. Their purpose is to demonstrate the usage of the sick_scan_xd driver. Please feel free to customize the scripts or use them as a starting point for own projects.</p>

<h2 id="windows">Windows</h2>

<p>Run script <code class="language-plaintext highlighter-rouge">run_simu_lms_5xx.cmd</code> in folder <code class="language-plaintext highlighter-rouge">test/scripts</code> or execute the following commands:</p>

<ol>
  <li>Start the test server:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    cd .\build
    start "testserver" cmd /k python ../test/emulator/test_server.py --scandata_file=../test/emulator/scandata/20210302_lms511.pcapng.scandata.txt --scandata_frequency=20.0 --tcp_port=2112
    @timeout /t 1
    
</code></pre></div></div>

<ol>
  <li>Run sick_generic_caller. On native Windows:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    .\Debug\sick_generic_caller.exe ../launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>On Windows with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False
    
</code></pre></div></div>

<ol>
  <li>Open file <code class="language-plaintext highlighter-rouge">image_viewer.html</code> in folder <code class="language-plaintext highlighter-rouge">demo</code> in your browser to view a jpg-image of the current scan.</li>
</ol>

<p>Note, that python version 3 incl. runtime dlls must be accessable, f.e. by extending the PATH environment variable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PYTHON_DIR=%ProgramFiles(x86)%/Microsoft Visual Studio/Shared/Python37_64
set PATH=%PYTHON_DIR%;%PYTHON_DIR%/Scripts;c:\vcpkg\installed\x64-windows\bin;%PATH%

</code></pre></div></div>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h2 id="linux">Linux</h2>

<p>Run script <code class="language-plaintext highlighter-rouge">run_simu_lms_5xx.bash</code> in folder <code class="language-plaintext highlighter-rouge">test/scripts</code> or execute the following commands:</p>

<ol>
  <li>Start the test server:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    python3 ./test/emulator/test_server.py --scandata_file=./test/emulator/scandata/20210302_lms511.pcapng.scandata.txt --scandata_frequency=20.0 --tcp_port=2112 &amp;
    sleep 1
    
</code></pre></div></div>

<ol>
  <li>Run sick_generic_caller.
    <ul>
      <li>On native Linux:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        ./build/sick_generic_caller ./launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 1:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>

<ol>
  <li>View the point cloud.
    <ul>
      <li>On native Linux:<br>
   Open file <code class="language-plaintext highlighter-rouge">image_viewer.html</code> in folder <code class="language-plaintext highlighter-rouge">demo</code> in a browser (f.e. firefox) to view a jpg-image of the current scan.</li>
      <li>On Linux with ROS 1:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg_lms5xx.rviz &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_lms5xx.rviz &amp;
        
</code></pre></div></div>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h1 id="profiling">Profiling</h1>

<p>Since the existing node can basically be used on different platforms, bottlenecks can occur with weak hardware. To better analyze these bottlenecks, software profiling can be performed.
The following example shows how to perform profiling.
For further details on profiling, please refer to https://baptiste-wicht.com/posts/2011/09/profile-c-application-with-callgrind-kcachegrind.html, for example.</p>

<h2 id="installation">Installation</h2>

<p>First of all, you need to install Callgrind and KCachegrind.
You also need to install graphviz in order to view the call graph in KCachegrind. The applications are already packaged for the most important Linux distributions. You can just use apt-get to install them:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install valgrind kcachegrind graphviz

</code></pre></div></div>
<h2 id="usage">Usage</h2>
<p>We have to start by profiling the application with Callgrind. To profile an application with Callgrind, you just have to prepend the Callgrind invocation in front of your normal program invocation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind --tool=callgrind program [program_options]

</code></pre></div></div>
<p>In order to establish a reference to the source code during profiling, the program must be compiled with debug symbols, this can be done with catkin_make</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catkin_make install -DCMAKE_BUILD_TYPE=Debug

</code></pre></div></div>
<p>It is necessary to create a rosmaster so that the sick_scan_xd node can connect to it because we can’t use roslaunch during profiling.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roscore

</code></pre></div></div>
<p>To set the parameters we start a node as usual with roslaunch.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=192.168.0.151

</code></pre></div></div>
<p>While this node is running we can use
<code class="language-plaintext highlighter-rouge">ps -aef| grep sick_scan_xd
</code> to determine the program path and the call parameters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosuser@ROS-NB:~$ ps -aef|grep sick_scan_xd
rosuser   4839  2443  0 14:43 pts/1    00:00:00 /usr/bin/python /opt/ros/melodic/bin/roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=192.168.0.151
rosuser   4854  4839  1 14:43 ?        00:00:03 /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller __name:=sick_lms_5xx __log:=/home/rosuser/.ros/log/f9861670-304c-11e9-9839-54e1ad2921b6/sick_lms_5xx-1.log
rosuser   4910  4875  0 14:46 pts/6    00:00:00 grep --color=auto sick_scan_xd

</code></pre></div></div>
<p>now we can close the node and restart with callgrid</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind --tool=callgrind program /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller __name:=sick_lms_5xx

</code></pre></div></div>
<p>The result will be stored in a callgrind.out.XXX file where XXX will be the process identifier.
You can read this file using a text editor, but it won’t be very useful because it’s very cryptic.
That’s here that KCacheGrind will be useful. You can launch KCacheGrind using command line
or in the program menu if your system installed it here. Then, you have to open your profile file.</p>

<p>The first view present a list of all the profiled functions. You can see the inclusive
and the self cost of each function and the location of each one.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/src_view.png" alt="src_view.png"></p>

<p>Once you click on a function, the other views are filled with information. The view in uppper right part of the window gives some information about the selected function.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/profile_002.png" alt="profile_002"></p>

<p>The view have several tabs presenting different information:</p>

<ul>
  <li>Types : Present the types of events that have been recorded. In our case, it’s not really interesting, it’s just the number of instructions fetch</li>
  <li>Callers : List of the direct callers.</li>
  <li>All Callers : List of all the callers, it seems the callers and the callers of the callers.</li>
  <li>Callee Map : A map of the callee, personally, I do not really understand this view, but it’s a kind of call graph representing the cost of the functions.</li>
  <li>Source code : The source code of the function if the application has been compiled with the debug symbol.</li>
</ul>

<p>And finally, you have another view with data about the selected function.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/master/doc/profile_003.png" alt="profile_003"></p>

<p>Again, several tabs:</p>

<ul>
  <li>Callees : The direct callees of the function</li>
  <li>Call Graph : The call graph from the function to the end</li>
  <li>All Callees : All the callees and the callees of the callees</li>
  <li>Caller Map : All functions are represented as blocks the size corresponds to their CPU time. Callees are stacked on the callers.</li>
  <li>Machine Code : The machine code of the function if the application has been profiled with –dump-instr=yes option</li>
</ul>

<p>You have also several display options and filter features to find exactly what you want and display it the way you want.</p>

<p>The information provided by KCacheGrind can be very useful to find which functions takes too much time or which functions are called too much.
This text is an adopted version of https://baptiste-wicht.com/posts/2011/09/profile-c-application-with-callgrind-kcachegrind.html . Thanks to Baptiste Wicht.</p>
</div>
              <hr id="noetic-contribute-lists">
              <ul class="nav nav-tabs nav-justified" id="noetic-contribute-lists-tabs">
                <li class="better-tabs active">
                  <a href="#noetic-contribute-lists-help-wanted" data-toggle="tab"><span class="contribute-lists-help-wanted-count label label-primary">0</span> Help Wanted</a>
                </li>
                <li class="better-tabs">
                  <a href="#noetic-contribute-lists-good-first-issue" data-toggle="tab"><span class="contribute-lists-good-first-issue-count label label-primary">0</span> Good First Issue</a>
                </li>
                <li class="better-tabs">
                  <a href="#noetic-contribute-lists-pull-requests" data-toggle="tab"><span class="contribute-lists-pull-requests-count label label-primary">0</span> Pull Requests to Review</a>
                </li>
              </ul>
              <div class="tab-content contribute-lists">
                <div class="tab-pane active" id="noetic-contribute-lists-help-wanted">
                  <div class="contribute-lists-help-wanted"></div>
                </div>
                <div class="tab-pane" id="noetic-contribute-lists-good-first-issue">
                  <div class="contribute-lists-good-first-issue"></div>
                </div>
                <div class="tab-pane" id="noetic-contribute-lists-pull-requests">
                  <div class="contribute-lists-pull-requests"></div>
                </div>
              </div>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-galactic">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/sick_scan_xd">sick_scan_xd</a> <small>repository</small></h3>
        <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-SICKAG-sick_scan_xd
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-SICKAG-sick_scan_xd" role="menuitem" tabindex="-1" href="/r/sick_scan_xd/github-SICKAG-sick_scan_xd" data="github-SICKAG-sick_scan_xd">
                    <span class="glyphicon glyphicon-star"></span>
                    github-SICKAG-sick_scan_xd
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>galactic</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>

  <div class="distro distro-iron">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/sick_scan_xd">sick_scan_xd</a> <small>repository</small></h3>
        <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        
        <a class="label label-primary pkg-label" href="/p/sick_scan_xd">sick_scan_xd</a>
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-SICKAG-sick_scan_xd
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-SICKAG-sick_scan_xd" role="menuitem" tabindex="-1" href="/r/sick_scan_xd/github-SICKAG-sick_scan_xd" data="github-SICKAG-sick_scan_xd">
                    <span class="glyphicon glyphicon-star"></span>
                    github-SICKAG-sick_scan_xd
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        
        <div class="panel panel-default">
          
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body" style="overflow-x: auto">
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">A versatile driver for a wide range of SICK LiDAR and RADAR devices, providing support for both Linux (native, ROS 1, ROS 2) and Windows (native, ROS 2) platforms.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/SICKAG/sick_scan_xd.git">https://github.com/SICKAG/sick_scan_xd.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">develop</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2025-04-03
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/sick_scan_xd/#iron-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/sick_scan_xd/#iron-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/sick_scan_xd/#iron-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Packages</h3></div>
          <div class="panel-body">
            
            
              <table class="table table-condensed table-hover table-striped">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Version</th>
                  </tr>
                </thead>
                <tbody>
                
                  <tr>
                    <td><a href="/p/sick_scan_xd">sick_scan_xd</a></td>
                    <td>3.6.0</td>
                  </tr>
                
                </tbody>
              </table>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">README</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<p><img align="right" width="200" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Logo_SICK_AG_2009.svg/1200px-Logo_SICK_AG_2009.svg.png"></p>

<h2 id="executive-summary">Executive Summary</h2>

<p>This project provides a driver for the SICK LiDARs and Radar sensors mentioned <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#supported-sick-devices">here</a>. The driver supports both Linux (native, ROS 1, ROS 2) and Windows (native and ROS 2). See the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/CHANGELOG.md">CHANGELOG.md</a> for the latest updates.</p>

<p><strong>Main features and characteristics</strong></p>
<ul>
  <li>Support of ROS 1 (Linux), ROS 2 (Linux and Windows)</li>
  <li>Generic C/C++ and python API for usage without ROS (Linux and Windows)</li>
  <li>SLAM support</li>
  <li>Compatible with x64 and ARM64 architecture (incl. Raspberry Pi)</li>
  <li>No dependencies to 3rd party libraries like boost</li>
</ul>

<h2 id="table-of-contents">Table of Contents</h2>

<details>
  <summary>Expand to full table of contents </summary>

- [Repository organization](#repository-organization)
- [Supported SICK Devices](#supported-sick-devices)
- [Getting started](#getting-started)
  - [Detecting SICK devices in the network](#detecting-sick-devices-in-the-network)
  - [Change IP address](#change-ip-address)
  - [Starting with a new lidar](#starting-with-a-new-lidar)
  - [Test connection (Linux)](#test-connection-linux)
- [Building the driver](#building-the-driver)
  - [Build on Linux ROS 1](#build-on-linux-ros-1)
    - [Install prebuilt binaries](#install-prebuilt-binaries)
    - [Build from sources](#build-from-sources)
  - [Build on Linux ROS 2](#build-on-linux-ros-2)
    - [Install prebuilt binaries](#install-prebuilt-binaries-1)
    - [Build from sources](#build-from-sources-1)
  - [Build on Windows ROS 2](#build-on-windows-ros-2)
  - [Build on Linux generic without ROS](#build-on-linux-generic-without-ros)
  - [Build on Windows generic without ROS](#build-on-windows-generic-without-ros)
- [Running the driver](#running-the-driver)
  - [Starting Scanner with Specific IP Address](#starting-scanner-with-specific-ip-address)
  - [Start Multiple Nodes](#start-multiple-nodes)
  - [Common parameters](#common-parameters)
  - [Further useful parameters and features](#further-useful-parameters-and-features)
  - [ROS services](#ros-services)
  - [Driver states, timeouts](#driver-states-timeouts)
  - [SOPAS Mode](#sopas-mode)
  - [Example Startup Sequence](#example-startup-sequence)
- [Driver features and additional information](#driver-features-and-additional-information)
  - [Software Overview](#software-overview)
    - [Software structure](#software-structure)
    - [Message receiving and message handling](#message-receiving-and-message-handling)
    - [sick\_scansegment\_xd](#sick_scansegment_xd)
    - [Files and folders](#files-and-folders)
  - [Generic Driver API](#generic-driver-api)
    - [Overview](#overview)
    - [Build and test shared library](#build-and-test-shared-library)
    - [Usage example](#usage-example)
    - [C-API](#c-api)
    - [Useful links](#useful-links)
  - [Timestamps and synchronization (Software PLL)](#timestamps-and-synchronization-software-pll)
  - [Coordinate transforms](#coordinate-transforms)
  - [IMU Support](#imu-support)
  - [Encoders](#encoders)
    - [Connecting encoders](#connecting-encoders)
    - [Example circuit to trigger encoder counts](#example-circuit-to-trigger-encoder-counts)
    - [Activation of encoder information](#activation-of-encoder-information)
  - [Field Evaluation Information](#field-evaluation-information)
    - [Field monitoring messages](#field-monitoring-messages)
    - [Visualization with rviz](#visualization-with-rviz)
    - [Cola commands](#cola-commands)
    - [Tools, emulation and unittests](#tools-emulation-and-unittests)
  - [SLAM Support](#slam-support)
    - [Introduction](#introduction)
    - [Measuring Principle](#measuring-principle)
    - [NAV350 ROS 1 SLAM example](#nav350-ros-1-slam-example)
    - [NAV350 ROS 2 SLAM example](#nav350-ros-2-slam-example)
    - [picoScan100 ROS 1 SLAM example](#picoscan100-ros-1-slam-example)
    - [MRS1104 SLAM support](#mrs1104-slam-support)
    - [Google Cartographer](#google-cartographer)
    - [OctoMap](#octomap)
    - [RTAB-Map](#rtab-map)
  - [Raspberry Pi Support](#raspberry-pi-support)
    - [multiScan100 example](#multiscan100-example)
    - [Performance](#performance)
    - [Troubleshooting](#troubleshooting)
  - [More Tools](#more-tools)
- [Device specific information](#device-specific-information)
  - [picoScan100/multiScan100](#picoscan100multiscan100)
    - [Configuration](#configuration)
    - [IMU support](#imu-support-1)
    - [SOPAS support](#sopas-support)
    - [Run multiScan100 and picoScan100 simultaneously](#run-multiscan100-and-picoscan100-simultaneously)
    - [Visualization](#visualization)
    - [PointCloud memory layout](#pointcloud-memory-layout)
    - [Customized point clouds](#customized-point-clouds)
    - [Customized point clouds on a Raspberry Pi](#customized-point-clouds-on-a-raspberry-pi)
    - [MSGPACK validation](#msgpack-validation)
    - [Firewall configuration](#firewall-configuration)
    - [SOPAS support for sick\_scan\_segment\_xd](#sopas-support-for-sick_scan_segment_xd)
  - [TiM781 and TiM781S](#tim781-and-tim781s)
  - [TiM240](#tim240)
  - [NAV350](#nav350)
    - [Process loop](#process-loop)
    - [Initialization and setup](#initialization-and-setup)
    - [Messages](#messages)
    - [Odometry messages](#odometry-messages)
    - [Angle compensation](#angle-compensation)
  - [MRS6124](#mrs6124)
    - [Timing between Layers](#timing-between-layers)
    - [MRS600 with RMS1000](#mrs600-with-rms1000)
  - [RMS1000](#rms1000)
    - [Raw Targets](#raw-targets)
    - [Tracking Objects](#tracking-objects)
    - [ROS message for Radar](#ros-message-for-radar)
    - [Launch Files](#launch-files)
    - [Parameter for Radar Usage](#parameter-for-radar-usage)
    - [Radar Datagram](#radar-datagram)
  - [RMS1000 and LMS1000 combination](#rms1000-and-lms1000-combination)
  - [LMS1000 and MRS1000 interlacing](#lms1000-and-mrs1000-interlacing)
- [FAQ](#faq)
  - [General](#general)
  - [Networking](#networking)
  - [multiScan100 / picoScan100](#multiscan100--picoscan100)
- [Troubleshooting and technical support](#troubleshooting-and-technical-support)
- [Creators and contribution](#creators-and-contribution)
- [Keywords](#keywords)


</details>

<h1 id="repository-organization">Repository organization</h1>

<p>The repository supports two main branches. The <strong>“master”</strong> branch is the branch that contains official releases that are tagged and versioned and also included in the ROS distribution. If you want to work with this official branch, you must explicitly specify this branch in the ‘git clone’ command by adding “-b master”. The “develop” branch is the default branch and contains the latest development status.</p>

<p>Example:</p>

<p>Checking out the latest revision (usually older than the develop version, but officially released):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone -b master https://github.com/SICKAG/sick_scan_xd.git

</code></pre></div></div>

<p>Checking out the latest development status:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/SICKAG/sick_scan_xd.git

</code></pre></div></div>

<h1 id="supported-sick-devices">Supported SICK Devices</h1>

<p>The driver supports Ethernet-IPv4-based communication with all of the following SICK products.</p>

<table>
  <thead>
    <tr>
      <th>2D LiDAR sensors</th>
      <th>Part no.</th>
      <th>3D LiDAR sensors</th>
      <th>Part no.</th>
      <th>RADAR sensors</th>
      <th>Part no.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>picoScan100 <a href="https://support.sick.com/sick-knowledgebase/article/?code=KA-09438">(supports native ROS 2 as well)</a>
</td>
      <td><a href="https://www.sick.com/de/en/search?text=1134610">e.g. 1134610</a></td>
      <td>multiScan100</td>
      <td><a href="https://www.sick.com/de/en/search?text=1131164">e.g. 1131164</a></td>
      <td>RMS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1107598">e.g. 1107598</a></td>
    </tr>
    <tr>
      <td>LRS4000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1098855">e.g. 1098855</a></td>
      <td>MRS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1081208">e.g. 1081208</a></td>
      <td>RMS2000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1129088">e.g. 1129088</a></td>
    </tr>
    <tr>
      <td>TiM2xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1104981">1104981</a></td>
      <td>MRS6124</td>
      <td><a href="https://www.sick.com/de/en/search?text=6065086">6065086</a></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM5xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060445">e.g. 1060445</a></td>
      <td>LD-MRS</td>
      <td><a href="https://www.sick.com/de/de/p/p662073">e.g. 1115128</a></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM7xxS</td>
      <td><a href="https://www.sick.com/de/en/search?text=1105052">e.g. 1105052</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>TiM7xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1096807">e.g 1096807</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS5xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1046135">e.g. 1046135</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1092445">1092445</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS1xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1041114">e.g. 1041114</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LMS4000</td>
      <td><a href="https://www.sick.com/de/en/search?text=1091423">e.g. 1091423</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LD-LRS</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060831">e.g. 1060831</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>LD-OEM</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060828">e.g. 1060828</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV3xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1060834">e.g. 1060834</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV2xx</td>
      <td><a href="https://www.sick.com/de/en/search?text=1074308">e.g. 1074308</a></td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS family is currently not supported on Windows.</li>
    <li>ROS services require installation of ROS 1 or ROS 2.</li>
    <li>ROS services are currently not available for LD-MRS.</li>
    <li>Publishing point cloud data requires ROS 1 or ROS 2. On native Linux and native Windows, point cloud data are exported via API</li>
    <li>The driver is not tested on MAC</li>
  </ul>
</blockquote>

<h1 id="getting-started">Getting started</h1>

<p>Run the following steps for a quick start:</p>

<ol>
  <li>
    <p>Create a workspace (e.g. folder <code class="language-plaintext highlighter-rouge">sick_scan_ws</code>), clone the sick_scan_xd repository and build sick_generic_caller and shared library:</p>

    <ul>
      <li>For <strong>Linux without ROS</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-generic-without-ros">build instructions for Linux generic without ROS</a>
</li>
      <li>For <strong>Linux with ROS 1</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-ros-1">build instructions for Linux ROS 1</a>
</li>
      <li>For <strong>Linux with ROS 2</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-ros-2">build instructions for Linux ROS 2</a>
</li>
      <li>For <strong>Windows without ROS</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-windows-generic-without-ros">build instructions for Windows without ROS</a>
</li>
      <li>For <strong>Windows with ROS 2</strong>: Follow the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-windows-ros-2">build instructions for Windows with ROS 2</a>
</li>
    </ul>
  </li>
  <li>
    <p>Connect your lidar. Check the network connection by <code class="language-plaintext highlighter-rouge">ping &lt;lidar-ip-address&gt;</code>.</p>
  </li>
  <li>
    <p>Run the sick_scan_xd driver:</p>

    <p>For <strong>Linux without ROS</strong>: Use the sick_scan_xd API and run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to the build folder
      ./build/sick_scan_xd_api_test ./sick_scan_xd/launch/sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Linux with ROS 1</strong>: Launch sick_scan_xd: <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      source ./devel_isolated/setup.bash
      roslaunch sick_scan_xd sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Linux with ROS 2</strong>: Run <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd ./sick_scan_ws
      source ./install/setup.bash
      ros2 launch sick_scan_xd sick_tim_7xx.launch.py hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Windows without ROS</strong>: Use the sick_scan_xd API and run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd .\sick_scan_ws\sick_scan_xd
      set PATH=.;.\build;..\build\Debug;%PATH%
      .\build\Debug\sick_scan_xd_api_test.exe launch/sick_tim_7xx.launch hostname:=192.168.0.1
      
</code></pre></div></div>

<p>For <strong>Windows with ROS 2</strong>: Run <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;</code>, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cd .\sick_scan_ws
      call .\install\setup.bat
      ros2 launch sick_scan_xd sick_tim_7xx.launch.py hostname:=192.168.0.1
      
</code></pre></div></div>

<h2 id="detecting-sick-devices-in-the-network">Detecting SICK devices in the network</h2>

<p>The Python script</p>

<pre><code class="language-sick_scan_xd/tools/sick_generic_device_finder/sick_generic_device_finder.py">
</code></pre>
<p>sends a UDP broadcast to which all available scanners respond with a device description.
The variable
<code class="language-plaintext highlighter-rouge">UDP_IP = "192.168.0.255"
</code> defines the broadcast address used by the script.
If you are using a different IP address configuration on your host pc you have to change this variable according to the broadcast address of your network card.</p>

<pre><code class="language-ifconfig">``` shows the broadcast address for every network adapter.

## Change IP address

The IP address of the device can be changed with a customized launch file. The following launch sequence is an example:

```roslaunch sick_scan_xd sick_new_ip.launch hostname:=192.168.0.1 new_IP:=192.168.0.100
</code></pre>

<p>The launch file restarts the lidar after the address change and stops the sick_scan_xd node. After a few seconds of booting time the scanner is reachable under the new IP address. The Python script is experimental. It is known that some ethernet adapter are not fully supported. As a fallback solution you can always use the SOPAS ET software under windows.</p>

<h2 id="starting-with-a-new-lidar">Starting with a new lidar</h2>

<p>The lidar is delivered with a standard IP address, to read or change it the <a href="https://www.sick.com/de/de/sopas-engineering-tool-2018/p/p367244">SICK SOPAS ET</a> for windows can be used.
When the tool is started, a search is performed which lists all scanners available in the network.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/scanner_found.PNG" alt="SOPAS start" title="SOPAS start"></p>

<p>Double-click to select the scanner for the project</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/scanner_added.PNG" alt="SOPAS select" title="SOPAS select"></p>

<p>Double click on the lidar icon to open the configuration menu of the scanner. Select here the network configuration menu and set the parameters by clicking on the save icon (red arrow)</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/set_config.PNG" alt="SOPAS save network" title="SOPAS save network"></p>

<p>To ensure that the settings are stored even after a power cycle, they must be stored in the eeprom. To do this, click on the eeprom icon and confirm the save.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/save_permanent.PNG" alt="SOPAS save eeprom" title="SOPAS save eeprom"></p>

<p>To test the settings under Windows use the commands</p>
<pre><code class="language-ipconfig">``` and 
```ping
``` in the 
```cmd.exe
```. Make sure that the lidar and host pc have different IP addresses e.g. 192.168.0.1 for the pc and 192.168.0.2 for the scanner.

## Test connection (Linux)

to test the settings under the Linux target system you can use netcat to check if a TCP connection to the scanner can be established

```nc -z -v -w5 $SCANNERIPADDRESS 2112
</code></pre>
<p>the connection can be successfully established</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/nc_scanner.PNG" alt="Linux netcat scanner" title="linux netcat scanner"></p>

<p>unlike a ping, the connection attempt to the host PC is not successful</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/ipconfig/nc_win_host.PNG" alt="Linux netcat host" title="linux netcat host"></p>

<h1 id="building-the-driver">Building the driver</h1>

<p>sick_scan_xd can be build on 64-bit Linux and Windows, with and without ROS, with and without LDMRS. The following table shows the allowed combinations and how to build. sick_scan_xd supports 64 bit Linux and Windows, 32 bit systems are not supported.</p>

<table>
  <thead>
    <tr>
      <th><strong>target</strong></th>
      <th><strong>cmake settings</strong></th>
      <th><strong>build script</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linux, native, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_linux.bash</td>
    </tr>
    <tr>
      <td>Linux, native, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_linux_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 1, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros1.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 1, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros1_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 2, LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT ON</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros2.bash</td>
    </tr>
    <tr>
      <td>Linux, ROS 2, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test/scripts &amp;&amp; chmod a+x ./*.bash &amp;&amp; ./makeall_ros2_no_ldmrs.bash</td>
    </tr>
    <tr>
      <td>Windows, native, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test\scripts &amp;&amp; make_win64.cmd</td>
    </tr>
    <tr>
      <td>Windows, ROS 2, no LD-MRS</td>
      <td>BUILD_WITH_LDMRS_SUPPORT OFF</td>
      <td>cd test\scripts &amp;&amp; make_ros2.cmd</td>
    </tr>
  </tbody>
</table>

<p>If you’re using ROS, set your ROS-environment before running one of these scripts, f.e.
<code class="language-plaintext highlighter-rouge">source /opt/ros/noetic/setup.bash</code> for ROS 1 noetic, or
<code class="language-plaintext highlighter-rouge">source /opt/ros/foxy/setup.bash</code> for ROS 2 foxy, or
<code class="language-plaintext highlighter-rouge">source /opt/ros/humble/setup.bash</code> for ROS 2 humble.
See the build descriptions for more details.</p>

<h2 id="build-on-linux-ros-1">Build on Linux ROS 1</h2>

<p>To build resp. install sick_scan_xd on Linux with ROS 1, you can build sick_scan_xd from sources or install prebuilt binaries.</p>

<h3 id="install-prebuilt-binaries">Install prebuilt binaries</h3>

<p>Run the following steps to install sick_scan_xd on Linux with ROS 1 noetic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-noetic-sick-scan-xd

</code></pre></div></div>

<p>After successful installation, you can run sick_scan_xd using <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd &lt;launchfile&gt;</code>, e.g. <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_picoscan.launch</code> for picoScan. sick_scan_xd can be removed by <code class="language-plaintext highlighter-rouge">sudo apt-get remove ros-noetic-sick-scan-xd</code>.</p>

<h3 id="build-from-sources">Build from sources</h3>

<p>Run the following steps to build sick_scan_xd on Linux with ROS 1:</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir ./src
   pushd ./src
   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   rm -rf ./build ./build_isolated/ ./devel ./devel_isolated/ ./install ./install_isolated/ ./log/ # remove any files from a previous build
   
</code></pre></div></div>
<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   source /opt/ros/noetic/setup.bash # replace noetic by your ros distro
   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
   source ./devel_isolated/setup.bash
   # source ./install_isolated/setup.bash
   
</code></pre></div></div>
<p>For ROS versions other than noetic, please replace <code class="language-plaintext highlighter-rouge">source /opt/ros/noetic/setup.bash</code> with your ros distribution.</p>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DRASPBERRY=1 -Wno-dev
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call catkin_make_isolated with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -Wno-dev
   
</code></pre></div></div>

<p>To build sick_generic_caller without multiScan136/sick_scansegment_xd/picoScan150 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DSCANSEGMENT_XD=0 -Wno-dev
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build <strong>without LDMRS</strong> and <strong>without multiScan100/picoScan100 support</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DSCANSEGMENT_XD=0 -Wno-dev
   
</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<p><strong>Build options</strong></p>

<p><strong>Without LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -DSCANSEGMENT_XD=0 -Wno-dev

</code></pre></div></div>
<p><strong>Without LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DLDMRS=0 -Wno-dev

</code></pre></div></div>
<p><strong>with LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DSCANSEGMENT_XD=0 -Wno-dev

</code></pre></div></div>
<p><strong>with LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev

</code></pre></div></div>

<p>To create source code documentation by doxygen, run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-linux-ros-2">Build on Linux ROS 2</h2>

<p>To build resp. install sick_scan_xd on Linux with ROS 2, you can build sick_scan_xd from sources or install prebuilt binaries.</p>

<h3 id="install-prebuilt-binaries-1">Install prebuilt binaries</h3>

<p>Run the following steps to install sick_scan_xd on Linux with ROS 2 humble:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-humble-sick-scan-xd

</code></pre></div></div>

<p>After successful installation, you can run sick_scan_xd using <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd &lt;launchfile&gt;.py</code>, e.g. <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py</code> for multiScan. sick_scan_xd can be removed by <code class="language-plaintext highlighter-rouge">sudo apt-get remove ros-humble-sick-scan-xd</code>.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> ROS 2 humble Debian packages require Ubuntu 22 or newer, see https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html for system requirements.</p>
</blockquote>

<h3 id="build-from-sources-1">Build from sources</h3>

<p>Run the following steps to build sick_scan_xd on Linux with ROS 2:</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir ./src
   pushd ./src
   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   rm -rf ./build ./build_isolated/ ./devel ./devel_isolated/ ./install ./install_isolated/ ./log/ # remove any files from a previous build
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   source /opt/ros/foxy/setup.bash # replace foxy by your ros distro
   colcon build --packages-select libsick_ldmrs --event-handlers console_direct+
   source ./install/setup.bash
   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" --event-handlers console_direct+
   source ./install/setup.bash
   
</code></pre></div></div>
<p>For ROS versions other than foxy, please replace <code class="language-plaintext highlighter-rouge">source /opt/ros/foxy/setup.bash</code> with your ros distribution.</p>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DRASPBERRY=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call colcon with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" --event-handlers console_direct+
   
</code></pre></div></div>
<p>To build sick_generic_caller without multiScan136/sick_scansegment_xd/picoScan150 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build <strong>without LDMRS</strong> and <strong>without multiScan100/picoScan100 support</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<p>Depending on the ROS 2 distribution, package diagnostic_updater might not be found (compiler error: <code class="language-plaintext highlighter-rouge">diagnostic_updater.hpp not found</code>). In this case package diagnostic_updater has to be installed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install ros-${ROS_DISTRO}-diagnostic-updater
sudo apt install ros-${ROS_DISTRO}-diagnostic-msgs
# E.g. to install diagnostic_updater on foxy, run
# sudo apt-get install ros-foxy-diagnostic-updater
# sudo apt install ros-foxy-diagnostic-msgs

</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<p><strong>Build options</strong></p>

<p><strong>Without LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>Without LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DLDMRS=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>with LDMRS-support</strong> and <strong>without multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+

</code></pre></div></div>

<p><strong>with LDMRS-support</strong> and <strong>with multiScan100/picoScan100 support</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " --event-handlers console_direct+

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong> To create source code documentation by doxygen, run</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-windows-ros-2">Build on Windows ROS 2</h2>

<p>To install sick_scan_xd on Windows with ROS 2, follow the steps below:</p>

<ol>
  <li>
    <p>If not yet done, install Visual Studio. Visual Studio 2019 Community or Professional Edition is recommended.</p>
  </li>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir sick_scan_ws
   cd sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repository https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir .\src
   pushd .\src
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   popd
   
</code></pre></div></div>

<ol>
  <li>Set the ROS 2 and Visual-Studio environment:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   call "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\Common7\Tools\VsDevCmd.bat" -arch=amd64 -host_arch=amd64
   call C:\opt\ros\foxy\x64\setup.bat
   
</code></pre></div></div>
<p>This step depends on your local ROS 2 and Visual-Studio installation. Please replace <code class="language-plaintext highlighter-rouge">C:\opt\ros\foxy\x64\setup.bat</code> with your ROS 2 version and adapt the path to the Visual Studio folder if your installation is different.</p>

<ol>
  <li>Cleanup to insure a complete rebuild:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   rmdir /s/q .\build
   rmdir /s/q .\install
   rmdir /s/q .\log
   del /f/q .\src\CMakeLists.txt
   
</code></pre></div></div>
<p>This step is only required for a complete rebuild. A complete rebuild is recommended e.g. after an update of the sick_scan_xd sources.</p>

<ol>
  <li>Build sick_generic_caller:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" --event-handlers console_direct+
   call .\install\setup.bat
   
</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS sensors are currently not supported on Windows.</li>
    <li>To build sick_generic_caller without multiScan136/sick_scansegment_xd support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   colcon build --packages-select sick_scan_xd --cmake-args " -DROS_VERSION=2" " -DSCANSEGMENT_XD=0" --event-handlers console_direct+
   
</code></pre></div></div>

<h2 id="build-on-linux-generic-without-ros">Build on Linux generic without ROS</h2>

<p>Run the following steps to build sick_scan_xd on Linux (no ROS required):</p>

<ol>
  <li>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./sick_scan_ws
   cd ./sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repositories https://github.com/SICKAG/libsick_ldmrs and https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   git clone https://github.com/SICKAG/libsick_ldmrs.git
   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   
</code></pre></div></div>

<ol>
  <li>Build libsick_ldmrs (required only once for LD-MRS sensors):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   pushd libsick_ldmrs
   mkdir -p ./build
   cd ./build
   cmake -G "Unix Makefiles" ..
   make -j4
   sudo make -j4 install
   popd
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller and libsick_scan_xd_shared_lib.so:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./build
   pushd ./build
   rm -rf ./*
   export ROS_VERSION=0
   cmake -DROS_VERSION=0 -G "Unix Makefiles" ../sick_scan_xd
   make -j4
   sudo make -j4 install
   popd
   
</code></pre></div></div>

<p>LD-MRS sensors are currently not supported on Raspberry. Build with cmake flag <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DRASPBERRY=1</code> on Raspberry:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -DRASPBERRY=1 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>libsick_ldmrs is only required to support LD-MRS sensors. If you do not need or want to support LDMRS, you can skip building libsick_ldmrs. To build sick_generic_caller without LD-MRS support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_LDMRS_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DLDMRS=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>To build sick_generic_caller without multiScan100/picoScan100 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DSCANSEGMENT_XD=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>cmake flags can be combined. Use flags <code class="language-plaintext highlighter-rouge">-DLDMRS=0 -DSCANSEGMENT_XD=0</code> to build without LD-MRS and scansegment_xd support:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DLDMRS=0 -DSCANSEGMENT_XD=0 -G "Unix Makefiles" ../sick_scan_xd
   
</code></pre></div></div>

<p>By default, sick_scan_xd builds with compiler flag <code class="language-plaintext highlighter-rouge">-O3</code> (optimization level for max speed). The optimization level can be overwritten (e.g. for debugging) by cmake flag <code class="language-plaintext highlighter-rouge">-DO=0</code> (compiler flags <code class="language-plaintext highlighter-rouge">-g -O0</code>), <code class="language-plaintext highlighter-rouge">-DO=1</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O1</code>) or <code class="language-plaintext highlighter-rouge">-DO=2</code> (for compiler flags <code class="language-plaintext highlighter-rouge">-O2</code>).</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> To create source code documentation by doxygen, run</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ./doxygen
doxygen ./docs/Doxyfile

</code></pre></div></div>

<h2 id="build-on-windows-generic-without-ros">Build on Windows generic without ROS</h2>

<p>To install sick_scan_xd on Windows, follow the steps below:</p>

<ol>
  <li>
    <p>If not yet done, install Visual Studio. Visual Studio 2019 Community or Professional Edition is recommended.</p>
  </li>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir sick_scan_ws
   cd sick_scan_ws
   
</code></pre></div></div>

<ol>
  <li>Clone repository https://github.com/SICKAG/sick_scan_xd :</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   git clone -b master https://github.com/SICKAG/sick_scan_xd.git
   
</code></pre></div></div>

<ol>
  <li>Build sick_generic_caller and sick_scan_xd_shared_lib.dll with cmake and Visual Studio 2019:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cd sick_scan_xd
   set _os=x64
   set _cmake_string=Visual Studio 16 2019
   set _msvc=Visual Studio 2019
   set _cmake_build_dir=build
   if not exist %_cmake_build_dir% mkdir %_cmake_build_dir%
   pushd %_cmake_build_dir%
   cmake -DROS_VERSION=0 -G "%_cmake_string%" ..
   cmake --build . --clean-first --config Debug
   cmake --build . --clean-first --config Release
   REM open sick_scan_xd.sln in Visual Studio 2019 for development and debugging
   popd
   
</code></pre></div></div>
<p>For development or debugging, open file <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\sick_scan_xd.sln</code> in Visual Studio. To install the library and header in the system folder, run <code class="language-plaintext highlighter-rouge">cmake --build . --target install</code> with admin privileges.</p>

<p>After successful build, binary files <code class="language-plaintext highlighter-rouge">sick_generic_caller.exe</code> and <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> are created in folders <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\Debug</code> and <code class="language-plaintext highlighter-rouge">sick_scan_xd\build\Release</code>.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>LD-MRS sensors are currently not supported on Windows.</li>
    <li>To build sick_generic_caller without multiScan100/picoScan100 support, switch off option <code class="language-plaintext highlighter-rouge">BUILD_WITH_SCANSEGMENT_XD_SUPPORT</code> in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CMakeLists.txt">CMakeLists.txt</a> or call cmake with option <code class="language-plaintext highlighter-rouge">-DSCANSEGMENT_XD=0</code>:</li>
  </ul>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cmake -DROS_VERSION=0 -DSCANSEGMENT_XD=0 -G "%_cmake_string%" ..
   
</code></pre></div></div>

<h1 id="running-the-driver">Running the driver</h1>

<p>The sick_scan_xd driver can be started on the command line by <code class="language-plaintext highlighter-rouge">sick_generic_caller &lt;launchfile&gt; [hostname:=&lt;ip-address&gt;]</code>. The start process varies slightly depending on the target OS:</p>

<p>On native Linux without ROS, call</p>

<p>```sick_generic_caller <launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On Linux with ROS 1, call

    
```./devel_isolated/setup.bash
</code></pre></div></div>

<p>```roslaunch sick_scan_xd <launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On Linux with ROS 2, call

    
```source ./install/setup.bash
</code></pre></div></div>

<p>```ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/<launchfile></launchfile></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
On native Windows without ROS, call

    
```sick_generic_caller &lt;launchfile&gt;
</code></pre></div></div>

<p>On Windows with ROS 2, call</p>

<p>```call .\install\setup.bat</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    
```ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/&lt;launchfile&gt;
</code></pre></div></div>

<p>Use the following commands to run the sick_scan_xd driver for a specific scanner type:</p>

<ul>
  <li>For MRS6124:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_6xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_mrs_6xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_6xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_6xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_6xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For MRS1104:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_1xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_mrs_1xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_1xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_mrs_1xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_mrs_1xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1104 with firmware 1.x:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1104 with firmware 2.x:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx_v2.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xxx_v2.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx_v2.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xxx_v2.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xxx_v2.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM240-prototype:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_240.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_240.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_240.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_240.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_240.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM5xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_5xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_5xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_5xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_5xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_5xx.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM7xx-family (no safety scanner):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch</code>
</li>
    </ul>
  </li>
  <li>For TiM7xxS-family (safety scanner):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xxS.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xxS.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xxS.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_tim_7xxS.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xxS.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS1xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_1xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_1xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_1xx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS5xx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_5xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_5xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_5xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch</code>
</li>
    </ul>
  </li>
  <li>For LMS4xxx-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_4xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lms_4xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_4xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lms_4xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_4xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS4000:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_4xxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_4xxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_4xxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_4xxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_4xxx.launch</code>
</li>
    </ul>
  </li>
  <li>For LDMRS-family:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_ldmrs.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_ldmrs.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_ldmrs.launch</code>
</li>
      <li>Note that LD-MRS are currently not supported on Windows</li>
    </ul>
  </li>
  <li>For LRS36x0:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x0.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS36x0 mounted upside down:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x0_upside_down.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x0_upside_down.launch</code>
  <br>For upside down mounted devices, the point cloud is rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>.</li>
    </ul>
  </li>
  <li>For LRS36x1:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x1.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1.launch</code>
</li>
    </ul>
  </li>
  <li>For LRS36x1 mounted upside down:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_lrs_36x1_upside_down.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lrs_36x1_upside_down.launch</code>
</li>
    </ul>

    <p><br>For upside down mounted devices, the point cloud is rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>.</p>
  </li>
  <li>For LD-OEM15xx:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_oem_15xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_oem_15xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_oem_15xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_oem_15xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_oem_15xx.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV210 and NAV245:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_2xx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_2xx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_2xx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_2xx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_2xx.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV310:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_31x.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_31x.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_31x.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_31x.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_31x.launch</code>
</li>
    </ul>
  </li>
  <li>For NAV350:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_350.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_nav_350.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_350.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_nav_350.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_nav_350.launch</code>
</li>
    </ul>
  </li>
  <li>For RMS-family (RMS1xxx, RMS2xxx):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_rms_xxxx.launch</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_rms_xxxx.launch</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_rms_xxxx.launch</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_rms_xxxx.launch</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_rms_xxxx.launch</code>
</li>
    </ul>
  </li>
  <li>For multiScan136 (sick_scansegement_xd):
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_multiscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">hostname</code> is the ip-address of the lidar, <code class="language-plaintext highlighter-rouge">udp_receiver_ip</code> is the ip-address of the receiver (i.e. the ip of the computer running sick_generic_caller).</li>
    </ul>
  </li>
  <li>For picoScan150:
    <ul>
      <li>Linux native:   <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 1:    <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Linux ROS 2:    <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_picoscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows native: <code class="language-plaintext highlighter-rouge">sick_generic_caller sick_picoscan.launch hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>Windows ROS 2:  <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_picoscan.launch.py hostname:=&lt;ip-address&gt; udp_receiver_ip:=&lt;ip-address&gt;</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">hostname</code> is the ip-address of the lidar, <code class="language-plaintext highlighter-rouge">udp_receiver_ip</code> is the ip-address of the receiver (i.e. the ip of the computer running sick_generic_caller).</li>
    </ul>
  </li>
</ul>

<p>Common command line options are</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">hostname:=&lt;ip-address&gt;</code> to connect to a sensor with a given IP address. Default value is always the factory default IP address of the scanner.</li>
</ul>

<p>Further (common and scanner specific) options can be set via launch file, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#common-parameters">Common parameters</a> and configure the settings in the launch file corresponding to the scanner type.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> After modifying a launch-file, it has to be installed by running <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev</code>
to be located and used by <code class="language-plaintext highlighter-rouge">roslaunch</code>.</p>
</blockquote>

<p>On ROS 2 you can launch sick_generic_caller by python launch files, too. Use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 launch sick_scan_xd &lt;name&gt;.launch.py &lt;param&gt;:=&lt;value&gt;

</code></pre></div></div>
<p>E.g. for LMS-5xx: <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_lms_5xx.launch.py hostname:=192.168.0.1</code></p>

<p>The launch.py-files on ROS 2 passes the corresponding launch-file to the driver: <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lms_5xx.launch.py">sick_lms_5xx.launch.py</a> gives an example for LMS-5xx. Parameter can be overwritten</p>
<ul>
  <li>either by command line, e.g. <br> <code class="language-plaintext highlighter-rouge">ros2 launch sick_scan_xd sick_lms_5xx.launch.py hostname:=192.168.0.1</code>,</li>
  <li>or by passing additional arguments in the launch.py-file, e.g. <br> <code class="language-plaintext highlighter-rouge">node = Node(package='sick_scan_xd', executable='sick_generic_caller', arguments=[launch_file_path, 'hostname:=192.168.0.1'])</code>
</li>
</ul>

<h2 id="starting-scanner-with-specific-ip-address">Starting Scanner with Specific IP Address</h2>

<p>To start the scanner with a specific IP address, option <code class="language-plaintext highlighter-rouge">hostname:=&lt;ip-address&gt;</code> can be used.
The hostname is the ip-address of the scanner, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71                         # Linux native
roslaunch sick_scan_xd sick_tim_5xx.launch hostname:=192.168.0.71                      # Linux ROS 1
ros2 run sick_scan_xd sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71   # Linux ROS 2
sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71                         # Windows native
ros2 run sick_scan_xd sick_generic_caller sick_tim_5xx.launch hostname:=192.168.0.71   # Windows ROS 2

</code></pre></div></div>

<h2 id="start-multiple-nodes">Start Multiple Nodes</h2>

<p>Multiple nodes can be started to support multiple sensors. In this case, multiple instances of sick_scan_xd have to be started, each node with different name and topic. ROS 1 example to run two TiM 7xx devices with ip address <code class="language-plaintext highlighter-rouge">192.168.0.1</code> and <code class="language-plaintext highlighter-rouge">192.168.0.2</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1 &amp;
roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2 &amp;

</code></pre></div></div>

<p>On Linux with ROS 1, multiple nodes to support multiple sensors can be started by one launch file, too.
Take the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_tim_5xx_twin.launch">sick_tim_5xx_twin.launch</a> as an example.
Remapping the scan and cloud topics is essential to distinguish the scandata and provide TF information.</p>

<p>ROS 2 example to run two TiM 7xx devices with IP address <code class="language-plaintext highlighter-rouge">192.168.0.1</code> and <code class="language-plaintext highlighter-rouge">192.168.0.2</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1 &amp;
ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2 &amp;

</code></pre></div></div>

<p>To support multiple sensors, sick_scan_xd has to be started multiple times, with one sick_scan_xd-node for each sensor. By default, each sick_scan_xd-node connects to “192.168.0.1” and publishes its point cloud on topic “cloud”. Therefore both the node name, the ip-address of the sensor and the point cloud topic have to be configured differently for each node.</p>

<p>Node name, ip-address and point cloud topic can be configured in the launch-file or by command line argument:</p>

<p>Topic, nodename and ip configuration in a launch-file (example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;launch&gt;
        &lt;arg name="nodename" default="sick_tim_7xx"/&gt;
        &lt;arg name="hostname" default="192.168.0.1"/&gt;
        &lt;arg name="cloud_topic" default="cloud"/&gt;
        &lt;node name="$(arg nodename)" pkg="sick_scan_xd" type="sick_generic_caller" respawn="false" output="screen"&gt;
            &lt;param name="scanner_type" type="string" value="sick_tim_7xx"/&gt;
            &lt;param name="nodename" type="string" value="$(arg nodename)"/&gt;
            &lt;param name="hostname" type="string" value="$(arg hostname)"/&gt;
            &lt;param name="cloud_topic" type="string" value="$(arg cloud_topic)"/&gt;
    
</code></pre></div></div>

<p>Topic, node name and ip configuration by command line (ROS 1 example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1
    roslaunch sick_scan_xd sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2
    
</code></pre></div></div>

<p>Topic, node name and IP configuration by command line (ROS 2 example for TiM7xx):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_1 hostname:=192.168.0.1 cloud_topic:=cloud_1
    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_tim_7xx.launch nodename:=sick_tim_7xx_2 hostname:=192.168.0.2 cloud_topic:=cloud_2
    
</code></pre></div></div>

<p>Scripts <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/scripts/run_linux_ros1_simu_tim7xx_twin.bash">run_linux_ros1_simu_tim7xx_twin.bash</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/scripts/run_linux_ros2_simu_tim7xx_twin.bash">run_linux_ros2_simu_tim7xx_twin.bash</a> show a complete example with emulation of two TiM7xx sensors and two sick_scan_xd nodes running concurrently using different nodenames and topics.</p>

<p>To run two multiScan100 or picoScan100 devices simultanously, each sick_scan_xd node must be configured with different lidar ip addresses and udp ports, different node names, different ros topics and frame ids for each point cloud. Therefore the following launch file parameter should be overwritten by individual settings for each lidar:</p>
<ul>
  <li>“hostname”: e.g. “192.168.0.190” and “192.168.0.98”</li>
  <li>“nodename”: e.g. sick_picoscan0” and “sick_picoscan1”</li>
  <li>“publish_frame_id”: e.g. “world0” and “world1”</li>
  <li>“publish_laserscan_segment_topic”: e.g. “scan0_segment” and “scan1_segment”</li>
  <li>“publish_laserscan_fullframe_topic”: e.g. “scan0_fullframe” and “scan1_fullframe”</li>
  <li>“imu_topic”: e.g. “imu0” and “imu1”</li>
  <li>“udp_port”: e.g. “56661” and “56662”</li>
  <li>“imu_udp_port”: e.g. “7503” and “7504”</li>
  <li>individual topics and frame ids for each customized point cloud, e.g.
    <ul>
      <li>replace all “topic=/cloud_” by “topic=/cloud0<em>” resp. “topic=/cloud1</em>”</li>
      <li>replace all “frameid=world” by “frameid=world0” resp. “frameid=world1”
It is recommend to first verify the launch file configurations separately for each picoScan100 before running them simultanously.</li>
    </ul>
  </li>
</ul>

<p>For picoScan100 and multiScan, parameter udp_receiver_ip must be set to the ip address of the PC running sick_scan_xd. It is recommend to use ip addresses in the same subnet.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The sick_scan_xd API does not support running multiple lidars simultaneously in a single process.** Currently the sick_scan_xd API does not support the single or multi-threaded use of 2 or more lidars in one process, since the sick_scan_xd library is not guaranteed to be thread-safe. To run multiple lidars simultaneously, we recommend using ROS or running sick_scan_xd in multiple and separate processes, so that each process serves one sensor.</p>
</blockquote>

<h2 id="common-parameters">Common parameters</h2>

<p>For the launch-file settings and the tag/values pairs the following keywords are supported:</p>

<table>
  <thead>
    <tr>
      <th>Keyword</th>
      <th>Meaning</th>
      <th>Default value</th>
      <th>Hint</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>scanner_type</td>
      <td>Scanner family</td>
      <td>???</td>
      <td>see list above</td>
    </tr>
    <tr>
      <td>min_ang</td>
      <td>Start scan angle in [rad]</td>
      <td>-2.3998277</td>
      <td> </td>
    </tr>
    <tr>
      <td>max_ang</td>
      <td>End scan angle in [rad]</td>
      <td>+2.3998277</td>
      <td> </td>
    </tr>
    <tr>
      <td>intensity_resolution_16bit</td>
      <td>Switch between 8Bit/16Bit</td>
      <td>“false”</td>
      <td>do not change</td>
    </tr>
    <tr>
      <td>hostname</td>
      <td>Ip address of scanner</td>
      <td>192.168.0.1</td>
      <td>change to scanner ip address in your network (see faq)</td>
    </tr>
    <tr>
      <td>port</td>
      <td>port number</td>
      <td>2112</td>
      <td>do not change, check firewall rules if there is blocking traffic</td>
    </tr>
    <tr>
      <td>timelimit</td>
      <td>Timelimit in [sec]</td>
      <td>5</td>
      <td>do not change</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">scanner_type</code>
Name of the used scanner. Usually this is also the name of the launch file. This entry is used to differentiate
between the various scanner properties within the software code.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">hostname</code>
IP-address of the scanner (default: 192.168.0.1)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">port</code>
IP-port of the scanner (default: 2112)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">min_ang</code>
Start angle in [rad]</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">max_ang</code>
End angle in [rad]</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">use_binary_protocol</code>
Switch between SOPAS Binary and SOPAS ASCII protocol</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">intensity</code>
Enable or disable transport of intensity values</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">intensity_resolution_16bit</code>
If true, the intensity values is transferred as 16 bit value. If false, as 8 bit value.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">min_intensity</code>
If min_intensity &gt; 0, all range values in a LaserScan message are set to infinity, if their intensity value is below min_intensity</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cloud_topic</code>
Topic name of the published pointcloud2 data</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">frame_id</code>
Frame id used for the published data</p>
  </li>
</ul>

<p>Tag/value pairs of the command line overwrite settings in the launch file.
The use of the parameters can be looked up in the launch files. This is also recommended as a starting point.</p>

<h2 id="further-useful-parameters-and-features">Further useful parameters and features</h2>

<ul>
  <li>
    <p><strong>Timestamps</strong>: If parameter<code class="language-plaintext highlighter-rouge">sw_pll_only_publish</code> is true (default), an internal Software PLL is used to sync the scan generation timestamps to system timestamps. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#timestamps-and-synchronization-software-pll">Timestamps and synchronization (Software PLL)</a> for details.</p>
  </li>
  <li>
    <p><strong>Angle compensation</strong>: For highest angle accuracy the NAV-Lidar series supports an <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#angle-compensation">angle compensation mechanism</a>.</p>
  </li>
  <li>
    <p><strong>Angle correction</strong>: MRS1000 lidars transmit accurate azimuth angles for each scan point. Therefore, the stride (angle increment) of the MRS1000 azimuth angles in polar and cartesian point clouds is not exactly constant. Since laserscan messages assume a constant angle increment, scan points in point cloud and laserscan messages have slightly different azimuth angles.</p>
  </li>
  <li>
    <p><strong>Field monitoring</strong>: The <strong>LMS1xx</strong>, <strong>LMS5xx</strong>, <strong>TiM7xx</strong> and <strong>TiM7xxS</strong> families have <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#field-evaluation-information">extended settings for field monitoring</a>.</p>
  </li>
  <li>
    <p><strong>Radar devices</strong>: For radar devices (RMS1000/RMS2000), radar raw targets or radar objects or both can be tracked and transmitted. You can activate parameter transmit_raw_targets, transmit_objects or both in the launch file:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   &lt;param name="transmit_raw_targets" type="bool" value="false"/&gt;
   &lt;param name="transmit_objects" type="bool" value="true"/&gt;
   
</code></pre></div></div>
<p>By default, radar objects are tracked.</p>

<ul>
  <li>
<strong>Coordinate transform</strong>: An optional coordinate transform can be applied to the point cloud. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#coordinate-transforms">coordinate transforms</a>) for details.</li>
</ul>

<h2 id="ros-services">ROS services</h2>

<p>On ROS 1 and ROS 2, services can be used to send COLA commands to the sensor. This can be very helpful for diagnosis, e.g. by querying the device status or its id.</p>

<p>Use the following examples to run a cola command on ROS 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_lms_5xx/ColaMsg "{request: 'sMN IsSystemReady'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sRN SCdevicestate'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sEN LIDinputstate 1'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sEN LIDoutputstate 1'}"
rosservice call /sick_lms_5xx/ColaMsg "{request: 'sMN LMCstartmeas'}"
rosservice call /sick_lms_5xx/SCdevicestate "{}" # query device state
rosservice call /sick_lms_5xx/SCreboot "{}"      # execute a software reset on the device
rosservice call /sick_lms_5xx/SCsoftreset "{}"   # save current parameter and shut down device

</code></pre></div></div>

<p>Use the following examples to run a cola command on ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN IsSystemReady'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN SCdevicestate'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sEN LIDinputstate 1'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sEN LIDoutputstate 1'}"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN LMCstartmeas'}"
ros2 service call /SCdevicestate sick_scan_xd/srv/SCdevicestateSrv "{}" # query device state
ros2 service call /SCreboot sick_scan_xd/srv/SCrebootSrv "{}"           # execute a software reset on the device
ros2 service call /SCsoftreset sick_scan_xd/srv/SCsoftresetSrv "{}"     # save current parameter and shut down device

</code></pre></div></div>

<p>Use ros service <code class="language-plaintext highlighter-rouge">SickScanExit</code> to stop the scanner and driver:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_nav_31x/SickScanExit "{}" # stop scanner and driver on ROS 1
ros2 service call /SickScanExit sick_scan_xd/srv/SickScanExitSrv "{}" # stop scanner and driver on ROS 2

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong></p>
  <ul>
    <li>The COLA commands are sensor specific. See the user manual and telegram listing for further details.</li>
    <li>ROS services require installation of ROS 1 or ROS 2, i.e. services for Cola commands are currently not supported on native Linux or native Windows.</li>
    <li>ROS services are currently not available for the LDMRS.</li>
    <li>ROS service “ColaMsg” should only be used for diagnosis. It is not recommended to change the lidar settings while the driver is running. Otherwise the driver settings can become different or inconsistant to the lidar settings. Restart the driver after changing lidar settings by SOAPS ET or SOPAS commands.</li>
    <li>Some SOPAS commands like <code class="language-plaintext highlighter-rouge">sMN SetAccessMode 3 F4724744</code> stop the current measurement. In this case, the driver restarts after a timeout (5 seconds by default). To process those SOPAS commands without restart, you can
      <ul>
        <li>send <code class="language-plaintext highlighter-rouge">sMN LMCstartmeas</code> and <code class="language-plaintext highlighter-rouge">sMN Run</code> to switch again into measurement mode within the timeout, or</li>
        <li>increase the driver timeout <code class="language-plaintext highlighter-rouge">read_timeout_millisec_default</code> in the launch-file.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Additional services can be available for specific lidars. Service “GetContaminationResult” is e.g. available for MRS1xxx, LMS1000 and multiScan:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ROS 1 example for service GetContaminationResult (LMS 1xxx)
rosservice call /sick_lms_1xxx/GetContaminationResult "{}"
# ROS 2 example for service GetContaminationResult (LMS 1xxx)
ros2 service call /GetContaminationResult sick_scan_xd/srv/GetContaminationResultSrv "{}"

</code></pre></div></div>

<p>Example sequence with stop and start measurement to set a particle filter (TiM-7xxx on ROS 1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LFPparticle'}" # response: "sRA LFPparticle \\x00\\x01\\xf4"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sWN LFPparticle 0101F4'}" # response: "sWA LFPparticle"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN LMCstartmeas'}"
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sMN Run'}"

</code></pre></div></div>

<h2 id="driver-states-timeouts">Driver states, timeouts</h2>

<p>The driver runs in two different states:</p>

<ol>
  <li>
    <p>Initialization: The scanner is initialized and configured by a list of sopas commands</p>
  </li>
  <li>
    <p>Measurement: The scanner is operational, scandata are transmitted and the point cloud is published.
After start, the driver enters initialization mode. After successful initialization, the driver switches automatically into measurement mode.</p>
  </li>
</ol>

<p>The communication between driver and scanner is monitored. In case of communication timeouts, e.g. due to network problems, the TCP connection is reset and the scanner is re-initialized. The driver uses 3 different timeouts (i.e time since last message received from lidar):</p>

<ol>
  <li>
    <p>In measurement mode: If no messages arrive for 5 seconds [timeout 0], the TCP/IP connection is closed. After a short delay, the tcp connection is reopened and the driver switches to initialization mode and reinitializes the Lidar.</p>
  </li>
  <li>
    <p>In initialization mode: If no messages received after 120 sec [Timeout 1] the TCP/IP connection is closed. After a short delay, the tcp connection is reopened and the driver switches to initialization mode and reinitializes the Lidar.</p>
  </li>
  <li>
    <p>In any mode: If no messages received after 150 sec [Timeout 2] the driver terminates.</p>
  </li>
</ol>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The internal timer is reset on successful communication. i.e. the timeout refers to the time of the last message from the Lidar. If there was no message yet, then the time of programme start is used.</p>
</blockquote>

<p>All timeouts can be configured in the launchfile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="message_monitoring_enabled" type="bool" value="True" /&gt;      &lt;!-- Enable message monitoring with reconnect+reinit in case of timeouts, default: true --&gt;
&lt;param name="read_timeout_millisec_default" type="int" value="5000"/&gt;     &lt;!-- 5 sec read timeout in operational mode (measurement mode), default: 5000 milliseconds --&gt;
&lt;param name="read_timeout_millisec_startup" type="int" value="120000"/&gt;   &lt;!-- 120 sec read timeout during startup (sensor may be starting up, which can take up to 120 sec.), default: 120000 milliseconds --&gt;
&lt;param name="read_timeout_millisec_kill_node" type="int" value="150000"/&gt; &lt;!-- 150 sec point cloud timeout, ros node will be killed if no point cloud published within the last 150 sec., default: 150000 milliseconds --&gt;

</code></pre></div></div>

<p>The following diagram shows the transition between the driver states:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/./doc/driverStatesDiagram1.png" alt="driverStatesDiagram"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Timeout 2 (i.e. no lidar message after 150 seconds) terminates the driver. By default, the driver does not restart automatically. It is therefor recommended to run the driver within an endless loop, e.g. in bash:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while(true) ; do roslaunch sick_scan_xd &lt;launchfile&gt; [&lt;arguments&gt;] ; done

</code></pre></div></div>

<p>The following table summarizes the timeout parameter:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/./doc/timeout_parameter.png" alt="timeout_parameter"></p>

<p>Details of timeout settings:</p>

<ul>
  <li>
    <p>message_monitoring_enabled: Enable or disable timeouts and monitoring. Disabling deactivates any error handling in case of network problems. Recommended default value: True</p>
  </li>
  <li>
    <p>read_timeout_millisec_default: Read timeout in milliseconds in operational (measurement) mode. If no datagrams are received from lidar within 5 seconds (default), the TCP socket is closed and the lidar is reinitialized.</p>
  </li>
  <li>
    <p>read_timeout_millisec_startup: Read timeout in milliseconds during initialization after startup. If SOPAS commands are not responded within 120 seconds (default), the TCP socket is closed and lidar is reinitialized.</p>
  </li>
  <li>
    <p>read_timeout_millisec_kill_node: Pointcloud timeout in milliseconds in operational (measurement) mode. If the sick_scan_xd does not publish a point cloud within the last 150 seconds, the sick_scan_xd process is killed. Should never happen, but is the �last resort� to exit after any kind of error (e.g. socket hangs up and blocks after network trouble).</p>
  </li>
  <li>
    <p>All timeouts configured in milliseconds</p>
  </li>
  <li>To disable timeouts (not recommended):
    <ul>
      <li>Set message_monitoring_enabled = false, or</li>
      <li>Set timeouts to “infinite” values, i.e MAX_INT = 2147483647 milliseconds (24.9 days)</li>
    </ul>
  </li>
  <li>To disable point cloud monitoring (not recommended):
    <ul>
      <li>read_timeout_millisec_kill_node &lt;= 0 deactivates pointcloud monitoring</li>
    </ul>
  </li>
  <li>Parameter read_timeout_millisec_default and read_timeout_millisec_startup: value 0 and negative values are currently NOT mapped to other values, i.e. will cause an immediately timeout error. Use value 2147483647 or message_monitoring_enabled = false to deactivate read timeouts (not recommended)</li>
</ul>

<h2 id="sopas-mode">SOPAS Mode</h2>

<p>This driver supports both COLA-B (binary) and COLA-A (ASCII) communication with the laser scanner. Binary mode is activated by default, since this mode generates less network traffic and enables more compatibility to all scanners.
If the communication mode set in the scanner memory is different from that used by the driver, the scanner’s communication mode is changed. This requires a restart of the TCP-IP connection, which can extend the start time by up to 30 seconds.
There are two ways to prevent this:</p>
<ol>
  <li>Recommended:
    <ul>
      <li>Set the communication mode with the SOPAS ET software to binary and save this setting in the scanner’s EEPROM.</li>
      <li>Set “use_binary_protocol” to default value “true”.</li>
    </ul>
  </li>
  <li>Use the parameter “use_binary_protocol” to overwrite the default settings of the driver.</li>
</ol>

<h2 id="example-startup-sequence">Example Startup Sequence</h2>

<p>The following ROS boot protocol shows the typical start sequence when starting a SICK laser scanner. The MRS6124 is shown here as an example. However, the startup sequence is generally similar for all scanners.</p>

<p>After a firmware update, the following Quickcheck is performed:</p>
<ol>
  <li>Is the device accessible via ping?</li>
  <li>Can the device be started with the corresponding generic launch file?</li>
  <li>At the end of the launch process, the device switches to receive mode
 for scan data? Typically the last command sent is
<code class="language-plaintext highlighter-rouge">&lt;STX&gt;sEA LMDscandata \x01&lt;ETX&gt;
</code>.</li>
  <li>Check with rviz: Is it possible to see the Pointcloud2 data or similar? Is the shown data reasonable?</li>
  <li>Check the scan rate with the command</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic hz /cloud

</code></pre></div></div>
<ol>
  <li>Further inspection, if any, by dumping Pointcloud2 data.
The header is of particular interest here. A typical call can therefore look as follows:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic echo /cloud|grep frame -B 7 -A 26

</code></pre></div></div>
<p><strong>Example Sequence</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_mrs_6xxx.launch hostname:=192.168.0.25
... logging to /home/rosuser/.ros/log/75631922-6109-11e9-b76f-54e1ad2921b6/roslaunch-ROS-NB-10680.log
Checking log directory for disk usage. This may take awhile.
Press Ctrl-C to interrupt
Done checking log file disk usage. Usage is &lt;1GB.
started roslaunch server http://ROS-NB:40757/
SUMMARY
========
PARAMETERS
 * /rosdistro: melodic
 * /rosversion: 1.14.3
 * /sick_mrs_6xxx/filter_echos: 0
 * /sick_mrs_6xxx/hostname: 192.168.0.25
 * /sick_mrs_6xxx/max_ang: 1.047197333
 * /sick_mrs_6xxx/min_ang: -1.040216
 * /sick_mrs_6xxx/port: 2112
 * /sick_mrs_6xxx/range_max: 250.0
 * /sick_mrs_6xxx/range_min: 0.1
 * /sick_mrs_6xxx/scanner_type: sick_mrs_6xxx
 * /sick_mrs_6xxx/timelimit: 5
 * /sick_mrs_6xxx/use_binary_protocol: True
NODES
  /
    sick_mrs_6xxx (sick_scan_xd/sick_generic_caller)
auto-starting new master
process[master]: started with pid [10690]
ROS_MASTER_URI=http://localhost:11311
setting /run_id to 75631922-6109-11e9-b76f-54e1ad2921b6
process[rosout-1]: started with pid [10701]
started core service [/rosout]
process[sick_mrs_6xxx-2]: started with pid [10708]
[ INFO] [1555502887.036684738]: sick_generic_caller V. 001.003.016
[ INFO] [1555502887.036717573]: Program arguments: /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller
[ INFO] [1555502887.036725741]: Program arguments: __name:=sick_mrs_6xxx
[ INFO] [1555502887.036731933]: Program arguments: __log:=/home/rosuser/.ros/log/75631922-6109-11e9-b76f-54e1ad2921b6/sick_mrs_6xxx-2.log
[ INFO] [1555502887.048425000]: Found sopas_protocol_type param overwriting default protocol:
[ INFO] [1555502887.048956468]: Binary protocol activated
[ INFO] [1555502887.048984179]: Start initialising scanner [Ip: 192.168.0.25] [Port: 2112]
[ INFO] [1555502887.067528995]: Publishing laserscan-pointcloud2 to cloud
[ INFO] [1555502887.071035827]: Parameter setting for &lt;active_echo: 0&gt;
[ INFO] [1555502887.271739084]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0023&gt;sMN SetAccessMode 0x03 0xf4 0x72 0x47 0x44 CRC:&lt;0xb3&gt;
[ INFO] [1555502887.273290840]: Receiving: &lt;STX&gt;sAN SetAccessMode \x01&lt;ETX&gt;
[ INFO] [1555502887.473927858]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sWN EIHstCola 0x01 CRC:&lt;0x09&gt;
[ INFO] [1555502887.475365983]: Receiving: &lt;STX&gt;sWA EIHstCola &lt;ETX&gt;
[ INFO] [1555502887.675864993]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sMN LMCstopmeas CRC:&lt;0x10&gt;
[ INFO] [1555502888.199590269]: Receiving: &lt;STX&gt;sAN LMCstopmeas \x00&lt;ETX&gt;
[ INFO] [1555502888.400030148]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0015&gt;sRN DeviceIdent CRC:&lt;0x25&gt;
[ INFO] [1555502888.401393378]: Receiving: &lt;STX&gt;sRA DeviceIdent \x00\x08\x4d\x52\x53\x36\x31\x32\x34\x52\x00\x0a\x31\x2e\x31\x2e\x30\x2e\x35\x36\x35\x43&lt;ETX&gt;
[ INFO] [1555502888.401653485]: Deviceinfo MRS6124R V1.1.0.565C found and supported by this driver.
[ INFO] [1555502888.602062286]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0019&gt;sRN FirmwareVersion CRC:&lt;0x24&gt;
[ INFO] [1555502888.603444526]: Receiving: &lt;STX&gt;sRA FirmwareVersion \x00\x0a\x31\x2e\x31\x2e\x30\x2e\x35\x36\x35\x43&lt;ETX&gt;
[ INFO] [1555502888.804094446]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0017&gt;sRN SCdevicestate CRC:&lt;0x30&gt;
[ INFO] [1555502888.805521867]: Receiving: &lt;STX&gt;sRA SCdevicestate \x01&lt;ETX&gt;
[ INFO] [1555502889.006161400]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0010&gt;sRN ODoprh CRC:&lt;0x41&gt;
[ INFO] [1555502889.007613972]: Receiving: &lt;STX&gt;sRA ODoprh \x00\x00\x19\xf1&lt;ETX&gt;
[ INFO] [1555502889.209949897]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0010&gt;sRN ODpwrc CRC:&lt;0x52&gt;
[ INFO] [1555502889.211413041]: Receiving: &lt;STX&gt;sRA ODpwrc \x00\x00\x02\x55&lt;ETX&gt;
[ INFO] [1555502889.413742132]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0016&gt;sRN LocationName CRC:&lt;0x55&gt;
[ INFO] [1555502889.415205992]: Receiving: &lt;STX&gt;sRA LocationName \x00\x0b\x6e\x6f\x74\x20\x64\x65\x66\x69\x6e\x65\x64&lt;ETX&gt;
[ INFO] [1555502889.417205292]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMPoutputRange CRC:&lt;0x5e&gt;
[ INFO] [1555502889.418631134]: Receiving: &lt;STX&gt;sRA LMPoutputRange \x00\x01\x00\x00\x05\x15\x00\x04\xa3\x80\x00\x16\xe3\x60&lt;ETX&gt;
[ INFO] [1555502889.418830949]: Angle resolution of scanner is 0.13010 [deg]  (in 1/10000th deg: 0x515)
[ INFO] [1555502889.418907556]: MIN_ANG:   -1.040 [rad]  -59.600 [deg]
[ INFO] [1555502889.418975818]: MAX_ANG:    1.047 [rad]   60.000 [deg]
[ INFO] [1555502889.419156102]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0033&gt;sWN LMPoutputRange 0x00 0x01 0x00 0x00 0x05 0x15 0x00 0x04 0xa3 0x80 0x00 0x16 0xe3 0x60 CRC:&lt;0xd8&gt;
[ INFO] [1555502889.420488646]: Receiving: &lt;STX&gt;sWA LMPoutputRange &lt;ETX&gt;
[ INFO] [1555502889.420719836]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMPoutputRange CRC:&lt;0x5e&gt;
[ INFO] [1555502889.421994443]: Receiving: &lt;STX&gt;sRA LMPoutputRange \x00\x01\x00\x00\x05\x15\x00\x04\xa3\x80\x00\x16\xe3\x60&lt;ETX&gt;
[ INFO] [1555502889.422165198]: Angle resolution of scanner is 0.13010 [deg]  (in 1/10000th deg: 0x515)
[ INFO] [1555502889.424815945]: MIN_ANG (after command verification):   -1.040 [rad]  -59.600 [deg]
[ INFO] [1555502889.424901901]: MAX_ANG (after command verification):    1.047 [rad]   60.000 [deg]
[ INFO] [1555502889.425102725]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0032&gt;sWN LMDscandatacfg 0x1f 0x00 0x01 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01 CRC:&lt;0x5c&gt;
[ INFO] [1555502889.426373088]: Receiving: &lt;STX&gt;sWA LMDscandatacfg &lt;ETX&gt;
[ INFO] [1555502889.426606493]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sRN LMDscandatacfg CRC:&lt;0x67&gt;
[ INFO] [1555502889.427933309]: Receiving: &lt;STX&gt;sRA LMDscandatacfg \x1f\x00\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01&lt;ETX&gt;
[ INFO] [1555502889.430654546]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0018&gt;sWN FREchoFilter 0x00 CRC:&lt;0x7f&gt;
[ INFO] [1555502889.431952374]: Receiving: &lt;STX&gt;sWA FREchoFilter &lt;ETX&gt;
[ INFO] [1555502889.432180430]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0016&gt;sMN LMCstartmeas CRC:&lt;0x68&gt;
[ INFO] [1555502889.963840302]: Receiving: &lt;STX&gt;sAN LMCstartmeas \x00&lt;ETX&gt;
[ INFO] [1555502889.964083670]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0007&gt;sMN Run CRC:&lt;0x19&gt;
[ INFO] [1555502889.965558914]: Receiving: &lt;STX&gt;sAN Run \x01&lt;ETX&gt;
[ INFO] [1555502889.965813465]: Sending  : &lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;STX&gt;&lt;Len=0017&gt;sEN LMDscandata 0x01 CRC:&lt;0x33&gt;
[ INFO] [1555502889.967297195]: Receiving: &lt;STX&gt;sEA LMDscandata \x01&lt;ETX&gt;

</code></pre></div></div>

<h1 id="driver-features-and-additional-information">Driver features and additional information</h1>

<h2 id="software-overview">Software Overview</h2>

<p>The sick_scan_xd software is essentially affected by its use cases:</p>

<ul>
  <li>Implement the common tasks for different lidars:
    <ul>
      <li>Provide driver software on Linux and Windows, generic, ROS 1 and ROS 2</li>
      <li>Receive and convert scan data, publish point cloud</li>
      <li>Run startup, configuration and setup</li>
    </ul>
  </li>
  <li>Use cases:
    <ul>
      <li>Provide a point cloud to the customer/application</li>
      <li>Provide a common high level interface for all supported lidars</li>
      <li>Hide datagram details, encodings and parsing knowhow</li>
      <li>The most common use case is to run lidar + sick_scan_xd to get a point cloud.</li>
    </ul>
  </li>
  <li>Software requirements:
    <ul>
      <li>Support different lidars (LMS, LRS, LDMRS, MRS, NAV, TiM, RMS, multiScan, etc.)</li>
      <li>Support different OS (Linux, Windows)</li>
      <li>Support different targets (ROS 1, ROS 2, generic)</li>
      <li>Support different protocols (Cola-A, Cola-B, TCP, UDP, msgpack)</li>
      <li>Implement parser for different telegrams (scandata, scancfg, fields, etc.)</li>
    </ul>
  </li>
</ul>

<p>This overview describes the most important modules and their relationship.</p>

<h3 id="software-structure">Software structure</h3>

<p>The following figures show the most important software blocks:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/software_overview_01.png" alt="software_overview_01"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/software_overview_02.png" alt="software_overview_02"></p>

<p>sick_scan_xd contains 6 main functional blocks:</p>

<ul>
  <li>sick_generic_caller and sick_generic_laser for initialization and setup:
    <ul>
      <li>Read configuration from launchfile:
        <ul>
          <li>ROS 1: <code class="language-plaintext highlighter-rouge">ros::NodeHandle::getParam</code>
</li>
          <li>ROS 2 and generic: <code class="language-plaintext highlighter-rouge">LaunchParser</code> (ros-wrapper)</li>
        </ul>
      </li>
      <li>Lidar specific setup:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickGenericParser</code>: lidar specific properties and messages parsing</li>
          <li>Set and get lidar specific properties: number of layers, angular resolution, etc.</li>
          <li>Parse and convert scan data, input: scan data (ascii or binary datagram), output: <code class="language-plaintext highlighter-rouge">ros::sensor_msgs::LaserScan</code>
</li>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanCommonTcp</code>: receive TCP messages, convert and publish point cloud</li>
        </ul>
      </li>
      <li>Start ros services:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanServices</code>: register ros services, convert from/to SOPAS</li>
        </ul>
      </li>
      <li>Start monitoring:
        <ul>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::SickScanMonitor</code>: monitor scan data, reinit on timeout</li>
          <li>class <code class="language-plaintext highlighter-rouge">sick_scan_xd::PointCloudMonitor</code>: monitor point cloud, reinit on timeout</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>sick_scan_common for the most common lidar devices (LMS, LRS, MRS, NAV, TiM, RMS, etc.):
    <ul>
      <li>Implemention by SickScanCommon and SickScanCommonTcp</li>
      <li>Uses SickGenericParser for lidar specific properties and parsing</li>
      <li>Runs common tasks for LMS/LRS/MRS/NAV/TiM/RMS:</li>
      <li>Run SOPAS startup sequence</li>
      <li>Run TCP receiver thread</li>
      <li>Process telegrams: parse and convert to point cloud</li>
      <li>Publish point cloud</li>
    </ul>
  </li>
  <li>sick_ldmrs for LD-MRS support using the ldmrs-library from https://github.com/SICKAG/libsick_ldmrs.git</li>
  <li>sick_scansegment_xd for multiScan136 and picoScan150 lidars using SOPAS, msgpack and UDP-communication</li>
  <li>sick_scan_services for ros services</li>
  <li>sick_generic_monitoring for monitoring and re-initialization in case of errors (e.g. network errors).</li>
</ul>

<p>The following figures show these 6 functional blocks:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/software_overview_03.png" alt="software_overview_03"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/software_overview_04.png" alt="software_overview_04"></p>

<p>The function blocks depend on and use the underlying system (ROS, TCP, etc.):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/driverComponentsDiagram1.png" alt="driver_components_01"></p>

<h3 id="message-receiving-and-message-handling">Message receiving and message handling</h3>

<p>Message receiving and message handling are decoupled, i.e. both tasks run in separate thread and exchange messages via a FIFO-buffer. This way, message handling cannot block tcp recv and vice versa. The following figure shows the message handling:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/software_overview_05.png" alt="software_overview_05"></p>

<p>The following figure shows the sequence diagram for a LMDscandata telegram:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/messageSequenceDiagram1.png" alt="messageSequenceDiagram1"></p>

<p>Incoming TCP messages and exported point cloud messages are monitored. sick_scan_xd reinitialises the lidar and the tcp connection in case of timeouts.</p>

<h3 id="sick_scansegment_xd">sick_scansegment_xd</h3>

<p>sick_scansegment_xd implements support for multiScan136 and picoScan150 lidars using SOPAS, msgpack and UDP-communication. It has 5 functional blocks:</p>

<ul>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackThreads</code>:
    <ul>
      <li>Init and run all sick_scansegment_xd components</li>
      <li>SOPAS startup (multiScan136, picoScan150)</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::UdpReceiver</code>:
    <ul>
      <li>Run UDP receiver thread</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackConverter</code>:
    <ul>
      <li>Parse and convert msgpacks</li>
      <li>Collect scan segments</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::MsgPackValidator</code>:
    <ul>
      <li>Validate msgpacks and scansegments</li>
    </ul>
  </li>
  <li>class <code class="language-plaintext highlighter-rouge">sick_scansegment_xd::RosMsgpackPublisher</code>:
    <ul>
      <li>Publish point cloud (single segments)</li>
      <li>Publish cloud_fullframe (fullframe pointcloud, 360 deg for Multiscan136 resp. 270 deg for picoscan)</li>
    </ul>
  </li>
</ul>

<p>The following figure shows the compoenent diagram for sick_scansegment_xd:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/driverComponentsDiagram2.png" alt="driverComponentsDiagram2"></p>

<p>Message receiving, converting and publishing run in 3 separate threads and exchange their messages via a FIFO-buffer.</p>

<p>The following figure shows the sequence diagram for a multiScan136 msgpack:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/messageSequenceDiagram2.png" alt="messageSequenceDiagram2"></p>

<p>The following figure shows the sequence diagram for a picoScan and compact format:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/messageSequenceDiagram3.png" alt="messageSequenceDiagram3"></p>

<h3 id="files-and-folders">Files and folders</h3>

<p>The source files for the sick_scan_xd core can be found in the following folders:</p>
<ul>
  <li>driver/src: source files</li>
  <li>include: header files</li>
  <li>launch: configuration</li>
  <li>msg: ros messages definitions</li>
  <li>srv: ros services definitions</li>
  <li>roswrap: ros wrapper (ROS 2 and generic)</li>
</ul>

<p>These folders are required to build sick_generic_caller.</p>

<p>Additional folders for sick_scan_xd support, development and test are:</p>
<ul>
  <li>test: test scripts and emulator</li>
  <li>tools: additional development tools</li>
</ul>

<h2 id="generic-driver-api">Generic Driver API</h2>

<h3 id="overview">Overview</h3>

<p>A generic API for sick_scan_xd has the following goals:</p>
<ul>
  <li>Easy integration of sick_scan_xd into customer systems with and without ROS</li>
  <li>Integrate SICK lidars with one API, independent of lidar types or underlying operating system</li>
  <li>Provide the same sick_scan_xd functionality on systems without ROS</li>
  <li>In particular: make the sick_scan_xd functionality available on non-ROS-systems without need to customize sources or configuration files.</li>
</ul>

<p>The generic sick_scan_xd API provides an interface to all lidars supported by sick_scan_xd. This API can be used in C, C++, Python, or any other language with support of C-bindings.</p>

<p>The generic sick_scan_xd API ships with the API-header, the library (binary or sources) and usage examples for C, C++ and Python. The following component diagram shows the relationship between API, library, lidar and a customized application:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_api/apiComponentsDiagram1.png" alt="apiComponentsDiagram1.png"></p>

<p>Running multiple lidars simultaneously in a single process is not supported.** Currently the sick_scan_xd API does not support the single or multi-threaded use of 2 or more lidars in one process, since the sick_scan_xd library is not guaranteed to be thread-safe. To run multiple lidars simultaneously, we recommend using ROS or running sick_scan_xd in multiple and separate processes, so that each process serves one sensor. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#start-multiple-nodes">start multiple lidars</a> for further information.</p>

<h3 id="build-and-test-shared-library">Build and test shared library</h3>

<p>The shared library, which implements the C-API, is built native on Linux or Windows (i.e. without ROS). Follow the instructions on <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-generic-without-ros">Build on Linux generic without ROS</a> for Linux resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-windows-generic-without-ros">Build on Windows</a> for Windows.</p>

<h4 id="build-the-shared-library-on-linux">Build the shared library on Linux</h4>

<p>Run the following commands to build the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Clone repositories
git clone https://github.com/SICKAG/libsick_ldmrs.git
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
# Build libsick_ldmrs library
mkdir -p ./build
mkdir -p ./libsick_ldmrs/build
pushd libsick_ldmrs/build
cmake -G "Unix Makefiles" ..
make -j4
sudo make -j4 install
popd
# Build libsick_scan_xd_shared_lib.so
pushd ./build
export ROS_VERSION=0
cmake -DROS_VERSION=0 -G "Unix Makefiles" ../sick_scan_xd
make -j4
sudo make -j4 install
# Check build and library dependencies
ls -al ./sick_generic_caller
ls -al ./libsick_scan_xd_shared_lib.so
ls -al ./sick_scan_xd_api_test
ldd -r ./libsick_scan_xd_shared_lib.so
popd

</code></pre></div></div>
<p>After successful build, the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> and a tiny test executable <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> are created.</p>

<h4 id="build-the-shared-library-on-windows">Build the shared library on Windows</h4>

<p>Run the following commands to build the shared library <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> with Visual Studio 2019 on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Clone repository sick_scan_xd
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
# Build libraries sick_scan_xd_shared_lib.dll
call "%ProgramFiles(x86)%\Microsoft Visual Studio\2019\Community\Common7\Tools\VsDevCmd.bat" -arch=amd64 -host_arch=amd64
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
cd sick_scan_xd
if not exist %_cmake_build_dir% mkdir %_cmake_build_dir%
pushd %_cmake_build_dir%
cmake -DROS_VERSION=0 -G "%_cmake_string%" ..
if %ERRORLEVEL% neq 0 ( @echo ERROR building %_cmake_string% sick_scan_xd with cmake &amp; @pause )
cmake --build . --clean-first --config Debug

</code></pre></div></div>
<p>After successful build, the shared library <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> and a tiny test executable <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test.exe</code> are created. To install the library and header in the system folder, run <code class="language-plaintext highlighter-rouge">cmake --build . --target install</code> with admin privileges. Note that LD-MRS is not supported on Windows.
privileges</p>
<blockquote>
  <p><strong><em>NOTE:</em></strong> sick_scan_xd builds and runs with both Visual Studio 2019 and 2022. Visual Studio 2019 is recommended, since ROS on Windows requires VS 2019.</p>
</blockquote>

<p>Replace <code class="language-plaintext highlighter-rouge">cmake -DROS_VERSION=0 -G "%_cmake_string%" ..</code> by  <code class="language-plaintext highlighter-rouge">cmake -DROS_VERSION=0 -DCMAKE_ENABLE_EMULATOR=1 -G "%_cmake_string%" ..</code> to build emulators for unit tests without lidar hardware, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CONTRIBUTING.md">Simulation</a>.</p>

<h4 id="test-the-shared-library">Test the shared library</h4>

<p>The executable file <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> provides a minimalistic API test. Run <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test &lt;launchfile&gt; hostname:=&lt;ip-address&gt;</code> to test the API against a lidar, e.g. on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH # append relative path to build folder
export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to build folder
./build/sick_scan_xd_api_test ./sick_scan_xd/launch/sick_tim_7xx.launch hostname:=192.168.0.1

</code></pre></div></div>
<p>On Windows, run e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;..\build\Debug;%PATH%
.\build\Debug\sick_scan_xd_api_test.exe launch/sick_lms_5xx.launch hostname:=192.168.0.1

</code></pre></div></div>

<p>The executable binary <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test</code> will just load library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code>, start the lidar and print a message when receiving lidar messages, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_xd_api_test: pointcloud callback</code>. Replace <code class="language-plaintext highlighter-rouge">sick_lms_1xx.launch</code> in the example by the launch file corresponding to your type of lidar.</p>

<p>To load the library, the build folder has to be included in <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code> (Linux) resp. <code class="language-plaintext highlighter-rouge">PATH</code> (Windows). Set this environment variable to your build folder, e.g. on Linux using</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH # append relative path to build folder
export LD_LIBRARY_PATH=.:`pwd`/build:$LD_LIBRARY_PATH  # append absolute path to build folder

</code></pre></div></div>
<p>resp. on Windows</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;.\build\Debug;%PATH%

</code></pre></div></div>

<h3 id="usage-example">Usage example</h3>

<p>The sick_scan_xd API can be used on Linux or Windows in any language with support of C-bindings. There are 3 steps required to use the API:</p>

<ol>
  <li>API- and lidar-initialization by
    <ul>
      <li>SickScanApiLoadLibrary</li>
      <li>SickScanApiCreate</li>
      <li>SickScanApiInitByLaunchfile or SickScanApiInitByCli</li>
    </ul>
  </li>
  <li>
    <p>Receive messages by registration of callbacks using <code class="language-plaintext highlighter-rouge">SickScanApiRegister&lt;MsgType&gt;Msg</code>-functions (recommended) or by polling using <code class="language-plaintext highlighter-rouge">SickScanApiWaitNext&lt;MsgType&gt;Msg</code>-functions.</p>

    <p>Alternative examples to receive lidar scan data as a point cloud:</p>
    <ul>
      <li>Register a callback for cartesian point cloud data using SickScanApiRegisterCartesianPointCloudMsg, or</li>
      <li>register a callback for polar point cloud data using SickScanApiRegisterPolarPointCloudMsg.</li>
    </ul>

    <p>The registered callback will be executed whenever the lidar has sent new scan data and receives the (cartesian or polar) point cloud by a parameter of type SickScanPointCloudMsg. The SickScanPointCloudMsg in sick_scan_xd API corresponds to ROS pointcloud: The cartesian point cloud  (registered by SickScanApiRegisterCartesianPointCloudMsg) contains the fields (x, y, z, intensity). The polar point cloud (registered by SickScanApiRegisterPolarPointCloudMsg) contains the fields (range, azimuth, elevation, intensity). Each field contains its name (i.e. x, y, z, range, azimuth, elevation, or intensity) and offset. The scan data is a flat buffer of size width x height fields:</p>

    <p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_api/apiPointCloudMsg.png" alt="apiPointCloudMsg"></p>

    <p>The following python code shows how to convert a cartesian point cloud to 3D points (x, y, z):</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Convert a SickScanCartesianPointCloudMsg to points
    def pySickScanCartesianPointCloudMsgToXYZ(pointcloud_msg):
        # get point cloud fields
        num_fields = pointcloud_msg.fields.size
        msg_fields_buffer = pointcloud_msg.fields.buffer
        field_offset_x = -1
        field_offset_y = -1
        field_offset_z = -1
        for n in range(num_fields):
            field_name = ctypesCharArrayToString(msg_fields_buffer[n].name)
            field_offset = msg_fields_buffer[n].offset
            if field_name == "x":
                field_offset_x = msg_fields_buffer[n].offset
            elif field_name == "y":
                field_offset_y = msg_fields_buffer[n].offset
            elif field_name == "z":
                field_offset_z = msg_fields_buffer[n].offset
        # Extract x,y,z
        cloud_data_buffer_len = (pointcloud_msg.row_step * pointcloud_msg.height) # length of polar cloud data in byte
        assert(pointcloud_msg.data.size == cloud_data_buffer_len and field_offset_x &gt;= 0 and field_offset_y &gt;= 0 and field_offset_z &gt;= 0)
        cloud_data_buffer = bytearray(cloud_data_buffer_len)
        for n in range(cloud_data_buffer_len):
            cloud_data_buffer[n] = pointcloud_msg.data.buffer[n]
        points_x = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        points_y = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        points_z = np.zeros(pointcloud_msg.width * pointcloud_msg.height, dtype = np.float32)
        point_idx = 0
        for row_idx in range(pointcloud_msg.height):
            for col_idx in range(pointcloud_msg.width):
                # Get lidar point in polar coordinates (range, azimuth and elevation)
                pointcloud_offset = row_idx * pointcloud_msg.row_step + col_idx * pointcloud_msg.point_step
                points_x[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_x)[0]
                points_y[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_y)[0]
                points_z[point_idx] = np.frombuffer(cloud_data_buffer, dtype = np.float32, count = 1, offset = pointcloud_offset + field_offset_z)[0]
                point_idx = point_idx + 1
        return points_x, points_y, points_z
   
</code></pre></div></div>
<p>Exchange field names (“x”, “y”, “z”) by (“range”, “azimuth”, “elevation”) to get 3D polar points (range, azimuth, elevation).</p>

<p>For further details, see minimalistic usage examples in C and Python.</p>

<p>Note for multiScan100 and picoScan100 lidars:</p>

<ul>
  <li>
    <p>The WaitNext-functions of the API return the next received message. For multiScan100 and picoScan, this can be a scan segment (i.e. a part of the full scan) or a fullframe point cloud (i.e. all scan points of a 360 degree scan). Depending on the timing, you may not receive all messages, i.e. you may e.g. receive scan points of different segments. We therefore recommend to register a message callback instead of a WaitNext-function. With a registered message callback, you will get all fullframe and segment point cloud messages.</p>
  </li>
  <li>
    <p>For multiScan100 and picoScan, point cloud messages can contain a scan segment (i.e. a part of the full scan) or a fullframe point cloud  (i.e. all scan points of a 360 degree scan). The type can be determined by the topic (default: “/cloud_unstructured_segments” for segments, “/cloud_unstructured_fullframe” for fullframe point clouds) or by segment index (-1 for fullframe, 0 up to 11 for segment point clouds).</p>
  </li>
</ul>

<ol>
  <li>Close lidar and API by
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">SickScanApiDeregister&lt;MsgType&gt;Msg</code>-functions</li>
      <li>SickScanApiClose</li>
      <li>SickScanApiRelease</li>
    </ul>
  </li>
</ol>

<p>It is recommended to store a deep copy of the point cloud data in a fifo buffer (first in, first out) for further data processing. After the registered callback is executed, the point cloud memory will be released. Make sure to store a deep copy of the point cloud, not a shallow copy.</p>

<p>All functions named <code class="language-plaintext highlighter-rouge">SickScanApi</code> are implemented within the library file (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux). A small wrapper is provided (<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/src/sick_scan_xd_api/sick_scan_xd_api_wrapper.c">sick_scan_xd_api_wrapper.c</a> for C/C++, <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a> for python), which loads and unloads the library (functions <code class="language-plaintext highlighter-rouge">SickScanApiLoadLibrary</code> and <code class="language-plaintext highlighter-rouge">SickScanApiUnloadLibrary</code>) and delegates the function calls to the binary.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). Otherwise, please install numpy with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> if numpy is not yet installed.</p>
</blockquote>

<h4 id="minimalistic-usage-example-in-c">Minimalistic usage example in C</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/examples/c/minimum_sick_scan_api_client.c">minimum_sick_scan_api_client.c</a> shows a minimalistic example of a C client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the build and run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd examples/c
mkdir -p ./build
cd ./build
cmake -G "Unix Makefiles" ..
make -j4
cd ../..
export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH
./examples/c/build/minimum_sick_scan_api_client &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the build and run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REM Set environment for Visual Studio 2019 (VS 16)
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
REM Build the minimalistic C usage example
cd examples\c
mkdir %_cmake_build_dir%
cd %_cmake_build_dir%
cmake -G "%_cmake_string%" ..
cmake --build . --clean-first --config Debug
REM Set environment: add build folder to LD_LIBRARY_PATH, add python/api to PYTHONPATH
cd ..\..
set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
REM Run minimalistic C api example
.\examples\c\build\Debug\minimum_sick_scan_api_client.exe &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<h4 id="minimalistic-usage-example-in-c-1">Minimalistic usage example in C++</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/examples/cpp/minimum_sick_scan_api_client.cpp">minimum_sick_scan_api_client.cpp</a> shows a minimalistic example of a C++ client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the build and run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd examples/cpp
mkdir -p ./build
cd ./build
cmake -G "Unix Makefiles" ..
make -j4
cd ../..
export LD_LIBRARY_PATH=.:./build:$LD_LIBRARY_PATH
./examples/cpp/build/minimum_sick_scan_api_client &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the build and run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REM Set environment for Visual Studio 2019 (VS 16)
set _os=x64
set _cmake_string=Visual Studio 16
set _msvc=Visual Studio 2019
set _cmake_build_dir=build
REM Build the minimalistic C++ usage example
cd examples\cpp
mkdir %_cmake_build_dir%
cd %_cmake_build_dir%
cmake -G "%_cmake_string%" ..
cmake --build . --clean-first --config Debug
REM Set environment: add build folder to LD_LIBRARY_PATH, add python/api to PYTHONPATH
cd ..\..
set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
REM Run minimalistic C++ api example
.\examples\cpp\build\Debug\minimum_sick_scan_api_client.exe &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<h4 id="minimalistic-usage-example-in-python">Minimalistic usage example in Python</h4>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/examples/python/minimum_sick_scan_api_client.py">minimum_sick_scan_api_client.py</a> shows a minimalistic example of a python client using the sick_scan_xd API. To build and run this example, open a command shell in folder <code class="language-plaintext highlighter-rouge">examples/scripts</code> and run <code class="language-plaintext highlighter-rouge">.\build_run_api_examples_linux.bash</code> on Linux resp. <code class="language-plaintext highlighter-rouge">build_run_api_examples_windows.cmd</code> on Windows. Make sure, that the shared library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code> has been successfully built in the build-folder.</p>

<p>Alternatively, follow the run instructions on Linux:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export LD_LIBRARY_PATH=`pwd`:`pwd`/build:$LD_LIBRARY_PATH
export PYTHONPATH=`pwd`:`pwd`/python/api:$PYTHONPATH
python3 ./examples/python/minimum_sick_scan_api_client.py &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<p>Alternatively, follow the run instructions on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PATH=.;.\build;.\build\Debug;.\build_win64;.\build_win64\Debug;%PATH%
set PYTHONPATH=.;.\python\api;%PATH%
python ./examples/python/minimum_sick_scan_api_client.py &lt;launchfile&gt; hostname:=&lt;lidar-ip-address&gt;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). Otherwise, please install numpy with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> if numpy is not yet installed.</p>
</blockquote>

<h4 id="complete-usage-example-in-c">Complete usage example in C++</h4>

<p>A complete C/C++ usage example is implemented in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a>. Note that the shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) has no dependencies to ROS. The usage example on the other hand supports both ROS 1, ROS 2 and native Linux or Windows. When build on ROS, it converts the SickScanApi-messages into ROS-messages. On ROS, they can be visualized by rviz. The following screenshot shows a point cloud published by <code class="language-plaintext highlighter-rouge">rosrun sick_scan_xd sick_scan_xd_api_test _sick_scan_args:="./src/sick_scan_xd/launch/sick_tim_7xx.launch"</code>:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_api/api_test_linux_ros1_tim7xx.png" alt="api_test_linux_ros1_tim7xx.png"></p>

<p>Without ROS, sick_scan_xd_api_test plots a jpeg-file to enable a simple visualization of a point cloud. E.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>firefox ./demo/image_viewer_api_test.html &amp;
./build_linux/sick_scan_xd_api_test ./launch/sick_tim_7xx.launch

</code></pre></div></div>
<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_api/api_test_linux_tim7xx.png" alt="api_test_linux_tim7xx.png"></p>

<h4 id="complete-usage-example-in-python">Complete usage example in Python</h4>

<p>A complete python usage example is implemented in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a>. It is handy to test the sick_scan_xd library. Like its C++ counterpart <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a>, it just loads library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> resp. <code class="language-plaintext highlighter-rouge">sick_scan_xd_shared_lib.dll</code>, starts a lidar and receives the lidar point cloud and messages via API. On ROS 1, the lidar point cloud and messages are converted to ROS and published. The lidar point cloud can be visualized by rviz using topic “/sick_scan_xd_api_test/api_cloud”.</p>

<p>Run <code class="language-plaintext highlighter-rouge">python3 sick_scan_xd_api_test.py &lt;launchfile&gt; hostname:=&lt;ip-address&gt;</code> to test the API against a lidar.
On Linux e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PYTHONPATH=`pwd`:`pwd`/src/sick_scan_xd/python/api:$PYTHONPATH
source /opt/ros/noetic/setup.bash # replace by noetic by your ros version
python3 ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_lms_1xx.launch hostname:=192.168.0.1

</code></pre></div></div>
<p>On Windows e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PYTHONPATH=.;.\src\sick_scan_xd\python\api;%PYTHONPATH%
python ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_lms_1xx.launch hostname:=192.168.0.1

</code></pre></div></div>

<p>The pthon usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> imports <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a>, which contains the python definitions of the sick_scan_xd API. Make sure that sick_scan_api.py can be imported, e.g. by including folder <code class="language-plaintext highlighter-rouge">python/api</code> in PYTHONPATH by:</p>

<p><code class="language-plaintext highlighter-rouge">export PYTHONPATH=</code>pwd<code class="language-plaintext highlighter-rouge">:</code>pwd<code class="language-plaintext highlighter-rouge">/src/sick_scan_xd/python/api:$PYTHONPATH</code> on Linux, resp. <br>
<code class="language-plaintext highlighter-rouge">set PYTHONPATH=.;.\src\sick_scan_xd\python\api;%PYTHONPATH%</code> on Windows</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  The shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) works standalone and does not have any ROS dependencies. The usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> converts API- to ROS-messages for visualization and is therefore dependent on ROS, if ROS is installed.</p>
</blockquote>

<p>If ROS is not installed, <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> uses matplotlib to visualize the pointcloud. The following screenshot shows a TiM-7xx point cloud on Linux without ROS:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_api/api_test_python_tim7xx.png" alt="api_test_python_tim7xx.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a> requires python module numpy. On Windows without ROS, <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> requires numpy and matplotlib. On Windows, we recommend to install and use Python either with Visual Studio 2019 or by installing from https://www.python.org/downloads/windows/ (python installer, embedded version not recommended). These python distributions provide the necessary packages and tools. Otherwise, please install numpy and matplotlib with <code class="language-plaintext highlighter-rouge">python -m pip install numpy</code> and <code class="language-plaintext highlighter-rouge">python -m pip install matplotlib</code> if not yet done.</p>
</blockquote>

<h4 id="diagnostic">Diagnostic</h4>

<p>The API provides the following functions for diagnostics:</p>

<ul>
  <li>SickScanApiRegisterDiagnosticMsg and SickScanApiDeregisterDiagnosticMsg: Register resp. deregister a callback to receive diagnostic messages. Diagnostic messages contain a status code and status message. The status code is one of the following numbers:
    <ul>
      <li>OK=0 (normal operation)</li>
      <li>WARN=1 (warning)</li>
      <li>ERROR=2 (error, should not occur)</li>
      <li>INIT=3 (initialization after startup or reconnection)</li>
      <li>EXIT=4 (sick_scan_xd exiting)</li>
    </ul>

    <p>The status message is descriptional C-string.</p>

    <p>A typical sequence of the status code is:</p>
    <ul>
      <li>INIT at startup, then</li>
      <li>after lidar initialization is completed: change to OK (normal operation) and run, and</li>
      <li>EXIT at shutdown.
 Diagnostic messages are generated whenever the status changed or an ERROR occured. Status code 2 (i.e. error) should not occur under normal operation.</li>
    </ul>
  </li>
  <li>
    <p>SickScanApiRegisterLogMsg and SickScanApiDeregisterLogMsg: Register resp. deregister a callback to receive log messages. This callback will receive all informational or error messages printed on console. The log messages contain a log level (Info=1, Warn=2, Error=3, Fatal=4) and the log message.</p>
  </li>
  <li>
    <p>SickScanApiGetStatus queries the current status. This function returns the current status code (OK=0 i.e. normal operation, WARN=1, ERROR=2, INIT=3 i.e. initialization after startup or reconnection or EXIT=4) and the descriptional status message.</p>
  </li>
  <li>SickScanApiSendSOPAS sends a SOPAS command (Cola-A) to the lidar and returns the response from the device.
    <ul>
      <li>C++ example:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     char sopas_response_buffer[1024] = { 0 };
     SickScanApiSendSOPAS(apiHandle, "sRN SCdevicestate", &amp;sopas_response_buffer[0], (int32_t)sizeof(sopas_response_buffer); // returns "sRA SCdevicestate \x00" in sopas_response_buffer
     
</code></pre></div></div>

<ul>
  <li>Python example:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     sopas_response = SickScanApiSendSOPAS(sick_scan_library, api_handle, "sRN SCdevicestate")` # returns "sRA SCdevicestate \x00".
      
</code></pre></div></div>
<p>See the telegram listing for valid SOPAS commands.</p>

<ul>
  <li>SickScanApiSetVerboseLevel and SickScanApiGetVerboseLevel sets resp. returns the verbose level. The verbose level can be 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR, 4=FATAL or 5=QUIET (equivalent to ros::console::levels). Default verbose level is 1 (INFO), i.e. sick_scan_xd prints informational, warnings and error messages on the console. Logging callbacks registered with SickScanApiRegisterLogMsg will receive all informational, warnings and error messages independent of the verbose level.</li>
</ul>

<p>To monitor sick_scan_xd resp. the lidar, it is recommended to register a callback for diagnostic messages using SickScanApiRegisterDiagnosticMsg and to display the error message in case for status code 2 (error). See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/src/sick_scan_xd_api/sick_scan_xd_api_test.cpp">sick_scan_xd_api_test.cpp</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> for an example.</p>

<h4 id="simulation-and-unit-test">Simulation and unit test</h4>

<p>sick_scan_xd provides a tiny server for offline tests which simulates a basic lidar. It just accepts TCP connections, responds to sopas requests with predefined responses and sends lidar data from file. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CONTRIBUTING.md">Simulation</a> for further details. Note that the simulation does not emulate or replace a lidar, it just supports basic unit tests.</p>

<p>Open a new terminal and run the following steps to test the api against a TiM7xx simulation using the python example mentioned above:</p>

<ol>
  <li>Build library <code class="language-plaintext highlighter-rouge">libsick_scan_xd_shared_lib.so</code> incl. emulator with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code>:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir -p ./src/build
   pushd ./src/build
   rm -rf ./*
   cmake -DROS_VERSION=0 -DCMAKE_ENABLE_EMULATOR=1 -G "Unix Makefiles" ../sick_scan_xd
   make -j4
   ls -al libsick_scan_xd_shared_lib.so sick_scan_xd_api_test sick_generic_caller sick_scan_emulator # list size and date of the binaries
   popd
   
</code></pre></div></div>
<p>Building sick_scan_xd with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code> requires jsoncpp. Install libjsoncpp by running “sudo apt-get install libjsoncpp-dev” on Linux resp. “vcpkg install jsoncpp:x64-windows” on Windows (vcpkg required). Run the following steps to install Visual Studios package manager vcpkg on Windows:
      * Download vcpkg-master.zip from https://github.com/microsoft/vcpkg/archive/master.zip and unzip to <code class="language-plaintext highlighter-rouge">c:\vcpkg</code>. Alternatively, run “git clone https://github.com/microsoft/vcpkg”
      * Install vcpkg by running the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        cd c:/vcpkg
        bootstrap-vcpkg.bat
        vcpkg integrate install
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  * Include vcpkg in your path:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        set PATH=c:\vcpkg\installed\x64-windows\bin;%PATH%
        
</code></pre></div></div>

<ol>
  <li>
    <p>Create a workspace folder, e.g. <code class="language-plaintext highlighter-rouge">sick_scan_ws</code> (or any other name):</p>
  </li>
  <li>
    <p>Build sick_scan_xd for ROS 1 on Linux, see <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-ros1">Build on Linux ROS 1</a></p>
  </li>
  <li>
    <p>Start the TiM7xx simulator:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cp -f ./src/sick_scan_xd/test/emulator/scandata/sopas_et_field_test_1_2_both_010.pcapng.json /tmp/lmd_scandata.pcapng.json
   ./src/build/sick_scan_emulator ./src/sick_scan_xd/test/emulator/launch/emulator_01_default.launch &amp;
   sleep 1
   
</code></pre></div></div>

<ol>
  <li>Run sick_scan_xd_api_test.py against the TiM7xx simulator on localhost:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   export PYTHONPATH=.:./src/sick_scan_xd/python/api:$PYTHONPATH
   python3 ./src/sick_scan_xd/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py ./src/sick_scan_xd/launch/sick_tim_7xx.launch hostname:=127.0.0.1 port:=2111 sw_pll_only_publish:=False
   
</code></pre></div></div>

<ol>
  <li>Start rviz and visualize the point cloud on topic “/sick_scan_xd_api_test/api_cloud”.</li>
</ol>

<blockquote>
  <p><strong><em>NOTE:</em></strong> The shared library (“sick_scan_xd_shared_lib.dll” on Windows resp. “libsick_scan_xd_shared_lib.so” on Linux) works standalone and does not have any ROS dependencies. The usage example <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/python/sick_scan_xd_api/sick_scan_xd_api_test.py">sick_scan_xd_api_test.py</a> uses ROS for visualization.</p>
</blockquote>

<h3 id="c-api">C-API</h3>

<p>The header file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/include/sick_scan_xd_api/sick_scan_api.h">sick_scan_api.h</a> defines the C-interface. It defines all datatypes, messages and functions of the generic sick_scan_xd API. To allow equal operations on all systems, the definition of datatypes and messages is as close as possible to their equivalents currently used on ROS.</p>

<p>Python file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/python/api/sick_scan_api.py">sick_scan_api.py</a> defines the same interface in python.</p>

<h3 id="useful-links">Useful links</h3>

<p><a href="https://docs.python.org/3/library/ctypes.html">ctypes</a> is used for data exchange and function calls between Python and C-libraries:</p>
<ul>
  <li>https://docs.python.org/3/library/ctypes.html</li>
  <li>https://docs.python.org/3/library/ctypes.html#structures-and-unions</li>
  <li>https://docs.python.org/3/library/ctypes.html#callback-functions</li>
</ul>

<h2 id="timestamps-and-synchronization-software-pll">Timestamps and synchronization (Software PLL)</h2>

<p>Often there is a requirement that the time stamp of the measurements should be calculated for each individual shot. This article explains some background information about the determination of these time stamps. Here the statements refer to the LMS511. However, they can be transferred to other lidars using the same logic.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/lms511_scan.png" alt="lms511_scan.png"></p>

<p>The lidar sends a pulsed beam onto a rotating mirror. Since the speed of rotation is relatively low, this mirror serves as transmitter and receiver. The direction of rotation can be seen in the drawing.</p>

<p>25 scans per second means that the mirror makes 25 360° rounds per second. The actual laser unit is only active during the 190°. Therefore the so-called duty cycle is 190/360. The rotation is unaccelerated, so that the lidar arrives at the same angular direction again after 40 ms (1/25). From the angular distance from shot to shot you can calculate the pulse rate of the laser. For example, if the angular difference from shot to shot is 0.1 degree, the so-called shot rate would be: 360/0.1 * 25 shots/second.</p>

<p>A scan means the group of all shots during one revolution. Just imagine the lidar as a lighthouse that rotates evenly and measures the distance values over time of flight in a certain sector (here 190°) with the above mentioned shot rate. Also you find some background material in the documentation of SICK.</p>

<p>In the transmission protocol of the lidar two points in time are given in so-called ticks (resolution in microseconds):
a) Start of the scans in ticks
b) Start of IP data transfer from lidar to PC in ticks</p>

<p>It is assumed that the transfer between lidar and PC is near latency-free.
The software PLL generates an assignment between the tick of the IP data transmission and the system time of the PC via an estimated line mapping. On the basis of this straight line equation, the start of the scan is then calculated relative to the system time. This generation time stamp is the time of the first shot of the scan. This timestamp is assigned to the point cloud timestamp. From there, the rotation speed and the angular distance from shot to shot can be used to approximately calculate the time for each shot.</p>

<p>A software pll is used to convert LiDAR timestamps in ticks to the ros system time.</p>

<p>Many sensor devices, e.g. lidar devices, provide sensor data with timestamps. These timestamps can be synchronized with the current system time by additional hardware, e.g. by GPS. But without specialized hardware, sensor timestamps and system time is normally unsynchronized. Sensor timestamps are often quite accurate, but have a different time base and a bias to the system time or to other sensor clocks. This difference is estimated and compensated by this Software PLL.</p>

<p>The scanner has an internal time base of microseconds since system startup. Against this “tick” time base all time stamps are made in the scanner. When sending messages from the scanner, two time stamps are added:</p>

<ol>
  <li>scan generation ticks–&gt; timestamp at the time of the first shot</li>
  <li>scan transmission ticks–&gt; time stamp for the transmission of the data</li>
</ol>

<p>When data packets are received, they are timestamped by the driver against the systemtime in ros::time format. See following Fig.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/timing_sync.png" alt="timing_syn.png"></p>

<p>The relationship between system time and ticks is then derived from the time stamps and kept synchronous.The time required for the transmission of data over the network is assumed to be short and constant and is therefore neglected. The function of the algorithms is shown in the following Fig.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sequence_time_pll.png" alt="sequence_time_pll.png"></p>

<p>To compensate the different time base and bias between sensor and system clock, the system time when receiving sensor data is gathered together with the sensor timestamp. While the system time is often measured in seconds resp. nanoseconds, the sensor timestamp is normally received in clock ticks. SoftwarePLL estimates the correlation between system time in secondsnanoseconds and sensor ticks, and computes a corrected time from ticks. This way you know at which time stamp the data
have been measured by your sensor.</p>

<p>SoftwarePLL is a generic module and independant from specific sensor types. It just uses the system timestamps and ticks, estimates their correlation and predicts the time from sensor ticks.SoftwarePLL computes a linear regression between ticks and system timestamps. The system time is measured immediately after receiving new sensor data, while sensor ticks represent the sensor clock at the time of measurement. Thus we have three different times for each measurement</p>

<ul>
  <li>The time when the system receives the sensor data (receive time t_rec), measured in seconds resp. nanoseconds.</li>
  <li>The sensor ticks (or just ticks) at the time of the measurement. These ticks are contained in the sensor data and
received later by the system.</li>
  <li>The time of the measurement (measurement time t_mea). We don’t know this time yet, but we estimate it from both the ticks
and their receive time t_rec using the SoftwarePLL.</li>
</ul>

<p>During initialization, ticks and system timestamps are stored in fifo buffer (first-in, first-out). After initialization,
typically after N=7 measurements, a regression line is computed, i.e. the slope <code class="language-plaintext highlighter-rouge">m</code> (gradient) of a function
<code class="language-plaintext highlighter-rouge">f(ticks) = m  ticks + c</code> is estimated from ticks <code class="language-plaintext highlighter-rouge">x(i)</code> and timestamps <code class="language-plaintext highlighter-rouge">y(i)</code> by a linear regression
<code class="language-plaintext highlighter-rouge">m = (N  sum(x(i)  y(i)) - sum(x(i))  sum(y(i)))  (N  sum(x(i)  x(i)) - sum(x(i))sum(x(i)))</code> with <code class="language-plaintext highlighter-rouge">0 = i  N</code> and
unbiased values <code class="language-plaintext highlighter-rouge">x(i) = tick(i) - tick(0)</code>, <code class="language-plaintext highlighter-rouge">y(i) = t_rec(i) - t_rec(0)</code>.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/pll_regression.png" alt="pll_regression.png"></p>

<p>The estimated system time <code class="language-plaintext highlighter-rouge">t_esti(i)</code> of a measurement can be computed from its sensor tick by <code class="language-plaintext highlighter-rouge">t_esti(i) = m  (ticks(i) - ticks(0)) + t_rec(0)</code>.
If the difference between estimated times <code class="language-plaintext highlighter-rouge">t_esti(i)</code> and the measured system timestamps <code class="language-plaintext highlighter-rouge">t_rec(i)</code> is small (typically
less than 100 milliseconds), the estimation can be considered to be valid. With a valid estimation of <code class="language-plaintext highlighter-rouge">m</code>, we can
get a corrected timestamp for new measurements by applying function <code class="language-plaintext highlighter-rouge">SoftwarePLLGetCorrectedTimeStamp</code>, which returns
the estimated system time of a measurement <code class="language-plaintext highlighter-rouge">t_esti  = m  (ticks - ticks(0)) + t_rec(0)</code>.</p>

<p>If the estimation is not valid (i.e. the difference between estimated times and measured system timestamps in the buffer is
significant), we can’t estimate system timestamps from sensor ticks. If this happens more than a given number of times
after initialization (typically 20 times), the fifo is reset and a new initialization is done.</p>

<p>Use the following code snippet as an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include softwarePLL.h

 Create an instance of SoftwarePLL
SoftwarePLL&amp; software_pll = SoftwarePLLInstance(Sensor1);

 Get system time t_rec in seconds and nanoseconds when receiving sensor data
rosTime t_rec = rosTimenow();
uint32_t sec = t_rec.nsec;
uint32_t nanosec = t_rec.nsec;

 Get sensor ticks from sensor data
uint32_t ticks = scanner_msg.ticks;

 Update SoftwarePLL
software_pll.UpdatePLL(sec, nanosec, ticks);

 Get corrected timestamp (time of measurement from ticks)
software_pll.GetCorrectedTimeStamp(sec, nanosec, ticks);

</code></pre></div></div>

<p><strong>Data buffering in MRS1000</strong></p>

<p>Due to their construction the MRS1000 scanners generate different layers at the same time which are output sequentially by the scanner firmware. In order to ensure that only point cloud messages that follow one another in time are sent, buffering can be activated in the driver.
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/scannbuffering.png" alt="scannbuffering.png"></p>

<h2 id="coordinate-transforms">Coordinate transforms</h2>

<p>Different lidars use different coordinate systems. sick_scan_xd transforms all points of the published pointclouds to the ROS coordinate system, independant of the lidar. The following figure shows the commonly used coordinate systems:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/3d_coordinate_system_comp.png" alt="3d_coordinate_system_comp.png"></p>

<p>An additional coordinate transform can be applied to the pointcloud. This optional transform can be used to transform the pointclouds into a user defined coordinate system. If the lidar is e.g. mounted on a vehicle, the pointclouds can be transformed into a vehicle coordinates.</p>

<p>An additional coordinate transform can be configured by a 6D pose (x, y, z, roll, pitch, yaw) with a translational part (x, y, z) in [m] and a rotational part (roll, pitch, yaw) in [rad].</p>

<p>If configured, it will transform the point cloud from its “cloud” coordinates into user defined “world” coordinate system:</p>

<p><code class="language-plaintext highlighter-rouge">T[world,cloud] with P_world = T[world,cloud] * P_cloud</code> (parent: world, child: cloud)</p>

<p>The final rotation is defined by: Rotation = Rot[yaw] * Rot[pitch] * Rot[roll] with roll = rotation about x-axis, pitch = rotation about y-axis and yaw = rotation about z-axis.</p>

<p>An additional transform can be configured in the launchfile, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- Apply an additional transform to the cartesian pointcloud, default: "0,0,0,0,0,0" (i.e. no transform) --&gt;
&lt;!-- &gt; **_NOTE:_** add_transform_xyz_rpy is specified by 6D pose x, y, z, roll, pitch, yaw in [m] resp. [rad] --&gt;
&lt;!-- It transforms a 3D point in cloud coordinates to 3D point in user defined world coordinates: --&gt;
&lt;!-- add_transform_xyz_rpy := T[world,cloud] with parent "world" and child "cloud", i.e. P_world = T[world,cloud] * P_cloud --&gt;
&lt;param name="add_transform_xyz_rpy" type="string" value="0,0,0,0,0,0" /&gt;

</code></pre></div></div>

<p>Default value is <code class="language-plaintext highlighter-rouge">"0,0,0,0,0,0"</code>, i.e. no additional transform will be applied.</p>

<p>The additional transform applies to cartesian lidar pointclouds and visualization marker (fields).
It is <strong>NOT</strong> applied to polar point clouds, radarscans, LD-MRS objects or other messages.</p>

<p>Note that sick_scan_xd configures an additional transform using (x, y, z, roll, pitch, yaw). In contrast, the ROS static_transform_publisher uses commandline arguments in order x, y, z, yaw, pitch, roll.</p>

<p>Example using ROS static_transform_publisher with x=0, y=0, z=0, roll=15, pitch=-10, yaw=5 [deg]:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source /opt/ros/noetic/setup.bash
# static_transform_publisher x y z yaw pitch roll frame_id child_frame_id period_in_ms
# tf_echo &lt;source_frame&gt; &lt;target_frame&gt;
# rot_x = 5 deg: 0.0872665, rot_y = -10 deg: -0.1745329, rot_z = 15 deg: 0.2617994
rosrun tf static_transform_publisher 0 0 0 0.2617994 -0.1745329 0.0872665 parent_frame child_frame 100
rosrun tf tf_echo parent_frame child_frame

</code></pre></div></div>

<p>File <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/doc/sick_scan_api/trafo_example.py">trafo_example.py</a> demonstrates how a transform can be computed.</p>

<p>For upside down mounted devices, the point cloud can be rotated by 180 deg about the x axis (180 deg roll angle). This additional rotation is configured in the launch file using parameter <code class="language-plaintext highlighter-rouge">add_transform_xyz_rpy</code> with value <code class="language-plaintext highlighter-rouge">"0,0,0,3.141592,0,0"</code>. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lrs_36x0_upside_down.launch">sick_lrs_36x0_upside_down.launch</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lrs_36x1_upside_down.launch">sick_lrs_36x1_upside_down.launch</a> show examples for compensating the point cloud of an upside down mounted device by a 180 deg rotation about the x axis.</p>

<h2 id="imu-support">IMU Support</h2>

<p>Devices of the MRS6xxx and MRS1xxx series are available with an optionally built-in IMU.</p>

<p>For the IMU support of multiScan100 and picoScan100 refer to the device specific section.</p>

<p>By setting the following config parameter in the launch file, the output of <a href="http://docs.ros.org/melodic/api/sensor_msgs/html/msg/Imu.html">imu messages</a> can be enabled with a compatible scanner. Currently the messages are published in the /imu Topic.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_enable"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">value=</span><span class="s">"True"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_topic"</span> <span class="na">type=</span><span class="s">"string"</span> <span class="na">value=</span><span class="s">"imu"</span><span class="nt">/&gt;</span>

</code></pre></div></div>
<p>The imu Messages contain covariance matrices, these are currently determined from empirical values and are not measured specifically for each scanner.
The laser scanner provides additional information (tick timestamp and confidence) to the Imu messages these can be activated by activating the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/msg/SickImu.msg">SickImu messages</a>.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"imu_enable_additional_info"</span> <span class="na">type=</span><span class="s">"bool"</span> <span class="na">value=</span><span class="s">"True"</span> <span class="nt">/&gt;</span>

</code></pre></div></div>

<p>IMU messages are only supported in SOPAS binary mode. Due to the high data rate of the IMU messages (100 Hz and more) while sending the standard laser scanner messages at the same time, the ASCII mode is not supported. Please set the scanner to binary mode if you are using the IMU.</p>

<h2 id="encoders">Encoders</h2>

<p>If the device is mounted for mobile use or if the objects to be measured are in motion,the application will usually also need position data to further process the measured val‐ues.Encoders can be connected for this purpose. The encoder data is then available withthe other measured values in a single scan and at the same interface. A volume,for example, can be calculated by evaluating the measurement data. The input fre‐quency of the encoder signal must not exceed 50 kHz.The following encoders with push-pull output stage can be used:</p>
<ol>
  <li>Single-channel, only connected at encoder A, no direction detection.</li>
  <li>Dual-channel (phase), connected at encoder A and encoder B; the pulses have aphase shift of 90°, making direction detection possible. By definition, during for‐ward motion (CW = clockwise) phase A precedes phase B; conversely, duringreverse motion (CCW = counterclockwise) edge A rises before edge B.</li>
  <li>Dual-channel (level), connected at encoder A and encoder B; the pulses are atencoder A; at encoder B, the direction is indicated by level 0 or level 1 (rarely).</li>
</ol>

<h3 id="connecting-encoders">Connecting encoders</h3>
<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/lms4xxx_encoder_connection.png" alt="LMS4000 encoder connection" title="LMS4000 encoder connection">
See also <a href="https://cdn.sick.com/media/docs/0/90/790/Operating_instructions_LMS4000_2D_LiDAR_sensors_en_IM0079790.PDF">LMS4000 Manual</a></p>

<h3 id="example-circuit-to-trigger-encoder-counts">Example circuit to trigger encoder counts</h3>
<p>Whenever the switch is closed a potential of 24 V is applied to the encoder input A in mode (01 single-channel) this leads to an increase of the count by 1.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/circuit.png" alt="encoder trigger" title="encoder trigger"></p>

<h3 id="activation-of-encoder-information">Activation of encoder information</h3>
<p>If the parameter</p>
<pre><code class="language-encoder_mode">``` is set to 1-4 in the launch file, the encoder is activated in the laser scanner in the corresponding mode (see list above).

The following encoder modes can be configured in the launch file or by commandline parameter:
* `encoder_mode:=-1`: Default value, i.e. encoder configuration not set
* `encoder_mode:=0`: Encoder off (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=1`: Single increment (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=2`: Direction recognition phase (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=3`: Direction recognition level (supported by LMS1xx, LMS5xx, LMS4000, LRS4000)
* `encoder_mode:=4`: Fixed increment speed/ticks (supported by LMS4000 only)

Encoder messages are published on topic `/encoder` synchronously to the point cloud messages. They contain a timestamp and the encoder value, e.g.:

```console
foo@bar:~$rostopic echo /encoder
header:
  seq: 20700
  stamp:
    secs: 1570722972
    nsecs:  28866142
  frame_id: "Encoder"
enc_count: 836
---
header:
  seq: 20701
  stamp:
    secs: 1570722972
    nsecs:  30598181
  frame_id: "Encoder"
enc_count: 836
---
header:
  seq: 20702
  stamp:
    secs: 1570722972
    nsecs:  32138020
  frame_id: "Encoder"
enc_count: 836

</code></pre>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/Encoder_data.png" alt="Encoderdata in Sopas datagramm" title="Encoderdata in Sopas datagramm"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/set_encoder_settings.png" alt="Set encoder config" title="Set encoder config"></p>

<h2 id="field-evaluation-information">Field Evaluation Information</h2>

<p>The LMS1xx, LMS5xx, TiM7xx and TiM7xxS families support extensions for field monitoring.</p>

<h3 id="field-monitoring-messages">Field monitoring messages</h3>

<p>LMS1xx, LMS5xx, TiM7xx and TiM7xxS scanner support field monitoring. Fields can be configured by Sopas ET. Once they are configured, sick_scan_xd publishes ros messages containing the monitoring information from the lidar.</p>

<p>By default, field monitoring is enabled in the launch files <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lms_1xx.launch">sick_lms_1xx.launch</a>,  <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lms_5xx.launch">sick_lms_5xx.launch</a>,
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_tim_7xx.launch">sick_tim_7xx.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_tim_7xxS.launch">sick_tim_7xxS.launch</a> by following settings:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="activate_lferec" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lferec messages --&gt;
&lt;param name="activate_lidoutputstate" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lidoutputstate messages --&gt;
&lt;param name="activate_lidinputstate" type="bool" value="True"/&gt; &lt;!-- activate field monitoring by lidinputstate messages --&gt;

</code></pre></div></div>

<p>The driver queries the field configuration from the lidar and activates field monitoring by sending cola commands <code class="language-plaintext highlighter-rouge">"sEN LFErec 1"</code> and <code class="language-plaintext highlighter-rouge">"sEN LIDoutputstate 1"</code> at startup. Field monitoring is deactivated when driver exits. During runtime, it’s possible to query, activate or deactivate monitoring using ros service ColaMsg with the following command (see section <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#cola-commands">Cola commands</a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LFErec 1'}" # activate LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LFErec 0'}" # deactivate LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LFErec'}"   # query activation status of LFErec messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDoutputstate 1'}" # activate LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDoutputstate 0'}" # deactivate LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LIDoutputstate'}"   # query activation status of LIDoutputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDinputstate 1'}"  # activate LIDinputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sEN LIDinputstate 0'}"  # deactivate LIDinputstate messages
rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN LIDinputstate'}"    # query activation status of LIDinputstate messages

</code></pre></div></div>

<p>LFErec and LIDoutputstate messages are defined in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/msg/LFErecMsg.msg">LFErecMsg.msg</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/msg/LFErecFieldMsg.msg">LFErecFieldMsg.msg</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/msg/LIDoutputstateMsg.msg">LIDoutputstateMsg.msg</a> and published on the following topics: <code class="language-plaintext highlighter-rouge">"/sick_tim_7xxS/lferec"</code> resp. <code class="language-plaintext highlighter-rouge">"/sick_tim_7xxS/lidoutputstate"</code>.</p>

<table>
  <thead>
    <tr>
      <th>** Lidar **</th>
      <th>** lferec topic **</th>
      <th>** lidoutputstate topic **</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>lms_1xx</td>
      <td>/sick_lms_1xx/lferec</td>
      <td>/sick_lms_1xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_5xx</td>
      <td>/sick_lms_5xx/lferec</td>
      <td>/sick_lms_5xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_7xx</td>
      <td>/sick_tim_7xx/lferec</td>
      <td>/sick_tim_7xx/lidoutputstate</td>
    </tr>
    <tr>
      <td>lms_7xxS</td>
      <td>/sick_tim_7xxS/lferec</td>
      <td>/sick_tim_7xxS/lidoutputstate</td>
    </tr>
  </tbody>
</table>

<p>To view the field monitoring messages, run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic echo "/sick_lms_1xx/lferec"
rostopic echo "/sick_lms_1xx/lidoutputstate"
rostopic echo "/sick_lms_5xx/lferec"
rostopic echo "/sick_lms_5xx/lidoutputstate"
rostopic echo "/sick_tim_7xx/lferec"
rostopic echo "/sick_tim_7xx/lidoutputstate"
rostopic echo "/sick_tim_7xxS/lferec"
rostopic echo "/sick_tim_7xxS/lidoutputstate"

</code></pre></div></div>
<p>or use rviz to visualize monitored fields and their status (see section <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#visualization-with-rviz">Visualization with rviz</a>)</p>

<p>The most important values of the field monitoring messages are</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">field_index</code> (uint8) and <code class="language-plaintext highlighter-rouge">field_result_mrs</code> (uint8) for each field of a LFErec message with result status<br>&lt;ul&gt;
    </li>
<li>0: invalid / incorrect,</li>
    <li>1: free / clear, or</li>
    <li>2: infringed.</li>
    <p>&lt;/ul&gt;</p>
  
  <li>
<code class="language-plaintext highlighter-rouge">output_state</code> (uint8) for each LIDoutputstate message with status 0 (not active), 1 (active) or 2 (not used).</li>
</ul>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Field monitoring currently supports binary cola messages only, which is the default. If cola ascii is activated, please switch back to cola binary for field monitoring.</p>
</blockquote>

<h3 id="visualization-with-rviz">Visualization with rviz</h3>

<p>The point cloud, the monitored fields and their status can be visualized using rviz. Use the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/emulator/config/rviz_emulator_cfg.rviz">rviz configuration file</a>
and run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz

</code></pre></div></div>

<p>Otherwise you can just add visualizations of type <code class="language-plaintext highlighter-rouge">/cloud/PointCloud2</code> and <code class="language-plaintext highlighter-rouge">/sick_tim_7xxS/marker</code> (resp. <code class="language-plaintext highlighter-rouge">/sick_tim_1xx/marker</code> for lms_1xx,  <code class="language-plaintext highlighter-rouge">/sick_tim_5xx/marker</code> for lms_5xx and  <code class="language-plaintext highlighter-rouge">/sick_tim_7xx/marker</code> for tim_7xx):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/tim7xxs_screenshot01.png" alt="tim7xxs_screenshot01.png"></p>

<p>The following screenshot shows a TiM781S example with 2 fields (the 3. field is not configured), the first field with status “Clear”, the second with status “Infringed”:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/tim7xxs_screenshot02.png" alt="tim7xxs_screenshot02.png"></p>

<p>The following screenshot shows a LMS511 example with a segmented field, two rectangular fields and a dynamic fields:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/lms511_screenshot01.png" alt="lms511_screenshot01.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Some combinations of rviz, OpenGL 3, VMware and graphic card drivers may cause visualization issues. In case of missing markers, try rviz with Open GL 2 using the command</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz --opengl 210

</code></pre></div></div>

<h3 id="cola-commands">Cola commands</h3>

<p>Cola commands can be sent for diagnosis and development using the ros service ColaMsg. This service is implemented in sick_scan_xd and started by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="start_services" type="bool" value="True"/&gt;

</code></pre></div></div>
<p>in the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_tim_7xxS.launch">sick_tim_7xxS.launch</a> (resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lms_1xx.launch">sick_lms_1xx.launch</a>, <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_lms_5xx.launch">sick_lms_5xx.launch</a>, <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_tim_7xx.launch">sick_tim_7xx.launch</a> ). The ros service sends the given cola command to the lidar and returns its response.</p>

<p>Example for cola command <code class="language-plaintext highlighter-rouge">"sRN SCdevicestate"</code> and response <code class="language-plaintext highlighter-rouge">"sRA SCdevicestate \\x00"</code> with error status 0 (no error):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/ColaMsg "{request: 'sRN SCdevicestate'}"
response: "sRA SCdevicestate \\x00"

</code></pre></div></div>

<h3 id="tools-emulation-and-unittests">Tools, emulation and unittests</h3>

<p>Package sick_scan_xd implements some tools to support unittests, development and emulation of Tim781S devices:</p>

<ul>
  <li>sick_scan_emulator to emulate lidar devices and enable unittests (currently for Tim781S only)</li>
  <li>pcap_json_converter to convert pcapng-files to json.</li>
</ul>

<h4 id="lms-and-tim-emulation">LMS and TiM emulation</h4>

<p>sick_scan_emulator implements a simple test server for cola commands. It rececives Cola-commands, returns Tim781S-like responses and sends Scandata from a json-file. Run</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_01_default.launch

</code></pre></div></div>
<p>to emulate a local Tim781S device. Then start and connect the sick_scan_xd driver by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>Note that sick_scan_emulator just implements a simple server for offline tests. It does not emulate a lidar device completely and should only be used for development and testing.</p>

<p>Scandata messages are parsed from json-file(s). These json-files are configured in the launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/emulator/launch/emulator_01_default.launch">emulator.launch</a> and converted form wireshark-records (pcapng-files) using pcap_json_converter.py (see section Pcapng converter tool](#pcapng-converter-tool)).</p>

<p>A LMS111 device can be emulated by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_lms1xx.launch &amp;
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms1xx.rviz &amp;
roslaunch sick_scan_xd sick_lms_1xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>A LMS511 device can be emulated by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd emulator_lms5xx.launch &amp;
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms5xx.rviz &amp;
roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<h4 id="unittests">Unittests</h4>

<p>Folder <code class="language-plaintext highlighter-rouge">test/emulator/scandata</code> contains scandata examples for unittests. To run an offline unittest for LMS111, LMS511, TiM781, TiM781S enter the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd test/scripts
./run_simu_lms1xx.bash
./run_simu_lms5xx.bash
./run_simu_tim7xx_tim7xxS.bash

</code></pre></div></div>
<p>or start emulator, driver and rviz by running</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1
# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz --opengl 210 &amp;
sleep 1
# Start sick_scan_xd driver for TiM871S
roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<h4 id="pcapng-converter-tool">Pcapng converter tool</h4>

<p>The pcapng converter tool <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/pcap_json_converter/pcap_json_converter.py">pcap_json_converter.py</a> converts pcapng-files to json-files. Run the following steps to create a json-file with scandata for the emulator:</p>

<ol>
  <li>Start wireshark and filter the tcp traffic on port 2112 with the filter expression <code class="language-plaintext highlighter-rouge">tcp and tcp.port==2112</code>.</li>
  <li>Start TiM781S and run the sick_scan_xd driver.</li>
  <li>Capture the network traffic for some time.</li>
  <li>Stop capturing and save the network traffic in a pcapng-file.</li>
  <li>Convert the pcapng-file to json by <code class="language-plaintext highlighter-rouge">python pcap_json_converter.py --pcap_filename=&lt;filepath&gt;.pcapng</code>. Result is a jsonfile <code class="language-plaintext highlighter-rouge">&lt;filepath&gt;.pcapng.json</code>
</li>
  <li>Set the resulting json-file in the emulator configuration <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/test/emulator/launch/emulator_01_default.launch">emulator.launch</a> by <code class="language-plaintext highlighter-rouge">&lt;arg name="scandatafiles" default="&lt;filepath&gt;.pcapng.json"/&gt;</code>
</li>
</ol>

<h2 id="slam-support">SLAM Support</h2>

<h3 id="introduction">Introduction</h3>

<p>In robotic mapping and navigation, simultaneous localization and mapping (SLAM) is the computational problem of constructing or updating a map of an unknown environment while simultaneously keeping track of an agent’s location within it. For further details please refer to https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping .</p>

<h3 id="measuring-principle">Measuring Principle</h3>

<p>The following assumes that the SLAM algorithm works with a laser scanner mounted on a mobile base. The mobile base (e.g. a robot) records the environment while driving and creates the map from it. The mobile base usually has a so-called intertial measurement unit (IMU). In principle, however, it is also possible to estimate the direction of movement from the chronological sequence of the laser scans by means of correlation observations. The laser scanner then virtually takes over the task of the IMU and other components (e.g. counting the wheel revolutions). The method of estimating the position and orientation (position estimation) of a mobile system based on data from its driving system is called odometry (cf. https://en.wikipedia.org/wiki/Odometry).</p>

<p>The SLAM algorithm hector_slam (http://wiki.ros.org/hector_slam) supports odometry estimation directly from the laser scans and is therefore used as a reference implementation in the following.</p>

<p>Other widely used SLAM algorithms such as gmapping (cf. http://wiki.ros.org/gmapping ) do not have this option. They depend on the data of an IMU. One possibility to use Gmapping nevertheless is the integration of the project laser_scan_matcher (https://answers.ros.org/question/63457/gmapping-without-odom/ and http://wiki.ros.org/laser_scan_matcher ).  Here, however, the pose must still be converted into an odometry message (see https://answers.ros.org/question/12489/obtaining-nav_msgsodometry-from-a-laser_scan-eg-with-laser_scan_matcher/ ).</p>

<h3 id="nav350-ros-1-slam-example">NAV350 ROS 1 SLAM example</h3>

<p>Build hector_slam and sick_scan_xd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd src
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
git clone https://github.com/tu-darmstadt-ros-pkg/hector_slam.git
cd ..
catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -DCMAKE_ENABLE_EMULATOR=1 -Wno-dev

</code></pre></div></div>

<p>Run rviz, sick_scan_xd with NAV350 and hector_slam:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./devel_isolated/setup.bash
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_slam_nav350.rviz &amp;
roslaunch sick_scan sick_nav_350.launch hostname:=192.168.0.1 tf_publish_rate:=0 &amp;
roslaunch sick_scan test_200_slam_ros1_hector.launch scan_topic:=/scan scan_layer_0_frame_id:=cloud_POS_000_DIST1 cloud_frame_id:=cloud &amp;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  By default, sick_scan_xd publishes transform (TF) messages, which map frame id “map” to the point cloud frame id. To avoid conflicts with hector SLAM, it is recommended to disable these TF messages by commandline parameter <strong><code class="language-plaintext highlighter-rouge">tf_publish_rate:=0</code></strong> or by setting <code class="language-plaintext highlighter-rouge">&lt;param name="tf_publish_rate" type="double" value="0"/&gt;</code> in the launchfile.</p>
</blockquote>

<p>The following rviz screenshot shows an example of a NAV350 pointcloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/slam_example_ros1_nav350.png" alt="slam_example_ros1_nav350.png"></p>

<h3 id="nav350-ros-2-slam-example">NAV350 ROS 2 SLAM example</h3>

<p>Install ths ROS 2 slam-toolbox with <code class="language-plaintext highlighter-rouge">sudo apt install ros-foxy-navigation2 ros-foxy-nav2-bringup ros-foxy-slam-toolbox</code> (replace <code class="language-plaintext highlighter-rouge">foxy</code> by your ros distribution).</p>

<p>Build sick_scan_xd for ROS 2 as described in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#install-on-ros-2">INSTALL ROS 2</a></p>

<p>Run rviz2, sick_scan_xd, slam_toolbox and static transforms:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
ros2 run rviz2 rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_slam_nav350.rviz &amp;
ros2 launch sick_scan sick_nav_350.launch.py hostname:=192.168.0.1 tf_publish_rate:=0 &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 base_link cloud  &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 base_footprint base_link  &amp;
ros2 run tf2_ros static_transform_publisher 0 0 0 0 0 0 odom base_footprint  &amp;
ros2 launch nav2_bringup navigation_launch.py &amp;
ros2 launch slam_toolbox online_async_launch.py &amp;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong> Laserscan messages need to be remapped to topic <code class="language-plaintext highlighter-rouge">/scan</code> (default is <code class="language-plaintext highlighter-rouge">/sick_nav_350/scan</code>). Use <code class="language-plaintext highlighter-rouge">remappings=[ ('/sick_nav_350/scan', '/scan'), ]</code> in the launchfile, e.g.:</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node = Node(
    package='sick_scan',
    executable='sick_generic_caller',
    output='screen',
    remappings=[ ('/sick_nav_350/scan', '/scan'), ], # remap laserscan messages to topic /scan
)

</code></pre></div></div>

<p>The following rviz2 screenshot shows an example of a NAV350 laserscan created by sick_scan_xd and its map generated by slam_toolbox on ROS 2:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/slam_example_ros2_nav350.png" alt="slam_example_ros2_nav350.png"></p>

<h3 id="picoscan100-ros-1-slam-example">picoScan100 ROS 1 SLAM example</h3>

<p>Run rviz, sick_scan_xd with picoScan100 and hector_slam:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./devel_isolated/setup.bash
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_slam_multiscan.rviz &amp;
roslaunch sick_scan sick_nav_350.launch hostname:=192.168.0.1 hostname:=127.0.0.1 udp_receiver_ip:=192.168.0.100 tf_publish_rate:=0 &amp;
roslaunch sick_scan test_200_slam_ros1_hector.launch scan_topic:=/sick_picoscan/scan_fullframe scan_layer_0_frame_id:=world_1 cloud_frame_id:=world &amp;

</code></pre></div></div>
<p>Replace ip address <code class="language-plaintext highlighter-rouge">192.168.0.100</code> with the ip address of your local machine running sick_scan_xd.</p>

<p>The following rviz screenshot shows an example of a picoScan100 point cloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/slam_example_ros1_picoscan.png" alt="slam_example_ros1_picoscan.png"></p>

<h3 id="mrs1104-slam-support">MRS1104 SLAM support</h3>

<p>MRS1104 provides 4 layers covering elevation angles at -2.5°, 0.0°, 2.5° and 5.0°. The layer with 0.0° is used for SLAM by default. The following rviz screenshot shows an example of a MRS1104 point cloud created by sick_scan_xd and its map generated by hector_slam on ROS 1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/slam_example_ros1_mrs1104.png" alt="slam_example_ros1_mrs1104.png"></p>

<p>Since Hector-Slam expects only one laser scan frame with a unique identifier for the laser scans, the following parameters were added to the driver.</p>

<p>slam_echo: The name of the echo is entered here, which is filtered out of all possible 12 echoes. This should be “laser_POS_000_DIST1”. This exports the first hit in the position with an elevation angle of 0°. If you want to use the layers with elevation angles -2.5°, 2.5° and 5.0°, you can set another flag with the name slam_bundle to True. If this flag is set, the oblique distances are multiplied by the cosine in this direction to obtain the projection onto the XY plane. This quadruples the number of points and increases the scan rate from 12.5 Hz to 50 Hz. However, for oblique impact surfaces (i.e. no vertical walls) this method can lead to larger estimation errors. In this case slam_bundle should be set to false.</p>

<h3 id="google-cartographer">Google Cartographer</h3>

<p>The support of Google Cartographer was made possible by a number of extensions to the driver. On the driver side, the MRS1104 is prepared to support the Google Cartographer. The Google Cartographer expects data packets at a high recording density (several hundred packets per second) to perform the SLAM algorithm. For this reason, an option has been introduced that allows the scans to be chopped into small angular ranges. The time stamps for these small ranges were converted accordingly.</p>

<p>Setup Google Cartographer (these steps are for illustration only, you must adapt these lines to your local directory names)</p>

<ol>
  <li>Login to Ubuntu.</li>
  <li>Open multiple terminals.</li>
  <li>Terminal 1:
. ros1_start.sh
roscore</li>
  <li>Terminal 2:
  . ros1_start.sh
cd ~/ros_catkin_ws
source ./devel/setup.bash</li>
  <li>Terminal 3:
roslaunch sick_scan_xd sick_mrs_1xxx_cartographer.launch cloud_topic:=horizontal_laser_3d frame_id:=horizontal_vlp16_link</li>
  <li>Terminal 4:
roslaunch sick_scan_xd sick_tim_5xx.launch cloud_topic:=vertical_laser_3d frame_id:=vertical_vlp16_link hostname:=192.168.0.71</li>
  <li>
    <p>Terminal 5:</p>

    <ul>
      <li>. ros1_start.sh</li>
      <li>cd ~/ros_cartographer_ws</li>
      <li>source ./install_isolated/setup.bash</li>
      <li>catkin_make_isolated</li>
      <li>roslaunch cartographer_ros live_demo_backpack_3d.launch</li>
    </ul>
  </li>
</ol>

<p><strong>Example output</strong></p>

<p>The following figure shows an example of an outdoor slam result using a MRS1104:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/slam_example.png" alt="slam_example"></p>

<h3 id="octomap">OctoMap</h3>

<p><a href="https://github.com/OctoMap">OctoMap</a> models a 3D occupancy map. The octomap_server builds and distributes volumetric 3D occupancy maps from a 3D point cloud. Tutorials and examples can be found e.g. in <a href="https://www.arminhornung.de/Research/pub/hornung13roscon.pdf">3D Mapping with OctoMap</a>, <a href="https://github.com/tejalbarnwal/octomap_tutorial">octomap_tutorial</a> and <a href="https://www.youtube.com/watch?v=dF2mlKJqkUg">Basic usage of octomap_mapping</a>. Note that OctoMap is not a fully SLAM algorithm, but it can create 2D and 3D maps from point clouds.</p>

<p>Run the following steps to build and run OctoMap and sick_scan_xd with a multiScan100 lidar on ROS 1:</p>
<ol>
  <li>Clone OctoMap + sick_scan_xd:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone https://github.com/SICKAG/sick_scan_xd.git
    git clone https://github.com/OctoMap/octomap_ros.git
    git clone https://github.com/OctoMap/octomap_msgs.git
    git clone https://github.com/OctoMap/octomap_mapping.git
    popd
    
</code></pre></div></div>
<ol>
  <li>Set topic and frame_id for multiScan100 in octomap_mapping.launch:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="frame_id" type="string" value="world" /&gt;
    &lt;remap from="cloud_in" to="/cloud_unstructured_fullframe" /&gt;
    
</code></pre></div></div>
<ol>
  <li>Build:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
    
</code></pre></div></div>
<ol>
  <li>Run OctoMap + sick_scan_xd:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Run sick_scan_xd + multiScan100
    roslaunch sick_scan_xd sick_multiscan.launch hostname:="192.168.0.1" udp_receiver_ip:=" 192.168.0.100"
    # Run octomap_server
    roslaunch octomap_server octomap_mapping.launch
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Replace parameter "hostname" with the ip address of the multiScan100 lidar and "udp_receiver_ip" with the ip address of the PC running sick_scan_xd. 5. Visualize OctoMap with rviz:
* Add MarkerArray topic "/occupied_cells_vis_array“ (colored voxels)
* Add Map topic "/projected_map“ (gray 2D Projection) 6. Save the OctoMap:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rosrun octomap_server octomap_saver -f ./octomap_multiscan.bt
    
</code></pre></div></div>
<ol>
  <li>Publish the saved OctoMap:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rosrun octomap_server octomap_server_node ./octomap_multiscan.bt
    
</code></pre></div></div>
<p>The following screenshot shows an example of an octomap created from a multiScan100 point cloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/octomap_example_ros1_multiscan.png" alt="octomap_example_ros1_multiscan"></p>

<h3 id="rtab-map">RTAB-Map</h3>

<p><a href="https://introlab.github.io/rtabmap/">RTAB-Map</a> (Real-Time Appearance-Based Mapping) is a RGB-D, Stereo and Lidar Graph-Based SLAM approach, which can be used for 3D-SLAM in combination with multiScan100 or other SICK lidars. sick_scan_xd provides a 3D-SLAM example using RTAB-Map with the multiScan100 lidar. The following section describes how to install and run RTAB-Map with sick_scan_xd and a multiScan.</p>

<h4 id="install-on-ros-1">Install on ROS 1</h4>

<p>Run the following steps to build rtabmap and sick_scan_xd with on ROS 1:</p>

<ol>
  <li>Build the prerequisites for RTAB-Map:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo apt-get install libboost-all-dev
    sudo apt-get install libeigen3-dev
    sudo apt-get install libsdl-image1.2-dev
    sudo apt-get install libsdl-dev
    sudo apt-get install ros-noetic-nav-msgs
    sudo apt-get install ros-noetic-tf2-sensor-msgs
    sudo apt-get install ros-noetic-imu-filter-madgwick
    sudo apt-get install python3-wstool
    sudo apt-get install ros-noetic-scan-tools
    pushd /tmp
    mkdir -p libnabo/build &amp;&amp; pushd libnabo/build
    cmake ..
    cmake --build .
    sudo cmake --build . --target install
    popd
    mkdir -p libpointmatcher/build &amp;&amp; pushd libpointmatcher/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    mkdir -p rtabmap/build &amp;&amp; pushd rtabmap/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    popd
    
</code></pre></div></div>
<ol>
  <li>Build RTAB-Map and sick_scan_xd in your workspace:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone https://github.com/ros-planning/navigation.git
    git clone https://github.com/ros-planning/navigation_msgs.git
    git clone https://github.com/introlab/rtabmap_ros.git
    git clone https://github.com/SICKAG/sick_scan_xd.git
    popd
    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    catkin_make_isolated --install --cmake-args -DROS_VERSION=1 -Wno-dev
    sudo ldconfig
    
</code></pre></div></div>

<p>Run <code class="language-plaintext highlighter-rouge">sudo ldconfig</code> if you encounter errors while loading shared libraries.</p>

<p>Note that building rtabmap with libpointermatch is highly recommended.</p>

<h4 id="run-rtab-map-and-multiscan100-on-ros-1">Run RTAB-MAP and multiScan100 on ROS 1</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan_rtabmap.launch">sick_multiscan_rtabmap.launch</a> provides a launch file to run 3D-SLAM using rtabmap and sick_scan_xd with a multiScan100 lidar. The SLAM parameters are just examples taken from <a href="https://github.com/introlab/rtabmap_ros/blob/master/rtabmap_examples/launch/test_ouster.launch">rtabmap_examples/launch/test_ouster.launch</a>. Run <code class="language-plaintext highlighter-rouge">rosrun rtabmap_slam rtabmap --params</code> to see all RTAB-Map options, parameters and their meaning and adopt launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan_rtabmap.launch">sick_multiscan_rtabmap.launch</a> if required.</p>

<p>Run the following command to start rtabmap and sick_scan_xd with a multiScan100 lidar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install_isolated/setup.bash
roslaunch sick_scan_xd sick_multiscan_rtabmap.launch hostname:="191.168.0.1" udp_receiver_ip:=" 191.168.0.100"

</code></pre></div></div>
<p>Replace parameter “hostname” with the ip address of the multiScan100 lidar and “udp_receiver_ip” with the ip address of the PC running sick_scan_xd. The following screenshot shows an example of RTAB-MAP and a multiScan100 point cloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/rtabmap_example_ros1_multiscan.png" alt="rtabmap_example_ros1_multiscan"></p>

<p>To visualize SLAM results, add e.g. topics <code class="language-plaintext highlighter-rouge">/rtabmap/grid_map</code>, <code class="language-plaintext highlighter-rouge">/rtabmap/localization_pose</code> and <code class="language-plaintext highlighter-rouge">/rtabmap/odom</code> in rviz.</p>

<p>rtabmap provides services to switch to mapping or localization mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /rtabmap/resume                # resume after pause
rosservice call /rtabmap/trigger_new_map       # start a new map
rosservice call /rtabmap/set_mode_mapping      # set mapping mode
rosservice call /rtabmap/set_mode_localization # set localization mode

</code></pre></div></div>

<p>Alternatively, you can use the options in rtabmap-viz:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/rtabmap_viz_options.png" alt="rtabmap_viz_options"></p>

<h4 id="install-on-ros-2">Install on ROS 2</h4>

<p>Building rtabmap and sick_scan_xd on ROS 2 is similar to ROS 1. Run the following steps to build rtabmap and sick_scan_xd with on ROS 2:</p>

<ol>
  <li>Build the prerequisites for RTAB-Map:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo apt-get install libboost-all-dev
    sudo apt-get install libeigen3-dev
    sudo apt-get install libsdl-image1.2-dev
    sudo apt-get install libsdl1.2-dev
    sudo apt-get install ros-humble-nav-msgs
    sudo apt-get install ros-humble-tf2-sensor-msgs
    sudo apt-get install ros-humble-imu-filter-madgwick
    sudo apt-get install python3-wstool
    sudo apt-get install ros-humble-scan-tools
    sudo apt install ros-humble-pcl-ros
    pushd /tmp
    git clone https://github.com/introlab/rtabmap.git rtabmap
    git clone https://github.com/ethz-asl/libnabo.git libnabo
    git clone https://github.com/ethz-asl/libpointmatcher.git libpointmatcher
    mkdir -p libnabo/build &amp;&amp; pushd libnabo/build
    cmake ..
    cmake --build .
    sudo cmake --build . --target install
    popd
    mkdir -p libpointmatcher/build &amp;&amp; pushd libpointmatcher/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    mkdir -p rtabmap/build &amp;&amp; pushd rtabmap/build
    cmake ..
    make -j4
    sudo make install
    popd
    sudo ldconfig
    popd
    
</code></pre></div></div>
<ol>
  <li>Build RTAB-Map and sick_scan_xd in your workspace:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pushd src
    git clone --branch ros2 https://github.com/introlab/rtabmap_ros.git rtabmap_ros
    git clone https://github.com/SICKAG/sick_scan_xd.git
    popd
    rosdep update &amp;&amp; rosdep install --from-paths src --ignore-src -r -y
    rm -rf ./build ./devel ./install ./build_isolated ./devel_isolated ./install_isolated ./log
    colcon build --symlink-install --cmake-args " -DROS_VERSION=2" " -DCMAKE_ENABLE_EMULATOR=1" "-DCMAKE_BUILD_TYPE=Release" --event-handlers console_direct+
    sudo ldconfig
    
</code></pre></div></div>

<h4 id="run-rtab-map-and-multiscan100-on-ros-2">Run RTAB-MAP and multiScan100 on ROS 2</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan_rtabmap.launch.py">sick_multiscan_rtabmap.launch.py</a> provides a launch file to run 3D-SLAM using rtabmap and sick_scan_xd with a multiScan100 lidar. The SLAM parameters are examples taken from <a href="https://github.com/introlab/rtabmap_ros/blob/master/rtabmap_examples/launch/test_ouster.launch">rtabmap_examples/launch/test_ouster.launch</a>.</p>

<p>Run the following command to start rtabmap and sick_scan_xd with a multiScan100 lidar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ./install/setup.bash
ros2 launch sick_scan_xd sick_multiscan_rtabmap.launch.py hostname:="191.168.0.1" udp_receiver_ip:=" 191.168.0.100"

</code></pre></div></div>
<p>Replace parameter “hostname” with the ip address of the multiScan100 lidar and “udp_receiver_ip” with the ip address of the PC running sick_scan_xd.</p>

<p>rtabmap provides services to switch to mapping or localization mode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /rtabmap/resume std_srvs/srv/Empty                # resume after pause
ros2 service call /rtabmap/trigger_new_map std_srvs/srv/Empty       # start a new map
ros2 service call /rtabmap/set_mode_mapping std_srvs/srv/Empty      # set mapping mode
ros2 service call /rtabmap/set_mode_localization std_srvs/srv/Empty # set localization mode

</code></pre></div></div>

<h2 id="raspberry-pi-support">Raspberry Pi Support</h2>

<p>sick_scan_xd supports Linux on Raspberry Pi 4. Follow the build instructions for Linux to run sick_scan_xd on a Raspberry:</p>
<ul>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-generic-without-ros">Build on Linux generic without ROS</a></li>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-ros-1">Build on Linux ROS 1</a></li>
  <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#build-on-linux-ros-2">Build on Linux ROS 2</a></li>
</ul>

<p>Cmake option “ -DRASPBERRY=1” activates compiler settings for the Raspberry. Laserscan messages and polar pointclouds are not published on the Raspberry due to performance reasons.</p>

<h3 id="multiscan100-example">multiScan100 example</h3>

<p>The following screenshot shows sick_scan_xd running under ROS 1 on a Raspberry Pi 4 connected to a multiScan100 lidar. A Linux-PC uses rviz to display the fullframe point cloud generated on the Raspberry. The ssh-terminal shows the sick_scan_xd log messages on the Raspberry:
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/raspberry-perftest-04.png" alt="screenshot raspberry performance test"></p>

<p>On a Raspberry Pi 4, sick_scan_xd processes 240 messages/second with a mean latency of 2.7 milliseconds/message.</p>

<h3 id="performance">Performance</h3>

<p>Due to the low power consumption of a Raspberry Pi, performance is critical for applications using sick_scan_xd, especially for multiScan100 lidars.</p>

<p>Symptoms for performance problems can be e.g.:</p>
<ul>
  <li>sick_scan_xd reports the loss of UDP packets or message drops</li>
  <li>sick_scan_xd does not publish the fullframe pointcloud</li>
  <li>rviz shows flickering segment pointclouds even with increased decay time</li>
  <li>low frequency of segment or fullframe pointcloud messages</li>
  <li>generally high system load</li>
</ul>

<p>Performance problems can have very different reasons. Notes to help with the elimination of performance issues:</p>

<ol>
  <li>
    <p>Use the latest Raspberry Pi 4. Previous Raspberry Pi models may work with sick_scan_xd, but are not supported officially.</p>
  </li>
  <li>
    <p>Eliminate multiple echos. For most lidars, the echo filter is activated by default and only the last echo is transmitted. Check the launch file configuration and set parameter <code class="language-plaintext highlighter-rouge">filter_echos</code> if not yet done:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="filter_echos" type="int" value="2"/&gt; &lt;!-- FREchoFilter settings: 0: first echo, 1: all echos, 2: last echo --&gt;
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For multican lidars, the echo filter is activated in the launch file by parameter `host_FREchoFilter`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;param name="host_FREchoFilter" type="int" value="2" /&gt;          &lt;!-- Optionally set FREchoFilter with 0 for FIRST_ECHO (default, EchoCount=1), 1 for ALL_ECHOS (EchoCount=3), or 2 for LAST_ECHO (EchoCount=1) --&gt;
    &lt;param name="host_set_FREchoFilter" type="bool" value="True" /&gt;  &lt;!-- If true, FREchoFilter is set at startup (default: false) --&gt;
    
</code></pre></div></div>

<ol>
  <li>Run a basic performance test on ROS 2 using a tiny sopas test server and a udp player to emulate a multiscan:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    # Start multiScan100 emulator (sopas test server)
    python3 ./src/sick_scan_xd/test/python/multiscan_sopas_test_server.py --tcp_port=2111 --cola_binary=0 &amp;
    # Start rviz
    ros2 run rviz2 rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_cfg_multiscan_emu_360_perftest.rviz &amp;
    sleep 1
    # Start sick_generic_caller with sick_scansegment_xd
    ros2 launch sick_scan sick_multiscan.launch.py hostname:=127.0.0.1 udp_receiver_ip:="127.0.0.1" &amp;
    sleep 3
    # Play udp packets to emulate multiScan
    python3 ./src/sick_scan_xd/test/python/multiscan_perftest_player.py --udp_port=2115 --repeat=100 --send_rate=100 --verbose=0 --prompt=0
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The result should look like the follwing screenshot:
![screenshot raspberry performance test](doc/screenshots/raspberry-perftest-01.png)
If you otherwise observe the loss of UDP packets, message drops, missing pointclouds or mean latency times significantly higher than 6 milliseconds/message, check the system load of your Raspberry and try to eliminate cpu or network intensive processes.
</code></pre></div></div>

<ol>
  <li>Start sick_scan and the sopas test server on the Raspberry as above, but run the udp player <code class="language-plaintext highlighter-rouge">multiscan_perftest_player.py</code> on another PC in your local subnet, e.g.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    python3 multiscan_perftest_player.py --dst_ip=192.168.1.27 --udp_port=2115 --repeat=1000 --send_rate=0 --force_delay=3.0e-3 --verbose=0 --prompt=0
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Replace the example ip adress `192.168.1.27` by the ip adress of your Raspberry. The result should look like the follwing screenshot:
![screenshot raspberry performance test](doc/screenshots/raspberry-perftest-02.png)
If you otherwise observe the loss of UDP packets, message drops, missing pointclouds or mean latency times significantly higher than 6 milliseconds/message, check the system load of your Raspberry and try to eliminate cpu or network intensive processes. sick_scan_xd (i.e. process sick_generic_caller) should consume ca. 80% of one core resp. cause ca. 20% of the total cpu load.
</code></pre></div></div>

<h3 id="troubleshooting">Troubleshooting</h3>

<h4 id="endianess">Endianess</h4>

<p>ARM processors support both little and big endian mode. sick_scan_xd has been tested on Raspberry Pi 4 using ROS 1 and ROS 2 on Linux in little endian mode. You can check the endianess of your system with <code class="language-plaintext highlighter-rouge">lscpu</code>.</p>

<h4 id="build-sick_scan_xd-on-a-raspberry-without-internet-or-github-access">Build sick_scan_xd on a Raspberry without internet or github access</h4>

<p>Checkout sick_scan_xd and use <code class="language-plaintext highlighter-rouge">scp -rp</code> to copy files and directories recursively from local host to a Raspberry, e.g.:</p>

<p>On your local Linux PC (Raspberry IP-address is 192.168.178.52 in this example):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p ./sick_scan_xd_raspberry_pi_pretest/src
pushd ./sick_scan_xd_raspberry_pi_pretest/src
git clone https://github.com/SICKAG/libsick_ldmrs.git
git clone -b master https://github.com/SICKAG/sick_scan_xd.git
popd
scp -rp ./sick_scan_xd_raspberry_pi_pretest 192.168.178.52:/home/rostest/sick_scan_xd_raspberry_pi_pretest

</code></pre></div></div>

<p>On your Raspberry Pi (ROS 1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /home/rostest/sick_scan_xd_raspberry_pi_pretest
pushd ./src/sick_scan_xd/test/scripts
chmod a+x ./*.bash
./makeall_ros1.bash
popd
source ./devel_isolated/setup.bash

</code></pre></div></div>

<p>To view the pointcloud on your local Linux PC (with Raspberry IP-address is 192.168.178.52 in this example):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export ROS_MASTER_URI=http://192.168.178.52:11311/
rviz

</code></pre></div></div>

<h2 id="more-tools">More Tools</h2>

<p>Various tools exist in the repository to improve the operation of the scanners. It is also recommended to read the section <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#Troubleshooting">Troubleshooting</a>.
Overview of the tools:</p>

<ul>
  <li>Search for scanner in the network:
Use the Python3 tool “sick_generic_device_finder.py” in the tools/sick_generic_device_finder directory.
The tools will output the IP addresses of the connected scanners and some more information about the scanner.
Call it with python3, i.e.
<code class="language-plaintext highlighter-rouge">
python3 sick_generic_device_finder.py
</code>
</li>
  <li>Setting new IP address: With the help of the parameter “new_IP” a new IP address can be assigned when calling the node sick_scan_xd.
The launch file sick_new_ip.launch in the launch directory shows an example of how to use this parameter.</li>
  <li>Converting of pointclouds to images: With the tool pcl_converter.cpp one can convert pointcloud2-data
to image. That is especial convenient for 24-layers scanners like the MRS6124.</li>
  <li>Setting up a brand new scanner: To set up a brand new scanner,
it is recommended to use the two tools “sick_generic_device_finder.py” to find the scanner in the network
and the launch file sick_new_ip.launch to set a new IP address. If further settings are to be saved that cannot be made via ROS   parameters, we recommend using the Windows tool “Sopas ET” from SICK.</li>
  <li>Unit tests: For a quick unit test after installation without the sensor hardware, a test server is provided to simulate a scanner. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CONTRIBUTING.md">Simulation</a> for further details.</li>
  <li>Testing: The sick_scan_test program was developed for testing the driver. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/./CONTRIBUTING.md">Testing</a> for details.</li>
</ul>

<h1 id="device-specific-information">Device specific information</h1>

<h2 id="picoscan100multiscan100">picoScan100/multiScan100</h2>

<p>The multiScan100 and picoScan100 are new lidars from Sick. multiScan100 has a total of 16 lidar units rotating around a vertical axis. The rotation speed is 20 rounds per second.</p>

<p>Scan data are transmitted in msgpack or compact format over UDP.</p>

<p>multiScan100/picoScan100 lidars are supported by sick_scan_xd.
The following describes the configuration, validation and test in more detail.</p>

<h3 id="configuration">Configuration</h3>

<p>multiScan100 is configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan.launch">sick_multiscan.launch</a>.
picoScan100 is configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_picoscan.launch">sick_picoscan.launch</a>.</p>

<p>Modify file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan.launch">sick_multiscan.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_picoscan.launch">sick_picoscan.launch</a> to change configuration. Note that the ip address of the udp receiver <strong>must</strong> be configured on each system. This is the ip address of the computer running sick_scan_xd.</p>

<p>The ip address of the lidar and the udp receiver can be configured in the launch file by e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;arg name="hostname" default="192.168.0.1"/&gt;
&lt;arg name="udp_receiver_ip" default="192.168.0.100"/&gt;

</code></pre></div></div>
<p>or by command line by e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Run sick_scansegment_xd generic without ROS:
sick_generic_caller ./launch/sick_multiscan.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100
# Run sick_scansegment_xd on ROS 1:
roslaunch sick_scan_xd sick_multiscan.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100
# Run sick_scansegment_xd on ROS 2:
ros2 launch sick_scan_xd sick_multiscan.launch.py hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100

</code></pre></div></div>

<h3 id="imu-support-1">IMU support</h3>

<p>IMU support for multiScan100 and picoScan100 is enabled by default and can be configured in the launchfile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="imu_enable" type="bool" value="True"/&gt;  &lt;!-- Enable inertial measurement unit IMU, compact format only --&gt;
&lt;param name="imu_udp_port" type="int" value="7503"/&gt; &lt;!-- udp port for multiScan100 imu data (if imu_enable is true) --&gt;
&lt;param name="imu_topic" type="string" value="imu"/&gt;  &lt;!-- topic of ros IMU messages --&gt;

</code></pre></div></div>

<p>sick_scan_xd receives IMU data by UDP and publishes <a href="https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/Imu.html">ROS 1 sensor_msgs/Imu</a> resp. <a href="https://docs.ros2.org/latest/api/sensor_msgs/msg/Imu.html">ROS 2 sensor_msgs/msg/Imu</a> messages.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong> IMU support requires compact format, which is the default. If msgpack communication is configured, imu support is automatically disabled.</p>
</blockquote>

<p>IMU support for picoScan100 requires firmware version 1.1 or newer, see https://www.sick.com/de/en/downloads/media/swp680096 for firmware downloads.</p>

<h3 id="sopas-support">SOPAS support</h3>

<p>On ROS 1 and ROS 2, service <code class="language-plaintext highlighter-rouge">ColaMsg</code> is provided to send CoLa commands to the lidar. Using this service, filters can be applied during runtime.</p>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#sopas-support-for-sick_scan_segment_xd">See</a> here for examples.</p>

<p>See the manual for further information of filter settings and parameter.</p>

<p>The driver sends the following SOPAS start and stop sequence at program start resp. exit (example with default ip address 192.168.0.1):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Prerequirement: measurement is active, but no UDP data is sent
// Start sending scan data output
sMN SetAccessMode 3 F4724744  // set authorization level for writing settings
sWN ScanDataEthSettings 1 +192 +168 +0 +1 +2115  // configure destination scan data output destination to 192.168.0.52 port 2115
sWN ScanDataFormat 1   // set scan data output format to MSGPACK
sWN ScanDataPreformatting 1 // for multiscan136 only
sWN ScanDataEnable 1   // enable scan data ouput
sMN LMCstartmeas       // start measurement
sMN Run                // apply the settings and logout
// ...
// UDP data is sent
// ...
// Stop sending scan data output
sMN SetAccessMode   3 F4724744   // set authorization level for writing settings
sWN ScanDataEnable 0   // disable scan data output
sMN Run   // apply the settings and logout
// No UDP data is sent anymore

</code></pre></div></div>

<h3 id="run-multiscan100-and-picoscan100-simultaneously">Run multiScan100 and picoScan100 simultaneously</h3>

<p>The following example shows a multiScan100 and a picoScan100 device running simultaneously on ROS 1. The ip address of the multiScan100 is <code class="language-plaintext highlighter-rouge">192.168.0.1</code> (default), the ip address of the picoScan100 has been set to <code class="language-plaintext highlighter-rouge">192.168.0.2</code>. The Linux-PC running sick_scan_xd uses ip address <code class="language-plaintext highlighter-rouge">192.168.0.100</code>. <code class="language-plaintext highlighter-rouge">fping -a -q -g 192.168.0.0/24</code> shows all available devices in subnet <code class="language-plaintext highlighter-rouge">192.168.0.x</code>:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_01.png" alt="multiple_lidars_01.png"></p>

<table>
  <thead>
    <tr>
      <th>device</th>
      <th>ip</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>192.168.0.1</td>
      <td>multiScan100</td>
    </tr>
    <tr>
      <td>192.168.0.2</td>
      <td>picoScan100</td>
    </tr>
    <tr>
      <td>192.168.0.100</td>
      <td>Linux-PC</td>
    </tr>
  </tbody>
</table>

<p>Open 192.168.0.1 and 192.168.0.2 in a browser to view the network settings with SOPAS Air:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_02.png" alt="multiple_lidars_02.png"></p>

<p>The frame ids and ros topics of both lidars should be configured differently. Copy both launchfiles (sick_multiscan.launch and sick_piocscan.launch in this example) e.g. to lidar1.launch and lidar2.launch and replace ros topics and frame ids, e.g.
    * replace all “topic=/cloud_” by “topic=/cloud1<em>” in lidar1.launch
    * replace all “topic=/cloud</em>” by “topic=/cloud2_” in lidar2.launch
    * replace all “frameid=world” by “frameid=world1” in lidar1.launch
    * replace all “frameid=world” by “frameid=world2” in lidar2.launch</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_03.png" alt="multiple_lidars_03.png"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_04.png" alt="multiple_lidars_04.png"></p>

<p>Provide the launchfiles with <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1</code>.</p>

<p>Then launch sick_scan_xd twice with two different launchfiles, ip addresses, node names, udp ports, topic and frame ids.</p>

<p>Example:</p>

<p>`
roslaunch sick_scan_xd lidar1.launch hostname:=192.168.0.1 udp_receiver_ip:=192.168.0.100 nodename:=lidar1 udp_port:=2115 imu_udp_port:=7503 publish_frame_id:=world1 publish_laserscan_segment_topic:=scan1_segment publish_laserscan_fullframe_topic:=scan1_fullframe imu_topic:=imu1 &amp;
`</p>

<p>`
roslaunch sick_scan_xd lidar2.launch hostname:=192.168.0.2 udp_receiver_ip:=192.168.0.100 nodename:=lidar2 udp_port:=2116 imu_udp_port:=7504 publish_frame_id:=world2 publish_laserscan_segment_topic:=scan2_segment publish_laserscan_fullframe_topic:=scan2_fullframe imu_topic:=imu2 &amp;
`</p>

<p>Rviz shows the point clouds of both lidars running simultaneously, with frame id <code class="language-plaintext highlighter-rouge">world1</code> for lidar1 (multiScan) and frame id <code class="language-plaintext highlighter-rouge">world2</code> for lidar2 (picoScan):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_05.png" alt="multiple_lidars_05.png"></p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_06.png" alt="multiple_lidars_06.png"></p>

<p>If the 6D poses of the lidars are known, their coordinates can be transformed to a common frame by a static_transform_publisher. Example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun tf static_transform_publisher 0 0 0 0 0 0 world world1 100 &amp;
rosrun tf static_transform_publisher 0 0 0 0 0 0 world world2 100 &amp;

</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/multiple_lidars_07.png" alt="multiple_lidars_07.png"></p>

<p>The big purple dots show the picoScan100 pointcloud, the other points are the multiScan100 point clouds. Both are transformed to the common frame id <code class="language-plaintext highlighter-rouge">world</code>. Note that both point clouds do not match exactly, because the 6D poses are just assumed to be (x=0, y=0, z=0, yaw=0, pitch=0, roll=0) in this example.</p>

<h3 id="visualization">Visualization</h3>

<p>The multiScan100 and picoScan100 scans can be visualized by rviz. The following screenshots show two examples of a multiScan100 pointcloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/20210929-tokenized-msgpacks-emulator-rviz.png" alt="msgpacks-emulator-rviz">
<img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/20210929-tokenized-msgpacks-multiScan-rviz.png" alt="msgpacks-emulator-rviz"></p>

<p>Note that sick_scan_xd publishes 2 pointclouds:</p>
<ul>
  <li>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud</code> is published for each scan segment.</li>
  <li>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_fullframe</code> collects all segments for a complete 360 degree full scan (360 degree for multiScan100, 276 degree for picoscan100).</li>
</ul>

<p>Pointcloud callbacks defined in the <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#generic-driver-api">API</a> are called the same way: A callback registered with SickScanApiRegisterPolarPointCloudMsg is called</p>
<ul>
  <li>with a segment_idx &gt;= 0 for each scan segment, and</li>
  <li>with segment_idx := -1 for the complete 360 degree full scan.</li>
</ul>

<h3 id="pointcloud-memory-layout">PointCloud memory layout</h3>

<p>The Multiscan136 scans with 12 segments and 16 layer. For test, development and debugging, knowledge the internal memory layout of the pointclouds can be helpful.</p>

<p>The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_unstructured_segments</code> (topic <code class="language-plaintext highlighter-rouge">/cloud</code> for sick_scan_xd version 2.10 or earlier) is published for each scan segment. Each pointcloud concatenates the layer of that segment. Each layer concatenates the points of that layer and segment. Each point concatenates the cartesian position (x, y, z) and the intensity i of a scan point. Each value of a point (x, y, z, i) is represented by a 4 byte float value. The pointcloud on topic <code class="language-plaintext highlighter-rouge">/cloud_unstructured_fullframe</code> (topic <code class="language-plaintext highlighter-rouge">/cloud_fullframe</code> for sick_scan_xd version 2.10 or earlier) collects all segments of a complete 360 degree full scan. Therefore, a total of 13 cartesian pointclouds are published for a 360 degree full scan:</p>

<ul>
  <li>
    <p>12 segment pointclouds. Each segment pointcloud concatenates the points of each layer in this segment in a flat memory layout:<br>
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_segment_xd_01.png" alt="sick_scan_segment_xd_01.png"></p>
  </li>
  <li>
    <p>1 full scan pointcloud concatenating all 12 segments:<br>
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/sick_scan_segment_xd_02.png" alt="sick_scan_segment_xd_02.png"></p>
  </li>
</ul>

<p>Note that segments and layer are not sorted in ascending order. They are published in the same order as they are received from the lidar.</p>

<h3 id="customized-point-clouds">Customized point clouds</h3>

<p>Pointclouds can be customized, i.e. the fields and points can be configured by launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan.launch">sick_multiscan.launch</a>.</p>

<p>Parameter “custom_pointclouds” lists all customized pointclouds to be published. Each pointcloud is given by its name, e.g:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="custom_pointclouds" type="string" value="cloud_unstructured_segments cloud_unstructured_fullframe cloud_polar_unstructured_segments cloud_polar_unstructured_fullframe cloud_all_fields_fullframe"/&gt;

</code></pre></div></div>
<p>This example publishes 5 types of pointclouds:</p>
<ul>
  <li>Pointcloud for each segment in cartesian coordinates (x,y,z,i), named “cloud_unstructured_segments”</li>
  <li>Pointcloud for each fullframe in cartesian coordinates (x,y,z,i), named “cloud_unstructured_fullframe”</li>
  <li>Pointcloud for each segment in polar coordinates (azimuth,elevation,range,i), named “cloud_polar_unstructured_segments”</li>
  <li>Pointcloud for each fullframe in polar coordinates (azimuth,elevation,range,i), named “cloud_polar_unstructured_fullframe”</li>
  <li>Pointcloud for each fullframe with all available fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), named “cloud_all_fields_fullframe”</li>
</ul>

<p>These 5 pointclouds are published by default.</p>

<p>The properties of the pointcloud, i.e. their fields and points, are configured by the pointcloud name, e.g. pointcloud “cloud_unstructured_segments” (i.e. the segment pointcloud in cartesian coordinates):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_unstructured_segments: cartesian coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_unstructured_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_segments frameid=world publish=1"/&gt;

</code></pre></div></div>
<p>The cloud property configuration is a list of key-value-pairs, where each key-value-pair specifies a property and its value. E.g. <code class="language-plaintext highlighter-rouge">topic=/cloud_unstructured_segments frameid=world</code> defines ros topic “/cloud_unstructured_segments” and frame id “world” for the pointcloud named “cloud_unstructured_segments”.</p>

<p>The following key-value-pairs of a customized pointcloud are currently supported:</p>

<ul>
  <li>Parameter “coordinateNotation” is an enum to configure pointcloud coordinates:
    <ul>
      <li>coordinateNotation=0: cartesian (default, pointcloud has fields x,y,z,i), identical to customized with fields=x,y,z,i</li>
      <li>coordinateNotation=1: polar (pointcloud has fields azimuth,elevation,r,i), identical to customized with fields=azimuth,elevation,range,i</li>
      <li>coordinateNotation=2: both cartesian and polar (pointcloud has fields x,y,z,azimuth,elevation,r,i), identical to customized with fields=x,y,z,azimuth,elevation,range,i</li>
      <li>coordinateNotation=3: customized pointcloud fields, i.e. the pointcloud has fields configured by parameter “fields”</li>
    </ul>
  </li>
  <li>Parameter “updateMethod” is an enum to configure fullframe pointclouds versus segmented pointcloud:
    <ul>
      <li>updateMethod=0: fullframe pointcloud (default)</li>
      <li>updateMethod=1: segmented pointcloud</li>
    </ul>
  </li>
  <li>Parameter “fields” defines the fields of the pointcloud for coordinateNotation == 3 (customized pointcloud fields), e.g.
    <ul>
      <li>fields=x,y,z,i: cartesian pointcloud</li>
      <li>fields=range,azimuth,elevation: polar pointcloud</li>
      <li>or any other combination of x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector</li>
    </ul>

    <p>These fields have the following meaning:</p>
    <ul>
      <li>field “x”: cartesian x coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “y”: cartesian y coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “z”: cartesian z coordinate in meter in ROS coordinates (4 byte, float32)</li>
      <li>field “i”: intensity  (4 byte, float32)</li>
      <li>field “range”: polar coordinate range in meter (4 byte, float32)</li>
      <li>field “azimuth”: polar coordinate azimuth in radians  (4 byte, float32)</li>
      <li>field “elevation”: polar coordinate elevation in radians  (4 byte, float32)</li>
      <li>field “t”:  time offset in nano seconds relative to the header timestamp in the point cloud (4 byte, uint32), used by rtabmap for deskewing</li>
      <li>field “ts”: time offset in seconds relative to the header timestamp (4 byte, float32)</li>
      <li>field “lidar_sec”: uint32 seconds part of the lidar timestamp in microseconds (lidar time), lidar_sec = (uint32_t)(lidar_timestamp_microsec / 1000000)</li>
      <li>field “lidar_nsec”: uint32nano seconds part of the lidar timestamp in microseconds (lidar time), lidar_nsec = (uint32_t)(1000 * (lidar_timestamp_microsec % 1000000))</li>
      <li>field “ring”:  layer id (1 byte, int8), identical to field “layer”</li>
      <li>field “layer”: layer (group) index (4 byte, int32), 0 &lt;= layer &lt; 16 for multiScan100 (16 layer), 0 for picoScan100 (1 layer)</li>
      <li>field “echo”: echo index (4 byte, int32)</li>
      <li>field “reflector”: optional reflector bit (1 byte, uint8), 0 or 1, default: 0</li>
    </ul>
  </li>
  <li>Parameter “echos” defines which echos are included in the pointcloud, e.g.
    <ul>
      <li>echos=0,1,2: all echos</li>
      <li>echos=2: last echo
 or any other combination of 0,1,2</li>
    </ul>
  </li>
  <li>Parameter “layers” defines which echos are included in the pointcloud, e.g
    <ul>
      <li>layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 for all layers</li>
      <li>layers=5 for the 0 degree layer
 or any other combination of 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</li>
    </ul>
  </li>
  <li>Parameter “reflectors” filters the points by the reflector bit, i.e.
    <ul>
      <li>reflectors=0,1 for points with reflector bit set or not set</li>
      <li>reflectors=0 for points with reflector bit not set</li>
      <li>reflectors=1 for points with reflector bit set</li>
    </ul>
  </li>
  <li>Parameter “infringed” defines filters the points by infringement, i.e.
    <ul>
      <li>infringed=0,1 for points with infringement bit set or not set</li>
      <li>infringed=0 for points with infringement bit not set</li>
      <li>infringed=1 for points with infringement bit set
 Parameter “infringed” is currently not supported (reserved for future use)</li>
    </ul>
  </li>
  <li>
    <p>Parameter “topic” defines the ros topic, e.g. topic=/cloud_fullframe for cartesian fullframe pointclouds</p>
  </li>
  <li>
    <p>Parameter “frameid” defines the ros frame of the pointcloud, e.g. frameid=world, frameid=map or frameid=base_link</p>
  </li>
  <li>Parameter “publish” activates or deactivates the pointcloud, e.g. publish=1 to generate and publish, or publish=0 to deactivate that pointcloud</li>
</ul>

<p>To add a new pointcloud, define a pointcloud name (e.g. “cloud_layer7_cartesian”), add “cloud_layer7_cartesian” in parameter “custom_pointclouds” and specify a new parameter “cloud_layer7_cartesian” with the new cloud properties, e.g.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_layer7_cartesian: cartesian coordinates, fullframe, first echo, layer7 --&gt;
&lt;param name="cloud_layer7_cartesian" type="string" value="coordinateNotation=0 updateMethod=0 echos=0 layers=7 reflectors=0,1 infringed=0,1 topic=/cloud_layer7_cartesian frameid=world publish=1"/&gt;

</code></pre></div></div>

<p>The following pointclouds are currently predefined in launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan.launch">sick_multiscan.launch</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- cloud_unstructured_segments: cartesian coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_unstructured_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_fullframe: cartesian coordinates, fullframe, all echos, all layers, max. 32400 points, mean ca. 10000 points per cloud --&gt;
&lt;param name="cloud_unstructured_fullframe" type="string" value="coordinateNotation=0 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_fullframe frameid=world publish=1"/&gt;

&lt;!-- cloud_polar_unstructured_segments: polar coordinates, segmented, all echos, all layers, max. 2700 points, mean ca. 1000 points per cloud --&gt;
&lt;param name="cloud_polar_unstructured_segments" type="string" value="coordinateNotation=1 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_polar_unstructured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_polar_unstructured_fullframe: polar coordinates, fullframe, all echos, all layers --&gt;
&lt;param name="cloud_polar_unstructured_fullframe" type="string" value="coordinateNotation=1 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_polar_unstructured_fullframe frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo1: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo1" type="string" value="coordinateNotation=0 updateMethod=0 echos=0 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo1 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo1_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo1_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo1_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo2: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo2" type="string" value="coordinateNotation=0 updateMethod=0 echos=1 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo2 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo2_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo2_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=1 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo2_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo3: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo3" type="string" value="coordinateNotation=0 updateMethod=0 echos=2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_unstructured_echo3 frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_echo3_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_echo3_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_echo3_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_reflector: cartesian coordinates, fullframe, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_reflector" type="string" value="coordinateNotation=0 updateMethod=0 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_reflector frameid=world publish=1"/&gt;

&lt;!-- cloud_unstructured_reflector_segments: cartesian coordinates, segmented, first echo, all layers --&gt;
&lt;param name="cloud_unstructured_reflector_segments" type="string" value="coordinateNotation=0 updateMethod=1 echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=1 infringed=0,1 topic=/cloud_unstructured_reflector_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires0: cartesian and polar coordinates, fullframe, all echos, high resolution layer 5, fields=x,y,z,i,range,azimuth,elevation, 12*2880x3=103680 points per cloud --&gt;
&lt;param name="cloud_structured_hires0" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=5 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires0 frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires0_segments: cartesian and polar coordinates, segments, all echos, high resolution layer 5, fields=x,y,z,i,range,azimuth,elevation, 2880x3=8640 points per cloud --&gt;
&lt;param name="cloud_structured_hires0_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=5 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires0_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires1: cartesian and polar coordinates, fullframe, all echos, high resolution layer 13, fields=x,y,z,i,range,azimuth,elevation, 12*2880x3=103680 points per cloud --&gt;
&lt;param name="cloud_structured_hires1" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=13 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires1 frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_hires1_segments: cartesian and polar coordinates, segments, all echos, high resolution layer 13, fields=x,y,z,i,range,azimuth,elevation, 2880x3=8640 points per cloud --&gt;
&lt;param name="cloud_structured_hires1_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=13 reflectors=0,1 infringed=0,1 topic=/cloud_structured_hires1_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_structured: cartesian and polar coordinates, fullframe, all echos, low resolution layers 0,1,2,3,4,6,7,8,9,10,11,12,14,15, fields=x,y,z,i,range,azimuth,elevation, 12*360*14*3=181440 points per cloud --&gt;
&lt;param name="cloud_structured" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=0,1,2,3,4,6,7,8,9,10,11,12,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_structured frameid=world publish=1"/&gt;

&lt;!-- cloud_structured_segments: cartesian and polar coordinates, segments, all echos, low resolution layers 0,1,2,3,4,6,7,8,9,10,11,12,14,15, fields=x,y,z,i,range,azimuth,elevation, 360*14*3=15120 points per cloud --&gt;
&lt;param name="cloud_structured_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation echos=0,1,2 layers=0,1,2,3,4,6,7,8,9,10,11,12,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_structured_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_all_fields_segments: all fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), segments, all echos, all layers --&gt;
&lt;param name="cloud_all_fields_segments" type="string" value="coordinateNotation=3 updateMethod=1 fields=x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_all_fields_segments frameid=world publish=1"/&gt;

&lt;!-- cloud_all_fields_fullframe: all fields (x,y,z,i,range,azimuth,elevation,layer,echo,reflector), fullframe, all echos, all layers --&gt;
&lt;param name="cloud_all_fields_fullframe" type="string" value="coordinateNotation=3 updateMethod=0 fields=x,y,z,i,range,azimuth,elevation,t,ts,lidar_sec,lidar_nsec,ring,layer,echo,reflector echos=0,1,2 layers=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 reflectors=0,1 infringed=0,1 topic=/cloud_all_fields_fullframe frameid=world publish=1"/&gt;

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  The sick_scan_xd API callback functions <code class="language-plaintext highlighter-rouge">SickScanApiRegisterCartesianPointCloudMsg</code> and <code class="language-plaintext highlighter-rouge">SickScanApiRegisterPolarPointCloudMsg</code> provide cartesian and polar pointclouds, i.e. pointclouds configured with <code class="language-plaintext highlighter-rouge">coordinateNotation=0</code> (cartesian) or <code class="language-plaintext highlighter-rouge">coordinateNotation=1</code> (polar). Pointclouds with <code class="language-plaintext highlighter-rouge">coordinateNotation=2</code> (cartesian + polar) or <code class="language-plaintext highlighter-rouge">coordinateNotation=3</code> (customized fields) are currently not supported by the generic API.</p>
</blockquote>

<h3 id="customized-point-clouds-on-a-raspberry-pi">Customized point clouds on a Raspberry Pi</h3>

<p>Performance is critical on a Raspberry. To reduce the cpu load, you may restrict the number of pointclouds to the minimum required for your application. E.g. if you just need the cartesian fullframe pointcloud, you can use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="custom_pointclouds" type="string" value="cloud_unstructured_fullframe"/&gt;

</code></pre></div></div>
<p>to decrease the cpu usage.</p>

<h3 id="msgpack-validation">MSGPACK validation</h3>

<p>A msgpack validation can be activated. This validation checks</p>
<ol>
  <li>each incoming msgpack for scan data out of the expected values, and</li>
  <li>missing scandata after collecting the msgpack data for a full scan (360 degree for multiScan100, 276 degree for picoScan100)</li>
</ol>

<p>If a msgpack contains scan data out of expected values, the msgpack is discarded and an error message is printed. This should not happen in normal operation mode. If scan data are missing after a full 360 degree scan, an error message is printed. This might happen in case of udp packet drops.</p>

<p>By default, the full range of scan data is expected, i.e. all echos, all segments, all layers and azimuth values covering -180 up to +180 degree. If filters are activated (echo-, layer- or angle-range-filter to reduce network traffic), the msgpack validation should currently be deactivated or configured thoroughly to avoid error messages. In the next release, the filter configuration is queried from  multiScan136 Beta and validation settings are adopted to the multiScan136 Beta filter settings.</p>

<p>The msgpack validation is configured in file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_multiscan.launch">sick_multiscan.launch</a> resp. <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_picoscan.launch">sick_picoscan.launch</a>. To activate or deactivate msgpack validation, set <code class="language-plaintext highlighter-rouge">msgpack_validator_enabled</code> to True (activated) resp. False (deactivated).</p>

<p>Msgpack validation leads to error messages in case of udp packet drops. Increase the value <code class="language-plaintext highlighter-rouge">msgpack_validator_check_missing_scandata_interval</code> to tolerate udp packet drops. Higher values increase the number of msgpacks collected for verification.</p>

<h3 id="firewall-configuration">Firewall configuration</h3>

<p>By default, UDP communication is allowed on localhosts. To enable udp communication between 2 different machines, firewalls have to be configured.</p>

<p>On Windows: Setup the windows firewall to allow sick_scan_xd to receive udp packages on port 2115.
To pass udp packages from a remote sender, the default rule for incoming udp packages has to be configured in the windows firewall:</p>
<ol>
  <li>Run “wf.msc” as admin,</li>
  <li>Click Inbound Rules and locate the rule(s) for lidar3d_msr100_recv (resp. python to allow python test scripts), and</li>
  <li>Deactivate the UDP-rule for this process(es) or configure exceptions for remote computers.</li>
  <li>Alternatively, you can create a new rule allowing udp communication on port 2115.</li>
</ol>

<p>On Linux: Run the following commands to allow any udp communication on port 2115:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo iptables -A INPUT -p udp -m udp --dport 2115 -j ACCEPT
sudo iptables -A OUTPUT -p udp -m udp --sport 2115 -j ACCEPT
sudo iptables-save

</code></pre></div></div>
<p>Alternatively, you can also use</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ufw allow from any to any port 2115 proto udp

</code></pre></div></div>
<p>to allow all udp traffic on port 2115.</p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  If Linux or Windows is running in a virtual machine, make sure UDP port 2115 is forwarded. With VMware Workstation Pro, you can configure port forwarding
using the Virtual Network Editor. Udp echos, delays, drops and other unexpected errors might occur when more than one network card is configured in VMware.
Make sure you have only one network adapter activated with custom NAT:</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/vmware_network_settings.png" alt="vmware_network_settings"></p>

<h3 id="sopas-support-for-sick_scan_segment_xd">SOPAS support for sick_scan_segment_xd</h3>

<p>On ROS 1 and ROS 2, sick_scan_segment_xd provides ros service <code class="language-plaintext highlighter-rouge">ColaMsg</code> to send CoLa commands to the lidar. Using this service, filters can be applied to multiScan136 and picoScan150 lidars during runtime.</p>

<p>Examples on ROS 1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice list
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN IsSystemReady'}"                             # response: "sAN IsSystemReady 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"                  # response: "sAN SetAccessMode 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataEthSettings 1 +127 +0 +0 +1 +2115'}" # response: "sWA ScanDataEthSettings"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataFormat 1'}"                          # response: "sWA ScanDataFormat"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataPreformatting 1'}"                   # response: "sWA ScanDataPreformatting"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN ScanDataEnable 1'}"                          # response: "sWA ScanDataEnable"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN LMCstartmeas'}"                              # response: "sAN LMCstartmeas"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN Run'}"                                       # response: "sAN Run 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN SetAccessMode 3 F4724744'}"                                    # response: "sAN SetAccessMode 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN FREchoFilter 1'}"                                              # response: "sWA FREchoFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1'}" # response: "sWA LFPangleRangeFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sWN LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'}"            # response: "sWA LFPlayerFilter"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sMN Run'}"                                                         # response: "sAN Run 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
rosservice call /sick_scansegment_xd/ColaMsg "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LFPlayerFilter is not supported by picoscan150.</p>
</blockquote>

<p>Examples on ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service list
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN IsSystemReady'}"                             # response: "sAN IsSystemReady 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN SetAccessMode 3 F4724744'}"                  # response: "sAN SetAccessMode 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataEthSettings 1 +127 +0 +0 +1 +2115'}" # response: "sWA ScanDataEthSettings"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataFormat 1'}"                          # response: "sWA ScanDataFormat"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataPreformatting 1'}"                   # response: "sWA ScanDataPreformatting"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN ScanDataEnable 1'}"                          # response: "sWA ScanDataEnable"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN LMCstartmeas'}"                              # response: "sAN LMCstartmeas"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN Run'}"                                       # response: "sAN Run 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN SetAccessMode 3 F4724744'}"                                    # response: "sAN SetAccessMode 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN FREchoFilter 1'}"                                              # response: "sWA FREchoFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1'}" # response: "sWA LFPangleRangeFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sWN LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1'}"            # response: "sWA LFPlayerFilter"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sMN Run'}"                                                         # response: "sAN Run 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN FREchoFilter'}"                                                # response: "sRA FREchoFilter 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPangleRangeFilter'}"                                         # response: "sRA LFPangleRangeFilter 0 C0490FF9 40490FF9 BFC90FF9 3FC90FF9 1"
ros2 service call /ColaMsg sick_scan_xd/srv/ColaMsgSrv "{request: 'sRN LFPlayerFilter'}"                                              # response: "sRA LFPlayerFilter 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LFPlayerFilter is not supported by picoscan150.</p>
</blockquote>

<h2 id="tim781-and-tim781s">TiM781 and TiM781S</h2>

<p>For TiM781S lidars, the initial lidar configuration can be deactivated using optional argument initialize_scanner:=0.
Note that this mode does not initialize the lidar. The mode assumes that the scanner is in an appropriate state corresponding to the properties configured in the launchfile. It is not recommended to use this option unless for specific tasks in a controlled environment.</p>

<p><strong>Do not use this mode except the lidar has been configured properly and initialized successfully and is in the same state as after initialization by the launchfile! This option is for advanced users only!</strong></p>

<p>Example: <code class="language-plaintext highlighter-rouge">roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=192.168.0.1 initialize_scanner:=0</code></p>

<h3 id="field-evaluation-tim7xx">Field evaluation TiM7xx</h3>

<p>The field evaluation for TiM7xx lidars support two additional options to configure the active field set: FieldSetSelectionMethod and ActiveFieldSet. These options allow to set the active field set during runtime, see the operation manual for details.</p>

<p>Options FieldSetSelectionMethod and ActiveFieldSet can be configured in the launch file and by ros services “FieldSetRead” and “FieldSetWrite”.</p>

<p>Initial values for FieldSetSelectionMethod and ActiveFieldSet can be configured in the launch file, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="active_field_set" type="int" value="-1"/&gt; &lt;!-- set ActiveFieldSet at startup: -1 = do not set (default), index of active field otherwise --&gt;
&lt;param name="field_set_selection_method" type="int" value="-1"/&gt; &lt;!-- set FieldSetSelectionMethod at startup: -1 = do not set (default), 0 = active field selection by digital inputs, 1 = active field selection by telegram --&gt;

</code></pre></div></div>
<p>By default, options FieldSetSelectionMethod and ActiveFieldSet are not written by the driver, i.e. the default values apply (factory defaults or settings by SOPAS ET).</p>

<p>Example service call for ROS1 to read resp. write options FieldSetSelectionMethod and ActiveFieldSet:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosservice call /sick_tim_7xx/FieldSetRead "{}" # returns field_set_selection_method and active_field_set
rosservice call /sick_tim_7xx/FieldSetWrite "{field_set_selection_method_in: -1, active_field_set_in: 1}" # write active_field_set

</code></pre></div></div>
<p>Example service call for ROS1 to read resp. write options FieldSetSelectionMethod and ActiveFieldSet:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ros2 service call /FieldSetRead sick_scan_xd/srv/FieldSetReadSrv "{}" # returns field_set_selection_method and active_field_set
ros2 service call /FieldSetWrite sick_scan_xd/srv/FieldSetWriteSrv "{field_set_selection_method_in: -1, active_field_set_in: 1}" # write active_field_set

</code></pre></div></div>

<p>Parameter active_field_set &lt; 0: do not set (default), active_field_set &gt; 0: index of active field otherwise (see operation manual for details about ActiveFieldSet telegram)</p>

<p>Parameter field_set_selection_method &lt; 0: do not set (default), field_set_selection_method = 0: active field selection by digital inputs, field_set_selection_method = 1: active field selection by telegram</p>

<p>Note that FieldSetSelectionMethod (parameter field_set_selection_method) requires a higher authorization level and should be configured in the launch file. It is therefore recommended to set <code class="language-plaintext highlighter-rouge">field_set_selection_method_in: -1</code> when using ros service FieldSetWrite.</p>

<h2 id="tim240">TiM240</h2>

<p>The TiM240 is a new scanner that fits seamlessly into the family of other TiM devices. The TiM240 has an opening angle of 240 degrees. In contrast to the previous scanners from SICK, the coordinate system used corresponds directly to the ROS convention. For this reason, this scanner does not require a coordinate conversion of 90 degrees around the Z-axis. However, this is taken into account in the driver code, so that the user will not notice any difference in the setting of the angular ranges during use.
The angular position according to the data sheet can be taken from the drawings below.</p>

<p>The following figures show the difference between the TiM5xx family and the TiM240 device.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/tim240/tim_5xx_scanarea.jpg" alt="TiM5xx scan area"></p>

<p>TiM5xx scanning area</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/tim240/tim_240_scanarea.jpg" alt="TiM240 scan area"></p>

<p>TiM240 scanning area</p>

<h2 id="nav350">NAV350</h2>

<p>NAV350 devices are supported by sick_scan_xd since 2023. Since they support navigation and use a different communication mode, this chapter gives an overview of the NAV350 support in sick_scan_xd. Please refer to the manuals for further information.</p>

<h3 id="process-loop">Process loop</h3>

<p>Scan data, landmarks and poses of NAV350 devices are queried by SOPAS commands with polling. Therefore the sick_scan_xd process loop runs as followed:</p>

<ol>
  <li>Initialization and setup</li>
  <li>Main loop (polling):
1 . Send data request “sMN mNPOSGetData 1 2”
2 . Receive and parse response
3 . Convert and publish pointcloud, laserscan, landmarks, pose and transform
4 . API: notify listeners and run their callback functions
5 . Repeat from step 1</li>
  <li>In case of incoming odometry messages (asynchron):
1 . Convert to SOPAS command
2 . Send “sMN mNPOSSetSpeed <odom_data>" to NAV350</odom_data>
</li>
</ol>

<h3 id="initialization-and-setup">Initialization and setup</h3>

<p>After initialization, sick_scan_xd switches to navigation mode by default. Navigation requires mapping (i.e. a valid landmark layout), which can be done by</p>
<ul>
  <li>SOPAS ET (recommended), or</li>
  <li>optional mapping with parameter <code class="language-plaintext highlighter-rouge">nav_do_initial_mapping:=True</code> using the landmarks detected at start, or</li>
  <li>using an optional imk-file.</li>
</ul>

<p>Configuration and setup using SOPAS ET is most powerful and recommended.</p>

<p>The default sopas initialization sequence runs as followed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"sMN SetAccessMode 3 F4724744"     # switch to access level authorized client
"sMN mNEVAChangeState 1"           # switch to operation mode standby
"sWN NEVACurrLayer &lt;layer&gt;"        # set layer configured by launchfile
"sWN NLMDLandmarkDataFormat 0 1 1" # set result format (landmark data)
"sWN NAVScanDataFormat 1 1"        # set result format (scan data)
"sWN NPOSPoseDataFormat 1 1"       # set result format (pose data)
"sMN mNEVAChangeState 4"           # switch to navigation mode
"sMN mNPOSGetData 1 2"             # query pose, landmark and scan data

</code></pre></div></div>

<p>If optional parameter <code class="language-plaintext highlighter-rouge">nav_do_initial_mapping</code> is true, a landmark layout is initialized using the reflectors detected at startup (sopas command “sMN mNMAPDoMapping”). The sopas initialization sequence for an initial mapping runs as followed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"sMN SetAccessMode 3 F4724744"     # switch to access level authorized client
"sMN mNEVAChangeState 1"           # switch to operation mode standby
"sWN NEVACurrLayer &lt;layer&gt;"        # set layer configured by launchfile
"sWN NLMDLandmarkDataFormat 0 1 1" # set result format (landmark data)
"sWN NAVScanDataFormat 1 1"        # set result format (scan data)
"sWN NPOSPoseDataFormat 1 1"       # set result format (pose data)
"sMN mNEVAChangeState 2"           # switch to mapping mode
"sMN mNLAYEraseLayout 1"           # clear landmark layout
"sWN NMAPMapCfg ..."               # configure mapping parameter
"sWN NLMDReflSize &lt;size&gt;"          # set reflector size configured by launchfile
"sMN mNMAPDoMapping"               # detect landmarks and run mapping
"sMN mNLAYAddLandmark ..."         # add all detected landmarks to the layout
"sMN mNLAYStoreLayout"             # store landmark layout
"sMN mNEVAChangeState 4"           # switch to navigation mode
"sMN mNPOSGetData 1 2"             # query pose, landmark and scan data

</code></pre></div></div>

<p>The landmark layout stored in an imk-file can optionally loaded at startup with optional parameter. See the NAV350 manual for details about imk-files.</p>

<p>The settings are configured in launch file <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/launch/sick_nav_350.launch">sick_nav_350.launch</a>.</p>

<h3 id="messages">Messages</h3>

<p>sick_scan_xd polls the NAV350 scan data, reflectors and poses in its main loop. Scan data are published by pointcloud messages (in topic “cloud” by default). Reflectors are published by type <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVLandmarkData</code> on topic “/sick_nav_350/nav_landmark” and as MarkerArray on topic “/sick_nav_350/nav_reflectors” for easy visualization using rviz. Poses are published by type <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVPoseData</code> on topic “/sick_nav_350/nav_pose” and as ros transform on topic “/tf”.</p>

<p>The following rviz-screenshot shows the pointcloud, landmarks and pose of a NAV350:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/nav350_ros1_screenshot2.jpg" alt="nav350_ros1_screenshot2.jpg"></p>

<h3 id="odometry-messages">Odometry messages</h3>

<p>Odometry messages can be sent to the NAV350 device using ROS messages <code class="language-plaintext highlighter-rouge">nav_msgs/Odometry</code> on topic “/sick_nav_350/odom” or <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVOdomVelocity</code> on topic “/sick_nav_350/nav_odom_velocity”. Odometry messages <code class="language-plaintext highlighter-rouge">sick_scan_xd/NAVOdomVelocity</code> specify the velocity (vx, vy) in m/s in lidar coordinates. Odometry messages <code class="language-plaintext highlighter-rouge">nav_msgs/Odometry</code> specify the velocity (vx, vy) in m/s in ros coordinates. The angular velocity is expected in radians/s.</p>

<p>Example odometry messages with vx = 1 m/s, vy = -1 m/s and omega: 0.5 rad/s:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rostopic pub --rate 10 /sick_nav_350/nav_odom_velocity sick_scan_xd/NAVOdomVelocity '{vel_x: 1.0, vel_y: -1.0, omega: 0.5, timestamp: 123456789, coordbase: 0}�
rostopic pub --rate 10 /sick_nav_350/odom nav_msgs/Odometry '{twist: { twist: { linear: {x: 1.0, y: -1.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.5}}}}'

</code></pre></div></div>

<h3 id="angle-compensation">Angle compensation</h3>

<h4 id="introduction-1">Introduction</h4>

<p>For measurements with the highest demands on the accuracy of the angle measurement, the devices of the NAV series allow compensation of slight angle deviations during a rotation. The compensation is determined by the three parameters.</p>
<ul>
  <li>Additive compensation by an angle offset</li>
  <li>Sinusoidal correction by specifying the amplitude and phase of compensation</li>
</ul>

<p>The three parameters are then used to calculate the compensation as follows:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/angle_compensation/angle_compensation_000.png" alt="Formula for angle compensation"></p>

<p>Offset and phase are given in [deg]</p>

<h4 id="example">Example</h4>

<p>The information is read from lidar by using the command <code class="language-plaintext highlighter-rouge">sRN MCAngleCompSin</code>.
The answer gives one amplitude, phase and offset compensation in tens of thousands.</p>

<p>The function reads</p>
<ul>
  <li>Amplitude-Parameter: +1893</li>
  <li>Phase-Parameter: -210503</li>
  <li>Offset-Parameter: -245</li>
</ul>

<p>These corresponds to:</p>
<ul>
  <li>Amplitude-compensation: +0.1893</li>
  <li>Phase-Compensation: -21.0503 [deg]</li>
  <li>Offset-Compensation: -0.0245 [deg]</li>
</ul>

<p><strong>Compensation formula for example for NAV210/NAV245</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Angle[comp.] = Angle[Raw] - 0.189300 * sin(Angle[Raw] + -21.050300 [deg]) -  -0.024500

</code></pre></div></div>

<p><strong>Compensation formula for example for NAV310</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Angle[comp.] = Angle[Raw] + 0.189300 * sin(Angle[Raw] - -21.050300 [deg]) +  -0.024500

</code></pre></div></div>
<p><strong>Example lookup values for NAV310 for this example (first entries)</strong></p>

<table>
  <thead>
    <tr>
      <th>IN [Deg]</th>
      <th>Out [Deg]</th>
      <th>Correction [Deg]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0.000000</td>
      <td>0.043494</td>
      <td>0.043494</td>
    </tr>
    <tr>
      <td>1.000000</td>
      <td>1.046567</td>
      <td>0.046567</td>
    </tr>
    <tr>
      <td>2.000000</td>
      <td>2.049618</td>
      <td>0.049618</td>
    </tr>
    <tr>
      <td>3.000000</td>
      <td>3.052647</td>
      <td>0.052647</td>
    </tr>
    <tr>
      <td>4.000000</td>
      <td>4.055652</td>
      <td>0.055652</td>
    </tr>
    <tr>
      <td>5.000000</td>
      <td>5.058633</td>
      <td>0.058633</td>
    </tr>
    <tr>
      <td>6.000000</td>
      <td>6.061588</td>
      <td>0.061588</td>
    </tr>
    <tr>
      <td>7.000000</td>
      <td>7.064518</td>
      <td>0.064518</td>
    </tr>
    <tr>
      <td>8.000000</td>
      <td>8.067420</td>
      <td>0.067420</td>
    </tr>
    <tr>
      <td>9.000000</td>
      <td>9.070294</td>
      <td>0.070294</td>
    </tr>
    <tr>
      <td>10.000000</td>
      <td>10.073139</td>
      <td>0.073139</td>
    </tr>
  </tbody>
</table>

<h4 id="comparing-compensated-vs-raw-values">Comparing compensated vs. raw values</h4>

<p>For the example the compensation function looks like this (X-Axis: measured angle [deg], Y-Axis: compensation in [deg])</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/angle_compensation/angle_compensation_001.png" alt="Plot of compensation function (example)"></p>

<h4 id="coordinate-systems">Coordinate systems</h4>

<p>For a better understanding of the data sheets of the different lidar systems the following drawings compare the different coordinate systems. Usually the scanners rotate counter-clockwise. The scanners of the NAV3xx series rotate clockwise. All coordinate systems following the right-hand rule, if the axis definition as shown in the picture is used.
 <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/angle_compensation/3d_coordinate_system_comp.png" alt="Used coordinate systems"></p>

<p>By means of simple matrix operations all axis orientations can be transformed into each other. But since we are only interested in the angle around the Z-axis, the conversions can be done as follows (CS = Coordinate System):</p>

<table>
  <thead>
    <tr>
      <th>IN From</th>
      <th>Out To</th>
      <th>Operation</th>
      <th>Additional info</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ROS</td>
      <td>NAV3xx</td>
      <td>Out=-In+180°</td>
      <td>maps [-180°…180°] to [360°…0°]</td>
    </tr>
    <tr>
      <td>NAV3xx</td>
      <td>ROS</td>
      <td>Out=-In+180°</td>
      <td>maps [0°…360°] to [180°…-180°]</td>
    </tr>
    <tr>
      <td>ROS</td>
      <td>NAV2XX</td>
      <td>Out=In+90°</td>
      <td> </td>
    </tr>
    <tr>
      <td>NAV2xx</td>
      <td>ROS</td>
      <td>Out=In-90°</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="check-compensation-function">Check compensation function</h4>

<p>By using <code class="language-plaintext highlighter-rouge">Octave</code> ones can check the compensation function against the given values by exporting the value via a testbed function.</p>

<!--
   40 a = dlmread("angle_compensation_debug.csv",';',1,0);
   41 size(a)
   42 a
   43 mean(a(:,3))
   44 a3 = a(:,3)-mean(a(:,3))
   45 mean(a3)
   46 S3 = fft(a3)
   47 plot(abs(S3))
   48 abs(S3)
   49 S3(1)
   50 S3(2)
   51 abs(S3(2))/360
   52 abs(S3(2))/360*2
   53 angle(S3(2))
   54 angle(S3(2))/pi*180
   55 angle(S3(2))/pi*180 - 90
   56 angle(S3(2))/pi*180 + 90
   57 plot(a(:,1),a(:,3))
   58 title "compensation example"
-->

<h2 id="mrs6124">MRS6124</h2>

<h3 id="timing-between-layers">Timing between Layers</h3>

<p>The layers are taken up by the scanner in packs of 6. The scanner delivers at an output data rate of 10 Hz and 24 layers 24/6*10=40 scan packets of 6 layers per second. The following table shows an example of the timing for a complete 24 layer recording</p>

<table>
  <thead>
    <tr>
      <th>Raw Time /µs</th>
      <th style="text-align: center">Delta Time /µs</th>
      <th style="text-align: right">Elevation Angle /Deg</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">13.19</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">12.565</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">11.940</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">11.315</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">10.690</td>
    </tr>
    <tr>
      <td>2551706348</td>
      <td style="text-align: center">0</td>
      <td style="text-align: right">10.065</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">9.440</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">8.815</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">8.190</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">7.565</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">6.940</td>
    </tr>
    <tr>
      <td>2551731348</td>
      <td style="text-align: center">25000</td>
      <td style="text-align: right">6.315</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">5.690</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">5.065</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">4.440</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">3.815</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">3.190</td>
    </tr>
    <tr>
      <td>2551756348</td>
      <td style="text-align: center">50000</td>
      <td style="text-align: right">2.565</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">1.940</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">1.315</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">0.690</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">0.065</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">-0.560</td>
    </tr>
    <tr>
      <td>2551781348</td>
      <td style="text-align: center">75000</td>
      <td style="text-align: right">-1.185</td>
    </tr>
    <tr>
      <td>NEW SCAN</td>
      <td style="text-align: center"> </td>
      <td style="text-align: right"> </td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">13.190</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">12.565</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">11.940</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">11.315</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">10.690</td>
    </tr>
    <tr>
      <td>2551807862</td>
      <td style="text-align: center">101514</td>
      <td style="text-align: right">10.065</td>
    </tr>
    <tr>
      <td>2551832862</td>
      <td style="text-align: center">126514</td>
      <td style="text-align: right">9.440</td>
    </tr>
  </tbody>
</table>

<p>The time stamps between the layers are interpolated by the scanner. The time stamps of the first layer (Ang.=13.19°) are measured and show jitter accordingly.</p>

<h3 id="mrs600-with-rms1000">MRS600 with RMS1000</h3>

<ol>
  <li>Setup environment and power supply</li>
  <li>roslaunch sick_scan_xd test_0002_combi_live.launch</li>
  <li>Check setup using rviz</li>
  <li>Close all applications, which are not necessary (like IDE, browser, git client)</li>
  <li>Setup Tracking algorithm</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>top

</code></pre></div></div>
<ol>
  <li>Record data</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosrun rosbag record record -o combi -a

</code></pre></div></div>

<h2 id="rms1000">RMS1000</h2>

<p>This driver supports the radar type RMS1000. This radar records raw targets and tracking objects. The tracking objects are determined on the basis of the raw targets. Two variants of a tracking method are already installed in the radar, which enables the radar to be put into operation quickly.</p>

<p>The RMS1000 is based on FMCW radar. With frequency-modulated continuous wave radar (FMCW radar), the transmission frequency is changed periodically. Triangle functions are usually used for distance measurement. While the transmission frequency changes as linearly as possible to the target object and back during the propagation time of the signal, the signal reflected by the object and received by the radar is time-shifted to the original transmitted frequency. By mixing the transmitted signal with the received signal, the frequency shift and thus the time shift can be determined. Based on the known modulation parameters of the transmitter, the propagation time of the signal can be determined, which in turn is proportional to the distance of the object. For precise distance measurement, therefore, the transmission frequency must be modulated as precisely as possible in linear fashion, since any non-linearity impairs the distance accuracy of the radar.</p>

<p>Through this indirect time measurement via the frequency change of the transmitter, even very close targets can be measured with high accuracy and cost-efficiency using the FMCW method, provided that the modulation parameters are selected appropriately. The distance resolution is determined by the bandwidth of the transmitted signal.</p>

<h3 id="raw-targets">Raw Targets</h3>

<p>Raw targets correspond to individual reflectors that are detected by the radar. Each individual reflector carries the following information:</p>
<ul>
  <li>Range</li>
  <li>Horizontal angle (azimuth)</li>
  <li>Doppler speed</li>
  <li>Reflectivity of the target (aka rcs - radar cross section)</li>
</ul>

<p>The radar RMSxxxx does not resolve elevation angles.  Therefore, the radar assumes the elevation values (z values) with 0.0. The error in distance estimation is usually negligible and is 0.4% (1.0 - cos(5°)) at an elevation angle of 5° compared to horizontal.</p>

<h3 id="tracking-objects">Tracking Objects</h3>

<p>Tracking objects are determined from the raw targets via a tracking procedure over the spatial and temporal
distribution of the raw targets. The track method estimates the location, direction and speed of the object based on an initial estimate.  After initialization, new raw targets are assigned to the track if they “fit” to the track.  This process is called “gating”. Once these raw targets have been assigned to the track,
the track is updated and the new estimate is used for further processing.</p>

<p>The distribution of raw targets over the object also determines the object length during the tracking process.</p>

<p>The tracking object therefore has the following properties:</p>
<ul>
  <li>Distance from radar in Cartesian coordinates</li>
  <li>Direction vector in Cartesian coordinates</li>
  <li>Direction of travel as an angle in the X/Y plane</li>
  <li>Vehicle speed</li>
  <li>Vehicle length</li>
</ul>

<h3 id="ros-message-for-radar">ROS message for Radar</h3>

<p>After parsing the telegram, the driver sends an ROS message of type RadarScan. RadarScan consists of the following components:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Header header
RadarPreHeader radarPreHeader
sensor_msgs/PointCloud2 targets
sick_scan_xd/RadarObject[] objects

</code></pre></div></div>
<h4 id="radarpreheader">RadarPreHeader</h4>
<p>The radar preheader contains information that provides general information about the radar. This data record can usually be ignored for object recognition with regard to raw targets and tracking objects.
For details please refer to the message specification of Sick.</p>

<h4 id="targets">targets</h4>

<p>The list with the raw targets of type sick_scan_xd/targets contains the information about the raw targets.
Each raw target contains the following data fields in a pointcloud2-message (height: 1, width: number of raw targets):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> std::string channelRawTargetId[] = { "x", "y", "z", "vrad","amplitude" };

</code></pre></div></div>
<p>This raw target contains cartesian coordinates, which are derived from range and azimuth angle (horizontal angle) in the following way (code snippet):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valSingle[0] = rawTargetList[i].Dist() cos(angle);    // x
valSingle[1] = rawTargetList[i].Dist() * sin(angle);  // y
valSingle[2] = 0.0;                                   // z
valSingle[3] = rawTargetList[i].Vrad();               // vrad
valSingle[4] = rawTargetList[i].Ampl();               // amplitude

</code></pre></div></div>

<h4 id="objects">objects</h4>

<p>The list with the objects of type sick_scan_xd/RadarObject[] contains the information about the track objects.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int32 id

time tracking_time                          // valid
time last_seen                              // not set

geometry_msgs/TwistWithCovariance velocity  // valid

geometry_msgs/Pose bounding_box_center      // valid
geometry_msgs/Vector3 bounding_box_size     // valid

geometry_msgs/PoseWithCovariance object_box_center // valid
geometry_msgs/Vector3 object_box_size              // valid

geometry_msgs/Point[] contour_points        // not set

</code></pre></div></div>

<p>Please note that not all fields are filled in the object messages. The message specification contains valid ones in the areas marked here in the code section.</p>

<p>The corresponding code fills the object list in the following manner:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        float heading = atan2( objectList[i].V3Dy(), objectList[i].V3Dx());

        radarMsg_.objects[i].velocity.twist.linear.x = objectList[i].V3Dx();
        radarMsg_.objects[i].velocity.twist.linear.y = objectList[i].V3Dy();
        radarMsg_.objects[i].velocity.twist.linear.z = 0.0;

        radarMsg_.objects[i].bounding_box_center.position.x = objectList[i].P3Dx();
        radarMsg_.objects[i].bounding_box_center.position.y = objectList[i].P3Dy();
        radarMsg_.objects[i].bounding_box_center.position.z = 0.0;
        radarMsg_.objects[i].bounding_box_center.orientation.x = cos(heading);
        radarMsg_.objects[i].bounding_box_center.orientation.y = sin(heading);
        radarMsg_.objects[i].bounding_box_center.orientation.z = 0.0;
        radarMsg_.objects[i].bounding_box_center.orientation.w = 1.0; // homogeneous coordinates


        radarMsg_.objects[i].bounding_box_size.x = objectList[i].ObjLength();
        radarMsg_.objects[i].bounding_box_size.y = 1.7;
        radarMsg_.objects[i].bounding_box_size.z = 1.7;
        for (int ii = 0; ii &lt; 6; ii++)
        {
          int mainDiagOffset = ii * 6 + ii;  // build eye-matrix
          radarMsg_.objects[i].object_box_center.covariance[mainDiagOffset] = 1.0;  // it is a little bit hacky ...
          radarMsg_.objects[i].velocity.covariance[mainDiagOffset] = 1.0;
        }
        radarMsg_.objects[i].object_box_center.pose = radarMsg_.objects[i].bounding_box_center;
        radarMsg_.objects[i].object_box_size= radarMsg_.objects[i].bounding_box_size;


</code></pre></div></div>
<p>As you can see there are default values for object height and object width of 1.7 (typical private vehicle)</p>

<!---

## Visualization

For the visualization a ROS node was developed, which receives
the radar messages and exports them as boxes for the objects and as arrows for the raw data.
The ROS node **radar_object_marker** receives the radar data and exports marker arrays that can be visualized in rviz.

The visualization could be controlled by the following parameters:

| Parameters                 | Description                                        |
| -------------------------- | -------------------------------------------------- |
| rawtarget_sphere_radius    | radius of the sphere for the raw data display      |
| rawtarget_arrow_scale      | Scaling factor for the arrow at the raw targets    |
| rawtarget_palette_name     | name of the color palette                          |
| rawtarget_palette_min_ampl | Minimum amplitude value mapped to color idx 0.     |
| rawtarget_palette_max_ampl | Maximum amplitude value mapped to color index 255. |
| object_arrow_scale         | Scaling factor for the arrow at the raw targets    |

The scaling values can be interpreted as the time an object or a raw target moves during this period. Using the distance/time equation, the distance corresponding to the arrow length is calculated from the product of this time period and the object speed or Doppler speed.

Example: Doppler speed: 20[m/s], rawtarget_arrow_scale: 0.4
An arrow of length 0.4 * 20[m] = 8[m] is displayed in rviz.

-->

<h3 id="launch-files">Launch Files</h3>

<p>The following launch files serve as examples for use:</p>

<ul>
  <li>sick_rms_xxxx.launch: Communication with the RMSxxxx and sending of radar ROS messages after successful parsing of SOPAS telegrams coming directly from the radar.</li>
  <li>radar_object_marker.launch : Conversion of radar messages to visualization messages</li>
</ul>

<h4 id="data-visualization-example-video">Data visualization example video</h4>

<p><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/doc/200326_5_video_track.mp4">A video example can be found here</a>.</p>

<p>The following figure shows a viz-screenshot of the pointcloud:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/radar_rviz.png" alt="radar_rviz"></p>

<h3 id="parameter-for-radar-usage">Parameter for Radar Usage</h3>

<p>The following parameters are support by the node <strong>sick_generic_caller</strong> in combination with the RADAR RMS1000 / RMS2000:</p>

<ul>
  <li>scanner_type (string, default: “”) –&gt; Must be set to <strong>sick_rms_xxxx</strong>
</li>
  <li>range_max (double, default: 25.0)</li>
  <li>Maximum range</li>
  <li>hostname</li>
  <li>port</li>
  <li>timelimit</li>
  <li>tracking_mode
0: BASIC-Tracking - use for tracking smaller objects
1: TRAFFIC-Tracking - use for tracking larger objects like vehicles</li>
  <li>transmit_raw_targets (bool, default: true)</li>
  <li>transmit_objects (bool, default: true)</li>
  <li>emul_sensor (bool, default: false)</li>
</ul>

<h3 id="radar-datagram">Radar Datagram</h3>

<p>The message sick_scan_xd/RadarScan consists of four parts:</p>
<ul>
  <li>Header in standard format</li>
  <li>radarPreHeader with higher-level information</li>
  <li>targets: Raw targets output from radar</li>
  <li>objects: Tracking objects that are determined based on the raw targets using the internal tracking algorithm.</li>
</ul>

<p>The complete structure can be determined using the command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosmsg show sick_scan_xd/RadarScan'

</code></pre></div></div>

<p>The following is a short datagram showing the structure of the radar datagram.
The position of the individual elements for the data of the PreHeader is explained below.
See the documenation on https://www.sick.com/de/en/radar-sensors/c/g575803?q=:Def_Type:ProductFamily
for further information.</p>

<p><strong>Example of very short radar datagram</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sSN LMDradardata 1 1 112F6E9 0 0 BCC DC0C 730E9D16 730EA06D 0 0 0 0 0 0 1 0 0 4 DIST1 42200000 00000000 0 AZMT1 3C23D70A 00000000 0 VRAD1 3C23D70A 00000000 0 AMPL1 3DCCCCCD 00000000 0 1 MODE1 3F800000 00000000 0 0 0 0 0 0

</code></pre></div></div>

<p>In the following, the individual tokens are numbered one after another and their meaning is explained:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0: sSN
  1: LMDradardata

  MeasurementData
  ===============
  2: 1             MeasurementData.uiVersionNo  : Version Information for this while structureValue
                   Value   Range: 0 ... 65535
  DeviceBlock
  ===========
  3: 1             DeviceBlock.uiIdent      : Logical number of the device
                   Value   Range: 0 ... 65535
  4: 112F6E9       DeviceBlock.udiSerialNo  : Serial number of the device
                   Value Range  : 0..4294967295


  5: 0             DeviceBlock.xbState      : State of the device
                   Bit length   : 16

                   0.0 Bool     : Value Range False, True
                   Initialisation: False
                   Meaning       : bDeviceError

                   0.1 Bool      : Value Range False, True
                   Initialisation: False
                   Meaning       : bContaminationWarning

                   0.2 Bool      : Value Range False, True
                   Initialisation: False
                   Meaning       : bContaminationError

                   0.3 ...  0.7
  6: 0             1.0 ...  1.7 Bool      : Value Range False, True
                                           Reserved

StatusBlock
===========
  7: BCC            uiTelegramCount
  8: DC0C           uiCycleCount (or uiScanCount???)
  9: 730E9D16       udiSystemCountScan
 10: 730EA06D       udiSystemCountTransmit
 11: 0              xbInputs (Bit 0.0 .. 0.7)
 12: 0              xbInputs (Bit 1.0 .. 1.7)
 13: 0              xbOutputs (Bit 0.0 .. 0.7)
 14: 0              xbOutputs (Bit 1.0 .. 1.7)

MeasurementParam1Block
======================
 15: 0              MeasurementParam1Block.uiCycleDuration
 16: 0              MeasurementParam1Block.uiNoiseLevel

aEncoderBlock
=============
 17: 1              Number of aEncoderBlocks


 18: 0              aEncoderBlock[0].udiEncoderPos
 19: 0              aEncoderBlock[0].iEncoderSpeed

 20: 4              Number of following data channels
 21: DIST1
 22: 42200000
 23: 00000000
 24: 0
 25: AZMT1
 26: 3C23D70A
 27: 00000000
 28: 0
 29: VRAD1
 30: 3C23D70A
 31: 00000000
 32: 0
 33: AMPL1
 34: 3DCCCCCD
 35: 00000000
 36: 0
 37: 1
 38: MODE1
 39: 3F800000
 40: 00000000
 41: 0
 42: 0
 43: 0
 44: 0
 45: 0
 46: 0

</code></pre></div></div>

<h2 id="rms1000-and-lms1000-combination">RMS1000 and LMS1000 combination</h2>

<p>This tutorial shows how to combine a RMS1000radar with a LMS1000 lidar.</p>

<p>To demonstrate the lidar/radar combination, a RMS1000and a LMS1000 device were put into operation. The sick_scan_xd driver and rviz were started on ROS 1 Linux. Bagfiles have been recorded to demonstrate the required transform (rms_1xxx_lms_1xx_movement_off.bag and rms_1xxx_lms_1xx_movement_on.bag).</p>

<p>Run the following steps:</p>

<ol>
  <li>Connect RMS1000and LMS1000 and start sick_scan_xd with launchfiles sick_lms_1xxx.launch and sick_rms_xxxx.launch:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   roslaunch sick_scan_xd sick_lms_1xxx.launch
   roslaunch sick_scan_xd sick_rms_xxxx.launch
   
</code></pre></div></div>
<p>Make sure, that different ros node names and different IP-addresses are used.</p>

<p>The following rviz screenshot shows both pointclouds:
   <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/combination_rms_1xxx_lms_1xx/rms_1xxx_lms_1xx_combi_screenshot01.png" alt="rms_1xxx_lms_1xx_combi_screenshot01.png"></p>

<p>Note that each sensor has its own frame id and coordinate system. The RMS1000uses the frame id “radar”, the LMS1000 uses the frame id “cloud”. To combine both sensor, we have to transform the radar frame and coordinates to the lidar frame and coordinates.
   Radar targets have multiple echos due to reflection.</p>

<ol>
  <li>Start a ros static_transform_publisher to convert radar frames (frame id <code class="language-plaintext highlighter-rouge">/radar</code>) to lidar frames (frame id <code class="language-plaintext highlighter-rouge">/cloud</code>):</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   rosrun tf static_transform_publisher 0 0 0 0 0 0 /cloud /radar 100
   
</code></pre></div></div>
<p>Using this transform, rviz displays both the radar and lidar pointcloud:
   <img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/combination_rms_1xxx_lms_1xx/rms_1xxx_lms_1xx_combi.png" alt="rms_1xxx_lms_1xx_combi.png"></p>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  If you use this example with a playback of bagfiles (e.g. <code class="language-plaintext highlighter-rouge">rosbag play --loop ./rms_1xxx_lms_1xx_movement_off.bag</code>), you might encounter errors due to different timestamps (the recorded timestamps in the bagfiles are different from the timestamps by the static_transform_publisher).</p>
</blockquote>

<p>Alternatively, the radar frame id and an optional transform can be configured in the radar launch file (parameter “frame_id” and “add_transform_xyz_rpy”).</p>

<h2 id="lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</h2>

<p>Most lidars create non interlaced scan data by default, i.e. a scan data telegram contains all scan points measured during a full 360 degree circulation. For MRS1xxx and LMS1000 lidars, parameter <code class="language-plaintext highlighter-rouge">ang_res</code> can be configured to increase the angular resolution. In this case, the scan data and point clouds are measured and published interlaced.</p>

<p>The following table shows valid combinations of the angular resolution (parameter <code class="language-plaintext highlighter-rouge">ang_res</code>) and scan frequency (parameter <code class="language-plaintext highlighter-rouge">scan_freq</code>) for MRS1000 and LMS1000 lidars:</p>

<table>
  <thead>
    <tr>
      <th>lidar</th>
      <th>ang_res [deg]</th>
      <th>scan_freq [Hz]</th>
      <th>interlacing</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MRS1000</td>
      <td>0.25</td>
      <td>50</td>
      <td>non-interlaced</td>
    </tr>
    <tr>
      <td>MRS1000</td>
      <td>0.125</td>
      <td>25</td>
      <td>2 x interlaced</td>
    </tr>
    <tr>
      <td>MRS1000</td>
      <td>0.0625</td>
      <td>12.5</td>
      <td>4 x interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.75</td>
      <td>150</td>
      <td>non-interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.375</td>
      <td>75</td>
      <td>2 x interlaced</td>
    </tr>
    <tr>
      <td>LMS1000</td>
      <td>0.1875</td>
      <td>37.5</td>
      <td>4 x interlaced</td>
    </tr>
  </tbody>
</table>

<p><strong>MRS1000 angular resolution</strong></p>

<p>By default, MRS1000 lidars create non-interlaced scans with an angular resolution 0.25 deg.
Using higher resolutions, the MRS1000 sends scan data interlaced.</p>

<p>MRS1000 lidars measure 4 consecutive scans with identical starting angles for each of its 4 layers, where each layer has a different elevation angle. This results in (12.5 Hz) * (4 layers) * (360 deg / 0.25 deg) * (275 deg / 360 deg) = 55000 shots per second.</p>

<p>With default configuration ang_res=0.25, the angular resolution of each scan is 0.25 [deg] and scans and point clouds are non-interlaced. The sequence of scan data telegrams is repeating with 4 consecutive telegrams (resp. 4 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5 deg, angle inc = 0.25 deg</li>
</ul>

<p>With configuration ang_res=0.125, the angular resolution of each scan is 0.125 [deg] and scans and point clouds are 2 x interlaced. The sequence of scan data telegrams is repeating with 8 consecutive telegrams (resp. 8 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.500 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.625 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.625 deg, angle inc = 0.25 deg</li>
</ul>

<p>With configuration ang_res=0.0625, the angular resolution of each scan is 0.0625 [deg] and scans and point clouds are 4 x interlaced. The sequence of scan data telegrams is repeating with 16 consecutive telegrams (resp. 16 point cloud messages):</p>
<ul>
  <li>layer[0] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.4375 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5000 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.5625 deg, angle inc = 0.25 deg</li>
  <li>layer[0] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[1] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[2] starting at -137.6250 deg, angle inc = 0.25 deg</li>
  <li>layer[3] starting at -137.6250 deg, angle inc = 0.25 deg</li>
</ul>

<p>To use the full angular resolution of one 360 degree circulation, the point cloud must be accumulated by 8 resp. 16 messages in interlaced mode.</p>

<p><strong>LMS1000 angular resolution</strong></p>

<p>By default, LMS1000 lidars create non-interlaced scans with an angular resolution 0.75 deg.
Using higher resolutions, the LMS1000 sends scan data interlaced.</p>

<p>With configuration ang_res=0.75, the angular resolution of each scan is 0.75 [deg]. This means that each point cloud message also has a resolution of 0.75 [deg]. With configuration ang_res=0.375, the scan is generated interlaced: Each scan still has 0.75 [deg] resolution, but 2 x 4 = 8 consecutive scans are rotated by 0.375 [deg] against each other. I.e. 8 consecutive point cloud messages each have an angular resolution of 0.375 [deg] at half the frequency. Within a point cloud message the angular resolution is still 0.75 [deg].</p>

<p>With ang_res=0.375, scan data are two times interlaced. The sequence of scan data telegrams is repeating with 8 consecutive telegrams:</p>
<ul>
  <li>4 scans starting at -138.000 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.375 deg, angle inc = 0.75 deg</li>
</ul>

<p>Thus the start angles of the received scan data telegrams are
{ …, -138.375, -138.375, -138.375, -138.375, -138.000, -138.000, -138.000, -138.000, … }</p>

<p>With ang_res=0.1875 the scan is generated quadruple interlaced, i.e. 4 x 4 = 16 consecutive scans are each rotated by 0.1875 [deg]. Each scan is resolved with 0.75 [deg]; 4 x 4 = 16 scans resp. 16 pointclouds together (accumulated) result in a resolution of 0.1875 [deg] at a quarter of the frequency.</p>

<p>With ang_res=0.1875, scan data are four times interlaced. The sequence of scan data telegrams is repeating with 16 consecutive telegrams:</p>
<ul>
  <li>4 scans starting at -137.8125 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.0000 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.1875 deg, angle inc = 0.75 deg, then</li>
  <li>4 scans starting at -138.3750 deg, angle inc = 0.75 deg, then</li>
</ul>

<p>Thus the start angles of the received scan data telegrams are
{ …, -137.8125, -137.8125, -137.8125, -137.8125, -138.0000, -138.0000, -138.0000, -138.0000, -138.1875, -138.1875, -138.1875, -138.1875, -138.3750, -138.3750, -138.3750, -138.3750, … }</p>

<p>You can see this in rviz by increasing the decay time to e.g. 4/75=0.054 or higher. The screenshot shows an example with the default setting ang_res=0.75:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/LMS1xxx_0.7500_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>The angular resolution is (just roughly measured) about atan(0.11/0.9) / 9 points = 0.77 [deg]. With ang_res=0.375 and decay=0.1 rviz shows twice the resolution:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/LMS1xxx_0.3750_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>Correspondingly, rviz shows four times the resolution with ang_res=0.1875 and decay=0.1:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/LMS1xxx_0.1875_deg.png" alt="LMS1xxx_0.7500_deg.png"></p>

<p>To use the full angular resolution of one 360 degree circulation, the pointcloud must be accumulated by 8 resp. 16 messages.</p>

<p>The active configuration can be seen in the log output during scanner initialization, e.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ INFO] [1669294673.078608968]: sRA LMPscancfg: scan frequency = 75 Hz, angular resolution = 0.375 deg.

</code></pre></div></div>

<blockquote>
  <p><strong><em>NOTE:</em></strong>  LMS creates 4 consecutive scans with identical starting angles for each of its 4 laser LEDs. The 4 laser LEDs are mounted in one plane. All together, this gives you (4 scans) * (37.5 Hz) * (1 layer) * (360 deg / 0.75 deg) * (275 deg / 360 deg) = 55000 shots per second.</p>

</blockquote>

<h1 id="faq">FAQ</h1>

<h2 id="general">General</h2>

<p><strong>How to run multiple sensors concurrently?</strong></p>

<p>:question: How can I run multiple sensors concurrently with sick_scan_xd ?</p>

<p>:white_check_mark: To support multiple sensors, sick_scan_xd has to be started multiple times, with one sick_scan_xd-node for each sensor. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#start-multiple-nodes">start multiple nodes</a> for details.</p>

<p><strong>Driver restarts again and again after “sFA” message</strong></p>

<p>:question: The sick_scan_xd driver restarts again and again after an error message “sFA”.</p>

<p>:white_check_mark: The behaviour is intentional. The error message “sFA” can be caused by faulty configuration or errors in the lidar. Correct operation after this error message is not guaranteed. In this case, the driver restarts itself. It is recommended to identify and correct the error using its error number (“<code class="language-plaintext highlighter-rouge">sFA&lt;hexcode&gt;</code>”). The SOPAS error codes are listed in the manual.</p>

<p><strong>Driver restarts after timeout error</strong></p>

<p>:question: The sick_scan_xd driver changes the communication protocol and restarts after a timeout error.</p>

<p>:white_check_mark: The use of binary communication (Cola-B) is highly recommended due to better compatibility, lower network traffic and general support.
Recommendation:</p>
<ol>
  <li>Set parameter “use_binary_protocol” to “true” in the launch file, and</li>
  <li>Set the lidar communication mode with the SOPAS ET software to binary and save this setting in the scanner’s EEPROM.</li>
</ol>

<p><strong>Changes in launchfiles are ignored</strong></p>

<p>:question: roslaunch still uses an old version after modifying the launch-file.</p>

<p>:white_check_mark: After modifying a launch-file, it has to be installed by running <code class="language-plaintext highlighter-rouge">catkin_make_isolated --install --cmake-args -DROS_VERSION=1</code>
to be located and used by <code class="language-plaintext highlighter-rouge">roslaunch</code>.</p>

<p><strong>ROS 2 launch file support</strong></p>

<p>:question: How can I create a ROS 2 node in python to run sick_generic_caller from a launch.py-file in ROS 2?</p>

<p>:white_check_mark: Example to launch a TiM-7xx node in ROS 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sick_scan_pkg_prefix = get_package_share_directory('sick_scan_xd')
    tim_launch_file_path = os.path.join(sick_scan_pkg_prefix, 'launch/sick_tim_7xx.launch')
    tim_top_node = Node(
        package='sick_scan_xd',
        executable='sick_generic_caller',
        output='screen',
        arguments=[
            tim_launch_file_path,
            'nodename:=/lidars/tim_top',
            'hostname:=192.168.0.110',
            'cloud_topic:=/lidars/tim_top/cloud',
            'frame_id:=tim_top'
        ]
    )

</code></pre></div></div>
<p>Thanks to user JWhitleyWork.</p>

<p><strong>Timestamps</strong></p>

<p>:question: What timestamp is provided in the pointcloud and laserscan messages?</p>

<p>:white_check_mark: Details about timestamps are given in <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#time-synchronization">timing</a> and <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#software-pll">software_pll</a>.</p>

<p>In a nutshell:
The lidars do not work with absolute time stamps but with “ticks”. There are two types of tick timestamps:</p>
<ul>
  <li>Tick timestamps for the generation</li>
  <li>Tick timestamps for sending the message
To match the tick timestamps against the system time, a straight line equation is estimated via the so-called software PLL, which can be used to calculate from the system time to the ticks in the lidar (and vice versa). The assumption is that the tick timestamp for sending the message corresponds to the system time when receiving the message. In reality there will be a tiny delay here. This delay can be ignored.</li>
</ul>

<p>With the help of this straight line equation, one can now calculate the system time at which the data is generated in the lidar.</p>

<p>Summary:</p>
<ol>
  <li>lidar: stamp with ticks the generation (first shot in the scan) (TICK_GEN)</li>
  <li>lidar: stamp with ticks the sending of the scan message (TICK_TRANSMIT)</li>
  <li>PC: Stamp with system time the receiving of the message</li>
  <li>PC: Calculate back to system time of generation:
System time of generation = System time of receiving - (TICK_TRANSMIT - TICK_GEN)/TICK_FREQUENCY</li>
</ol>

<p><strong>Laserscan messages with multiple frame ids</strong></p>

<p>:question: sick_scan_xd publishes laserscan messages for multiScan100 and picoScan100 with multiple frame ids and possibly inconsistent data. Which frame id is correct?</p>

<p>:white_check_mark: By default, an echo filter is activated in the multiScan100 and picoScan100 launchfile. This echo filter suppresses multiple echos, e.g. echos from an object and a protective glass pane. The default configuration is “last echo only”. In this case (i.e. one echo only), the fullframe laserscan messages on topic scan_fullframe all have identical frame ids for each layer, i.e. “world_&lt;layer&gt;”. For the multiScan100 lidars with 16 layers, sick_scan_xd publishes laserscan messages with frame ids “world_1”, “world_2” up to “world_16”. For picoScan100 lidars with 1 layer, there is just one frame id “world_1”.</p>

<p>In case of multiple echos (i.e. echo filter is deactivated), each echo is published by a laserscan message with different frame ids “world_&lt;layer&gt;_&lt;echo_idx&gt;”. For picoScan100 lidars with 3 echos, there are 3 frame ids “world_1_0”, “world_1_1”, “world_1_2” published. For multiScan100 lidars with 16 layers and 3 echos, there are 48 different frame ids published “world_1_0”, “world_1_1”, “world_1_2”, “world_2_0”, “world_2_1”, “world_2_2”, … , “world_16_0”, “world_16_1”, “world_16_2”.</p>

<p>This behaviour is intended, since a laserscan message can not contain multiple ranges for a single scan point at one azimuth angle. Therefore, there have to be different laserscan messages for each layer and each echo. Layer and echo of a laserscan message are identified by the frame id.</p>

<p><strong>Compilation errors</strong></p>

<p>:question: Compiler reports errors in file <code class="language-plaintext highlighter-rouge">/opt/ros/&lt;distro&gt;/include/sick_scan</code></p>

<p>:white_check_mark: If sick_scan was previously installed using <code class="language-plaintext highlighter-rouge">apt-get install ros-&lt;distro&gt;-sick-scan</code>, you have to remove previous versions using <code class="language-plaintext highlighter-rouge">apt-get purge ros-&lt;distro&gt;-sick-scan</code>. Run the following steps for a complete rebuild:</p>
<ol>
  <li>Run <code class="language-plaintext highlighter-rouge">sudo apt-get purge ros-&lt;distro&gt;-sick-scan</code> (e.g. <code class="language-plaintext highlighter-rouge">sudo apt-get purge ros-noetic-sick-scan</code>) to remove previously installed sick_scan-packages</li>
  <li>Remove the folders sick_scan_xd/build, sick_scan_xd/build_isolated, sick_scan_xd/devel, sick_scan_xd/devel_isolated, sick_scan_xd/install and sick_scan_xd/install_isolated</li>
  <li>Rebuild</li>
</ol>

<p>:question: cmake cannot find diagnostic_updater</p>

<p>:white_check_mark: On ROS 2 foxy, package diagnostic_updater needs to be installed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get update
sudo apt-get install ros-$ROS_DISTRO-diagnostic-updater # install diagnostic_updater
# E.g. to install diagnostic_updater on foxy, run
# sudo apt-get install ros-foxy-diagnostic-updater

</code></pre></div></div>

<p>:question: catkin gives me the following error message:
<code class="language-plaintext highlighter-rouge">By not providing "FindSICKLDMRS.cmake" in CMAKE_MODULE_PATH this project ..., but CMake did not find one."</code></p>

<p>:white_check_mark:  One problem with ROS is that it doesn’t automatically rebuild everything if you just append “-DLMRRS=0”.
If you accidentally did the following call before</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catkin_make_isolated --install --cmake-args -DROS_VERSION=1

</code></pre></div></div>
<p>you must remove the build/devel/install-directories created by the ROS build process.
For this please run the following commands to remove the directories, which holds the previous build results:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~/ros_catkin_ws
rm -rf build_isolated
rm -rf devel_isolated
rm -rf install_isolated
rm -rf devel

</code></pre></div></div>
<p>It is possible that not all directories are present in this list. But that does not matter.
The only subdirectory left should be “src”.
You can check this with the following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls */ -d

</code></pre></div></div>
<p>The output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/

</code></pre></div></div>
<p>After doing this please rerun the command
catkin_make_isolated –install –cmake-args -DROS_VERSION=1 -DLDMRS=0</p>

<p><strong>rviz or rviz2 do not work as expected</strong></p>

<p>:question: rviz shows a grey point cloud. The size of points can be adjusted.</p>

<p>:white_check_mark: Check in the launch file that the intensity flag is set to True.</p>

<p>:question: rviz shows a grey point cloud and the size of points can not be adjusted.</p>

<p>:white_check_mark: Probably in this case you are running Linux in a virtual machine. In this case, OpenGL may not work correctly in the VM. rviz then chooses a kind of “fallback solution” and deactivates the colors.
Also, changing the “Size” and “Style” display in rviz has no effect on the display of the pointcloud data.</p>

<p>The problem can be avoided by starting rviz with the following sequence:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export LIBGL_ALWAYS_SOFTWARE=1
rosrun rviz rviz

</code></pre></div></div>

<p>:question: rviz2 on Ubuntu 24 with ROS 2 jazzy crashes immediately after start</p>

<p>:white_check_mark: This can be a wayland vs. X11 problem. Try <code class="language-plaintext highlighter-rouge">export QT_QPA_PLATFORM=xcb</code> before starting rviz2. See https://github.com/ros-visualization/rviz/issues/1442#issuecomment-553900795 and https://blog.martin-graesslin.com/blog/2015/07/porting-qt-applications-to-wayland/ for further information.</p>

<p><strong>Angular resolution and scan frequency</strong></p>

<p>:question: The angular resolution/ number of shots is too small</p>

<p>:white_check_mark: Possibly Mean or Median filters are activated. Use Sopas ET to deactivate them and store this settings permanent on the device, see picture.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/tim5xxx_filter.PNG" alt="Sopas_filter"></p>

<p>Further information can be found at http://wiki.ros.org/rviz/Troubleshooting .</p>

<p>:question: The scanner and message frequency is lower than expected</p>

<p>:white_check_mark: Mean or median filters decrease the scanner frequency. Check and configure filter settings with SOPAS ET or deactivate them in the launch file (MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx only):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="lfp_meanfilter" type="int" value="-1" /&gt; &lt;!-- MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx: lfp_meanfilter&lt;0: do not apply, lfp_meanfilter==0: deactivate LFPmeanfilter, lfp_meanfilter&gt;0: activate LFPmeanfilter with lfp_meanfilter = number of scans --&gt;
&lt;param name="lfp_medianfilter" type="int" value="-1" /&gt; &lt;!-- MRS1xxx, LMS1xxx, LMS4xxx, LRS4xxx: lfp_medianfilter&lt;0: do not apply, lfp_medianfilter==0: deactivate LFPmedianfilter, lfp_medianfilter==1: activate LFPmedianfilter --&gt;

</code></pre></div></div>
<p>By default, filter settings are not overwritten, i.e. the filter settings stored in the lidars EEPROM apply (factory defaults resp. SOPAS ET filter settings).</p>

<p><strong>LMS1xxx angular resolution</strong></p>

<p>:question: Independent of the configuration, the LMS1xxx pointcloud always displays 0.75 [deg] angular resolution</p>

<p>:white_check_mark: Using higher resolutions, the LMS1xxx sends scan data interlaced. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</a> for details.</p>

<p><strong>“ERROR: Tcp::open: Failed to open TCP connection to 192.168.0.1, aborting.”</strong></p>

<p>:question: Question:
sick_generic_caller gives you an answer like:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"ERROR: Tcp::open: Failed to open TCP connection to 192.168.0.1, aborting."</span>

</code></pre></div></div>

<p>:white_check_mark: Answer: See FAQ for network diagnosis and recommended configuration.</p>

<p><strong>IP Address of Lidar</strong></p>

<p>:question: Question:
My scanner does not use the default ip address. What shall I do?</p>

<p>:white_check_mark: Answer:
There are two options doing this:</p>

<ul>
  <li>Permanently:
Replace the following entry with your ip address.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;param <span class="nv">name</span><span class="o">=</span><span class="s2">"hostname"</span> <span class="nb">type</span><span class="o">=</span><span class="s2">"string"</span> <span class="nv">value</span><span class="o">=</span><span class="s2">"192.168.0.1"</span> /&gt;

</code></pre></div></div>
<ul>
  <li>Temporarily
Use a command line argument in addition to the launch file argument:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nb">hostname</span>:<span class="o">=</span>192.168.0.2

</code></pre></div></div>

<p><strong>Timeout Warning</strong></p>

<p>:question: Question:
During start phase the are warning/error message like</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>no answer received after 5000 ms. Maybe sopas mode is wrong.

</code></pre></div></div>
<p>and some more warning/error messages:</p>

<p>:white_check_mark: Answer:
In this case the driver tries to start the scanner in binary mode. If this is not possible, warnings and error messages are generated.
The driver switches the scanner from ASCII mode to binary mode and then restarts communication. The messages can therefore be ignored.
For a long-term solution, we recommend switching from ASCII to binary communication with SOPAS ET under Windows.</p>

<p><strong>Own Data Handling</strong></p>

<p>:question: Question:
I would like to process data with my own methods.</p>

<p>:white_check_mark: Answer:
Search for keyword “PUBLISH_DATA:” in the code and replace the code for writing
jpeg-files and CSV-files with your own source code.</p>

<p><strong>Occasionally missing scan data</strong></p>

<p>:question: Question:
Occasionally, no scan data appear, but the scanner is still reachable using <code class="language-plaintext highlighter-rouge">ping &lt;ip-address&gt;</code> or <code class="language-plaintext highlighter-rouge">nc -z -v &lt;ip-address&gt; &lt;port&gt;</code></p>

<p>:white_check_mark: Answer:
This is likely to be a data capture issue. In any case it’s recommend (if not already set) to use SOPAS-Binary instead of SOPAS-ASCII, because here the data rate is lower.</p>

<p>In addition, the following measures can help to determine the source of the problems:
a) Exchange the cables to the lidar(s) incl. the network cables
b) Exchange the power supply to the lidar(s)
c) avoidance of interconnection of other components (like switch etc.)
d) upgrade hardware and firmware of devices (if new versions available)</p>

<p>If it is not a hardware problem (e.g. cable), check if there are other software components using the network interface.</p>

<p>If there are still problems, use Wireshark to see if there are any communication problems reported. Wireshark can export the recorded network traffic as text (see screenshot). Search for entries like “LMDscandata” in the generated text file. This marks the beginning of a new scan message. You can then compare the order of the timestamps of these packets to see if there were any failures.</p>

<p><img src="https://user-images.githubusercontent.com/33296049/124088216-01aa2280-da53-11eb-91ae-2b88b37e08eb.png" alt="Wireshark screenshot"></p>

<p><strong>python_d.exe not found</strong></p>

<p>:question: Question:
On Windows with ROS, cmake complains “python_d.exe not found” when running rosidl generator</p>

<p>:white_check_mark: Answer:
Workaround: Copy python.exe to python_d.exe in the python folder.</p>

<p><strong>Debugging</strong></p>

<p>:question: Question:
How can I debug sick_generic_caller on ROS 1?</p>

<p>:white_check_mark: Answer:
Build with compiler option <code class="language-plaintext highlighter-rouge">-g</code> and run sick_generic_caller as described using a launchfile. Stop sick_generic_caller (Ctrl-C or kill) and save the current ros parameter using <code class="language-plaintext highlighter-rouge">rosparam dump &lt;dumpfile&gt;.yaml</code>. Load these parameter with <code class="language-plaintext highlighter-rouge">rosparam load &lt;dumpfile&gt;.yaml</code> and restart sick_generic_caller in gdb or in your IDE.</p>

<p><strong>Curved lines on a straight wall</strong></p>

<p>:question: Question:
The X,Y points of the lidar show a curved line even though the lidar is scanning a straight wall. How can this be?</p>

<p>:white_check_mark: Answer:
This effect occurs when the lidar has multiple planes that are tilted up or down. In this case, the laser beams of this plane do not lie on a flat plane. Rather, the beams lie on a cone. If the laser beams then hit a wall, the result is a curved course of the lidar points. If the lidar is horizontal and the wall is vertical, this is a hyperbola (see following figure):</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/cone_section.png" alt="cone_section"></p>

<p>This image is generated using the website https://www.intmath.com/plane-analytic-geometry/conic-sections-summary-interactive.php.
Thus, the mathematical laws for a conic section apply, as they are explained e.g. at Wikipedia at https://en.wikipedia.org/wiki/Conic_section.</p>

<p><strong>Interlacing</strong></p>

<p>:question: Question:
How should I interpret the scan rate and lidar resolution from the manual? What is the relationship between ROS point cloud publishing rate and scan frequency here?</p>

<p>:white_check_mark: Answer:</p>

<p>The angular resolution and scan frequency is configurable in many lidars such as the LRS-4xxx or MRS1000. Depending on the lidar type, angular resolution and scan frequency can be set in the launch file either via the parameter “scan_cfg_list_entry” or the parameters “ang_res” and “scan_freq”. Angular resolution and scan frequency are not independent of each other. If no default settings are used, the values must be selected according to the manual for the respective lidar and set in launch file.</p>

<p>An increase in resolution is achieved by interlacing by a factor of N. This means that N consecutive scans are rotated by a constant angular offset. Each scan in itself still has the physically given angular resolution and frequency. By concatenating N interlaced scans, the angular resolution is increased by the factor N.</p>

<p>Example: The default setting of an MRS1000 is 0.25 degrees horizontal angular resolution at 50 Hz scan frequency without interlacing and an angular range of 275 degrees in total. I.e. each scan measures the distance at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ].</p>

<p>If 0.125 degrees horizontal angular resolution is configured at 25 Hz scan frequency, the scans are performed with 2 times interlacing (N=2). Every 2nd scan is horizontally shifted by 0.125 degrees. I.e. each scan measures alternately at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ] and [ … , 0.125, 0.375, 0.625, 0.875 … ]. 50 single scans per second resp. 25 interlaced scans per second are sent.</p>

<p>If 0.0625 degrees horizontal angular resolution at 12.5 Hz scan frequency is configured, the scans are performed with 4 times interlacing (N=4). Successive scans are shifted horizontally by 0.0625 degrees each. That is, each scan measures alternately at the hor. angles [ …, 0.000, 0.250, 0.500, 0.750, … ], [… , 0.0625, 0.3125, 0.5625, 0.8125 … ], [… , 0.125, 0.375, 0.625, 0.875 … ] and [… , 0.1875, 0.4375, 0.6875, 0.9375 … ]. 50 single scans per second resp. 12.5 interlaced scans per second are sent.</p>

<p>In interlacing mode, laser scan and point cloud messages are published interlaced, too. In rviz, the higher angular resolution is clearly visible when the decay time is increased.</p>

<p>With a scan frequency of 50 Hz and 4 active layers, the lidar will send a new scan line each 0.02 seconds. Each layer is scanned after 0.08 seconds resp. with 12.5 Hz (4 layers multiplied by 12.5 Hz = 50 Hz scan frequency). The point cloud accumulates all active layers and is therefore published with 12.5 Hz (i.e. scan frequency divided by number of layers).</p>

<p>If you check the publishing rate of the point cloud messages of a MRS-1104, you will measure 12.4 Hz, since the scans of 4 layers are accumulated in 1 point cloud message (50 hz scan frequency divided by 4 layers = 12.5 Hz point cloud publishing frequency). The resolution of each single point cloud message is 0.125 [deg]. Only by interleaving 4 consecutive messages you get the high resolution of 0.0625 [deg].</p>

<p>See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#lms1000-and-mrs1000-interlacing">LMS1000 and MRS1000 interlacing</a> for further informations.</p>

<h2 id="networking">Networking</h2>

<p>A TCP connection is needed to receive scan data from a lidar, which requires an appropriate network setup.</p>

<p>Common errors when establishing the TCP connection and possible solutions are described below. If you encounter network errors like “Failed to open TCP connection” when running sick_scan_xd, follow these recommendations.</p>

<p><strong>Static IP addresses</strong></p>

<p>Most lidars have the default IP address 192.168.0.1. It is highly recommended to use a static IPv4 network with IP addresses 192.168.x.y. PC and lidar should use the same subnet. <strong>Avoid using DHCP.</strong></p>

<p>Example IP address of the lidar: 192.168.0.1 (default)</p>

<p>Example IP address of the PC running sick_scan_xd: 192.168.0.100</p>

<p>The IP address of the PC running sick_scan_xd and the lidar must not be identical!</p>

<p>Use <code class="language-plaintext highlighter-rouge">ifconfig -a</code> on Linux resp. <code class="language-plaintext highlighter-rouge">ipconfig /all</code> on Windows to view network settings and lcoal IP addresses.</p>

<ol>
  <li>Try to ping your device:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>
<ol>
  <li>Disconnect your scanner and retry ping</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>
<p>The result of ping contains a pattern like</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ... Destination Host Unreachable
   
</code></pre></div></div>
<ol>
  <li>Reconnect your device and try to ping:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ping 192.168.0.1
   
</code></pre></div></div>

<p>If you do not know the IP addresses, try to find the IP addresses of your PC and your lidar in your subnet:</p>

<ol>
  <li>
    <p>Install fping: <code class="language-plaintext highlighter-rouge">apt-get install fping</code></p>
  </li>
  <li>
    <p>Scan your network (for example, subnet 192.168.10.0/24): <code class="language-plaintext highlighter-rouge">fping -a 192.168.0.1\24</code> to
search for all IP addresses from 192.168.0.0 to 192.168.0.255.</p>
  </li>
</ol>

<p>The result is similar to:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.0.4 is alive
192.168.0.22 is alive

</code></pre></div></div>
<p>and a lot of unreachable entries.
In the example the IP address 192.168.0.4 is the laserscanner MRS1104 and the IP address 192.168.0.22 is the computer running linux. Check this with <code class="language-plaintext highlighter-rouge">ifconfig|grep 192.168.0.22</code>.</p>

<p>We recommend to use wired Ethernet. On Ubuntu, use the “Wired Settings” menu to check the network profile. Network profiles sometimes change automatically when multiple profiles are in use or the lidar has been switched off and on.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/screenshots/network_setup_02.png" alt="network_setup_02.png"></p>

<p><strong>Network configuration with SOPAS ET</strong></p>

<p>The <a href="https://www.sick.com/de/en/catalog/digital-services-and-solutions/software/sopas-engineering-tool/p/p367244">SOPAS Engineering Tool</a> (SOPAS ET) allows a detailed lidar configuration incl. network settings. We recommend to use SOPAS ET in case of network problems or to change the lidars network configuration. The operation manual contains further details.</p>

<p><strong>Diagnostic tools</strong></p>

<p>Network tools can help in case of connection errors. Examples are:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">ping &lt;lidar-ip-address&gt;</code> to check if the lidar is reachable</li>
  <li>
<code class="language-plaintext highlighter-rouge">fping -a 192.168.0.1\24</code> to see ip addresses available in the subnet</li>
  <li>
<code class="language-plaintext highlighter-rouge">netcat &lt;lidar-ip-address&gt; &lt;lidar-tcp-port&gt;</code> to read or write network data</li>
  <li>
<code class="language-plaintext highlighter-rouge">wireshark</code> to monitor and record the network traffic between PC and lidar.</li>
  <li>
<code class="language-plaintext highlighter-rouge">sudo ufw status</code> to see if a firewall is active. If active, disable firewalls with <code class="language-plaintext highlighter-rouge">sudo ufw disable</code>.</li>
</ul>

<h2 id="multiscan100--picoscan100">multiScan100 / picoScan100</h2>

<p><strong>Visual Studio: Breakpoints in Debug Mode disabled</strong></p>

<p>:question: In Windows debug version the compiler does not stop at breakpoints.</p>

<p>:white_check_mark: Check, that you are using the Debug Version. At ‘/Zi’ to compiler settings. Disable optimization.
(see <code class="language-plaintext highlighter-rouge">https://stackoverflow.com/questions/865546/generating-symbols-in-release-binaries-with-visual-studio</code> for details).</p>

<p><strong>Packages lost in benchmark</strong></p>

<p>:question: sick_scan_xd seems to drop packages, when sending 10000 msgpacks with polarscan_sender_test.py from another computer</p>

<p>:white_check_mark: There can be a number of reasons for dropped messages (udp or msgpacks). Besides slow network connection, there can be other pitfalls depending on the system:</p>

<ul>
  <li>
    <p>If Linux or Windows is running in a virtual machine, make sure UDP port 2115 is forwarded. See <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#firewall-configuration">Firewall configuration</a>.</p>
  </li>
  <li>
    <p>Depending on ROS 2 system settings, log messages might be buffered. To really see all log messages of sick_generic_caller, terminate sick_scan_xd/sick_generic_caller (Ctrl-C or kill) and view the ros logfile by <code class="language-plaintext highlighter-rouge">cat ~/.ros/log/sick_scan_*.log</code></p>
  </li>
</ul>

<p><strong>Convert pcapng-files to msgpack or json</strong></p>

<p>:question: How can I convert a pcapng-file with scandata to a msgpack- or json-file?</p>

<p>:white_check_mark: Run the following steps:</p>
<ul>
  <li>Install python msgpack package with <code class="language-plaintext highlighter-rouge">pip install msgpack</code>
</li>
  <li>Play the pcapng-file using multiscan_pcap_player.py</li>
  <li>Receive and convert to msgpack using multiscan_receiver.py</li>
  <li>Convert to json using online-converter https://toolslick.com/conversion/data/messagepack-to-json</li>
</ul>

<p>Linux example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pushd sick_scan_xd/test/python
python3 python multiscan_receiver.py &amp;
python3 multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20210929_multiscan_token_udp.pcapng
mv ./multiscan_dump_12472.msgpack     20210929_multiscan_token_udp.msgpack
mv ./multiscan_dump_12472.msgpack.hex 20210929_multiscan_token_udp.msgpack.hex
popd

</code></pre></div></div>
<p>Then paste the content of file <code class="language-plaintext highlighter-rouge">20210929_multiscan_token_udp.msgpack.hex</code> in https://toolslick.com/conversion/data/messagepack-to-json and save the json-output.</p>

<p>Windows example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pushd sick_scan_xd\test\python
python --version
REM Convert 20220915_multiscan_msgpack_output.pcapng (16-bit RSSI record) to msgpack resp. json
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
start python multiscan_receiver.py
python multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20220915_multiscan_msgpack_output.pcapng --udp_port=2115
move /y .\multiscan_dump_23644.msgpack     20220915_multiscan_msgpack_output.msgpack
move /y .\multiscan_dump_23644.msgpack.hex 20220915_multiscan_msgpack_output.msgpack.hex
REM Convert 20210929_multiscan_token_udp.pcapng (8-bit RSSI record) to msgpack resp. json
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
start python multiscan_receiver.py
python multiscan_pcap_player.py --pcap_filename=../emulator/scandata/20210929_multiscan_token_udp.pcapng --verbose=0
move /y .\multiscan_dump_12472.msgpack     20210929_multiscan_token_udp.msgpack
move /y .\multiscan_dump_12472.msgpack.hex 20210929_multiscan_token_udp.msgpack.hex
del /f/q multiscan_dump*.msgpack
del /f/q multiscan_dump*.msgpack.hex
popd

</code></pre></div></div>
<p>Then paste the content of files <code class="language-plaintext highlighter-rouge">20220915_multiscan_msgpack_output.msgpack.hex</code> resp. <code class="language-plaintext highlighter-rouge">20210929_multiscan_token_udp.msgpack.hex</code> in https://toolslick.com/conversion/data/messagepack-to-json and save the json-output.</p>

<h1 id="troubleshooting-and-technical-support">Troubleshooting and technical support</h1>

<p>The software is based on the ROS drivers sick_scan, sick_scan_base and sick_scan2. For FAQ and troubleshooting please also have a look at https://github.com/SICKAG/sick_scan , https://github.com/SICKAG/sick_scan_base and https://github.com/SICKAG/sick_scan2 .
Common problems might be solved in closed issues.</p>

<ol>
  <li>Check Scanner IP in the launch file.</li>
  <li>Check Ethernet connection to scanner with netcat e.g.
<code class="language-plaintext highlighter-rouge">nc -z -v -w5 $SCANNERIPADDRESS 2112
</code>.
For further details about setting up the correct ip settings see <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#ip-address-configuration">IP configuration</a>)</li>
  <li>View node startup output wether the IP connection could be established</li>
  <li>Check the scanner status using the LEDs on the device. The LED codes are described in the above mentioned operation manuals.</li>
  <li>Further testing and troubleshooting informations can found in the file test/readme_testplan.txt</li>
  <li>If you stop the scanner in your debugging IDE or by other hard interruption (like Ctrl-C), you must wait until 60 sec. before
the scanner is up and running again. During this time the MRS6124 reconnects twice.
If you do not wait this waiting time you could see one of the following messages:
    <ul>
      <li>TCP connection error</li>
      <li>Error-Message 0x0d</li>
    </ul>
  </li>
  <li>Amplitude values in rviz: If you see only one color in rviz try the following:
Set the min/max-Range of intensity display in the range [0…200] and switch on the intensity flag in the launch file</li>
  <li>In case of network problems check your own ip address and the ip address of your laser scanner (by using SOPAS ET).
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>List of own IP-addresses: ifconfig</td>
              <td>grep “inet addr”</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Try to ping scanner ip address (used in launch file)</li>
    </ul>
  </li>
  <li>If the driver stops during init phase please stop the driver with ctrl-c and restart (could be caused due to protocol ASCII/Binary cola-dialect)</li>
</ol>

<p>In case of technical support please open a new issue. For optimal support, add the following information to your request:</p>

<ol>
  <li>Scanner model name,</li>
  <li>Ros node startup log,</li>
  <li>Sopas file of your scanner configuration. The instructions at https://sickconnect.com/create-and-download-a-sopas-file/ show how to create the Sopas file.</li>
</ol>

<p>In case of application support please use <a href="https://support.sick.com">https://support.sick.com</a>.</p>

<h1 id="creators-and-contribution">Creators and contribution</h1>

<p>Michael Lehning (http://www.lehning.de) on behalf of SICK AG (https://www.sick.com/)</p>

<p>This <a href="https://github.com/SICKAG/sick_scan_xd/tree/develop//CONTRIBUTING.md">documentation</a> is intended to provide background information on the maintenance and extension of the repository.</p>

<h1 id="keywords">Keywords</h1>

<p>MRS1000, MRS1104, LMS1000, LMS1104, MRS6000, MRS6124, RMS1xxx, RMS1000, RMSxxxx, ROS LiDAR, SICK LiDAR, SICK Laser, SICK Laserscanner, SICK Radar, LMS1xx, MRS1xxx, LMS1xxx, MRS6xxx, TiM5xx, TiM551, TiM561, TiM571, TiM781, TiM781S, LMS5xx, LMS511, NAV210, NAV245, NAV310, LD-MRS, LRS4000, LD-LRS3600, LD-LRS3601, LD-LRS3611, LD-OEM1500, LD-OEM1501, multiScan100, multiScan, picoScan100, picoScan150, picoScan120, multiScan136, multiScan165</p>
</div>
            
          </div>
        </div>

        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">CONTRIBUTING</h3></div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<p><img align="right" width="200" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Logo_SICK_AG_2009.svg/1200px-Logo_SICK_AG_2009.svg.png"></p>

<h2 id="executive-summary">Executive Summary</h2>

<p>This documentation is intended to provide background information on the maintenance and extension of the repository.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#adding-a-new-device-to-the-driver">Adding a new device to the driver</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#naming-convention">Naming Convention</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#launch-files">Launch Files</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#code-modification">Code Modification</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#bloom-release">Bloom release</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#first-time-installation-of-toolchain">First time installation of toolchain</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#release-build-for-ros-1">Release build for ROS 1</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#release-build-for-ros-2">Release build for ROS 2</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#check-status">Check status</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#useful-links-and-information">Useful links and information</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#testing">Testing</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#unit-tests">Unit tests</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#examples">Examples</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#simulation">Simulation</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#windows">Windows</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#linux">Linux</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#profiling">Profiling</a>
    <ul>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#installation">Installation</a></li>
      <li><a href="https://github.com/SICKAG/sick_scan_xd/tree/develop/#usage">Usage</a></li>
    </ul>
  </li>
</ul>

<h1 id="adding-a-new-device-to-the-driver">Adding a new device to the driver</h1>

<p>This driver is designed to support several different scanner types (including radar) from Sick. This documentation describes how to add additional devices to the driver.</p>

<h2 id="naming-convention">Naming Convention</h2>

<p>For each device type a name pattern is assigned as follows:
<code class="language-plaintext highlighter-rouge">
sick_&lt;device family&gt;_&lt;identifier&gt;
</code></p>

<p>The name type is used in the code to decide which scanner-specific parameters are set.
The name type is passed as a parameter as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;param name="scanner_type" type="string" value="sick_lms_5xx" /&gt;

</code></pre></div></div>

<h2 id="launch-files">Launch Files</h2>

<p>A launch file is created for each device type,
which usually has the same naming convention as the scanner type.
To create a new device, it is recommended to copy, rename and edit an existing launch file.</p>

<h2 id="code-modification">Code Modification</h2>

<ol>
  <li>Hint: Construction of parser:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sick_scan_xd::SickGenericParser *parser = new sick_scan_xd::SickGenericParser(scannerName);
    
</code></pre></div></div>
<ol>
  <li>
    <p>Add string constant like the constant SICK_SCANNER_RMS_XXXX_NAME</p>
  </li>
  <li>
    <p>Append this constant to allowedScannerNames
like allowedScannerNames.push_back(SICK_SCANNER_RMS_XXXX_NAME);
in the file sick_generic_parser.cpp</p>
  </li>
  <li>
    <p>Add new parameter block like</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	if (basicParams[i].getScannerName().compare(SICK_SCANNER_MRS_1XXX_NAME) == 0)
	{...
	} in the file sick_generic_parser.cpp
	
</code></pre></div></div>

<ol>
  <li>Copy the file sick_generic_radar.cpp and add a new class following the structure
of this file.</li>
</ol>

<h1 id="bloom-release">Bloom release</h1>

<h2 id="first-time-installation-of-toolchain">First time installation of toolchain</h2>

<ol>
  <li>Install on Linux:
    <ul>
      <li>Install bloom:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        sudo apt-get update
        sudo apt-get install python3-bloom python3-catkin-pkg
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Install docker:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        pushd /tmp
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        sudo usermod -aG docker $USER
        popd
        shutdown -r now # reboot
        # short quicktest
        docker --version
        docker info
        docker run hello-world
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Install ros-buildfarm:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        # sudo apt-get install python3-ros-buildfarm # not successfully, unable to locate
        pip3 install ros-buildfarm # installs ros-buildfarm 3.0 successfully
        
</code></pre></div></div>

<ol>
  <li>Build the prerelease:
    <ul>
      <li>Short version to build a prerelase:
        <ul>
          <li>Run the following commands:</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            mkdir -p ./ws_sick_scan_xd_bloom/src
            cd ./ws_sick_scan_xd_bloom/src
            git clone -b master https://github.com/SICKAG/sick_scan_xd.git
            cd ./sick_scan_xd/test/scripts
            ./run_linux_ros1_bloom.bash
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * Fix any errors during the prerelease build and check in
    * Repeat `./run_linux_ros1_bloom.bash` until the the prerelease build finishes without errors
* Alternative version:
    * Open http://prerelease.ros.org/noetic in the brower
    * Add a custom repository: `sick_scan_xd` , `https://github.com/SICKAG/sick_scan_xd` , `master` (or `feature/bloom_pretest` or any other branch to test)
    * Add a custom repository: `msgpack11` , `https://github.com/SICKAG/msgpack11` , `master`
    * Add a custom repository: `libsick_ldmrs` , `https://github.com/SICKAG/libsick_ldmrs` , `master`
    * Confirm next steps (i.e. URL of build farm: https://raw.githubusercontent.com/ros-infrastructure/ros_buildfarm_config/production/index.yaml, Ubuntu focal)
    * Click on `Generate command`
    * Run the generated command, i.e.:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            source /opt/ros/noetic/setup.bash
            mkdir -p /tmp/prerelease_job
            cd /tmp/prerelease_job
            generate_prerelease_script.py \
              https://raw.githubusercontent.com/ros-infrastructure/ros_buildfarm_config/production/index.yaml \
              noetic default ubuntu focal amd64 \
              --custom-repo \
                sick_scan_xd:git:https://github.com/SICKAG/sick_scan_xd:master \
                msgpack11:git:https://github.com/SICKAG/msgpack11:master \
                libsick_ldmrs:git:https://github.com/SICKAG/libsick_ldmrs:master \
              --level 1 \
              --output-dir ./
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * Run `printf "\033c" ; rm -rf ~/.ccache ; mkdir -p ~/.ccache ; ./prerelease.sh` in folder `/tmp/prerelease_job`
    * In case of error message `/usr/lib/ccache/cc is not able to compile a simple test program`:
        * Remove folder `~/.ccache` before running `./prerelease.sh`
        * See https://answers.ros.org/question/347063/error-pre-release-melodic/
    * Fix any errors during the prerelease build and check in
    * Remove the temporary build folder by `rm -rf /tmp/prerelease_job`
    * Repeat until `prerelease.sh` finishes without errors.
</code></pre></div></div>

<ol>
  <li>Submit package sick_scan_xd for indexing (noetic)
    <ul>
      <li>Fork <code class="language-plaintext highlighter-rouge">https://github.com/ros/rosdistro</code> -&gt; <code class="language-plaintext highlighter-rouge">https://github.com/&lt;username&gt;/rosdistro.git</code>
</li>
      <li><code class="language-plaintext highlighter-rouge">git clone https://github.com/&lt;username&gt;/rosdistro.git</code></li>
      <li>Edit file <code class="language-plaintext highlighter-rouge">rosdistro/noetic/distribution.yaml</code> and add after <code class="language-plaintext highlighter-rouge">sick_scan</code>:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        sick_scan_xd:
          doc:
            type: git
            url: https://github.com/SICKAG/sick_scan_xd.git
            version: master
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* `cd rosdistro ; source /opt/ros/noetic/setup.bash ; rosdistro_reformat file://"$(pwd)"/index.yaml`
* git commit: `git commit -m "Adding sick_scan_xd to documentation index for distro noetic" distribution.yaml`
* git push: `git push origin master`
* Submit a pull request on `https://github.com/&lt;username&gt;/rosdistro`
</code></pre></div></div>

<ol>
  <li>For ROS 2 humble: Follow instructions on https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html</li>
</ol>

<p><strong><em>NOTE:</em></strong> Bloom releases for ROS 2 foxy are not longer supported (Pull request failed, “This pull request changes files for a ROS distribution that is no longer supported (End Of Life)”)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Submit package sick_scan_xd for indexing (ROS 2 humble)
    * Reset fork `https://github.com/&lt;username&gt;/rosdistro.git` to origin/master or delete the fork and create a new one -&gt; `https://github.com/&lt;username&gt;/rosdistro.git`
    * `git clone https://github.com/&lt;username&gt;/rosdistro.git`
    * Edit file `rosdistro/humble/distribution.yaml` and add after `sick_safevisionary_ros2`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            sick_scan_xd:
              doc:
                type: git
                url: https://github.com/SICKAG/sick_scan_xd.git
                version: develop
              status: developed
            
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * git commit and push ("Adding sick_scan_xd to documentation index for distro humble")
    * Submit a pull request on `https://github.com/&lt;username&gt;/rosdistro`
    * Do the same for any new ROS 2 version, e.g. iron and jazzy (`rosdistro/iron/distribution.yaml`, `rosdistro/jazzy/distribution.yaml`)
* [Start a new release team](https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&amp;labels=&amp;template=new_release_team.md&amp;title=Add+release+team)
    * ROS 2 sick_scan_xd team: https://github.com/orgs/ros2-gbp/teams/sick_scan_xd
    * ROS 2 sick_scan_xd release repository: https://github.com/ros2-gbp/sick_scan_xd-release
</code></pre></div></div>

<h2 id="release-build-for-ros-1">Release build for ROS 1</h2>

<ul>
  <li>Build a prerelease (dry run in a docker container):
    <ul>
      <li>Run the following commands:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        git clone -b master https://github.com/SICKAG/sick_scan_xd.git
        cd ./sick_scan_xd/test/scripts
        sudo dos2unix ./*.bash ; sudo chmod a+x ./*.bash
        ./run_linux_ros1_bloom.bash
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Fix any errors during the prerelease build and check in
* Repeat `./run_linux_ros1_bloom.bash` until the the prerelease build finishes without errors
</code></pre></div></div>

<ul>
  <li>Build a binary release: follow https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease
    <ul>
      <li>Update version number in package.xml, minor version number should be incremented at least</li>
      <li>Create resp. update CHANGELOG.rst:</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        cd ./src/sick_scan_xd
        rm ./CHANGELOG.rst
        catkin_generate_changelog --all # create CHANGELOG.rst
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Commit and pull all changes incl. CHANGELOG.rst and package.xml:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        git add CHANGELOG.rst package.xml
        git commit -m "Update CHANGELOG.rst and package version"
        git push
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Run `catkin_prepare_release` and `bloom-release` in folder `src/sick_scan_xd`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        catkin_prepare_release -y
        bloom-release --rosdistro noetic --track noetic sick_scan_xd # at first time: call with option --edit for configuration
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* For the initial release (first time): Run `bloom-release` in folder `src/sick_scan_xd` with option `--edit`:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        source /opt/ros/noetic/setup.bash
        catkin_prepare_release -y
        bloom-release --rosdistro noetic --track noetic sick_scan_xd --edit
        Release repository url: https://github.com/SICKAG/sick_scan_xd-release.git
        upstream: &lt;default, i.e. press ENTER&gt;
        Upstream Repository URI: https://github.com/SICKAG/sick_scan_xd.git
        Upstream VCS Type: &lt;default: git, i.e. press ENTER&gt;
        Version: &lt;default: auto, i.e. press ENTER&gt;
        Release Tag: &lt;default: version, i.e. press ENTER&gt;
        Upstream Devel Branch: feature/bloom_pretest
        ROS Distro: noetic
        Patches Directory: &lt;default: none, i.e. press ENTER&gt;
        Release Repository Push URL:  &lt;default: none, i.e. press ENTER&gt;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Check status: https://index.ros.org/p/sick_scan_xd/#noetic
* Install binary release: `sudo apt update ; sudo apt-get install ros-noetic-sick-scan-xd`. Note from https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease : Packages built are periodically synchronized over to the shadow-fixed and public repositories, so it might take as long as a month before your package is available on the public ROS debian repositories (i.e. available via apt-get).
</code></pre></div></div>

<h2 id="release-build-for-ros-2">Release build for ROS 2</h2>

<p>For ROS 2 follow the instructions on https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html :</p>
<ul>
  <li>Checkout the sick_scan_xd version to be released and run:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    git clone -b master https://github.com/SICKAG/sick_scan_xd.git
    cd ./sick_scan_xd
    rm ./CHANGELOG.rst
    catkin_generate_changelog --all # create CHANGELOG.rst
    
</code></pre></div></div>
<ul>
  <li>Commit CHANGELOG.rst and optional modifications:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    git add CHANGELOG.rst
    git commit -m "Update CHANGELOG.rst"
    git push
    
</code></pre></div></div>
<ul>
  <li>Run <code class="language-plaintext highlighter-rouge">catkin_prepare_release</code> and <code class="language-plaintext highlighter-rouge">bloom-release</code>:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    bloom-release --rosdistro humble --track humble sick_scan_xd # at first time: call with option --new-track
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For the initial release (i.e. at the first time): Run bloom-relase configuration with option --new-track:
`bloom-release --new-track --rosdistro humble --track humble sick_scan_xd`
* Release repository url: https://github.com/ros2-gbp/sick_scan_xd-release.git
* Upstream: &lt;default&gt;
* Upstream Repository URI: https://github.com/SICKAG/sick_scan_xd.git
* Upstream Devel Branch: develop
* ROS Distro: humble
After the initial release has been approved: Run
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sudo rosdep init
    rosdep update
    
</code></pre></div></div>

<h2 id="check-status">Check status</h2>
<p>Jenkins build status:</p>
<ul>
  <li>ROS 1 noetic jenkins build status: https://build.ros.org/job/Ndev__sick_scan_xd__ubuntu_focal_amd64/lastBuild/</li>
  <li>ROS 2 humble jenkins build status: https://build.ros2.org/job/Hdev__sick_scan_xd__ubuntu_jammy_amd64/lastBuild/</li>
  <li>ROS 2 iron   jenkins build status: https://build.ros2.org/job/Idev__sick_scan_xd__ubuntu_jammy_amd64/lastBuild/</li>
  <li>ROS 2 jazzy  jenkins build status: https://build.ros2.org/job/Jdev__sick_scan_xd__ubuntu_noble_amd64/lastBuild/</li>
  <li>ROS 1 jenkins: https://build.ros.org/search/?q=sick_scan_xd</li>
  <li>ROS 2 jenkins: https://build.ros2.org/search/?q=sick_scan_xd</li>
</ul>

<p>Release repositories:</p>
<ul>
  <li>ROS 1 release repository: https://github.com/SICKAG/sick_scan_xd-release</li>
  <li>ROS 2 release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git</li>
</ul>

<p>Show version and list information about prebuilt binaries:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt show ros-noetic-sick-scan-xd
sudo apt show ros-humble-sick-scan-xd
sudo apt show ros-iron-sick-scan-xd
sudo apt show ros-jazzy-sick-scan-xd

</code></pre></div></div>

<p>Installation of prebuilt binaries:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt update
sudo apt-get install ros-noetic-sick-scan-xd
sudo apt-get install ros-humble-sick-scan-xd
sudo apt-get install ros-iron-sick-scan-xd
sudo apt-get install ros-jazzy-sick-scan-xd
sudo apt-get remove ros-noetic-sick-scan-xd
sudo apt-get remove ros-humble-sick-scan-xd
sudo apt-get remove ros-iron-sick-scan-xd
sudo apt-get remove ros-jazzy-sick-scan-xd

</code></pre></div></div>

<h2 id="useful-links-and-information">Useful links and information</h2>

<ul>
  <li>http://wiki.ros.org/bloom</li>
  <li>https://wiki.ros.org/bloom/Tutorials/FirstTimeRelease</li>
  <li>https://docs.ros.org/en/humble/How-To-Guides/Releasing/Releasing-a-Package.html</li>
</ul>

<p><strong>Bloom builds an old sick_scan_xd version (ROS 1)</strong></p>

<p>Check <code class="language-plaintext highlighter-rouge">devel_branch</code> in https://github.com/SICKAG/sick_scan_xd-release/blob/master/tracks.yaml . If devel_branch is an old branch, replace it with e.g. <code class="language-plaintext highlighter-rouge">develop</code> or <code class="language-plaintext highlighter-rouge">master</code>, or update the <code class="language-plaintext highlighter-rouge">&lt;devel_branch&gt;</code> to a new version.</p>

<p><strong>Bloom builds an old sick_scan_xd version (ROS 2)</strong>
Check <code class="language-plaintext highlighter-rouge">devel_branch</code> in https://github.com/ros2-gbp/sick_scan_xd-release/blob/master/tracks.yaml . If devel_branch is an old branch, replace it with e.g. <code class="language-plaintext highlighter-rouge">develop</code> or <code class="language-plaintext highlighter-rouge">master</code>, or update the <code class="language-plaintext highlighter-rouge">&lt;devel_branch&gt;</code> to a new version.</p>

<p><strong>Bloom builds a new sick_scan_xd version, but apt still installs an old version</strong></p>

<ul>
  <li>Check the sick_scan_xd version in the release repositories https://github.com/SICKAG/sick_scan_xd-release.git (ROS 1) and https://github.com/ros2-gbp/sick_scan_xd-release.git (ROS 2)</li>
  <li>Install bloom (if not yet done) using <code class="language-plaintext highlighter-rouge">sudo apt-get install python-bloom</code> on Linux or <code class="language-plaintext highlighter-rouge">pip install -U bloom</code> on Windows</li>
  <li>Run</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        bloom-release --rosdistro noetic -d sick_scan_xd # release repository: https://github.com/SICKAG/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro humble -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro iron   -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        bloom-release --rosdistro jazzy  -d sick_scan_xd # release repository: https://github.com/ros2-gbp/sick_scan_xd-release.git, argument -d enables debug infos
        
</code></pre></div></div>
<ul>
  <li>In case of github 2FA errors: Follow http://wiki.ros.org/bloom/Tutorials/GithubManualAuthorization to create a 2FA token and configure the token in file <code class="language-plaintext highlighter-rouge">~/.config/bloom</code>.</li>
  <li>Note: Updates of release repository https://github.com/SICKAG/sick_scan_xd-release.git require github authentification via ssh. See https://docs.github.com/en/authentication/connecting-to-github-with-ssh and https://wiki.ros.org/bloom/Tutorials/GithubManualAuthorization for details.</li>
</ul>

<h1 id="testing">Testing</h1>

<h2 id="unit-tests">Unit tests</h2>

<p>For a quick unit test after installation without the sensor hardware, a test server is provided to simulate a scanner. It implements a simple tcp server, which responds to binary cola messages and sends predefined LMDscandata to a tcp-client. The sick_scan_xd driver can connect to the local test server instead of the lidar device for offline-tests. Please note, that this test server does not emulate a Lidar sensor. It just sends some simple scan data and response messages to a tcp client. It can be used for a quick unit test after build and install.</p>

<p>To build the test server, activate cmake option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> in CMakeLists.txt and rebuild sick_scan_xd. By default, option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> is switched off.</p>

<p>For a unit test of LMS1xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_lms1xx.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms1xx.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_lms_1xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS5xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_lms5xx.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_lms5xx.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS7xx, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_tim_7xx.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>For a unit test of LMS7xxS, run the following commands in different terminals:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd
source ./install/setup.bash

# Start sick_scan_xd emulator
roslaunch sick_scan_xd emulator_01_default.launch &amp;
sleep 1

# Start rviz
rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg.rviz &amp;
sleep 1

# Start sick_scan_xd driver
roslaunch sick_scan_xd sick_tim_7xxS.launch hostname:=127.0.0.1

</code></pre></div></div>

<p>Alternatively, you can just run the test scripts provided in folder <code class="language-plaintext highlighter-rouge">sick_scan_xd/test/scripts</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd sick_scan_xd/test/scripts
./makeall.bash
./run_simu_lms1xx.bash
./run_simu_lms5xx.bash
./run_simu_tim7xx_tim7xxS.bash

</code></pre></div></div>

<p>Make sure to finish all sick_scan_xd nodes after a test. All nodes can be killed by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosnode kill -a ; sleep 1
killall sick_generic_caller ; sleep 1
killall sick_scan_emulator ; sleep 1

</code></pre></div></div>

<h2 id="examples">Examples</h2>

<p>rviz example screenshots using sick_scan_xd with LMS1xx and LMS5xx test server:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/emulator_lms1xx_screenshot.png" alt="emulator_lms1xx_screenshot.png"></p>

<p>rviz example screenshots using sick_scan_xd with LMS7xx and LMS7xxS test server:</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/emulator_lms7xx_screenshot.png" alt="emulator_lms1xx_screenshot.png"></p>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h1 id="simulation">Simulation</h1>

<p>For unittests without sensor hardware, a simple test server is provided. To build the test server, call either cmake with option <code class="language-plaintext highlighter-rouge">-DCMAKE_ENABLE_EMULATOR=1</code>, or activate cmake option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> in CMakeLists.txt. Then rebuild sick_scan_xd. By default, option <code class="language-plaintext highlighter-rouge">ENABLE_EMULATOR</code> is switched off.</p>

<p>Please note that this just builds a simple test server for basic unittests of sick_scan_xd drivers. Its purpose is to run basic tests and to help with diagnosis in case of issues. It does not emulate a real scanner!</p>

<p>Simulation requires jsoncpp. Install with <code class="language-plaintext highlighter-rouge">sudo apt-get install libjsoncpp-dev</code> on Linux and with <code class="language-plaintext highlighter-rouge">vcpkg install jsoncpp:x64-windows</code> on Windows.</p>

<p>You can find examples to test and run sick_scan_xd in offline mode in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>. Their purpose is to demonstrate the usage of the sick_scan_xd driver. Please feel free to customize the scripts or use them as a starting point for own projects.</p>

<h2 id="windows">Windows</h2>

<p>Run script <code class="language-plaintext highlighter-rouge">run_simu_lms_5xx.cmd</code> in folder <code class="language-plaintext highlighter-rouge">test/scripts</code> or execute the following commands:</p>

<ol>
  <li>Start the test server:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    cd .\build
    start "testserver" cmd /k python ../test/emulator/test_server.py --scandata_file=../test/emulator/scandata/20210302_lms511.pcapng.scandata.txt --scandata_frequency=20.0 --tcp_port=2112
    @timeout /t 1
    
</code></pre></div></div>

<ol>
  <li>Run sick_generic_caller. On native Windows:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    .\Debug\sick_generic_caller.exe ../launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False
    
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>On Windows with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False
    
</code></pre></div></div>

<ol>
  <li>Open file <code class="language-plaintext highlighter-rouge">image_viewer.html</code> in folder <code class="language-plaintext highlighter-rouge">demo</code> in your browser to view a jpg-image of the current scan.</li>
</ol>

<p>Note, that python version 3 incl. runtime dlls must be accessable, f.e. by extending the PATH environment variable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set PYTHON_DIR=%ProgramFiles(x86)%/Microsoft Visual Studio/Shared/Python37_64
set PATH=%PYTHON_DIR%;%PYTHON_DIR%/Scripts;c:\vcpkg\installed\x64-windows\bin;%PATH%

</code></pre></div></div>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h2 id="linux">Linux</h2>

<p>Run script <code class="language-plaintext highlighter-rouge">run_simu_lms_5xx.bash</code> in folder <code class="language-plaintext highlighter-rouge">test/scripts</code> or execute the following commands:</p>

<ol>
  <li>Start the test server:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    python3 ./test/emulator/test_server.py --scandata_file=./test/emulator/scandata/20210302_lms511.pcapng.scandata.txt --scandata_frequency=20.0 --tcp_port=2112 &amp;
    sleep 1
    
</code></pre></div></div>

<ol>
  <li>Run sick_generic_caller.
    <ul>
      <li>On native Linux:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        ./build/sick_generic_caller ./launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 1:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        ros2 run sick_scan_xd sick_generic_caller ./src/sick_scan_xd/launch/sick_lms_5xx.launch hostname:=127.0.0.1 sw_pll_only_publish:=False &amp;
        
</code></pre></div></div>

<ol>
  <li>View the point cloud.
    <ul>
      <li>On native Linux:<br>
   Open file <code class="language-plaintext highlighter-rouge">image_viewer.html</code> in folder <code class="language-plaintext highlighter-rouge">demo</code> in a browser (f.e. firefox) to view a jpg-image of the current scan.</li>
      <li>On Linux with ROS 1:</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        rosrun rviz rviz -d ./src/sick_scan_xd/test/emulator/config/rviz_emulator_cfg_lms5xx.rviz &amp;
        
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- On Linux with ROS 2:
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        rviz2 -d ./src/sick_scan_xd/test/emulator/config/rviz2_lms5xx.rviz &amp;
        
</code></pre></div></div>

<p>Further examples are provided in folder <code class="language-plaintext highlighter-rouge">test/scripts</code>.</p>

<h1 id="profiling">Profiling</h1>

<p>Since the existing node can basically be used on different platforms, bottlenecks can occur with weak hardware. To better analyze these bottlenecks, software profiling can be performed.
The following example shows how to perform profiling.
For further details on profiling, please refer to https://baptiste-wicht.com/posts/2011/09/profile-c-application-with-callgrind-kcachegrind.html, for example.</p>

<h2 id="installation">Installation</h2>

<p>First of all, you need to install Callgrind and KCachegrind.
You also need to install graphviz in order to view the call graph in KCachegrind. The applications are already packaged for the most important Linux distributions. You can just use apt-get to install them:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install valgrind kcachegrind graphviz

</code></pre></div></div>
<h2 id="usage">Usage</h2>
<p>We have to start by profiling the application with Callgrind. To profile an application with Callgrind, you just have to prepend the Callgrind invocation in front of your normal program invocation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind --tool=callgrind program [program_options]

</code></pre></div></div>
<p>In order to establish a reference to the source code during profiling, the program must be compiled with debug symbols, this can be done with catkin_make</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catkin_make install -DCMAKE_BUILD_TYPE=Debug

</code></pre></div></div>
<p>It is necessary to create a rosmaster so that the sick_scan_xd node can connect to it because we can’t use roslaunch during profiling.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roscore

</code></pre></div></div>
<p>To set the parameters we start a node as usual with roslaunch.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=192.168.0.151

</code></pre></div></div>
<p>While this node is running we can use
<code class="language-plaintext highlighter-rouge">ps -aef| grep sick_scan_xd
</code> to determine the program path and the call parameters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosuser@ROS-NB:~$ ps -aef|grep sick_scan_xd
rosuser   4839  2443  0 14:43 pts/1    00:00:00 /usr/bin/python /opt/ros/melodic/bin/roslaunch sick_scan_xd sick_lms_5xx.launch hostname:=192.168.0.151
rosuser   4854  4839  1 14:43 ?        00:00:03 /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller __name:=sick_lms_5xx __log:=/home/rosuser/.ros/log/f9861670-304c-11e9-9839-54e1ad2921b6/sick_lms_5xx-1.log
rosuser   4910  4875  0 14:46 pts/6    00:00:00 grep --color=auto sick_scan_xd

</code></pre></div></div>
<p>now we can close the node and restart with callgrid</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind --tool=callgrind program /home/rosuser/ros_catkin_ws/devel/lib/sick_scan_xd/sick_generic_caller __name:=sick_lms_5xx

</code></pre></div></div>
<p>The result will be stored in a callgrind.out.XXX file where XXX will be the process identifier.
You can read this file using a text editor, but it won’t be very useful because it’s very cryptic.
That’s here that KCacheGrind will be useful. You can launch KCacheGrind using command line
or in the program menu if your system installed it here. Then, you have to open your profile file.</p>

<p>The first view present a list of all the profiled functions. You can see the inclusive
and the self cost of each function and the location of each one.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/src_view.png" alt="src_view.png"></p>

<p>Once you click on a function, the other views are filled with information. The view in uppper right part of the window gives some information about the selected function.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/profile_002.png" alt="profile_002"></p>

<p>The view have several tabs presenting different information:</p>

<ul>
  <li>Types : Present the types of events that have been recorded. In our case, it’s not really interesting, it’s just the number of instructions fetch</li>
  <li>Callers : List of the direct callers.</li>
  <li>All Callers : List of all the callers, it seems the callers and the callers of the callers.</li>
  <li>Callee Map : A map of the callee, personally, I do not really understand this view, but it’s a kind of call graph representing the cost of the functions.</li>
  <li>Source code : The source code of the function if the application has been compiled with the debug symbol.</li>
</ul>

<p>And finally, you have another view with data about the selected function.</p>

<p><img src="https://raw.githubusercontent.com/SICKAG/sick_scan_xd/develop/doc/profile_003.png" alt="profile_003"></p>

<p>Again, several tabs:</p>

<ul>
  <li>Callees : The direct callees of the function</li>
  <li>Call Graph : The call graph from the function to the end</li>
  <li>All Callees : All the callees and the callees of the callees</li>
  <li>Caller Map : All functions are represented as blocks the size corresponds to their CPU time. Callees are stacked on the callers.</li>
  <li>Machine Code : The machine code of the function if the application has been profiled with –dump-instr=yes option</li>
</ul>

<p>You have also several display options and filter features to find exactly what you want and display it the way you want.</p>

<p>The information provided by KCacheGrind can be very useful to find which functions takes too much time or which functions are called too much.
This text is an adopted version of https://baptiste-wicht.com/posts/2011/09/profile-c-application-with-callgrind-kcachegrind.html . Thanks to Baptiste Wicht.</p>
</div>
              <hr id="iron-contribute-lists">
              <ul class="nav nav-tabs nav-justified" id="iron-contribute-lists-tabs">
                <li class="better-tabs active">
                  <a href="#iron-contribute-lists-help-wanted" data-toggle="tab"><span class="contribute-lists-help-wanted-count label label-primary">0</span> Help Wanted</a>
                </li>
                <li class="better-tabs">
                  <a href="#iron-contribute-lists-good-first-issue" data-toggle="tab"><span class="contribute-lists-good-first-issue-count label label-primary">0</span> Good First Issue</a>
                </li>
                <li class="better-tabs">
                  <a href="#iron-contribute-lists-pull-requests" data-toggle="tab"><span class="contribute-lists-pull-requests-count label label-primary">0</span> Pull Requests to Review</a>
                </li>
              </ul>
              <div class="tab-content contribute-lists">
                <div class="tab-pane active" id="iron-contribute-lists-help-wanted">
                  <div class="contribute-lists-help-wanted"></div>
                </div>
                <div class="tab-pane" id="iron-contribute-lists-good-first-issue">
                  <div class="contribute-lists-good-first-issue"></div>
                </div>
                <div class="tab-pane" id="iron-contribute-lists-pull-requests">
                  <div class="contribute-lists-pull-requests"></div>
                </div>
              </div>
            
          </div>
        </div>

        
        
      
    </div>
  </div>

  <div class="distro distro-melodic">
    <div class="container-fluid">
      <div class="well well-sm">
  <div>
    
  </div>
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px;" src="/assets/repo.png">
      </td>
      <td>
        <h3><a style="text-decoration:none;" href="/r/sick_scan_xd">sick_scan_xd</a> <small>repository</small></h3>
        <span class="label label-default">mrs</span> <span class="label label-default">lrs</span> <span class="label label-default">lms</span> <span class="label label-default">rms</span> <span class="label label-default">tim</span> <span class="label label-default">ldmrs</span> 
        

      </td>
    </tr>
  </table>
  <div class="top-buffer">
    
    
<table class="table table-condensed instance-switch">
  <tr>
    <td>
      <div id="repo-switch" class="btn-group btn-group-justified" role="group">
        <div class="btn-group" style="width: 90%" role="group">
          <div class="dropdown">
            <!-- TODO: add disabled when only 1 version is known? -->
            <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" title="Select Instance">
              <span class="pull-left" style="width: 100%; text-align: left">
                <span class="pull-right"><span class="caret"></span></span> 
              <span class="glyphicon glyphicon-star"></span>
                  github-SICKAG-sick_scan_xd
              </span>
            </button>
            <ul class="dropdown-menu" role="menu">
              
                <li role="presentation">
                  <a id="github-SICKAG-sick_scan_xd" role="menuitem" tabindex="-1" href="/r/sick_scan_xd/github-SICKAG-sick_scan_xd" data="github-SICKAG-sick_scan_xd">
                    <span class="glyphicon glyphicon-star"></span>
                    github-SICKAG-sick_scan_xd
                  </a>
                </li>
              
            </ul>
          </div>
        </div>
      </div>
    </td>
  </tr>
</table>

  </div>
  <div class="top-buffer">
  </div>
</div>

      
        <div class="alert alert-warning" role="alert">No version for distro <strong>melodic</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>


<script src=/js/contribution_suggestions.js></script>
<script type="text/javascript">
  $(function() {
    setupContributeListTabLinks();
  });
  $(document).ready(function() {
    setupDistroSwitch("humble");
    setupContributeLists("https://github.com/SICKAG/sick_scan_xd.git");
  });
</script>

      </div>
    </div>

    <footer class="site-footer">
  <div class="wrapper">
    <div class="container-fluid">
      <div style="float:left;">
        
          <a href="https://github.com/rkent/rosindex" title="Find rosindex in Github">
          <span class="icon  icon--github">
            <svg viewBox="0 0 16 16">
              <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
            </svg>
          </span>

          <span class="username">rkent/rosindex</span>
        </a>
        <em class="hidden-xs">| generated on 2025-05-05</em>
      
      </div>
      <div style="float:right;">
        <p class="text"><span class="hidden-xs">a community-maintained index of robotics software
 | </span><a href="/privacy.txt">privacy</a></p>
      </div>
    </div>
  </div>

</footer>


  </body>

</html>
