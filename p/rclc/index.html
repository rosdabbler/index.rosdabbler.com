<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>ROS Package: rclc</title>
    <meta name="description" content="a community-maintained index of robotics software
">

    
    <link rel="canonical" href="http://index.rosdabbler.com/p/rclc/">
    
    
    <link rel="icon" sizes="any" type="image/svg+xml" href="/assets/rosindex_logo.svg">

    

    <link rel="stylesheet" type="text/css" href="/bootstrap/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="/css/main.css">
    

    

    <script type="text/javascript" src=/js/jquery.js></script>
    <script src=/bootstrap/js/bootstrap.min.js type="text/javascript"></script>
    <script src=/js/jquery-cookie.js type="text/javascript"></script>
    
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EVD5Z6G6NH"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EVD5Z6G6NH');
</script>

    <script type="text/javascript" src=/js/toc.js></script>

    <script src=/js/distro_switch.js></script>
  </head>

  <body>

    <header class="site-header">

  <div class="wrapper">
    <div class="container-fluid" style="margin-bottom: 10px">
      <div class="row">
        <!-- title -->
        <div class="col-xs-3" style="white-space:nowrap">
          <a class="site-title" href="/">
            <img src="/assets/rosindex_logo.svg" width="26" height="26" alt="ROS index logo" style="padding-bottom: 3px"/>
            ROS Index</a>
        </div>
        <!-- main internal links -->
        <div class="col-xs-6 text-center" style="padding:0px">
          <div class="btn-group hidden-xs" role="group" aria-label="..." style="padding: 6px">
            <div class="btn-group" role="group">
              <a href="/?search_packages=true" class="btn btn-default" role="button">Package List</a>
            </div>
            <div class="btn-group" role="group">
              <a href="/?search_repos=true" class="btn btn-default" role="button">Repository List</a>
            </div>
            <div class="btn-group" role="group">
              <a href="/search_deps" class="btn btn-default" role="button">System Dependencies</a>
            </div>
          </div>
          <div class="hidden-lg hidden-md hidden-sm">
            <button id="hLabel" class="btn btn-link dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
              Lists <span class="caret"></span>
            </button>
            <ul class="dropdown-menu" aria-labelledby="hLabel">
              <li><a href="/?search_packages=true">Package List</a></li>
              <li><a href="/?search_repos=true">Repository List</a></li>
              <li><a href="/search_deps">System Dependencies</a></li>
            </ul>
          </div>
        </div>
        <!-- additional links -->
        <div class="col-xs-3 text-right" style="white-space:nowrap; padding:0px">
          <ul class="list-inline" style="margin-bottom:0px;">
            <li class="dropdown hidden-xs hidden-sm">
              <button id="rLabel" class="btn btn-link" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                ROS Resources <span class="caret"></span>
              </button>
              <ul class="dropdown-menu" role="menu" aria-labelledby="rLabel">
                <li><a href="http://docs.ros.org/">Documentation</a></li>
                <li><a href="http://wiki.ros.org/Support">Support</a></li>
                <li><a href="http://discourse.ros.org/">Discussion Forum</a></li>
                <li><a href="http://status.ros.org/">Service Status</a></li>
                <li><a href="https://robotics.stackexchange.com/questions/tagged/ros">ros @ Robotics Stack Exchange</a></li>
                <li><a href="https://docs.ros.org/en/ros2_packages/">Package API</a></li>
              </ul>
            </li>
            <li class="dropdown hidden-xs hidden-sm">
              <button id="aLabel" class="btn btn-link" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                About <span class="caret"></span>
              </button>
              <ul class="dropdown-menu dropdown-menu-right" role="menu" aria-labelledby="aLabel">
                <li><a href="/about">About </a></li>
                <li><a href="/contribute">Contribute</a></li>
                <li><a href="/help">Help</a></li>
                <li><a href="/stats">Stats</a></li>
              </ul>
            </li>
            <li class="dropdown hidden-md hidden-lg">
              <button id="qLabel" class="btn btn-link" type="button"
                      data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                Resources <span class="caret"></span>
              </button>
              <ul class="dropdown-menu dropdown-menu-right" role="menu" aria-labelledby="qLabel">
                <li><a href="/about">About </a></li>
                <li><a href="/contribute">Contribute</a></li>
                <li><a href="/help">Help</a></li>
                <li><a href="/stats">Stats</a></li>
                <hr style="margin:7px" />
                <li><a href="http://docs.ros.org/">Documentation</a></li>
                <li><a href="http://wiki.ros.org/Support">Support</a></li>
                <li><a href="http://discourse.ros.org/">Discussion Forum</a></li>
                <li><a href="http://status.ros.org/">Service Status</a></li>
                <li><a href="https://robotics.stackexchange.com/questions/tagged/ros">ros @ Robotics Stack Exchange</a></li>
                <li><a href="https://docs.ros.org/en/ros2_packages/">Package API</a></li>
              </ul>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="container-fluid" style="margin-top: 20px">
  <div class="container-fluid">
    <div class="row">
      <ol class="breadcrumb">
        <li><a href="/">Home</a></li>
        <li><a href="/?search_packages=true">Packages</a></li>
        <li class="active">rclc</li>
      </ol>
    </div>
    <div class="row">
      

<div id="distro-switch" class="btn-group btn-group-justified" data-toggle="buttons">
  
    <label id="humble-option" class="distro-button btn btn-xs btn-primary" href="#humble" data="humble">
      <input type="radio" name="options" id="humble-radio" autocomplete="off"> humble
    </label>
  
    <label id="jazzy-option" class="distro-button btn btn-xs btn-primary" href="#jazzy" data="jazzy">
      <input type="radio" name="options" id="jazzy-radio" autocomplete="off"> jazzy
    </label>
  
    <label id="kilted-option" class="distro-button btn btn-xs btn-primary" href="#kilted" data="kilted">
      <input type="radio" name="options" id="kilted-radio" autocomplete="off"> kilted
    </label>
  
    <label id="rolling-option" class="distro-button btn btn-xs btn-primary" href="#rolling" data="rolling">
      <input type="radio" name="options" id="rolling-radio" autocomplete="off"> rolling
    </label>
  
    <label id="github-option" class="distro-button btn btn-xs btn-primary" href="#github" data="github">
      <input type="radio" name="options" id="github-radio" autocomplete="off"> github
    </label>
  
    <label id="noetic-option" class="distro-button btn btn-xs btn-default" href="#noetic" data="noetic">
      <input type="radio" name="options" id="noetic-radio" autocomplete="off"> noetic
    </label>
  

  <!-- Older distros -->
  <div class="btn-group dropdown">
    <label type="button" class="btn btn-xs dropdown-toggle btn-primary" data-toggle="dropdown" id="older-distro-button">
        <input type="radio" name="options" autocomplete="off">
      <span id="older-label">Older</span>
      <span class="caret"></span>
    </label>
    <ul class="dropdown-menu" role="menu">
      
        <li data="galactic" id="galactic-option" class=" older-distro-option"  href="#galactic">
          <a href="#galactic" data="galactic" id="galactic-button">galactic</a>
        </li>
      
        <li data="iron" id="iron-option" class=" older-distro-option"  href="#iron">
          <a href="#iron" data="iron" id="iron-button">iron</a>
        </li>
      
        <li data="melodic" id="melodic-option" class="disabled older-distro-option"  href="#melodic">
          <a href="#melodic" data="melodic" id="melodic-button">melodic</a>
        </li>
      
    </ul>
  </div>
</div>

    </div>
    <div class="row">
      &nbsp;
    </div>
  </div>
</div>


  <div class="distro distro-humble">
    <div class="container-fluid">
      
        
        
        

        <div class="row">
          <div class="col-md-10">
            

<div class="well well-sm">
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px" src="/assets/package.png">
      </td>
      <td>
        <h3 style="margin-top: 5px">
          <a style="text-decoration:none" href="/p/rclc">rclc</a> <small>package from <a style="text-decoration:none" href="/r/rclc/github-ros2-rclc">rclc</a> repo</small>
        </h3>
          
            
            
              <span class="label label-default pkg-label">

rclc
</span>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_examples">

rclc_examples
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_lifecycle">

rclc_lifecycle
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_parameter">

rclc_parameter
</a>
            
          
      </td>
    </tr>
  </table>
</div>

            <div class="visible-xs visible-sm">
              
              
              



<div class="list-group list-group-sm list-group-horizontal list-group-justified">
  <a class="list-group-item text-center"
     target="_blank"
     href="http://docs.ros.org/en/humble/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       <br>
       API Docs
  </a>
  <a class="list-group-item text-center"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/humble/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       <br>
       Browse Code
  </a>
  
  
  
  
  
  
</div>

            </div>
            



<ul class="nav nav-tabs nav-justified" id="humble-tabs" style="margin-bottom:20px">
  <li class="better-tabs active">
    <a href="#humble-overview" data-toggle="tab">Overview</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    
    <a href="#humble-assets" data-toggle="tab"><span class="label label-default">0</span> Assets</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    <a href="#humble-deps" data-toggle="tab"><span class="label label-primary">17</span> Dependencies</a>
  </li>
  <li class="better-tabs">
    
    <a href="#humble-tutorials" data-toggle="tab"><span class="label label-default">0</span> Tutorials</a>
  </li>
  <li class="better-tabs">
    <a href="#humble-questions" data-toggle="tab"><span id="humble-questions-count" class="label label-primary">0</span> Q & A</a>
  </li>
</ul>

<div class="tab-content">
  <div class="tab-pane active" id="humble-overview">
    
    <div class="row">
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h4 class="panel-title">Package Summary</h4></div>
          <div class="panel-body">
            <table class="table table-condensed">
              <tr>
                <td style="width:100px;" class="text-right"><strong>Tags</strong></td>
                <td>
                  
                  
                    <em>No category tags.</em>
                  
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Version</strong></td>
                <td>4.0.2</td>
              </tr>
              <tr>
                <td class="text-right"><strong>License</strong></td>
                <td>Apache License 2.0</td>
              </tr>
              <tr>
                <td class="text-right"><strong>Build type</strong></td>
                <td>
                  
                    <span class="label label-default">
                  
                    AMENT_CMAKE</span>
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Use</strong></td>
                <td>
                
                  <span class="label label-success">RECOMMENDED</span>
                
                </td>
              </tr>
            </table>
          </div>
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body">
            
            
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">ROS Client Library for the C language.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/ros2/rclc.git">https://github.com/ros2/rclc.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">humble</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2023-12-15
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="No CI information available for this package.">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <em>No category tags.</em>
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/rclc/#humble-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#humble-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#humble-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
      </div>
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Package Description</h3></div>
          <div class="panel-body">
            The ROS client library in C.
          </div>
          <div class="panel-heading"><h4 class="panel-title">Additional Links</h4></div>
          <div class="panel-body">
            
            
              <em>No additional links.</em>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Maintainers</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>Pablo Garrido</li>
                
              </ul>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Authors</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>William Woodall</li>
                
              </ul>
            
          </div>
        </div>
      </div>
    </div>
    
      
        <div class="row">
          <div class="col-xs-12">
            <div class="panel panel-default">
              <div class="panel-heading"><span class="glyphicon glyphicon-file"></span><a href="https://github.com/ros2/rclc/tree/humble/rclc/README.md" title="Open in git repository">rclc/README.md</a></div>
              <div class="panel-body">
                    <div class="rendered-markdown">
<h1 id="the-rclc-package">The rclc package</h1>

<h2 id="table-of-contents">Table of contents</h2>

<ul>
  <li>
    <p><a href="https://github.com/ros2/rclc/tree/humble/rclc/#introduction">Introduction</a></p>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/humble/rclc/#analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#architecture">Architecture</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#scheduling-semantics">Scheduling Semantics</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/humble/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#synchronization-of-multiple-rates">Synchronization of multiple rates</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#high-priority-processing-path">High-priority processing path</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#real-time-embedded-applications">Real-time embedded applications</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/humble/rclc/#rclc-executor">rclc Executor</a>
    <ul>
      <li>
<a href="https://github.com/ros2/rclc/tree/humble/rclc/#features">Features</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#trigger-condition">Trigger condition</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#sequential-execution">Sequential execution</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#let-semantics">LET-Semantics</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/humble/rclc/#executor-api">Executor API</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#configuration-phase">Configuration phase</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#running-phase">Running phase</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/humble/rclc/#examples">Examples</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#synchronization-of-multiple-rates-example">Synchronization of multiple rates example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#high-priority-processing-path-example">High-priority processing path example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#real-time-embedded-applications-example">Real-time embedded applications example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#future-work">Future work</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#download">Download</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/humble/rclc/#callback-group-level-executor">Callback-group-level Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#api-changes">API Changes</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#test-bench">Test Bench</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/humble/rclc/#related-work">Related Work</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#fawkes-framework">Fawkes Framework</a></li>
    </ul>
  </li>
  <li><a href="https://github.com/ros2/rclc/tree/humble/rclc/#references">References</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Predictable execution under given real-time constraints is a crucial requirement for many robotic applications. While the service-based paradigm of ROS allows a fast integration of many different functionalities, it does not provide sufficient control over the execution management. For example, there are no mechanisms to enforce a certain execution order of callbacks within a node. Also the execution order of multiple nodes is essential for control applications in mobile robotics. Cause-effect-chains comprising of sensor acquisition, evaluation of data and actuation control should be mapped to ROS nodes executed in this order, however there are no explicit mechanisms to enforce it. Furthermore, when data recordings collected in field tests as ROS-bags are re-played, then the results are often surprisingly different due to non-determinism of process scheduling.</p>

<p>Manually setting up a particular execution order of subscriptions and publishing topics as well as defining use-case specific priorities of the corresponding Linux processes is always possible. However, this approach is error-prone, difficult to extend and requires an in-depth knowledge of the deployed ROS 2 packages in the system.</p>

<p>Therefore the goal of the Executor in micro-ROS is to support roboticists with practical and easy-to-use real-time mechanisms which provide solutions for:</p>
<ul>
  <li>Deterministic execution</li>
  <li>Real-time guarantees</li>
  <li>Integration of real-time and non real-time functionalities on one platform</li>
  <li>Specific support for RTOS and microcontrollers</li>
</ul>

<p>In ROS 1 a network thread is responsible for receiving all messages and putting them into a FIFO queue (in roscpp). That is, all callbacks were called in a FIFO manner, without any execution management. With the introduction of DDS (data distribution service) in ROS 2, the messages are buffered in DDS. In ROS 2, an Executor concept was introduced to support execution management. At the rcl-layer, a <em>wait-set</em> is configured with handles to be received and in a second step, the handles are taken from the DDS-queue. A handle is a generic term defined in rcl-layer for timers, subscriptions, services, clients and guard conditions.</p>

<p>The standard implementation of the ROS 2 Executor for the C++ API (rclcpp) has, however, certain unusual features, like precedence of timers over all other DDS handles, non-preemptive round-robin scheduling for non-timer handles and considering only one input data for each handle (even if multiple could be available). These features have the consequence, that in certain situations the standard rclcpp Executor is not deterministic and it makes guaranteeing real-time requirements very hard [<a href="https://github.com/ros2/rclc/tree/humble/rclc/#CB2019">CB2019</a>]. We have not looked at the ROS 2 Executor implementation for Python Frontend (rclpy) because we consider a micro-controllers platform, on which typically C or C++ appliations will run.</p>

<p>Given the goals for a Real-Time Executor and the limitations of the ROS 2 standard rclcpp Executor, the challenges are:</p>
<ul>
  <li>to develop an adequate and well-defined scheduling mechanisms for the ROS 2 framework and the real-time operating system (RTOS)</li>
  <li>to define an easy-to-use interface for ROS developers</li>
  <li>to model requirements (like latencies, determinism in subsystems)</li>
  <li>mapping of ROS 2 framework and operating system schedulers (semi-automated and optimized mapping is desired as well as generic, well-understood framework mechanisms)</li>
</ul>

<p>Our approach is to provide a real-time-capable Executor for the rcl+rclc layer (as described in section <a href="https://github.com/ros2/rclc/tree/humble/rclc/../">Introduction to Client Library</a>.) in the C programming language .</p>

<p>As the first step, we propose the rclc Executor for the rcl-layer in C programming language with several new features to support real-time and deterministic execution: It supports 1.) user-defined static sequential execution, 2) conditional execution semantics, 3) multi-threaded execution with scheduling configuration, and 4) logical execution semantics (LET). Sequential execution refers to the runtime behavior, that all callbacks are executed in a pre-defined order independent of the arrival time of messages. Conditional execution is available with a trigger condition which enables typical processing patterns in robotics (which are analyzed in detail in section <a href="https://github.com/ros2/rclc/tree/humble/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>. Configuration of scheduling parameters for multi-threaded application accomplishes prioritized execution. The logical execution time concept (LET) provides data synchronization for fixed periodic task scheduling of embedded applications.</p>

<p>Beyond the advanced execution management mechanisms for micro-ROS, we also contributed to improving and extending the Executor concept in rclcpp for standard ROS 2: the callback group-level Executor. It is not a new Executor but rather a refinement of the ROS 2 Executor API allowing to prioritize a group of callbacks which is not possible with the ROS 2 default Executor in its current Galactic release.</p>

<h2 id="analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</h2>

<p>ROS 2 allows to bundle multiple nodes in one operating system process. To coordinate the execution of the callbacks of the nodes of a process, the Executor concept was introduced in rclcpp (and also in rclpy).</p>

<p>The ROS 2 design defines one Executor (instance of <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">rclcpp::executor::Executor</a>) per process, which is typically created either in a custom main function or by the launch system. The Executor coordinates the execution of all callbacks issued by these nodes by checking for available work (timers, services, messages, subscriptions, etc.) from the DDS queue and dispatching it to one or more threads, implemented in <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/single_threaded_executor.hpp">SingleThreadedExecutor</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp">MultiThreadedExecutor</a>, respectively.</p>

<p>The dispatching mechanism resembles the ROS 1 spin thread behavior: the Executor looks up the wait sets, which notifies it of any pending callback in the DDS queue. If there are multiple pending callbacks, the ROS 2 Executor executes them in an in the order as they were registered at the Executor.</p>

<h3 id="architecture">Architecture</h3>

<p>The following diagram depicts the relevant classes of the standard ROS 2 Executor implementation:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/executor_class_diagram.png" alt="ROS 2 Executor class diagram" width="100%">
</center>

<p>Note that an Executor instance maintains weak pointers to the NodeBaseInterfaces of the nodes only. Therefore, nodes can be destroyed safely, without notifying the Executor.</p>

<p>Also, the Executor does not maintain an explicit callback queue, but relies on the queue mechanism of the underlying DDS implementation as illustrated in the following sequence diagram:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/executor_to_dds_sequence_diagram.png" alt="Call sequence from executor to DDS" width="100%">
</center>

<p>The Executor concept, however, does not provide means for prioritization or categorization of the incoming callback calls. Moreover, it does not leverage the real-time characteristics of the underlying operating-system scheduler to have finer control on the order of executions. The overall implication of this behavior is that time-critical callbacks could suffer possible deadline misses and a degraded performance since they are serviced later than non-critical callbacks. Additionally, due to the FIFO mechanism, it is difficult to determine usable bounds on the worst-case latency that each callback execution may incur.</p>

<h3 id="scheduling-semantics">Scheduling Semantics</h3>

<p>In a recent paper [<a href="https://github.com/ros2/rclc/tree/humble/rclc/#CB2019">CB2019</a>], the rclcpp Executor has been analyzed in detail and a response time analysis of cause-effect chains has been proposed under reservation-based scheduling. The Executor distinguishes four categories of callbacks: <em>timers</em>, which are triggered by system-level timers, <em>subscribers</em>, which are triggered by new messages on a subscribed topic, <em>services</em>, which are triggered by service requests, and <em>clients</em>, which are triggered by responses to service requests. The Executor is responsible for taking messages from the input queues of the DDS layer and executing the corresponding callback. Since it executes callbacks to completion, it is a non-preemptive scheduler, However it does not consider all ready tasks for execution, but only a snapshot, called readySet. This readySet is updated when the Executor is idle and in this step it interacts with the DDS layer updating the set of ready tasks. Then for every type of task, there are dedicated queues (timers, subscriptions, services, clients) which are processed sequentially. The following undesired properties were pointed out:</p>

<ul>
  <li>Timers have the highest priority. The Executor processes <em>timers</em> always first.  This can lead to the intrinsic effect, that in overload situations messages from the DDS queue are not processed.</li>
  <li>Non-preemptive round-robin scheduling of non-timer handles. Messages arriving during the processing of the readySet are not considered until the next update, which depends on the execution time of all remaining callbacks. This leads to priority inversion, as lower-priority callbacks may implicitly block higher-priority callbacks by prolonging the current processing of the readySet.</li>
  <li>Only one message per handle is considered. The readySet contains only one task instance, For example, even if multiple messages of the same topic are available, only one instance is processed until the Executor is idle again and the readySet is updated from the DDS layer. This aggravates priority inversion, as a backlogged callback might have to wait for multiple processing of readySets until it is considered for scheduling. This means that non-timer callback instances might be blocked by multiple instances of the same lower-priority callback.</li>
</ul>

<p>Due to these findings, the authors present an alternative approach to provide determinism and to apply well-known schedulability analyses to a ROS 2 systems. A response time analysis is described under reservation-based scheduling.</p>

<h2 id="analysis-of-processing-patterns">Analysis of processing patterns</h2>
<p>The development of an execution management mechanism for micro-ROS is based on an analysis of processing patterns commonly used in robotics and embedded systems. First, typical processing patterns in mobile robotics are presented which are used to implement deterministic behavior. Then, the processing patterns in the real-time embedded systems are analyzed, in which, as a main difference, the time-triggered paradigm is applied to accomplish real-time behavior.</p>

<h3 id="sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</h3>
<p>Now we describe common software design patterns which are used in mobile robotics to achieve deterministic behavior. For each design pattern we describe the concept and the derived requirements for a deterministic Executor.</p>

<p><strong>Concept:</strong></p>

<p>A common design paradigm in mobile robotics is a control loop, consisting of several phases: A sensing phase to aquire sensor data, a plan phase for localization and path planning and an actuation-phase to steer the mobile robot. Of course, more phases are possible, here these three phases shall serve as an example. Such a processing pipeline is shown in Figure 1.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/sensePlanActScheme.png" alt="Sense Plan Act Pipeline" width="60%">
</center>
<center>
Figure 1: Multiple sensors driving a Sense-Plan-Act pipeline.
</center>

<p>Typically multiple sensors are used to perceive the environment. For example an IMU and a laser scanner. The quality of localization algorithms highly depend on how old such sensor data is when it is processed. Ideally the latest data of all sensors should be processed. One way to achive this is to execute first all sensor drivers in the sense-phase and then process all algorithms in the plan-phase.</p>

<p>Currently, such a processing order cannot be defined with the default Executor of rclcpp. One could in principle design a data-driven pipeline, however if e.g. the Laser scan is needed by some other callback in the sense-phase as well as in the plan-phase, the processing order of these subscribers is arbitrary.</p>

<p>For this sense-plan-act pattern, we could define one executor for each phase. The plan-phase would be triggered only when all callbacks in the sense-phase have finished.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
</ul>

<h3 id="synchronization-of-multiple-rates">Synchronization of multiple rates</h3>

<p><strong>Concept:</strong></p>

<p>Often multiple sensors are being used to sense the environment for mobile robotics. While an IMU sensor provides data samples at a very high rate (e.g., 500 Hz), laser scans are availabe at a much slower frequency (e.g. 10Hz) determined by the revolution time. Then the challenge is, how to deterministically fuse sensor data with different frequencies. This problem is depicted in Figure 2.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/sensorFusion_01.png" alt="Sychronization of multiple rates" width="30%">
</center>
<center>
Figure 2: How to deterministically process multi-frequent sensor data.
</center>

<p>Due to scheduling effects, the callback for evaluating the laser scan might be called just before or just after an IMU data is received. One way to tackle this is to write additional synchronization code inside the application. Obviously, this is a cumbersome and not-portable solution.</p>

<p>An Alternative would be to evalute the IMU sample and the laser scan by synchronizing their frequency. For example by processing always 50 IMU samples with one laser scan. This approach is shown in Figure 3. A pre-processing callback aggregates the IMU samples and sends an aggregated message with 50 samples at 10Hz rate. Now both messages have the same frequency. With a trigger condition, which fires when both messages are available, the sensor fusion algorithm can expect always synchronized input data.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/sensorFusion_02.png" alt="Sychnronization with a trigger" width="40%">
</center>
<center>
Figure 3: Synchronization of multiple input data with a trigger.
</center>

<p>In ROS 2, this is currently not possible to be modeled because of the lack of a trigger concept in the Executors of rclcpp and rclpy. Message filters could be used to synchronize input data based on the timestamp in the header, but this is only available in rclcpp (and not in rcl). Further more, it would be more efficient to have such a trigger concept directly in the Executor.</p>

<p>Another idea would be to activly request for IMU data only when a laser scan is received. This concept is shown in Figure 4. Upon arrival of a laser scan mesage, first, a message with aggregated IMU samples is requested. Then, the laser scan is processed and later the sensor fusion algorithm. An Executor, which would support sequential execution of callbacks, could realize this idea.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/sensorFusion_03.png" alt="Sychronization with sequence" width="30%">
</center>
<center>
Figure 4: Synchronization with sequential processing.
</center>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
  <li>sequential procesing of callbacks</li>
</ul>

<h3 id="high-priority-processing-path">High-priority processing path</h3>
<p><strong>Concept</strong>
Often a robot has to fullfill several activities at the same time. For example following a path and avoiding obstacles. While path following is a permanent activity, obstacle avoidance is trigged by the environment and should be immediately reacted upon. Therefore one would like to specify priorities to activities. This is depicted in Figure 5:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/highPriorityPath.png" alt="HighPriorityPath" width="50%">
</center>
<center>
Figure 5: Managing high priority path with sequential order.
</center>

<p>Assuming a simplified control loop with the activities sense-plan-act, the obstacle avoidance, which might temporarily stop the robot, should be processed before the planning phase. In this example we assume that these activites are processed in one thread.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>sequential processing of callbacks</li>
</ul>

<h3 id="real-time-embedded-applications">Real-time embedded applications</h3>
<p>In embedded systems, real-time behavior is approached by using the time-triggered paradigm, which means that the processes are periodically activated. Processes can be assigned priorities to allow pre-emptions. Figure 6 shows an example, in which three processes with fixed periods are shown. The middle and lower process are preempted multiple times depicted with empty dashed boxes.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/scheduling_01.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 6: Fixed periodic preemptive scheduling.
</center>

<p>To each process one or multiple tasks can be assigned, as shown in Figure 7. These tasks are executed sequentially, which is often called cooperative scheduling.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/scheduling_02.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 7: Processes with sequentially executed tasks.
</center>

<p>While there are different ways to assign priorities to a given number of processes,
the rate-monotonic scheduling assignment, in which processes with a shorter period have a higher priority, has been shown optimal if the processor utilization is less than 69% [<a href="https://github.com/ros2/rclc/tree/humble/rclc/#LL1973">LL1973</a>].</p>

<p>In the last decades many different scheduling approaches have been presented, however fixed-periodic preemptive scheduling is still widely used in embedded real-time systems [<a href="https://github.com/ros2/rclc/tree/humble/rclc/#KZH2015">KZH2015</a>]. This becomes also obvious, when looking at the features of current operating systems. Like Linux, real-time operating systems, such as NuttX, Zephyr, FreeRTOS, QNX etc., support fixed-periodic preemptive scheduling and the assignment of priorities, which makes the time-triggered paradigm the dominant design principle in this domain.</p>

<p>However, data consistency is often an issue when preemptive scheduling is used and if data is being shared across multiple processes via global variables. Due to scheduling effects and varying execution times of processes, writing and reading these variables could occur sometimes sooner or later. This results in an latency jitter of update times (the timepoint at which a variable change becomes visible to other processes). Race conditions can occur when multiple processes access a variable at the same time. So solve this problem, the concept of logical-execution time (LET) was introduced in [<a href="https://github.com/ros2/rclc/tree/humble/rclc/#HHK2001">HHK2001</a>], in which communication of data occurs only at pre-defined periodic time instances: Reading data only at the beginning of the period and writing data only at the end of the period. The cost of an additional latency delay is traded for data consistency and reduced jitter. This concept has also recently been applied to automotive applications[<a href="https://github.com/ros2/rclc/tree/humble/rclc/#NSP2018">NSP2018</a>].</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/scheduling_LET.png" alt="Schedule with fixed periods" width="80%">
</center>
<center>
Figure 8: Data communication without and with Logical Execution Time paradigm.
</center>

<p>An Example of the LET concept is shown in Figure 8. Assume that two processes are communicating data via one global variable. The timepoint when this data is written is at the end of the processing time. In the default case (left side), the process p<sub>3</sub> and p<sub>4</sub> receive the update. At the right side of Figure 8, the same scenario is shown with LET semantics. Here, the data is communicated only at period boundaries. In this case, the lower process communicates at the end of the period, so that always process p<sub>3</sub> and p<sub>5</sub> receive the new data.</p>

<p><strong>Concept:</strong></p>
<ul>
  <li>periodic execution of processes</li>
  <li>assignment of fixed priorities to processes</li>
  <li>preemptive scheduling of processes</li>
  <li>co-operative scheduling of tasks within a process (sequential execution)</li>
  <li>data synchronization with LET-semantics</li>
</ul>

<p>While periodic activation is possible in ROS 2 by using timers, preemptive scheduling is supported by the operating system and assigning priorities on the granularity of threads/processes that correspond to the ROS nodes; it is not possible to sequentially execute callbacks, which have no data-dependency. Furthermore data is read from the DDS queue just before the callback is executed and data is written sometime during the time the application is executed. While the <code class="language-plaintext highlighter-rouge">spin_period</code> function of the rclcpp Executor allows to check for data at a fixed period and executing those callbacks for which data is available, however, with this spin-function does not execute all callbacks irrespective wheter data is available or not. So <code class="language-plaintext highlighter-rouge">spin_period</code> is not helpful to periodically execute a number of callbacks (aka tasks within a process). So we need a mechanism that triggers the execution of multiple callbacks (aka tasks) based on a timer. Data transmission is achieved via DDS which does not allow to implement a LET-semantics. To summarize, we derive the following requirements.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>trigger the execution</li>
  <li>sequential processing of callbacks</li>
  <li>data synchronization with LET semantics</li>
</ul>

<h2 id="rclc-executor">rclc Executor</h2>

<p>The rclc Executor is a ROS 2 Executor based on the rcl-layer in C programming language. As discussed above, the default rclcpp Executor is not suitable to implement real-time applications because of three main reasons: timers are preferred over all other handles, no priorization of callback execution and the round-robin to completion execution of callbacks. On the other hand, several processing patterns have been developed as best practices to achieve non-functional requirements, such as bounded end-to-end latencies, low jitter of response times of cause-effect chains, deterministic processing and short response times even in overload situations. These processing patterns are difficult to implement with the concepts availabe in the default ROS 2 Executor, therefore we have developed a flexible Executor: the rclc Executor.</p>

<h3 id="features">Features</h3>

<p>The rclc Executor is feature-complete, i.e. it supports all event types as the default ROS 2 Executor, which are:</p>
<ul>
  <li>subscriptions</li>
  <li>timers</li>
  <li>services</li>
  <li>clients</li>
  <li>guard conditions</li>
  <li>actions</li>
  <li>lifecycle</li>
</ul>

<p>The flexible rclc Executor provides on top the following new features:</p>
<ul>
  <li>triggered execution</li>
  <li>user-defined sequential execution</li>
  <li>multi-threading and scheduling configuration (WIP)</li>
  <li>LET-semantics for data synchronization of periodic process scheduling</li>
</ul>

<p>First, a <em>trigger condition</em> allows to define when the processing of a callback shall start. This is useful to implement sense-plan-act control loops or more complex processing structures with directed acyclic graphs. Second, a user can specify the <em>processing order</em> in which these callbacks will be executed. With this feature, the pattern of sensor fusion with multiple rates, in which data is requested from a sensor based on the arrival of some other sensor, can be easily implemented. Third, the assignment of scheduling parameters (e.g., priorities) of the underlying operating system. With this feature, prioritized processing can be implemented. Finally, for periodic applications, the <em>LET Semantics</em> has been implemented to support data consistency for periodic process scheduling. These features are now described in more detail.</p>

<h4 id="sequential-execution">Sequential execution</h4>

<ul>
  <li>At configuration, the user defines the order of handles.</li>
  <li>At configuration, the user defines whether the handle shall be called only when new data is available (ON_NEW_DATA) or whether the callback shall always be called (ALWAYS).</li>
  <li>At runtime, all handles are processed in the user-defined order
    <ul>
      <li>if the configuration of handle is ON_NEW_DATA, then the corresponding callback is only called if new data is available</li>
      <li>if the configuration of the handle is ALWAYS, then the corresponding callback is always. If no data is available, then the callback is called with no data (e.g. NULL pointer).</li>
    </ul>
  </li>
</ul>

<p>Figure 9 shows three callbacks, A, B and C. Assume, they shall be executed in the order <em>B,A,C</em>. Then the user adds the callbacks to the rclc Executor in this order. Whenever new messages have arrived then the callbacks for which a new message is availabe will be always executed in the user-defined processing order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/rclc_executor_sequential_execution.png" alt="Sequential execution semantics" width="50%">
</center>
<center>
Figure 9: Sequential execution semantics.
</center>

<h4 id="trigger-condition">Trigger condition</h4>

<ul>
  <li>Given a set of handles, a trigger condition, which is based on the availability of input data of these handles, decides when the processing of all callbacks starts. This is shown in Figure 10.</li>
</ul>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/trigger_01.png" alt="Trigger condition overview" width="50%">
</center>
<center>
Figure 10: Executor with trigger condition
</center>

<ul>
  <li>Available options:
    <ul>
      <li>ALL operation: fires when input data is available for all handles</li>
      <li>ANY operation: fires when input data is available for at least one handle (OR semantics)</li>
      <li>ONE: fires when input data for a user-specified handle is available</li>
      <li>User-defined function: user can implement custom logic</li>
    </ul>
  </li>
</ul>

<p>Figure 11 shows an example of the ALL semantics. Only if all messages <em>msg_A, msg_B, msg_C</em> were received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/trigger_ALL.png" alt="Trigger condition ALL" width="30%">
</center>
<center>
Figure 11: Trigger condition ALL
</center>

<p>Figure 12 shows an example of the ANY semantics. Thas is, if any messages <em>msg_A, msg_B, msg_C</em> was received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order. This is equivalent to OR semantics.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/trigger_OR.png" alt="Trigger condition ANY" width="30%">
</center>
<center>
Figure 12: Trigger condition ANY (OR)
</center>

<p>Figure 13 shows an example of the ONE semantics. Thas is, only if message <em>msg_B</em> was received, the trigger condition is fullfilled and (potentially all) callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/trigger_ONE.png" alt="Trigger condition ONE" width="30%">
</center>
<center>
Figure 13: Trigger condition ONE
</center>

<p>Figure 14 describes the custom semantics. A custom trigger condition with could be a more complex logic of multiple messages, can be passed to the executor. This might also include hardware triggers, like interrupts.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/trigger_user_defined.png" alt="Trigger condition user-defined" width="30%">
</center>
<center>
Figure 14: Trigger condition user-defined
</center>

<h4 id="let-semantics">LET-Semantics</h4>
<ul>
  <li>Assumption: time-triggered system, the executor is activated periodically</li>
  <li>When the trigger fires, reads all input data and makes a local copy</li>
  <li>Processes all callbacks in sequential order</li>
  <li>Write output data at the end of the executors period (Note: this is not implemented yet)</li>
</ul>

<p>Additionally we have implemented the current rclcpp Executor semantics (RCLCPP):</p>
<ul>
  <li>waiting for new data for all handles (rcl_wait)</li>
  <li>using trigger condition ANY</li>
  <li>if trigger fires, start processing handles in pre-defined sequential order</li>
  <li>request from DDS-queue the new data just before the handle is executed (rcl_take)</li>
</ul>

<p>The selection of the Executor semantics is optional. The default semantics is RCLCPP.</p>

<h4 id="multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</h4>

<p>The rclc Executor has been extended for multi-threading. It supports the assignment of scheduling policies, like priorities or more advanced scheduling algorithms as reservation-based scheduling, to subscription callbacks. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, Pre-print <a href="https://github.com/ros2/rclc/tree/humble/rclc/#SLD2021">SLD2021</a>]. The overall architecture is shown in Figure 15. One Executor thread is responsible for checking for new data from the DDS queue. For every callback, a thread is spawned with the dedicted scheduling policy provided by the operating system. The Executor then dispatches new data of a subscription to its corresponding callback function, which is then executed in its own thread by operating system.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/rclc_executor_multi_threaded.png" alt="Multi-threaded rclc Executor" width="90%">
</center>
<center>
Figure 15: multi-threaded rclc-Executor
</center>

<h3 id="executor-api">Executor API</h3>
<p>The API of the rclc Executor can be divided in two phases: Configuration and Running.</p>
<h4 id="configuration-phase">Configuration phase</h4>
<p>During the configuration phase, the user shall define:</p>
<ul>
  <li>the total number of callbacks</li>
  <li>the sequence of the callbacks</li>
  <li>trigger condition (optional, default: ANY)</li>
  <li>data communcation semantics (optional, default ROS2)</li>
</ul>

<p>As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added.</p>

<p>Also in the XRCE-DDS middleware the maximum number of handles need to be configured. See <a href="https://docs.vulcanexus.org/en/humble/rst/tutorials/micro/memory_management/memory_management.html#entity-creation">Memory Management Tutorial</a> for the defaults and configuration of the colcon.meta configuration file. To make sure that the changes were applied, you can check the defined values in the following library include file: build/rmw_microxrcedds/include/rmw_microxrcedds_c/config.h.</p>

<p>Then, the user adds handles and the corresponding callbacks (e.g. for subscriptions and timers) to the Executor. The order in which this takes place, defines later the sequential processing order during runtime.</p>

<p>For each handle the user can specify, if the callback shall be executed only if new data is available (ON_NEW_DATA) or if the callback shall always be executed (ALWAYS). The second option is useful when the callback is expected to be called at a fixed rate.</p>

<p>The trigger condition defines when the processing of these callbacks shall start. For convenience some default conditions have been defined:</p>
<ul>
  <li>trigger_any(default) : start executing if any callback has new data</li>
  <li>trigger_all : start executing if all callbacks have new data</li>
  <li>trigger_one(&amp;<code class="language-plaintext highlighter-rouge">data</code>) : start executing if <code class="language-plaintext highlighter-rouge">data</code> has been received</li>
  <li>user_defined_function: the user can also define its own function with more complex logic</li>
</ul>

<p>With trigger_any being the default, the current semantics of the rclcpp Executor is selected.</p>

<p>The data communication semantics can be</p>
<ul>
  <li>ROS2 (default)</li>
  <li>LET</li>
</ul>

<p>To be compatible with ROS2 rclcpp Executor, the existing rclcpp semantics is implemented as ROS2. That is, with the spin-function the DDS-queue is constantly monitored for new data (rcl_wait). If new data becomes available, then is fetched from DDS (rcl_take) immediately before the callback is executed. All callbacks are processed in the user-defined order, this is the only difference to the rclcpp Executor, in which no order can be specified.</p>

<p>Secondly, the LET semantics is implemented such that at the beginning of processing all available data is fetched (rcl_take) and buffered and then the callbacks are processed in the pre-defined operating on the buffered copy.</p>

<h4 id="running-phase">Running phase</h4>

<p>As the main functionality, the Executor has a <code class="language-plaintext highlighter-rouge">spin</code>-function which constantly checks for new data at the DDS-queue, like the rclcpp Executor in ROS2. If the trigger condition is satisfied then all available data from the DDS queue is processed according to the specified semantics (ROS or LET) in the user-defined sequential order. After all callbacks have been processed the DDS is checked for new data again.</p>

<p>Available spin functions are</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">spin_some</code>  - spin one time</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin_period</code> - spin with a period</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin</code> - spin indefinitly</li>
</ul>

<h3 id="examples">Examples</h3>
<p>We provide the relevant code snippets how to setup the rclc Executor for the processing patterns as described above.</p>

<h4 id="sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</h4>

<p>In this example we want to realise a sense-plan-act pipeline in a single thread. The trigger condition is demonstrated by activating
the sense-phase when both data for the Laser and IMU are available. Three executors are necessary <code class="language-plaintext highlighter-rouge">exe_sense</code>, <code class="language-plaintext highlighter-rouge">exe_plan</code> and <code class="language-plaintext highlighter-rouge">exe_act</code>. The two sensor acquisition callbacks <code class="language-plaintext highlighter-rouge">sense_Laser</code> and <code class="language-plaintext highlighter-rouge">sense_IMU</code> are registered in the Executor <code class="language-plaintext highlighter-rouge">exe_sense</code>.
The trigger condition ALL is responsible to activate the sense-phase only when all data for these two callbacks are available. Finally all three Executors are spinning using a <code class="language-plaintext highlighter-rouge">while</code>-loop and the <code class="language-plaintext highlighter-rouge">spin_some</code> function.</p>

<p>The definitions of callbacks are omitted.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act;
rcle_let_executor_t exe_sense, exe_plan, exe_act;
// initialize executors
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
rclc_executor_init(&amp;exe_plan, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_act, &amp;context, 1, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb1, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_let_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);
// executor for plan-phase
rclc_executor_add_subscription(&amp;exe_plan, &amp;plan, &amp;my_sub_cb3, ON_NEW_DATA);
// executor for act-phase
rclc_executor_add_subscription(&amp;exe_act, &amp;act, &amp;my_sub_cb4, ON_NEW_DATA);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_sense);
  rclc_executor_spin_some(&amp;exe_plan);
  rclc_executor_spin_some(&amp;exe_act);
}

</code></pre>

<h4 id="synchronization-of-multiple-rates-example">Synchronization of multiple rates example</h4>

<p>The sensor fusion synchronizing the multiple rates with a trigger is shown below.</p>

<pre><code class="language-C">...
rcl_subscription_t aggr_IMU, sense_Laser, sense_IMU;
rcle_let_executor_t exe_aggr, exe_sense;
// initialize executors
rclc_executor_init(&amp;exe_aggr, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for aggregate IMU data
rclc_executor_add_subscription(&amp;exe_aggr, &amp;aggr_IMU, &amp;my_sub_cb1, ON_NEW_DATA);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb3, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_aggr);
  rclc_executor_spin_some(&amp;exe_sense);
}

</code></pre>

<p>The setup for the sensor fusion using sequential execution is shown below.
Note that the sequetial order is <code class="language-plaintext highlighter-rouge">sense_IMU</code>, which will request the aggregated IMU message, and then <code class="language-plaintext highlighter-rouge">sense_Laser</code>
while the trigger will fire, when a laser message is received.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU;
rcle_let_executor_t exe_sense;
// initialize executor
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe_sense);

</code></pre>
<h4 id="high-priority-processing-path-example">High priority processing path example</h4>

<p>This example shows the sequential processing order to execute the obstacle avoidance <code class="language-plaintext highlighter-rouge">obst_avoid</code>
after the callbacks of the sense-phase and before the callback of the planning phase <code class="language-plaintext highlighter-rouge">plan</code>.
The control loop is started when a laser message is received. Then an aggregated IMU message is requested,
like in the example above. Then all the other callbacks are always executed. This assumes that these callbacks
communicate via a global data structure. Race conditions cannot occur, because the callbacks
run all in one thread.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act, obst_avoid;
rcle_let_executor_t exe;
// initialize executors
rclc_executor_init(&amp;exe, &amp;context, 5, ...);
// define processing order
rclc_executor_add_subscription(&amp;exe, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe, &amp;obst_avoid, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;plan, &amp;my_sub_cb4, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;act, &amp;my_sub_cb5, ALWAYS);
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="real-time-embedded-applications-example">Real-time embedded applications example</h4>

<p>With seqential execution the co-operative scheduling of tasks within a process can be modeled. The trigger condition is used to periodically activate the process which will then execute all callbacks in a pre-defined order. Data will be communicated using the LET-semantics. Every Executor is executed in its own tread, to which an appropriate priority can be assigned.</p>

<p>In the following example, the Executor is setup with 4 handles. We assume a process has three subscriptions <code class="language-plaintext highlighter-rouge">sub1</code>, <code class="language-plaintext highlighter-rouge">sub2</code>, <code class="language-plaintext highlighter-rouge">sub3</code>. The sequential processing order is given by the order as they are added to the Executor. A timer <code class="language-plaintext highlighter-rouge">timer</code> defines the period.  The <code class="language-plaintext highlighter-rouge">trigger_one</code> with the paramter <code class="language-plaintext highlighter-rouge">timer</code> is used, so that whenever the timer is ready, all callbacks are processed. Finally the data communication semantics LET is defined.</p>

<pre><code class="language-C">#include "rcl_executor/let_executor.h"

// define subscription callback
void my_sub_cb1(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb2(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb3(const void * msgin)
{
  // ...
}

// define timer callback
void my_timer_cb(rcl_timer_t * timer, int64_t last_call_time)
{
  // ...
}

// necessary ROS 2 objects
rcl_context_t context;   
rcl_node_t node;
rcl_subscription_t sub1, sub2, sub3;
rcl_timer_t timer;
rcle_let_executor_t exe;

// define ROS context
context = rcl_get_zero_initialized_context();
// initialize ROS node
rcl_node_init(&amp;node, &amp;context,...);
// create subscriptions
rcl_subscription_init(&amp;sub1, &amp;node, ...);
rcl_subscription_init(&amp;sub2, &amp;node, ...);
rcl_subscription_init(&amp;sub3, &amp;node, ...);
// create a timer
rcl_timer_init(&amp;timer, &amp;my_timer_cb, ... );
// initialize executor with four handles
rclc_executor_init(&amp;exe, &amp;context, 4, ...);
// define static execution order of handles
rclc_executor_add_subscription(&amp;exe, &amp;sub1, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub2, &amp;my_sub_cb2, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub3, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_timer(&amp;exe, &amp;timer);
// trigger when handle 'timer' is ready
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;timer);
// select LET-semantics
rclc_executor_data_comm_semantics(&amp;exe, LET);
// spin forever
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</h4>
<p>The rclc Executor has been presented at the workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at <a href="https://roscon.ros.org/world/2021/">ROS World 2021</a> (i.e. the online version of ROSCon)[<a href="https://github.com/ros2/rclc/tree/humble/rclc/#S2021">S2021</a>]. A <a href="https://github.com/ros-realtime/reference-system">Reference System</a> for testing and benchmarking ROS Executors has been developed for this workshop. The application of the rclc Executor on the reference system with the trigger condition can be found in the <a href="https://github.com/ros-realtime/reference-system/tree/rclc_executor">rclc-executor branch of the Reference System</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/IazrPF3RN1U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>The slides can be downloaded <a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">here</a>. All information and the videos and slides of the other talks of the workshop can be found at <a href="https://www.apex.ai/roscon-21">www.apex.ai/roscon-21</a>.</p>

<h3 id="future-work">Future work</h3>

<ul>
  <li>Full LET semantics (writing data at the end of the period)
    <ul>
      <li>one publisher that periodically publishes</li>
      <li>if Executors are running in multiple threads,
publishing needs to be atomic</li>
    </ul>
  </li>
  <li>Multi-threaded executor with assignment of scheduling policies of unerlying operating system. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, pre-print <a href="https://github.com/ros2/rclc/tree/humble/rclc/#SLD2021">SLD2021</a>].</li>
</ul>

<h3 id="download">Download</h3>
<p>The rclc Executor can be downloaded from the <a href="https://github.com/ros2/rclc">ros2/rclc repository</a>. It is available for the ROS 2 versions Foxy, Galactic and Rolling. The repository provides several packages including the <a href="https://github.com/ros2/rclc/tree/master/rclc">rclc Executor</a> and an <a href="https://github.com/ros2/rclc/tree/master/rclc_examples">rclc_examples package</a> with several application examples.</p>

<h2 id="callback-group-level-executor">Callback-group-level Executor</h2>

<p>The Callback-group-level Executor was an early prototype for a refined rclcpp Executor API developed in micro-ROS. It has been derived from the default rclcpp Executor and addresses some of the aforementioned deficits. Most important, it was used to validate that the underlying layers (rcl, rmw, rmw_adapter, DDS) allow for multiple Executor instances without any negative interferences.</p>

<p>As the default rclcpp Executor works at a node-level granularity  which is a limitation given that a node may issue different callbacks needing different real-time guarantees - we decided to refine the API for more fine-grained control over the scheduling of callbacks on the granularity of callback groups using. We leverage the callback-group concept existing in rclcpp by introducing real-time profiles such as RT-CRITICAL and BEST-EFFORT in the callback-group API (i.e. rclcpp/callback_group.hpp). Each callback needing specific real-time guarantees, when created, may therefore be associated with a dedicated callback group. With this in place, we enhanced the Executor and depending classes (e.g., for memory allocation) to operate at a finer callback-group granularity. This allows a single node to have callbacks with different real-time profiles assigned to different Executor instances - within one process.</p>

<p>Thus, an Executor instance can be dedicated to specific callback group(s) and the Executors thread(s) can be prioritized according to the real-time requirements of these groups. For example, all time-critical callbacks are handled by an RT-CRITICAL Executor instance running at the highest scheduler priority.</p>

<p>The following Figure illustrates this approach with two nodes served by three Callback-group-level Executors in one process:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/cbg-executor_sample_system.png" alt="Sample system with two nodes and three Callback-group-level Executors in one process" width="60%">
</center>

<p>The different callbacks of the Drive-Base node are distributed to different Executors (visualized by the color red, yellow and green).  For example the onCmdVel and publishWheelTicks callback are scheduled by the same Executor (yellow). Callbacks from different nodes can be serviced by the same Executor.</p>

<h3 id="api-changes">API Changes</h3>

<p>In this section, we describe the necessary changes to the Executor API:</p>
<ul>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/callback_group.hpp">include/rclcpp/callback_group.hpp</a>:</p>

    <ul>
      <li>Introduced an enum to distinguish up to three real-time classes (requirements) per node (RealTimeCritical, SoftRealTime, BestEffort)</li>
      <li>Changed association with Executor instance from nodes to callback groups.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">include/rclcpp/executor.hpp</a></p>

    <ul>
      <li>
        <p>Added functions to add and remove individual callback groups in addition to whole nodes.</p>
      </li>
      <li>
        <p>Replaced private vector of nodes with a map from callback groups to nodes.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/memory_strategy.hpp">include/rclcpp/memory_strategy.hpp</a></p>

    <ul>
      <li>Changed all functions that expect a vector of nodes to the just mentioned map.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node.hpp">include/rclcpp/node.hpp</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node_interfaces/node_base.hpp">include/rclcpp/node_interfaces/node_base.hpp</a></p>

    <ul>
      <li>Extended arguments of create_callback_group function for the real-time class.</li>
      <li>Removed the get_associated_with_executor_atomic function.</li>
    </ul>
  </li>
</ul>

<p>The callback-group-level executor has been merged into ROS 2 rclcpp in <a href="https://github.com/ros2/rclcpp/pull/1218/commits">pull request 1218</a>.</p>

<h3 id="test-bench">Test Bench</h3>

<p>As a proof of concept, we implemented a small test bench in the present package cbg-executor_ping-pong_cpp. The test bench comprises a Ping node and a Pong node which exchange real-time and best-effort messages simultaneously with each other. Each class of messages is handled with a dedicated Executor, as illustrated in the following Figure.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/ping_pong_diagram.png" alt="Architecture for the Callback-group-level Executor test bench" width="100%">
</center>

<p>With the test bench, we validated the functioning of the approach.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/cbg_executor_demo_plot.png" alt="Results from Callback-group-level Executor test bench" width="80%">
</center>

<p>In this example, the callback for the high priority task (red line) consumes 10ms and the low priority task (blue line) 40ms in the Pong Node. With a ping rate of 20 Hz, the CPU saturates (10ms*20+40ms*20=1000ms). With higher frequencies the high priorty task can continue to send its pong message, while the low priority pong task degrades. With a frequency of 100Hz the high priority task requires 100% CPU utilization. With higher ping rates it keeps sending pong messages with 100Hz, while the low priority task does not get any CPU ressources any more and cannot send any messages.</p>

<p>The test bench is provided in the <a href="https://github.com/ros2/examples/tree/master/rclcpp/executors/cbg_executor">cbg_executor_demo</a>.</p>

<h2 id="related-work">Related Work</h2>

<p>In this section, we provide an overview to related approaches and link to the corresponding APIs.</p>

<h3 id="fawkes-framework">Fawkes Framework</h3>

<p><a href="http://www.fawkesrobotics.org/">Fawkes</a> is a robotic software framework, which supports synchronization points for sense-plan-act like execution. It has been developed by RWTH Aachen since 2006. Source code is available at <a href="https://github.com/fawkesrobotics">github.com/fawkesrobotics</a>.</p>

<h4 id="synchronization">Synchronization</h4>
<p>Fawkes provides developers different synchronization points, which are very useful for defining an execution order of a typical sense-plan-act application. These ten synchronization points (wake-up hooks) are the following (cf. <a href="https://github.com/fawkesrobotics/fawkes/blob/master/src/libs/aspect/blocked_timing.h">libs/aspect/blocked_timing.h</a>):</p>

<ul>
  <li>WAKEUP_HOOK_PRE_LOOP</li>
  <li>WAKEUP_HOOK_SENSOR_ACQUIRE</li>
  <li>WAKEUP_HOOK_SENSOR_PREPARE</li>
  <li>WAKEUP_HOOK_SENSOR_PROCESS</li>
  <li>WAKEUP_HOOK_WORLDSTATE</li>
  <li>WAKEUP_HOOK_THINK</li>
  <li>WAKEUP_HOOK_SKILL</li>
  <li>WAKEUP_HOOK_ACT</li>
  <li>WAKEUP_HOOK_ACT_EXEC</li>
  <li>WAKEUP_HOOK_POST_LOOP</li>
</ul>

<h4 id="configuration-at-compile-time">Configuration at compile time</h4>
<p>At compile time, a desired synchronization point is defined as a constructor parameter for a module. For example, assuming that <code class="language-plaintext highlighter-rouge">mapLaserGenThread</code> shall be executed in SENSOR_ACQUIRE, the constructor is implemented as:</p>

<pre><code class="language-C++">MapLaserGenThread::MapLaserGenThread()
  :: Thread("MapLaserGenThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE),
     TransformAspect(TransformAspect::BOTH_DEFER_PUBLISHER, "Map Laser Odometry")

</code></pre>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">NaoQiButtonThread</code> shall be executed in the SENSOR_PROCESS hook, the constructor is:</p>

<pre><code class="language-C++">NaoQiButtonThread::NaoQiButtonThread()
  :: Thread("NaoQiButtonThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS)

</code></pre>

<h4 id="runtime-execution">Runtime execution</h4>
<p>At runtime, the <em>Executor</em> iterates through the list of synchronization points and executes all registered threads until completion. Then, the threads of the next synchronization point are called.</p>

<p>A module (thread) can be configured independent of these sense-plan-act synchronization points. This has the effect, that this thread is executed in parallel to this chain.</p>

<p>The high level overview of the Fawkes framework is shown in the next figure. At compile-time the configuration of the sense-plan act wakeup hook is done (upper part), while at run-time the scheduler iterates through this list of wakeup-hooks (lower part):</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/humble/rclc/png/fawkes_executor_diagram.png" alt="Sequence diagram for Fawkes Executor" width="50%">
</center>

<p>Hence, at run-time, the hooks are executed as a fixed static schedule without preemption. Multiple threads registered in the same hook are executed in parallel.</p>

<p>Orthogonal to the sequential execution of sense-plan-act like applications, it is possible to define further constraints on the execution order by means of a <code class="language-plaintext highlighter-rouge">Barrier</code>. A barrier defines a number of threads, which need to have finished before the thread can start, which owns the barrier.</p>

<p>These concepts are implemented by the following main classes:</p>

<ul>
  <li>
<em>Wakeup hook</em> by <code class="language-plaintext highlighter-rouge">SyncPoint</code> and <code class="language-plaintext highlighter-rouge">SyncPointManager</code>, which manages a list of synchronization points.</li>
  <li>
<em>Executor</em> by the class <code class="language-plaintext highlighter-rouge">FawkesMainThread</code>, which is the scheduler, responsible for calling the user threads.</li>
  <li>
<code class="language-plaintext highlighter-rouge">ThreadManager</code>, which is derived from <code class="language-plaintext highlighter-rouge">BlockedTimingExecutor</code>, provides the necessary API to add and remove threads to wakeup hooks as well as for sequential execution of the wakeup-hooks.</li>
  <li>
<code class="language-plaintext highlighter-rouge">Barrier</code> is an object similar to <code class="language-plaintext highlighter-rouge">condition_variable</code> in C++.</li>
</ul>

<h4 id="discussion">Discussion</h4>

<p>All threads are executed with the same priority. If multiple sense-plan-act chains shall be executed with different priorities, e.g. to prefer execution of emergency-stop over normal operation, then this framework reaches its limits.</p>

<p>Also, different execution frequencies cannot be modeled by a single instance of this sense-plan-act chain. However, in robotics the fastest sensor will drive the chain and all other hooks are executed with the same frequency.</p>

<p>The option to execute threads independent of the predefined wakeup-hooks is very useful, e.g. for diagnostics. The concept of the Barrier is useful for satisfying functional dependencies which need to be considered in the execution order.</p>

<h2 id="references">References</h2>
<ul>
  <li>
    <p>[S2021]<a name="S2021"></a> J. Staschulat, Micro-ROS: The rclc Executor, in Workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at ROS World, Oct. 2021, [<a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">slides</a>] [<a href="https://www.youtube.com/embed/IazrPF3RN1U">Video</a>]</p>
  </li>
  <li>
    <p>[SLD2021]<a name="SLD2021"></a> J. Staschulat, R. Lange and D. N. Dasari, Budget-based real-time Executor for Micro-ROS, arXiv Pre-Print, May 2021. [<a href="https://arxiv.org/abs/2105.05590">paper</a>]</p>
  </li>
  <li>
    <p>[L2020]<a name="L2020"></a> Ralph Lange: Advanced Execution Management with ROS 2, ROS-Industrial Conference, Dec 2020 <a href="https://micro-ros.github.io/download/2020-12-16_Advanced_Execution_Management_with_ROS_2.pdf">[Slides]</a></p>
  </li>
  <li>
    <p>[SLL2020]<a name="SLL2020"></a> J. Staschulat, I. Ltkebohle and R. Lange, The rclc Executor: Domain-specific deterministic scheduling mechanisms for ROS applications on microcontrollers: work-in-progress, 2020 International Conference on Embedded Software (EMSOFT), Singapore, Singapore, 2020, pp. 18-19. <a href="https://ieeexplore.ieee.org/document/9244014">[Paper]</a> <a href="https://whova.com/embedded/session/eswe_202009/1145800/">[Video]</a></p>
  </li>
  <li>
    <p>[CB2019]<a name="CB2019"> </a> D. Casini, T. Bla, I. Ltkebohle, B. Brandenburg: Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling, in Euromicro-Conference on Real-Time Systems 2019. <a href="http://drops.dagstuhl.de/opus/volltexte/2019/10743/">[Paper]</a> <a href="https://t-blass.de/talks/ECRTS2019.pdf">[slides]</a></p>
  </li>
  <li>
    <p>[L2018]<a name="L2018"></a> Ralph Lange: Callback-group-level Executor for ROS 2. Lightning talk at ROSCon 2018. Madrid, Spain. Sep 2018. <a href="https://roscon.ros.org/2018/presentations/ROSCon2018_Lightning1_4.pdf">[Slides]</a> <a href="https://vimeo.com/292707644">[Video]</a></p>
  </li>
  <li>
    <p>[EK2018]<a name="EK2018"></a> R. Ernst, S. Kuntz, S. Quinton, M. Simons: The Logical Execution Time Paradigm: New Perspectives for Multicore Systems, February 25-28 2018 (Dagstuhl Seminar 18092). <a href="http://drops.dagstuhl.de/opus/volltexte/2018/9293/pdf/dagrep_v008_i002_p122_18092.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[NSP2018]<a name="NSP2018"></a> A. Naderlinger, S. Resmerita, and W. Pree: LET for Legacy and Model-based Applications,
Proceedings of The Logical Execution Time Paradigm: New Perspectives for Multicore Systems (Dagstuhl Seminar 18092), Wadern, Germany, February 2018.</p>
  </li>
  <li>
    <p>[BP2017]<a name="BP2017"></a> A. Biondi, P. Pazzaglia, A. Balsini,  M. D. Natale: Logical Execution Time Implementation and Memory Optimization Issues in AUTOSAR Applications for Multicores, International Worshop on Analysis Tools and Methodologies for Embedded and Real-Time Systems (WATERS2017), Dubrovnik, Croatia.<a href="https://pdfs.semanticscholar.org/4a9e/b9a616c25fd0b4a4f7810924e73eee0e7515.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[KZH2015]<a name="KZH2015"></a> S. Kramer, D. Ziegenbein, and A. Hamann: Real World Automotive Benchmarks For Free, International Workshop on Analysis Tools and Methodologies for Embedded adn Real-Time Sysems (WATERS), 2015.</p>
  </li>
  <li>
    <p>[HHK2001]<a name="HHK2001"></a> Henzinger T.A., Horowitz B., Kirsch C.M. (2001) Giotto: A Time-Triggered Language for Embedded Programming. In: Henzinger T.A., Kirsch C.M. (eds) Embedded Software. EMSOFT 2001. Lecture Notes in Computer Science, vol 2211. Springer, Berlin, Heidelberg</p>
  </li>
  <li>
    <p>[LL1973]<a name="LL1973"></a> Liu, C. L.; Layland, J.:Scheduling algorithms for multiprogramming in a hard real-time environment, Journal of the ACM, 20 (1): 4661, 1973.</p>
  </li>
</ul>
</div>
              </div>
            </div>
          </div>
        </div>
      
    
    <div class="row">
      <div class="col-xs-12">
        <div class="panel panel-default">
          <div class="panel-heading"><span class="glyphicon glyphicon-list"></span> CHANGELOG</div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="changelog-for-package-rclc">Changelog for package rclc</h1>

<h2 id="402-2023-03-22">4.0.2 (2023-03-22)</h2>

<ul>
  <li>Drop build dependency on std_msgs (backport #314) (#315)</li>
  <li>Updated &lt;ros-tooling/setup-ros@0.4.2&gt; and
&lt;ros-tooling/action-ros-ci@0.2.7&gt; (#318) (#320)</li>
  <li>Removed build status for Galactic in README (EOL November 2022)
(#321) (#322)</li>
  <li>Update documentation about number_of_handles (#326) (#327)</li>
</ul>

<h2 id="401-2022-07-20">4.0.1 (2022-07-20)</h2>

<ul>
  <li>updated documentation bloom build status table (#291) (#292)</li>
  <li>updated os-version to ubuntu-22.04 (#295)</li>
  <li>[rolling] updated ros-tooling versions (backport #289) (#297)</li>
  <li>improved doxygen-generated API documentation (#301) (#302)</li>
</ul>

<h2 id="400-2022-04-28">4.0.0 (2022-04-28)</h2>

<ul>
  <li>updated version for Humble release</li>
</ul>

<h2 id="308-2022-04-14">3.0.8 (2022-04-14)</h2>

<ul>
  <li>Remove duplicate typedefs. (#249)</li>
  <li>Add rmw dependencies due to EventsExecutor PR in rcl (#255)</li>
  <li>Fix action client &amp; server deallocation (#257)</li>
  <li>updated documentation: build status for Rolling (#266)</li>
  <li>Update action client goal callback signature (#282)</li>
  <li>Upgrade parameters (#274)</li>
</ul>

<h2 id="307-2022-02-17">3.0.7 (2022-02-17)</h2>

<ul>
  <li>Fix enum naming for avoid collision (#242)</li>
  <li>Added dependency for package performance-test-fixture (#245)</li>
</ul>

<h2 id="306-2022-01-25">3.0.6 (2022-01-25)</h2>

<ul>
  <li>executor ignore canceled timers (#220)</li>
  <li>uddated documentation README.md (#229)</li>
  <li>resolved error in unit test see issue #230 (#231)</li>
  <li>Add thread dependency to examples (Rolling) (#237) (resolves in
this package only cpplint errors)</li>
</ul>

<h2 id="305-2021-11-23">3.0.5 (2021-11-23)</h2>

<ul>
  <li>Fix data_available reset for timer (backport #215) (#217)</li>
</ul>

<h2 id="304-2021-11-17">3.0.4 (2021-11-17)</h2>

<ul>
  <li>Ignoring unsuccessful SERVICE_TAKE (#175)</li>
  <li>Add rclc_parameter Quality Declaration (#144)</li>
  <li>use-ros2-testing (#185)</li>
  <li>Fix: printf in executor spin (#195)</li>
  <li>Fix init options handling (#202) (#205)</li>
  <li>Remove init options from support (#203)</li>
  <li>RCLC Actions Implementation (#170)</li>
  <li>Add rcl_action as build export dependency (#211)</li>
</ul>

<h2 id="303-2021-07-28">3.0.3 (2021-07-28)</h2>

<ul>
  <li>Checking for valid ROS context in spin_some</li>
  <li>Refactoring executor (removing callback_type)</li>
  <li>Fixing codecov config</li>
</ul>

<h2 id="302-2021-07-26">3.0.2 (2021-07-26)</h2>

<ul>
  <li>Updated codecov to ignore test folders</li>
  <li>Updated bloom release status table</li>
</ul>

<h2 id="301-2021-07-17">3.0.1 (2021-07-17)</h2>

<ul>
  <li>Added rclc_parameter package</li>
  <li>Added quality of service entity creation API</li>
  <li>Added executor prepare API</li>
  <li>Added support for removing subscription from executor</li>
  <li>Added support for subscription with context</li>
  <li>Added quality declaration statement</li>
  <li>Updated compatability function for sleep</li>
  <li>Removed duplicate NOTICE files</li>
</ul>

<h2 id="200-2021-04-23">2.0.0 (2021-04-23)</h2>

<ul>
  <li>Added codecov support</li>
  <li>New API of rcl_lifecycle in Rolling required major version bump</li>
</ul>

<h2 id="101-2021-03-29">1.0.1 (2021-03-29)</h2>

<ul>
  <li>Windows port</li>
  <li>Compatibility sleep function (Windows, POSIX-OS)</li>
  <li>Fixed RCL lifecycle API change for Rolling</li>
</ul>

<h2 id="100-2021-03-04">1.0.0 (2021-03-04)</h2>

<ul>
  <li>Service callbacks with context</li>
  <li>Fixed minor issues unit tests</li>
  <li>Upgraded setup_ros action (ci jobs)</li>
  <li>Removed Eloquent from ci jobs</li>
</ul>

<h2 id="017-2021-01-20">0.1.7 (2021-01-20)</h2>

<ul>
  <li>Corrected corrupted changelog</li>
</ul>

<h2 id="016-2021-01-20">0.1.6 (2021-01-20)</h2>

<ul>
  <li>Fixed issues due to Github Action timing delays on cloud build</li>
  <li>Fixed missing package dependency in Github Action for Eloquent</li>
</ul>

<h2 id="015-2020-12-11">0.1.5 (2020-12-11)</h2>

<ul>
  <li>Added support for services,clients and guard_conditions to rclc
executor</li>
  <li>Added table for bloom release status in README file</li>
</ul>

<h2 id="014-2020-11-25">0.1.4 (2020-11-25)</h2>

<ul>
  <li>Fixed error in bloom release</li>
</ul>

<h2 id="013-2020-11-23">0.1.3 (2020-11-23)</h2>

<ul>
  <li>Added rclc_lifecycle package</li>
  <li>Change maintainer information</li>
  <li>Minor fixes, updated unit tests</li>
</ul>

<h2 id="012-2020-05-19">0.1.2 (2020-05-19)</h2>

<ul>
  <li>Fixed compiler errors for bloom release</li>
</ul>

<h2 id="011-2020-05-14">0.1.1 (2020-05-14)</h2>

<ul>
  <li>Initial release</li>
</ul>
</div>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="humble-tutorials">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Wiki Tutorials</h3>
      </div>
      <div class="panel-body">
        
        <em>This package does not provide any links to tutorials in it's <a href="https://index.ros.org/contribute/metadata/">rosindex metadata</a>.</em>
        <em>You can check on the <a href="http://wiki.ros.org/rclc/Tutorials" target="_blank">ROS Wiki Tutorials</a> page for the package.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="humble-deps">
    <div class="row">
      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Package Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th class="text-center">Deps</th>
                  <th style="width: 100%">Name</th>
                </thead>
                <tbody>
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl#humble">rcl  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl_action#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl_action#humble">rcl_action  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcutils#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcutils#humble">rcutils  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_generator_c#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_generator_c#humble">rosidl_generator_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_typesupport_c#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_typesupport_c#humble">rosidl_typesupport_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_ros#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_ros#humble">ament_cmake_ros  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_gtest#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_gtest#humble">ament_cmake_gtest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_pytest#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_pytest#humble">ament_cmake_pytest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_auto#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_auto#humble">ament_lint_auto  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_common#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_common#humble">ament_lint_common  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/launch_testing#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/launch_testing#humble">launch_testing  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/osrf_testing_tools_cpp#humble-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/osrf_testing_tools_cpp#humble">osrf_testing_tools_cpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/std_msgs#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/std_msgs#humble">std_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/test_msgs#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/test_msgs#humble">test_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/example_interfaces#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/example_interfaces#humble">example_interfaces  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp#humble">rclcpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp_action#humble-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp_action#humble">rclcpp_action  </a></td>
                      </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
          <div class="panel-heading">
            <h3 class="panel-title">System Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <em>No direct system dependencies.</em>
            
          </div>
        </div>
      </div>

      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Dependant Packages</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th>Name</th>
                  <th class="text-center">Deps</th>
                </thead>
                <tbody>
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_common_diagnostics#humble">micro_ros_common_diagnostics</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_common_diagnostics#humble-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_diagnostic_updater#humble">micro_ros_diagnostic_updater</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_diagnostic_updater#humble-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_examples#humble">rclc_examples</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_examples#humble-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_lifecycle#humble">rclc_lifecycle</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_lifecycle#humble-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_parameter#humble">rclc_parameter</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_parameter#humble-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="humble-assets">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Launch files</h3>
      </div>
      <div class="panel-body">
        
          <em>No launch files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Messages</h3>
      </div>
      <div class="panel-body">
        
          <em>No message files found.</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Services</h3>
      </div>
      <div class="panel-body">
        
          <em>No service files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Plugins</h3>
      </div>
      <div class="panel-body">
        
          <em>No plugins found.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="humble-questions">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Recent questions tagged <kbd>rclc</kbd> at <strong><a href="https://robotics.stackexchange.com/" target="_blank">Robotics Stack Exchange</a></strong></h3>      </div>
      <div id="humble-question-list" class="panel-body" style="display: none;"></div>
      <div id="humble-no-question-list" class="panel-body" style="display: none;">
        <p>No questions yet, you can ask one <a href="https://robotics.stackexchange.com/questions/tagged/rclc+humble">here</a>.</p>
      </div>
      <div id="humble-get-question-fail" class="panel-body alert alert-warning" style="display: none;">
        <p>Failed to get question list, you can ticket an issue <a href="https://github.com/ros-infrastructure/rosindex/issues/new" target="_blank" class="alert-link">here</a> </p>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript" src="/js/package_body_tabs.js"></script>

<script src=/js/contribution_suggestions.js></script>
<script type="text/javascript">
jQuery(function() {
    // Update the count on the links to the contribution suggestions
    updateContributionSuggestionsCountOnPackage('https://github.com/ros2/rclc.git');
});
</script>

          </div>
          <div class="col-md-2 hidden-xs hidden-sm">
            
            
            



<div class="list-group list-group-sm ">
  <a class="list-group-item"
     target="_blank"
     href="http://docs.ros.org/en/humble/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       
       API Docs
  </a>
  <a class="list-group-item"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/humble/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       
       Browse Code
  </a>
  
  
  
  
  
  
</div>

          </div>
        </div>
      
    </div>
  </div>

  <div class="distro distro-jazzy">
    <div class="container-fluid">
      
        
        
        

        <div class="row">
          <div class="col-md-10">
            

<div class="well well-sm">
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px" src="/assets/package.png">
      </td>
      <td>
        <h3 style="margin-top: 5px">
          <a style="text-decoration:none" href="/p/rclc">rclc</a> <small>package from <a style="text-decoration:none" href="/r/rclc/github-ros2-rclc">rclc</a> repo</small>
        </h3>
          
            
            
              <span class="label label-default pkg-label">

rclc
</span>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_examples">

rclc_examples
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_lifecycle">

rclc_lifecycle
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_parameter">

rclc_parameter
</a>
            
          
      </td>
    </tr>
  </table>
</div>

            <div class="visible-xs visible-sm">
              
              
              



<div class="list-group list-group-sm list-group-horizontal list-group-justified">
  <a class="list-group-item text-center"
     target="_blank"
     href="http://docs.ros.org/en/jazzy/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       <br>
       API Docs
  </a>
  <a class="list-group-item text-center"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/rolling/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       <br>
       Browse Code
  </a>
  
  
  
  
  
  
</div>

            </div>
            



<ul class="nav nav-tabs nav-justified" id="jazzy-tabs" style="margin-bottom:20px">
  <li class="better-tabs active">
    <a href="#jazzy-overview" data-toggle="tab">Overview</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    
    <a href="#jazzy-assets" data-toggle="tab"><span class="label label-default">0</span> Assets</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    <a href="#jazzy-deps" data-toggle="tab"><span class="label label-primary">17</span> Dependencies</a>
  </li>
  <li class="better-tabs">
    
    <a href="#jazzy-tutorials" data-toggle="tab"><span class="label label-default">0</span> Tutorials</a>
  </li>
  <li class="better-tabs">
    <a href="#jazzy-questions" data-toggle="tab"><span id="jazzy-questions-count" class="label label-primary">0</span> Q & A</a>
  </li>
</ul>

<div class="tab-content">
  <div class="tab-pane active" id="jazzy-overview">
    
    <div class="row">
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h4 class="panel-title">Package Summary</h4></div>
          <div class="panel-body">
            <table class="table table-condensed">
              <tr>
                <td style="width:100px;" class="text-right"><strong>Tags</strong></td>
                <td>
                  
                  
                    <em>No category tags.</em>
                  
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Version</strong></td>
                <td>6.2.0</td>
              </tr>
              <tr>
                <td class="text-right"><strong>License</strong></td>
                <td>Apache License 2.0</td>
              </tr>
              <tr>
                <td class="text-right"><strong>Build type</strong></td>
                <td>
                  
                    <span class="label label-default">
                  
                    AMENT_CMAKE</span>
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Use</strong></td>
                <td>
                
                  <span class="label label-success">RECOMMENDED</span>
                
                </td>
              </tr>
            </table>
          </div>
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body">
            
            
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">ROS Client Library for the C language.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/ros2/rclc.git">https://github.com/ros2/rclc.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">rolling</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2024-10-30
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="No CI information available for this package.">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <em>No category tags.</em>
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/rclc/#jazzy-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#jazzy-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#jazzy-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
      </div>
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Package Description</h3></div>
          <div class="panel-body">
            The ROS client library in C.
          </div>
          <div class="panel-heading"><h4 class="panel-title">Additional Links</h4></div>
          <div class="panel-body">
            
            
              <em>No additional links.</em>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Maintainers</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>Pablo Garrido</li>
                
              </ul>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Authors</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>William Woodall</li>
                
              </ul>
            
          </div>
        </div>
      </div>
    </div>
    
      
        <div class="row">
          <div class="col-xs-12">
            <div class="panel panel-default">
              <div class="panel-heading"><span class="glyphicon glyphicon-file"></span><a href="https://github.com/ros2/rclc/tree/rolling/rclc/README.md" title="Open in git repository">rclc/README.md</a></div>
              <div class="panel-body">
                    <div class="rendered-markdown">
<h1 id="the-rclc-package">The rclc package</h1>

<h2 id="table-of-contents">Table of contents</h2>

<ul>
  <li>
    <p><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#introduction">Introduction</a></p>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#architecture">Architecture</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#scheduling-semantics">Scheduling Semantics</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#synchronization-of-multiple-rates">Synchronization of multiple rates</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#high-priority-processing-path">High-priority processing path</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#real-time-embedded-applications">Real-time embedded applications</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#rclc-executor">rclc Executor</a>
    <ul>
      <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#features">Features</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#trigger-condition">Trigger condition</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#sequential-execution">Sequential execution</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#let-semantics">LET-Semantics</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#executor-api">Executor API</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#configuration-phase">Configuration phase</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#running-phase">Running phase</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#examples">Examples</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#synchronization-of-multiple-rates-example">Synchronization of multiple rates example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#high-priority-processing-path-example">High-priority processing path example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#real-time-embedded-applications-example">Real-time embedded applications example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#future-work">Future work</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#download">Download</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#callback-group-level-executor">Callback-group-level Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#api-changes">API Changes</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#test-bench">Test Bench</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#related-work">Related Work</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#fawkes-framework">Fawkes Framework</a></li>
    </ul>
  </li>
  <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#references">References</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Predictable execution under given real-time constraints is a crucial requirement for many robotic applications. While the service-based paradigm of ROS allows a fast integration of many different functionalities, it does not provide sufficient control over the execution management. For example, there are no mechanisms to enforce a certain execution order of callbacks within a node. Also the execution order of multiple nodes is essential for control applications in mobile robotics. Cause-effect-chains comprising of sensor acquisition, evaluation of data and actuation control should be mapped to ROS nodes executed in this order, however there are no explicit mechanisms to enforce it. Furthermore, when data recordings collected in field tests as ROS-bags are re-played, then the results are often surprisingly different due to non-determinism of process scheduling.</p>

<p>Manually setting up a particular execution order of subscriptions and publishing topics as well as defining use-case specific priorities of the corresponding Linux processes is always possible. However, this approach is error-prone, difficult to extend and requires an in-depth knowledge of the deployed ROS 2 packages in the system.</p>

<p>Therefore the goal of the Executor in micro-ROS is to support roboticists with practical and easy-to-use real-time mechanisms which provide solutions for:</p>
<ul>
  <li>Deterministic execution</li>
  <li>Real-time guarantees</li>
  <li>Integration of real-time and non real-time functionalities on one platform</li>
  <li>Specific support for RTOS and microcontrollers</li>
</ul>

<p>In ROS 1 a network thread is responsible for receiving all messages and putting them into a FIFO queue (in roscpp). That is, all callbacks were called in a FIFO manner, without any execution management. With the introduction of DDS (data distribution service) in ROS 2, the messages are buffered in DDS. In ROS 2, an Executor concept was introduced to support execution management. At the rcl-layer, a <em>wait-set</em> is configured with handles to be received and in a second step, the handles are taken from the DDS-queue. A handle is a generic term defined in rcl-layer for timers, subscriptions, services, clients and guard conditions.</p>

<p>The standard implementation of the ROS 2 Executor for the C++ API (rclcpp) has, however, certain unusual features, like precedence of timers over all other DDS handles, non-preemptive round-robin scheduling for non-timer handles and considering only one input data for each handle (even if multiple could be available). These features have the consequence, that in certain situations the standard rclcpp Executor is not deterministic and it makes guaranteeing real-time requirements very hard [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#CB2019">CB2019</a>]. We have not looked at the ROS 2 Executor implementation for Python Frontend (rclpy) because we consider a micro-controllers platform, on which typically C or C++ appliations will run.</p>

<p>Given the goals for a Real-Time Executor and the limitations of the ROS 2 standard rclcpp Executor, the challenges are:</p>
<ul>
  <li>to develop an adequate and well-defined scheduling mechanisms for the ROS 2 framework and the real-time operating system (RTOS)</li>
  <li>to define an easy-to-use interface for ROS developers</li>
  <li>to model requirements (like latencies, determinism in subsystems)</li>
  <li>mapping of ROS 2 framework and operating system schedulers (semi-automated and optimized mapping is desired as well as generic, well-understood framework mechanisms)</li>
</ul>

<p>Our approach is to provide a real-time-capable Executor for the rcl+rclc layer (as described in section <a href="https://github.com/ros2/rclc/tree/rolling/rclc/../">Introduction to Client Library</a>.) in the C programming language .</p>

<p>As the first step, we propose the rclc Executor for the rcl-layer in C programming language with several new features to support real-time and deterministic execution: It supports 1.) user-defined static sequential execution, 2) conditional execution semantics, 3) multi-threaded execution with scheduling configuration, and 4) logical execution semantics (LET). Sequential execution refers to the runtime behavior, that all callbacks are executed in a pre-defined order independent of the arrival time of messages. Conditional execution is available with a trigger condition which enables typical processing patterns in robotics (which are analyzed in detail in section <a href="https://github.com/ros2/rclc/tree/rolling/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>. Configuration of scheduling parameters for multi-threaded application accomplishes prioritized execution. The logical execution time concept (LET) provides data synchronization for fixed periodic task scheduling of embedded applications.</p>

<p>Beyond the advanced execution management mechanisms for micro-ROS, we also contributed to improving and extending the Executor concept in rclcpp for standard ROS 2: the callback group-level Executor. It is not a new Executor but rather a refinement of the ROS 2 Executor API allowing to prioritize a group of callbacks which is not possible with the ROS 2 default Executor in its current Galactic release.</p>

<h2 id="analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</h2>

<p>ROS 2 allows to bundle multiple nodes in one operating system process. To coordinate the execution of the callbacks of the nodes of a process, the Executor concept was introduced in rclcpp (and also in rclpy).</p>

<p>The ROS 2 design defines one Executor (instance of <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">rclcpp::executor::Executor</a>) per process, which is typically created either in a custom main function or by the launch system. The Executor coordinates the execution of all callbacks issued by these nodes by checking for available work (timers, services, messages, subscriptions, etc.) from the DDS queue and dispatching it to one or more threads, implemented in <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/single_threaded_executor.hpp">SingleThreadedExecutor</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp">MultiThreadedExecutor</a>, respectively.</p>

<p>The dispatching mechanism resembles the ROS 1 spin thread behavior: the Executor looks up the wait sets, which notifies it of any pending callback in the DDS queue. If there are multiple pending callbacks, the ROS 2 Executor executes them in an in the order as they were registered at the Executor.</p>

<h3 id="architecture">Architecture</h3>

<p>The following diagram depicts the relevant classes of the standard ROS 2 Executor implementation:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/executor_class_diagram.png" alt="ROS 2 Executor class diagram" width="100%">
</center>

<p>Note that an Executor instance maintains weak pointers to the NodeBaseInterfaces of the nodes only. Therefore, nodes can be destroyed safely, without notifying the Executor.</p>

<p>Also, the Executor does not maintain an explicit callback queue, but relies on the queue mechanism of the underlying DDS implementation as illustrated in the following sequence diagram:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/executor_to_dds_sequence_diagram.png" alt="Call sequence from executor to DDS" width="100%">
</center>

<p>The Executor concept, however, does not provide means for prioritization or categorization of the incoming callback calls. Moreover, it does not leverage the real-time characteristics of the underlying operating-system scheduler to have finer control on the order of executions. The overall implication of this behavior is that time-critical callbacks could suffer possible deadline misses and a degraded performance since they are serviced later than non-critical callbacks. Additionally, due to the FIFO mechanism, it is difficult to determine usable bounds on the worst-case latency that each callback execution may incur.</p>

<h3 id="scheduling-semantics">Scheduling Semantics</h3>

<p>In a recent paper [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#CB2019">CB2019</a>], the rclcpp Executor has been analyzed in detail and a response time analysis of cause-effect chains has been proposed under reservation-based scheduling. The Executor distinguishes four categories of callbacks: <em>timers</em>, which are triggered by system-level timers, <em>subscribers</em>, which are triggered by new messages on a subscribed topic, <em>services</em>, which are triggered by service requests, and <em>clients</em>, which are triggered by responses to service requests. The Executor is responsible for taking messages from the input queues of the DDS layer and executing the corresponding callback. Since it executes callbacks to completion, it is a non-preemptive scheduler, However it does not consider all ready tasks for execution, but only a snapshot, called readySet. This readySet is updated when the Executor is idle and in this step it interacts with the DDS layer updating the set of ready tasks. Then for every type of task, there are dedicated queues (timers, subscriptions, services, clients) which are processed sequentially. The following undesired properties were pointed out:</p>

<ul>
  <li>Timers have the highest priority. The Executor processes <em>timers</em> always first.  This can lead to the intrinsic effect, that in overload situations messages from the DDS queue are not processed.</li>
  <li>Non-preemptive round-robin scheduling of non-timer handles. Messages arriving during the processing of the readySet are not considered until the next update, which depends on the execution time of all remaining callbacks. This leads to priority inversion, as lower-priority callbacks may implicitly block higher-priority callbacks by prolonging the current processing of the readySet.</li>
  <li>Only one message per handle is considered. The readySet contains only one task instance, For example, even if multiple messages of the same topic are available, only one instance is processed until the Executor is idle again and the readySet is updated from the DDS layer. This aggravates priority inversion, as a backlogged callback might have to wait for multiple processing of readySets until it is considered for scheduling. This means that non-timer callback instances might be blocked by multiple instances of the same lower-priority callback.</li>
</ul>

<p>Due to these findings, the authors present an alternative approach to provide determinism and to apply well-known schedulability analyses to a ROS 2 systems. A response time analysis is described under reservation-based scheduling.</p>

<h2 id="analysis-of-processing-patterns">Analysis of processing patterns</h2>
<p>The development of an execution management mechanism for micro-ROS is based on an analysis of processing patterns commonly used in robotics and embedded systems. First, typical processing patterns in mobile robotics are presented which are used to implement deterministic behavior. Then, the processing patterns in the real-time embedded systems are analyzed, in which, as a main difference, the time-triggered paradigm is applied to accomplish real-time behavior.</p>

<h3 id="sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</h3>
<p>Now we describe common software design patterns which are used in mobile robotics to achieve deterministic behavior. For each design pattern we describe the concept and the derived requirements for a deterministic Executor.</p>

<p><strong>Concept:</strong></p>

<p>A common design paradigm in mobile robotics is a control loop, consisting of several phases: A sensing phase to aquire sensor data, a plan phase for localization and path planning and an actuation-phase to steer the mobile robot. Of course, more phases are possible, here these three phases shall serve as an example. Such a processing pipeline is shown in Figure 1.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensePlanActScheme.png" alt="Sense Plan Act Pipeline" width="60%">
</center>
<center>
Figure 1: Multiple sensors driving a Sense-Plan-Act pipeline.
</center>

<p>Typically multiple sensors are used to perceive the environment. For example an IMU and a laser scanner. The quality of localization algorithms highly depend on how old such sensor data is when it is processed. Ideally the latest data of all sensors should be processed. One way to achive this is to execute first all sensor drivers in the sense-phase and then process all algorithms in the plan-phase.</p>

<p>Currently, such a processing order cannot be defined with the default Executor of rclcpp. One could in principle design a data-driven pipeline, however if e.g. the Laser scan is needed by some other callback in the sense-phase as well as in the plan-phase, the processing order of these subscribers is arbitrary.</p>

<p>For this sense-plan-act pattern, we could define one executor for each phase. The plan-phase would be triggered only when all callbacks in the sense-phase have finished.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
</ul>

<h3 id="synchronization-of-multiple-rates">Synchronization of multiple rates</h3>

<p><strong>Concept:</strong></p>

<p>Often multiple sensors are being used to sense the environment for mobile robotics. While an IMU sensor provides data samples at a very high rate (e.g., 500 Hz), laser scans are availabe at a much slower frequency (e.g. 10Hz) determined by the revolution time. Then the challenge is, how to deterministically fuse sensor data with different frequencies. This problem is depicted in Figure 2.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensorFusion_01.png" alt="Sychronization of multiple rates" width="30%">
</center>
<center>
Figure 2: How to deterministically process multi-frequent sensor data.
</center>

<p>Due to scheduling effects, the callback for evaluating the laser scan might be called just before or just after an IMU data is received. One way to tackle this is to write additional synchronization code inside the application. Obviously, this is a cumbersome and not-portable solution.</p>

<p>An Alternative would be to evalute the IMU sample and the laser scan by synchronizing their frequency. For example by processing always 50 IMU samples with one laser scan. This approach is shown in Figure 3. A pre-processing callback aggregates the IMU samples and sends an aggregated message with 50 samples at 10Hz rate. Now both messages have the same frequency. With a trigger condition, which fires when both messages are available, the sensor fusion algorithm can expect always synchronized input data.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensorFusion_02.png" alt="Sychnronization with a trigger" width="40%">
</center>
<center>
Figure 3: Synchronization of multiple input data with a trigger.
</center>

<p>In ROS 2, this is currently not possible to be modeled because of the lack of a trigger concept in the Executors of rclcpp and rclpy. Message filters could be used to synchronize input data based on the timestamp in the header, but this is only available in rclcpp (and not in rcl). Further more, it would be more efficient to have such a trigger concept directly in the Executor.</p>

<p>Another idea would be to activly request for IMU data only when a laser scan is received. This concept is shown in Figure 4. Upon arrival of a laser scan mesage, first, a message with aggregated IMU samples is requested. Then, the laser scan is processed and later the sensor fusion algorithm. An Executor, which would support sequential execution of callbacks, could realize this idea.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensorFusion_03.png" alt="Sychronization with sequence" width="30%">
</center>
<center>
Figure 4: Synchronization with sequential processing.
</center>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
  <li>sequential procesing of callbacks</li>
</ul>

<h3 id="high-priority-processing-path">High-priority processing path</h3>
<p><strong>Concept</strong>
Often a robot has to fullfill several activities at the same time. For example following a path and avoiding obstacles. While path following is a permanent activity, obstacle avoidance is trigged by the environment and should be immediately reacted upon. Therefore one would like to specify priorities to activities. This is depicted in Figure 5:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/highPriorityPath.png" alt="HighPriorityPath" width="50%">
</center>
<center>
Figure 5: Managing high priority path with sequential order.
</center>

<p>Assuming a simplified control loop with the activities sense-plan-act, the obstacle avoidance, which might temporarily stop the robot, should be processed before the planning phase. In this example we assume that these activites are processed in one thread.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>sequential processing of callbacks</li>
</ul>

<h3 id="real-time-embedded-applications">Real-time embedded applications</h3>
<p>In embedded systems, real-time behavior is approached by using the time-triggered paradigm, which means that the processes are periodically activated. Processes can be assigned priorities to allow pre-emptions. Figure 6 shows an example, in which three processes with fixed periods are shown. The middle and lower process are preempted multiple times depicted with empty dashed boxes.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/scheduling_01.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 6: Fixed periodic preemptive scheduling.
</center>

<p>To each process one or multiple tasks can be assigned, as shown in Figure 7. These tasks are executed sequentially, which is often called cooperative scheduling.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/scheduling_02.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 7: Processes with sequentially executed tasks.
</center>

<p>While there are different ways to assign priorities to a given number of processes,
the rate-monotonic scheduling assignment, in which processes with a shorter period have a higher priority, has been shown optimal if the processor utilization is less than 69% [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#LL1973">LL1973</a>].</p>

<p>In the last decades many different scheduling approaches have been presented, however fixed-periodic preemptive scheduling is still widely used in embedded real-time systems [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#KZH2015">KZH2015</a>]. This becomes also obvious, when looking at the features of current operating systems. Like Linux, real-time operating systems, such as NuttX, Zephyr, FreeRTOS, QNX etc., support fixed-periodic preemptive scheduling and the assignment of priorities, which makes the time-triggered paradigm the dominant design principle in this domain.</p>

<p>However, data consistency is often an issue when preemptive scheduling is used and if data is being shared across multiple processes via global variables. Due to scheduling effects and varying execution times of processes, writing and reading these variables could occur sometimes sooner or later. This results in an latency jitter of update times (the timepoint at which a variable change becomes visible to other processes). Race conditions can occur when multiple processes access a variable at the same time. So solve this problem, the concept of logical-execution time (LET) was introduced in [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#HHK2001">HHK2001</a>], in which communication of data occurs only at pre-defined periodic time instances: Reading data only at the beginning of the period and writing data only at the end of the period. The cost of an additional latency delay is traded for data consistency and reduced jitter. This concept has also recently been applied to automotive applications[<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#NSP2018">NSP2018</a>].</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/scheduling_LET.png" alt="Schedule with fixed periods" width="80%">
</center>
<center>
Figure 8: Data communication without and with Logical Execution Time paradigm.
</center>

<p>An Example of the LET concept is shown in Figure 8. Assume that two processes are communicating data via one global variable. The timepoint when this data is written is at the end of the processing time. In the default case (left side), the process p<sub>3</sub> and p<sub>4</sub> receive the update. At the right side of Figure 8, the same scenario is shown with LET semantics. Here, the data is communicated only at period boundaries. In this case, the lower process communicates at the end of the period, so that always process p<sub>3</sub> and p<sub>5</sub> receive the new data.</p>

<p><strong>Concept:</strong></p>
<ul>
  <li>periodic execution of processes</li>
  <li>assignment of fixed priorities to processes</li>
  <li>preemptive scheduling of processes</li>
  <li>co-operative scheduling of tasks within a process (sequential execution)</li>
  <li>data synchronization with LET-semantics</li>
</ul>

<p>While periodic activation is possible in ROS 2 by using timers, preemptive scheduling is supported by the operating system and assigning priorities on the granularity of threads/processes that correspond to the ROS nodes; it is not possible to sequentially execute callbacks, which have no data-dependency. Furthermore data is read from the DDS queue just before the callback is executed and data is written sometime during the time the application is executed. While the <code class="language-plaintext highlighter-rouge">spin_period</code> function of the rclcpp Executor allows to check for data at a fixed period and executing those callbacks for which data is available, however, with this spin-function does not execute all callbacks irrespective wheter data is available or not. So <code class="language-plaintext highlighter-rouge">spin_period</code> is not helpful to periodically execute a number of callbacks (aka tasks within a process). So we need a mechanism that triggers the execution of multiple callbacks (aka tasks) based on a timer. Data transmission is achieved via DDS which does not allow to implement a LET-semantics. To summarize, we derive the following requirements.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>trigger the execution</li>
  <li>sequential processing of callbacks</li>
  <li>data synchronization with LET semantics</li>
</ul>

<h2 id="rclc-executor">rclc Executor</h2>

<p>The rclc Executor is a ROS 2 Executor based on the rcl-layer in C programming language. As discussed above, the default rclcpp Executor is not suitable to implement real-time applications because of three main reasons: timers are preferred over all other handles, no priorization of callback execution and the round-robin to completion execution of callbacks. On the other hand, several processing patterns have been developed as best practices to achieve non-functional requirements, such as bounded end-to-end latencies, low jitter of response times of cause-effect chains, deterministic processing and short response times even in overload situations. These processing patterns are difficult to implement with the concepts availabe in the default ROS 2 Executor, therefore we have developed a flexible Executor: the rclc Executor.</p>

<h3 id="features">Features</h3>

<p>The rclc Executor is feature-complete, i.e. it supports all event types as the default ROS 2 Executor, which are:</p>
<ul>
  <li>subscriptions</li>
  <li>timers</li>
  <li>services</li>
  <li>clients</li>
  <li>guard conditions</li>
  <li>actions</li>
  <li>lifecycle</li>
</ul>

<p>The flexible rclc Executor provides on top the following new features:</p>
<ul>
  <li>triggered execution</li>
  <li>user-defined sequential execution</li>
  <li>multi-threading and scheduling configuration (WIP)</li>
  <li>LET-semantics for data synchronization of periodic process scheduling</li>
</ul>

<p>First, a <em>trigger condition</em> allows to define when the processing of a callback shall start. This is useful to implement sense-plan-act control loops or more complex processing structures with directed acyclic graphs. Second, a user can specify the <em>processing order</em> in which these callbacks will be executed. With this feature, the pattern of sensor fusion with multiple rates, in which data is requested from a sensor based on the arrival of some other sensor, can be easily implemented. Third, the assignment of scheduling parameters (e.g., priorities) of the underlying operating system. With this feature, prioritized processing can be implemented. Finally, for periodic applications, the <em>LET Semantics</em> has been implemented to support data consistency for periodic process scheduling. These features are now described in more detail.</p>

<h4 id="sequential-execution">Sequential execution</h4>

<ul>
  <li>At configuration, the user defines the order of handles.</li>
  <li>At configuration, the user defines whether the handle shall be called only when new data is available (ON_NEW_DATA) or whether the callback shall always be called (ALWAYS).</li>
  <li>At runtime, all handles are processed in the user-defined order
    <ul>
      <li>if the configuration of handle is ON_NEW_DATA, then the corresponding callback is only called if new data is available</li>
      <li>if the configuration of the handle is ALWAYS, then the corresponding callback is always. If no data is available, then the callback is called with no data (e.g. NULL pointer).</li>
    </ul>
  </li>
</ul>

<p>Figure 9 shows three callbacks, A, B and C. Assume, they shall be executed in the order <em>B,A,C</em>. Then the user adds the callbacks to the rclc Executor in this order. Whenever new messages have arrived then the callbacks for which a new message is availabe will be always executed in the user-defined processing order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/rclc_executor_sequential_execution.png" alt="Sequential execution semantics" width="50%">
</center>
<center>
Figure 9: Sequential execution semantics.
</center>

<h4 id="trigger-condition">Trigger condition</h4>

<ul>
  <li>Given a set of handles, a trigger condition, which is based on the availability of input data of these handles, decides when the processing of all callbacks starts. This is shown in Figure 10.</li>
</ul>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_01.png" alt="Trigger condition overview" width="50%">
</center>
<center>
Figure 10: Executor with trigger condition
</center>

<ul>
  <li>Available options:
    <ul>
      <li>ALL operation: fires when input data is available for all handles</li>
      <li>ANY operation: fires when input data is available for at least one handle (OR semantics)</li>
      <li>ONE: fires when input data for a user-specified handle is available</li>
      <li>User-defined function: user can implement custom logic</li>
    </ul>
  </li>
</ul>

<p>Figure 11 shows an example of the ALL semantics. Only if all messages <em>msg_A, msg_B, msg_C</em> were received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_ALL.png" alt="Trigger condition ALL" width="30%">
</center>
<center>
Figure 11: Trigger condition ALL
</center>

<p>Figure 12 shows an example of the ANY semantics. Thas is, if any messages <em>msg_A, msg_B, msg_C</em> was received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order. This is equivalent to OR semantics.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_OR.png" alt="Trigger condition ANY" width="30%">
</center>
<center>
Figure 12: Trigger condition ANY (OR)
</center>

<p>Figure 13 shows an example of the ONE semantics. Thas is, only if message <em>msg_B</em> was received, the trigger condition is fullfilled and (potentially all) callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_ONE.png" alt="Trigger condition ONE" width="30%">
</center>
<center>
Figure 13: Trigger condition ONE
</center>

<p>Figure 14 describes the custom semantics. A custom trigger condition with could be a more complex logic of multiple messages, can be passed to the executor. This might also include hardware triggers, like interrupts.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_user_defined.png" alt="Trigger condition user-defined" width="30%">
</center>
<center>
Figure 14: Trigger condition user-defined
</center>

<h4 id="let-semantics">LET-Semantics</h4>
<ul>
  <li>Assumption: time-triggered system, the executor is activated periodically</li>
  <li>When the trigger fires, reads all input data and makes a local copy</li>
  <li>Processes all callbacks in sequential order</li>
  <li>Write output data at the end of the executors period (Note: this is not implemented yet)</li>
</ul>

<p>Additionally we have implemented the current rclcpp Executor semantics (RCLCPP):</p>
<ul>
  <li>waiting for new data for all handles (rcl_wait)</li>
  <li>using trigger condition ANY</li>
  <li>if trigger fires, start processing handles in pre-defined sequential order</li>
  <li>request from DDS-queue the new data just before the handle is executed (rcl_take)</li>
</ul>

<p>The selection of the Executor semantics is optional. The default semantics is RCLCPP.</p>

<h4 id="multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</h4>

<p>The rclc Executor has been extended for multi-threading. It supports the assignment of scheduling policies, like priorities or more advanced scheduling algorithms as reservation-based scheduling, to subscription callbacks. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, Pre-print <a href="https://github.com/ros2/rclc/tree/rolling/rclc/#SLD2021">SLD2021</a>]. The overall architecture is shown in Figure 15. One Executor thread is responsible for checking for new data from the DDS queue. For every callback, a thread is spawned with the dedicted scheduling policy provided by the operating system. The Executor then dispatches new data of a subscription to its corresponding callback function, which is then executed in its own thread by operating system.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/rclc_executor_multi_threaded.png" alt="Multi-threaded rclc Executor" width="90%">
</center>
<center>
Figure 15: multi-threaded rclc-Executor
</center>

<h3 id="executor-api">Executor API</h3>
<p>The API of the rclc Executor can be divided in two phases: Configuration and Running.</p>
<h4 id="configuration-phase">Configuration phase</h4>
<p>During the configuration phase, the user shall define:</p>
<ul>
  <li>the total number of callbacks</li>
  <li>the sequence of the callbacks</li>
  <li>trigger condition (optional, default: ANY)</li>
  <li>data communcation semantics (optional, default ROS2)</li>
</ul>

<p>As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added.</p>

<p>Also in the XRCE-DDS middleware the maximum number of handles need to be configured. See <a href="https://docs.vulcanexus.org/en/humble/rst/tutorials/micro/memory_management/memory_management.html#entity-creation">Memory Management Tutorial</a> for the defaults and configuration of the colcon.meta configuration file. To make sure that the changes were applied, you can check the defined values in the following library include file: build/rmw_microxrcedds/include/rmw_microxrcedds_c/config.h.</p>

<p>Then, the user adds handles and the corresponding callbacks (e.g. for subscriptions and timers) to the Executor. The order in which this takes place, defines later the sequential processing order during runtime.</p>

<p>For each handle the user can specify, if the callback shall be executed only if new data is available (ON_NEW_DATA) or if the callback shall always be executed (ALWAYS). The second option is useful when the callback is expected to be called at a fixed rate.</p>

<p>The trigger condition defines when the processing of these callbacks shall start. For convenience some default conditions have been defined:</p>
<ul>
  <li>trigger_any(default) : start executing if any callback has new data</li>
  <li>trigger_all : start executing if all callbacks have new data</li>
  <li>trigger_one(&amp;<code class="language-plaintext highlighter-rouge">data</code>) : start executing if <code class="language-plaintext highlighter-rouge">data</code> has been received</li>
  <li>user_defined_function: the user can also define its own function with more complex logic</li>
</ul>

<p>With trigger_any being the default, the current semantics of the rclcpp Executor is selected.</p>

<p>The data communication semantics can be</p>
<ul>
  <li>ROS2 (default)</li>
  <li>LET</li>
</ul>

<p>To be compatible with ROS2 rclcpp Executor, the existing rclcpp semantics is implemented as ROS2. That is, with the spin-function the DDS-queue is constantly monitored for new data (rcl_wait). If new data becomes available, then is fetched from DDS (rcl_take) immediately before the callback is executed. All callbacks are processed in the user-defined order, this is the only difference to the rclcpp Executor, in which no order can be specified.</p>

<p>Secondly, the LET semantics is implemented such that at the beginning of processing all available data is fetched (rcl_take) and buffered and then the callbacks are processed in the pre-defined operating on the buffered copy.</p>

<h4 id="running-phase">Running phase</h4>

<p>As the main functionality, the Executor has a <code class="language-plaintext highlighter-rouge">spin</code>-function which constantly checks for new data at the DDS-queue, like the rclcpp Executor in ROS2. If the trigger condition is satisfied then all available data from the DDS queue is processed according to the specified semantics (ROS or LET) in the user-defined sequential order. After all callbacks have been processed the DDS is checked for new data again.</p>

<p>Available spin functions are</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">spin_some</code>  - spin one time</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin_period</code> - spin with a period</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin</code> - spin indefinitly</li>
</ul>

<h3 id="examples">Examples</h3>
<p>We provide the relevant code snippets how to setup the rclc Executor for the processing patterns as described above.</p>

<h4 id="sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</h4>

<p>In this example we want to realise a sense-plan-act pipeline in a single thread. The trigger condition is demonstrated by activating
the sense-phase when both data for the Laser and IMU are available. Three executors are necessary <code class="language-plaintext highlighter-rouge">exe_sense</code>, <code class="language-plaintext highlighter-rouge">exe_plan</code> and <code class="language-plaintext highlighter-rouge">exe_act</code>. The two sensor acquisition callbacks <code class="language-plaintext highlighter-rouge">sense_Laser</code> and <code class="language-plaintext highlighter-rouge">sense_IMU</code> are registered in the Executor <code class="language-plaintext highlighter-rouge">exe_sense</code>.
The trigger condition ALL is responsible to activate the sense-phase only when all data for these two callbacks are available. Finally all three Executors are spinning using a <code class="language-plaintext highlighter-rouge">while</code>-loop and the <code class="language-plaintext highlighter-rouge">spin_some</code> function.</p>

<p>The definitions of callbacks are omitted.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act;
rcle_let_executor_t exe_sense, exe_plan, exe_act;
// initialize executors
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
rclc_executor_init(&amp;exe_plan, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_act, &amp;context, 1, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb1, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_let_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);
// executor for plan-phase
rclc_executor_add_subscription(&amp;exe_plan, &amp;plan, &amp;my_sub_cb3, ON_NEW_DATA);
// executor for act-phase
rclc_executor_add_subscription(&amp;exe_act, &amp;act, &amp;my_sub_cb4, ON_NEW_DATA);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_sense);
  rclc_executor_spin_some(&amp;exe_plan);
  rclc_executor_spin_some(&amp;exe_act);
}

</code></pre>

<h4 id="synchronization-of-multiple-rates-example">Synchronization of multiple rates example</h4>

<p>The sensor fusion synchronizing the multiple rates with a trigger is shown below.</p>

<pre><code class="language-C">...
rcl_subscription_t aggr_IMU, sense_Laser, sense_IMU;
rcle_let_executor_t exe_aggr, exe_sense;
// initialize executors
rclc_executor_init(&amp;exe_aggr, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for aggregate IMU data
rclc_executor_add_subscription(&amp;exe_aggr, &amp;aggr_IMU, &amp;my_sub_cb1, ON_NEW_DATA);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb3, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_aggr);
  rclc_executor_spin_some(&amp;exe_sense);
}

</code></pre>

<p>The setup for the sensor fusion using sequential execution is shown below.
Note that the sequetial order is <code class="language-plaintext highlighter-rouge">sense_IMU</code>, which will request the aggregated IMU message, and then <code class="language-plaintext highlighter-rouge">sense_Laser</code>
while the trigger will fire, when a laser message is received.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU;
rcle_let_executor_t exe_sense;
// initialize executor
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe_sense);

</code></pre>
<h4 id="high-priority-processing-path-example">High priority processing path example</h4>

<p>This example shows the sequential processing order to execute the obstacle avoidance <code class="language-plaintext highlighter-rouge">obst_avoid</code>
after the callbacks of the sense-phase and before the callback of the planning phase <code class="language-plaintext highlighter-rouge">plan</code>.
The control loop is started when a laser message is received. Then an aggregated IMU message is requested,
like in the example above. Then all the other callbacks are always executed. This assumes that these callbacks
communicate via a global data structure. Race conditions cannot occur, because the callbacks
run all in one thread.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act, obst_avoid;
rcle_let_executor_t exe;
// initialize executors
rclc_executor_init(&amp;exe, &amp;context, 5, ...);
// define processing order
rclc_executor_add_subscription(&amp;exe, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe, &amp;obst_avoid, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;plan, &amp;my_sub_cb4, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;act, &amp;my_sub_cb5, ALWAYS);
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="real-time-embedded-applications-example">Real-time embedded applications example</h4>

<p>With seqential execution the co-operative scheduling of tasks within a process can be modeled. The trigger condition is used to periodically activate the process which will then execute all callbacks in a pre-defined order. Data will be communicated using the LET-semantics. Every Executor is executed in its own tread, to which an appropriate priority can be assigned.</p>

<p>In the following example, the Executor is setup with 4 handles. We assume a process has three subscriptions <code class="language-plaintext highlighter-rouge">sub1</code>, <code class="language-plaintext highlighter-rouge">sub2</code>, <code class="language-plaintext highlighter-rouge">sub3</code>. The sequential processing order is given by the order as they are added to the Executor. A timer <code class="language-plaintext highlighter-rouge">timer</code> defines the period.  The <code class="language-plaintext highlighter-rouge">trigger_one</code> with the paramter <code class="language-plaintext highlighter-rouge">timer</code> is used, so that whenever the timer is ready, all callbacks are processed. Finally the data communication semantics LET is defined.</p>

<pre><code class="language-C">#include "rcl_executor/let_executor.h"

// define subscription callback
void my_sub_cb1(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb2(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb3(const void * msgin)
{
  // ...
}

// define timer callback
void my_timer_cb(rcl_timer_t * timer, int64_t last_call_time)
{
  // ...
}

// necessary ROS 2 objects
rcl_context_t context;   
rcl_node_t node;
rcl_subscription_t sub1, sub2, sub3;
rcl_timer_t timer;
rcle_let_executor_t exe;

// define ROS context
context = rcl_get_zero_initialized_context();
// initialize ROS node
rcl_node_init(&amp;node, &amp;context,...);
// create subscriptions
rcl_subscription_init(&amp;sub1, &amp;node, ...);
rcl_subscription_init(&amp;sub2, &amp;node, ...);
rcl_subscription_init(&amp;sub3, &amp;node, ...);
// create a timer
rcl_timer_init(&amp;timer, &amp;my_timer_cb, ... );
// initialize executor with four handles
rclc_executor_init(&amp;exe, &amp;context, 4, ...);
// define static execution order of handles
rclc_executor_add_subscription(&amp;exe, &amp;sub1, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub2, &amp;my_sub_cb2, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub3, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_timer(&amp;exe, &amp;timer);
// trigger when handle 'timer' is ready
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;timer);
// select LET-semantics
rclc_executor_data_comm_semantics(&amp;exe, LET);
// spin forever
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</h4>
<p>The rclc Executor has been presented at the workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at <a href="https://roscon.ros.org/world/2021/">ROS World 2021</a> (i.e. the online version of ROSCon)[<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#S2021">S2021</a>]. A <a href="https://github.com/ros-realtime/reference-system">Reference System</a> for testing and benchmarking ROS Executors has been developed for this workshop. The application of the rclc Executor on the reference system with the trigger condition can be found in the <a href="https://github.com/ros-realtime/reference-system/tree/rclc_executor">rclc-executor branch of the Reference System</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/IazrPF3RN1U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>The slides can be downloaded <a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">here</a>. All information and the videos and slides of the other talks of the workshop can be found at <a href="https://www.apex.ai/roscon-21">www.apex.ai/roscon-21</a>.</p>

<h3 id="future-work">Future work</h3>

<ul>
  <li>Full LET semantics (writing data at the end of the period)
    <ul>
      <li>one publisher that periodically publishes</li>
      <li>if Executors are running in multiple threads,
publishing needs to be atomic</li>
    </ul>
  </li>
  <li>Multi-threaded executor with assignment of scheduling policies of unerlying operating system. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, pre-print <a href="https://github.com/ros2/rclc/tree/rolling/rclc/#SLD2021">SLD2021</a>].</li>
</ul>

<h3 id="download">Download</h3>
<p>The rclc Executor can be downloaded from the <a href="https://github.com/ros2/rclc">ros2/rclc repository</a>. It is available for the ROS 2 versions Foxy, Galactic and Rolling. The repository provides several packages including the <a href="https://github.com/ros2/rclc/tree/master/rclc">rclc Executor</a> and an <a href="https://github.com/ros2/rclc/tree/master/rclc_examples">rclc_examples package</a> with several application examples.</p>

<h2 id="callback-group-level-executor">Callback-group-level Executor</h2>

<p>The Callback-group-level Executor was an early prototype for a refined rclcpp Executor API developed in micro-ROS. It has been derived from the default rclcpp Executor and addresses some of the aforementioned deficits. Most important, it was used to validate that the underlying layers (rcl, rmw, rmw_adapter, DDS) allow for multiple Executor instances without any negative interferences.</p>

<p>As the default rclcpp Executor works at a node-level granularity  which is a limitation given that a node may issue different callbacks needing different real-time guarantees - we decided to refine the API for more fine-grained control over the scheduling of callbacks on the granularity of callback groups using. We leverage the callback-group concept existing in rclcpp by introducing real-time profiles such as RT-CRITICAL and BEST-EFFORT in the callback-group API (i.e. rclcpp/callback_group.hpp). Each callback needing specific real-time guarantees, when created, may therefore be associated with a dedicated callback group. With this in place, we enhanced the Executor and depending classes (e.g., for memory allocation) to operate at a finer callback-group granularity. This allows a single node to have callbacks with different real-time profiles assigned to different Executor instances - within one process.</p>

<p>Thus, an Executor instance can be dedicated to specific callback group(s) and the Executors thread(s) can be prioritized according to the real-time requirements of these groups. For example, all time-critical callbacks are handled by an RT-CRITICAL Executor instance running at the highest scheduler priority.</p>

<p>The following Figure illustrates this approach with two nodes served by three Callback-group-level Executors in one process:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/cbg-executor_sample_system.png" alt="Sample system with two nodes and three Callback-group-level Executors in one process" width="60%">
</center>

<p>The different callbacks of the Drive-Base node are distributed to different Executors (visualized by the color red, yellow and green).  For example the onCmdVel and publishWheelTicks callback are scheduled by the same Executor (yellow). Callbacks from different nodes can be serviced by the same Executor.</p>

<h3 id="api-changes">API Changes</h3>

<p>In this section, we describe the necessary changes to the Executor API:</p>
<ul>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/callback_group.hpp">include/rclcpp/callback_group.hpp</a>:</p>

    <ul>
      <li>Introduced an enum to distinguish up to three real-time classes (requirements) per node (RealTimeCritical, SoftRealTime, BestEffort)</li>
      <li>Changed association with Executor instance from nodes to callback groups.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">include/rclcpp/executor.hpp</a></p>

    <ul>
      <li>
        <p>Added functions to add and remove individual callback groups in addition to whole nodes.</p>
      </li>
      <li>
        <p>Replaced private vector of nodes with a map from callback groups to nodes.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/memory_strategy.hpp">include/rclcpp/memory_strategy.hpp</a></p>

    <ul>
      <li>Changed all functions that expect a vector of nodes to the just mentioned map.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node.hpp">include/rclcpp/node.hpp</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node_interfaces/node_base.hpp">include/rclcpp/node_interfaces/node_base.hpp</a></p>

    <ul>
      <li>Extended arguments of create_callback_group function for the real-time class.</li>
      <li>Removed the get_associated_with_executor_atomic function.</li>
    </ul>
  </li>
</ul>

<p>The callback-group-level executor has been merged into ROS 2 rclcpp in <a href="https://github.com/ros2/rclcpp/pull/1218/commits">pull request 1218</a>.</p>

<h3 id="test-bench">Test Bench</h3>

<p>As a proof of concept, we implemented a small test bench in the present package cbg-executor_ping-pong_cpp. The test bench comprises a Ping node and a Pong node which exchange real-time and best-effort messages simultaneously with each other. Each class of messages is handled with a dedicated Executor, as illustrated in the following Figure.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/ping_pong_diagram.png" alt="Architecture for the Callback-group-level Executor test bench" width="100%">
</center>

<p>With the test bench, we validated the functioning of the approach.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/cbg_executor_demo_plot.png" alt="Results from Callback-group-level Executor test bench" width="80%">
</center>

<p>In this example, the callback for the high priority task (red line) consumes 10ms and the low priority task (blue line) 40ms in the Pong Node. With a ping rate of 20 Hz, the CPU saturates (10ms*20+40ms*20=1000ms). With higher frequencies the high priorty task can continue to send its pong message, while the low priority pong task degrades. With a frequency of 100Hz the high priority task requires 100% CPU utilization. With higher ping rates it keeps sending pong messages with 100Hz, while the low priority task does not get any CPU ressources any more and cannot send any messages.</p>

<p>The test bench is provided in the <a href="https://github.com/ros2/examples/tree/master/rclcpp/executors/cbg_executor">cbg_executor_demo</a>.</p>

<h2 id="related-work">Related Work</h2>

<p>In this section, we provide an overview to related approaches and link to the corresponding APIs.</p>

<h3 id="fawkes-framework">Fawkes Framework</h3>

<p><a href="http://www.fawkesrobotics.org/">Fawkes</a> is a robotic software framework, which supports synchronization points for sense-plan-act like execution. It has been developed by RWTH Aachen since 2006. Source code is available at <a href="https://github.com/fawkesrobotics">github.com/fawkesrobotics</a>.</p>

<h4 id="synchronization">Synchronization</h4>
<p>Fawkes provides developers different synchronization points, which are very useful for defining an execution order of a typical sense-plan-act application. These ten synchronization points (wake-up hooks) are the following (cf. <a href="https://github.com/fawkesrobotics/fawkes/blob/master/src/libs/aspect/blocked_timing.h">libs/aspect/blocked_timing.h</a>):</p>

<ul>
  <li>WAKEUP_HOOK_PRE_LOOP</li>
  <li>WAKEUP_HOOK_SENSOR_ACQUIRE</li>
  <li>WAKEUP_HOOK_SENSOR_PREPARE</li>
  <li>WAKEUP_HOOK_SENSOR_PROCESS</li>
  <li>WAKEUP_HOOK_WORLDSTATE</li>
  <li>WAKEUP_HOOK_THINK</li>
  <li>WAKEUP_HOOK_SKILL</li>
  <li>WAKEUP_HOOK_ACT</li>
  <li>WAKEUP_HOOK_ACT_EXEC</li>
  <li>WAKEUP_HOOK_POST_LOOP</li>
</ul>

<h4 id="configuration-at-compile-time">Configuration at compile time</h4>
<p>At compile time, a desired synchronization point is defined as a constructor parameter for a module. For example, assuming that <code class="language-plaintext highlighter-rouge">mapLaserGenThread</code> shall be executed in SENSOR_ACQUIRE, the constructor is implemented as:</p>

<pre><code class="language-C++">MapLaserGenThread::MapLaserGenThread()
  :: Thread("MapLaserGenThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE),
     TransformAspect(TransformAspect::BOTH_DEFER_PUBLISHER, "Map Laser Odometry")

</code></pre>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">NaoQiButtonThread</code> shall be executed in the SENSOR_PROCESS hook, the constructor is:</p>

<pre><code class="language-C++">NaoQiButtonThread::NaoQiButtonThread()
  :: Thread("NaoQiButtonThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS)

</code></pre>

<h4 id="runtime-execution">Runtime execution</h4>
<p>At runtime, the <em>Executor</em> iterates through the list of synchronization points and executes all registered threads until completion. Then, the threads of the next synchronization point are called.</p>

<p>A module (thread) can be configured independent of these sense-plan-act synchronization points. This has the effect, that this thread is executed in parallel to this chain.</p>

<p>The high level overview of the Fawkes framework is shown in the next figure. At compile-time the configuration of the sense-plan act wakeup hook is done (upper part), while at run-time the scheduler iterates through this list of wakeup-hooks (lower part):</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/fawkes_executor_diagram.png" alt="Sequence diagram for Fawkes Executor" width="50%">
</center>

<p>Hence, at run-time, the hooks are executed as a fixed static schedule without preemption. Multiple threads registered in the same hook are executed in parallel.</p>

<p>Orthogonal to the sequential execution of sense-plan-act like applications, it is possible to define further constraints on the execution order by means of a <code class="language-plaintext highlighter-rouge">Barrier</code>. A barrier defines a number of threads, which need to have finished before the thread can start, which owns the barrier.</p>

<p>These concepts are implemented by the following main classes:</p>

<ul>
  <li>
<em>Wakeup hook</em> by <code class="language-plaintext highlighter-rouge">SyncPoint</code> and <code class="language-plaintext highlighter-rouge">SyncPointManager</code>, which manages a list of synchronization points.</li>
  <li>
<em>Executor</em> by the class <code class="language-plaintext highlighter-rouge">FawkesMainThread</code>, which is the scheduler, responsible for calling the user threads.</li>
  <li>
<code class="language-plaintext highlighter-rouge">ThreadManager</code>, which is derived from <code class="language-plaintext highlighter-rouge">BlockedTimingExecutor</code>, provides the necessary API to add and remove threads to wakeup hooks as well as for sequential execution of the wakeup-hooks.</li>
  <li>
<code class="language-plaintext highlighter-rouge">Barrier</code> is an object similar to <code class="language-plaintext highlighter-rouge">condition_variable</code> in C++.</li>
</ul>

<h4 id="discussion">Discussion</h4>

<p>All threads are executed with the same priority. If multiple sense-plan-act chains shall be executed with different priorities, e.g. to prefer execution of emergency-stop over normal operation, then this framework reaches its limits.</p>

<p>Also, different execution frequencies cannot be modeled by a single instance of this sense-plan-act chain. However, in robotics the fastest sensor will drive the chain and all other hooks are executed with the same frequency.</p>

<p>The option to execute threads independent of the predefined wakeup-hooks is very useful, e.g. for diagnostics. The concept of the Barrier is useful for satisfying functional dependencies which need to be considered in the execution order.</p>

<h2 id="references">References</h2>
<ul>
  <li>
    <p>[S2021]<a name="S2021"></a> J. Staschulat, Micro-ROS: The rclc Executor, in Workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at ROS World, Oct. 2021, [<a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">slides</a>] [<a href="https://www.youtube.com/embed/IazrPF3RN1U">Video</a>]</p>
  </li>
  <li>
    <p>[SLD2021]<a name="SLD2021"></a> J. Staschulat, R. Lange and D. N. Dasari, Budget-based real-time Executor for Micro-ROS, arXiv Pre-Print, May 2021. [<a href="https://arxiv.org/abs/2105.05590">paper</a>]</p>
  </li>
  <li>
    <p>[L2020]<a name="L2020"></a> Ralph Lange: Advanced Execution Management with ROS 2, ROS-Industrial Conference, Dec 2020 <a href="https://micro-ros.github.io/download/2020-12-16_Advanced_Execution_Management_with_ROS_2.pdf">[Slides]</a></p>
  </li>
  <li>
    <p>[SLL2020]<a name="SLL2020"></a> J. Staschulat, I. Ltkebohle and R. Lange, The rclc Executor: Domain-specific deterministic scheduling mechanisms for ROS applications on microcontrollers: work-in-progress, 2020 International Conference on Embedded Software (EMSOFT), Singapore, Singapore, 2020, pp. 18-19. <a href="https://ieeexplore.ieee.org/document/9244014">[Paper]</a> <a href="https://whova.com/embedded/session/eswe_202009/1145800/">[Video]</a></p>
  </li>
  <li>
    <p>[CB2019]<a name="CB2019"> </a> D. Casini, T. Bla, I. Ltkebohle, B. Brandenburg: Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling, in Euromicro-Conference on Real-Time Systems 2019. <a href="http://drops.dagstuhl.de/opus/volltexte/2019/10743/">[Paper]</a> <a href="https://t-blass.de/talks/ECRTS2019.pdf">[slides]</a></p>
  </li>
  <li>
    <p>[L2018]<a name="L2018"></a> Ralph Lange: Callback-group-level Executor for ROS 2. Lightning talk at ROSCon 2018. Madrid, Spain. Sep 2018. <a href="https://roscon.ros.org/2018/presentations/ROSCon2018_Lightning1_4.pdf">[Slides]</a> <a href="https://vimeo.com/292707644">[Video]</a></p>
  </li>
  <li>
    <p>[EK2018]<a name="EK2018"></a> R. Ernst, S. Kuntz, S. Quinton, M. Simons: The Logical Execution Time Paradigm: New Perspectives for Multicore Systems, February 25-28 2018 (Dagstuhl Seminar 18092). <a href="http://drops.dagstuhl.de/opus/volltexte/2018/9293/pdf/dagrep_v008_i002_p122_18092.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[NSP2018]<a name="NSP2018"></a> A. Naderlinger, S. Resmerita, and W. Pree: LET for Legacy and Model-based Applications,
Proceedings of The Logical Execution Time Paradigm: New Perspectives for Multicore Systems (Dagstuhl Seminar 18092), Wadern, Germany, February 2018.</p>
  </li>
  <li>
    <p>[BP2017]<a name="BP2017"></a> A. Biondi, P. Pazzaglia, A. Balsini,  M. D. Natale: Logical Execution Time Implementation and Memory Optimization Issues in AUTOSAR Applications for Multicores, International Worshop on Analysis Tools and Methodologies for Embedded and Real-Time Systems (WATERS2017), Dubrovnik, Croatia.<a href="https://pdfs.semanticscholar.org/4a9e/b9a616c25fd0b4a4f7810924e73eee0e7515.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[KZH2015]<a name="KZH2015"></a> S. Kramer, D. Ziegenbein, and A. Hamann: Real World Automotive Benchmarks For Free, International Workshop on Analysis Tools and Methodologies for Embedded adn Real-Time Sysems (WATERS), 2015.</p>
  </li>
  <li>
    <p>[HHK2001]<a name="HHK2001"></a> Henzinger T.A., Horowitz B., Kirsch C.M. (2001) Giotto: A Time-Triggered Language for Embedded Programming. In: Henzinger T.A., Kirsch C.M. (eds) Embedded Software. EMSOFT 2001. Lecture Notes in Computer Science, vol 2211. Springer, Berlin, Heidelberg</p>
  </li>
  <li>
    <p>[LL1973]<a name="LL1973"></a> Liu, C. L.; Layland, J.:Scheduling algorithms for multiprogramming in a hard real-time environment, Journal of the ACM, 20 (1): 4661, 1973.</p>
  </li>
</ul>
</div>
              </div>
            </div>
          </div>
        </div>
      
    
    <div class="row">
      <div class="col-xs-12">
        <div class="panel panel-default">
          <div class="panel-heading"><span class="glyphicon glyphicon-list"></span> CHANGELOG</div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="changelog-for-package-rclc">Changelog for package rclc</h1>

<h2 id="620-2024-10-15">6.2.0 (2024-10-15)</h2>

<ul>
  <li>added CI status for iron builds (#377)</li>
  <li>rclc_executor: improve enum type names (#379)</li>
  <li>fix rclc_example: memory leaking in msg.data allocation (backport
#386) (#387)</li>
  <li>updated ci versions (#396)</li>
  <li>updated ros-tooling versions (#407)</li>
</ul>

<h2 id="610-2023-06-15">6.1.0 (2023-06-15)</h2>

<ul>
  <li>Data structures interfaces for multi-threaded executor (#355)</li>
  <li>update ros-tooling versions (#361)</li>
  <li>updated actions/checkout version (#367)</li>
  <li>updated branch names to rolling (#370)</li>
</ul>

<h2 id="309-2023-03-22">3.0.9 (2023-03-22)</h2>

<ul>
  <li>Added build status of bloom-releases for Humble distribution (#291)</li>
  <li>[rolling] updated ros-tooling versions (#289)</li>
  <li>github action: updated os-version to ubuntu-22.04 (backport #295)
(#296)</li>
  <li>Added documentation (#301)</li>
  <li>Drop build dependency on std_msgs (#314)</li>
  <li>Updated &lt;ros-tooling/setup-ros@0.4.2&gt; and
&lt;ros-tooling/action-ros-ci@0.2.7&gt; (#318)</li>
  <li>Removed build status for Galactic in README (EOL November 2022)
(#321)</li>
  <li>Update documentation about number_of_handles (#326)</li>
  <li>executor.h: Fix a few docs typos (#338)</li>
</ul>

<h2 id="308-2022-04-14">3.0.8 (2022-04-14)</h2>

<ul>
  <li>Remove duplicate typedefs. (#249)</li>
  <li>Add rmw dependencies due to EventsExecutor PR in rcl (#255)</li>
  <li>Fix action client &amp; server deallocation (#257)</li>
  <li>updated documentation: build status for Rolling (#266)</li>
  <li>Update action client goal callback signature (#282)</li>
  <li>Upgrade parameters (#274)</li>
</ul>

<h2 id="307-2022-02-17">3.0.7 (2022-02-17)</h2>

<ul>
  <li>Fix enum naming for avoid collision (#242)</li>
  <li>Added dependency for package performance-test-fixture (#245)</li>
</ul>

<h2 id="306-2022-01-25">3.0.6 (2022-01-25)</h2>

<ul>
  <li>executor ignore canceled timers (#220)</li>
  <li>uddated documentation README.md (#229)</li>
  <li>resolved error in unit test see issue #230 (#231)</li>
  <li>Add thread dependency to examples (Rolling) (#237) (resolves in
this package only cpplint errors)</li>
</ul>

<h2 id="305-2021-11-23">3.0.5 (2021-11-23)</h2>

<ul>
  <li>Fix data_available reset for timer (backport #215) (#217)</li>
</ul>

<h2 id="304-2021-11-17">3.0.4 (2021-11-17)</h2>

<ul>
  <li>Ignoring unsuccessful SERVICE_TAKE (#175)</li>
  <li>Add rclc_parameter Quality Declaration (#144)</li>
  <li>use-ros2-testing (#185)</li>
  <li>Fix: printf in executor spin (#195)</li>
  <li>Fix init options handling (#202) (#205)</li>
  <li>Remove init options from support (#203)</li>
  <li>RCLC Actions Implementation (#170)</li>
  <li>Add rcl_action as build export dependency (#211)</li>
</ul>

<h2 id="303-2021-07-28">3.0.3 (2021-07-28)</h2>

<ul>
  <li>Checking for valid ROS context in spin_some</li>
  <li>Refactoring executor (removing callback_type)</li>
  <li>Fixing codecov config</li>
</ul>

<h2 id="302-2021-07-26">3.0.2 (2021-07-26)</h2>

<ul>
  <li>Updated codecov to ignore test folders</li>
  <li>Updated bloom release status table</li>
</ul>

<h2 id="301-2021-07-17">3.0.1 (2021-07-17)</h2>

<ul>
  <li>Added rclc_parameter package</li>
  <li>Added quality of service entity creation API</li>
  <li>Added executor prepare API</li>
  <li>Added support for removing subscription from executor</li>
  <li>Added support for subscription with context</li>
  <li>Added quality declaration statement</li>
  <li>Updated compatability function for sleep</li>
  <li>Removed duplicate NOTICE files</li>
</ul>

<h2 id="200-2021-04-23">2.0.0 (2021-04-23)</h2>

<ul>
  <li>Added codecov support</li>
  <li>New API of rcl_lifecycle in Rolling required major version bump</li>
</ul>

<h2 id="101-2021-03-29">1.0.1 (2021-03-29)</h2>

<ul>
  <li>Windows port</li>
  <li>Compatibility sleep function (Windows, POSIX-OS)</li>
  <li>Fixed RCL lifecycle API change for Rolling</li>
</ul>

<h2 id="100-2021-03-04">1.0.0 (2021-03-04)</h2>

<ul>
  <li>Service callbacks with context</li>
  <li>Fixed minor issues unit tests</li>
  <li>Upgraded setup_ros action (ci jobs)</li>
  <li>Removed Eloquent from ci jobs</li>
</ul>

<h2 id="017-2021-01-20">0.1.7 (2021-01-20)</h2>

<ul>
  <li>Corrected corrupted changelog</li>
</ul>

<h2 id="016-2021-01-20">0.1.6 (2021-01-20)</h2>

<ul>
  <li>Fixed issues due to Github Action timing delays on cloud build</li>
  <li>Fixed missing package dependency in Github Action for Eloquent</li>
</ul>

<h2 id="015-2020-12-11">0.1.5 (2020-12-11)</h2>

<ul>
  <li>Added support for services,clients and guard_conditions to rclc
executor</li>
  <li>Added table for bloom release status in README file</li>
</ul>

<h2 id="014-2020-11-25">0.1.4 (2020-11-25)</h2>

<ul>
  <li>Fixed error in bloom release</li>
</ul>

<h2 id="013-2020-11-23">0.1.3 (2020-11-23)</h2>

<ul>
  <li>Added rclc_lifecycle package</li>
  <li>Change maintainer information</li>
  <li>Minor fixes, updated unit tests</li>
</ul>

<h2 id="012-2020-05-19">0.1.2 (2020-05-19)</h2>

<ul>
  <li>Fixed compiler errors for bloom release</li>
</ul>

<h2 id="011-2020-05-14">0.1.1 (2020-05-14)</h2>

<ul>
  <li>Initial release</li>
</ul>
</div>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="jazzy-tutorials">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Wiki Tutorials</h3>
      </div>
      <div class="panel-body">
        
        <em>This package does not provide any links to tutorials in it's <a href="https://index.ros.org/contribute/metadata/">rosindex metadata</a>.</em>
        <em>You can check on the <a href="http://wiki.ros.org/rclc/Tutorials" target="_blank">ROS Wiki Tutorials</a> page for the package.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="jazzy-deps">
    <div class="row">
      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Package Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th class="text-center">Deps</th>
                  <th style="width: 100%">Name</th>
                </thead>
                <tbody>
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl#jazzy">rcl  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl_action#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl_action#jazzy">rcl_action  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcutils#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcutils#jazzy">rcutils  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_generator_c#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_generator_c#jazzy">rosidl_generator_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_typesupport_c#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_typesupport_c#jazzy">rosidl_typesupport_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_ros#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_ros#jazzy">ament_cmake_ros  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_gtest#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_gtest#jazzy">ament_cmake_gtest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_pytest#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_pytest#jazzy">ament_cmake_pytest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_auto#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_auto#jazzy">ament_lint_auto  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_common#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_common#jazzy">ament_lint_common  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/launch_testing#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/launch_testing#jazzy">launch_testing  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/osrf_testing_tools_cpp#jazzy-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/osrf_testing_tools_cpp#jazzy">osrf_testing_tools_cpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/std_msgs#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/std_msgs#jazzy">std_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/test_msgs#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/test_msgs#jazzy">test_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/example_interfaces#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/example_interfaces#jazzy">example_interfaces  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp#jazzy">rclcpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp_action#jazzy-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp_action#jazzy">rclcpp_action  </a></td>
                      </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
          <div class="panel-heading">
            <h3 class="panel-title">System Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <em>No direct system dependencies.</em>
            
          </div>
        </div>
      </div>

      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Dependant Packages</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th>Name</th>
                  <th class="text-center">Deps</th>
                </thead>
                <tbody>
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_common_diagnostics#jazzy">micro_ros_common_diagnostics</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_common_diagnostics#jazzy-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_diagnostic_updater#jazzy">micro_ros_diagnostic_updater</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_diagnostic_updater#jazzy-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_examples#jazzy">rclc_examples</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_examples#jazzy-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_lifecycle#jazzy">rclc_lifecycle</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_lifecycle#jazzy-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_parameter#jazzy">rclc_parameter</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_parameter#jazzy-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="jazzy-assets">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Launch files</h3>
      </div>
      <div class="panel-body">
        
          <em>No launch files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Messages</h3>
      </div>
      <div class="panel-body">
        
          <em>No message files found.</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Services</h3>
      </div>
      <div class="panel-body">
        
          <em>No service files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Plugins</h3>
      </div>
      <div class="panel-body">
        
          <em>No plugins found.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="jazzy-questions">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Recent questions tagged <kbd>rclc</kbd> at <strong><a href="https://robotics.stackexchange.com/" target="_blank">Robotics Stack Exchange</a></strong></h3>      </div>
      <div id="jazzy-question-list" class="panel-body" style="display: none;"></div>
      <div id="jazzy-no-question-list" class="panel-body" style="display: none;">
        <p>No questions yet, you can ask one <a href="https://robotics.stackexchange.com/questions/tagged/rclc+jazzy">here</a>.</p>
      </div>
      <div id="jazzy-get-question-fail" class="panel-body alert alert-warning" style="display: none;">
        <p>Failed to get question list, you can ticket an issue <a href="https://github.com/ros-infrastructure/rosindex/issues/new" target="_blank" class="alert-link">here</a> </p>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript" src="/js/package_body_tabs.js"></script>

<script src=/js/contribution_suggestions.js></script>
<script type="text/javascript">
jQuery(function() {
    // Update the count on the links to the contribution suggestions
    updateContributionSuggestionsCountOnPackage('https://github.com/ros2/rclc.git');
});
</script>

          </div>
          <div class="col-md-2 hidden-xs hidden-sm">
            
            
            



<div class="list-group list-group-sm ">
  <a class="list-group-item"
     target="_blank"
     href="http://docs.ros.org/en/jazzy/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       
       API Docs
  </a>
  <a class="list-group-item"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/rolling/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       
       Browse Code
  </a>
  
  
  
  
  
  
</div>

          </div>
        </div>
      
    </div>
  </div>

  <div class="distro distro-kilted">
    <div class="container-fluid">
      
        
        
        

        <div class="row">
          <div class="col-md-10">
            

<div class="well well-sm">
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px" src="/assets/package.png">
      </td>
      <td>
        <h3 style="margin-top: 5px">
          <a style="text-decoration:none" href="/p/rclc">rclc</a> <small>package from <a style="text-decoration:none" href="/r/rclc/github-ros2-rclc">rclc</a> repo</small>
        </h3>
          
            
            
              <span class="label label-default pkg-label">

rclc
</span>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_examples">

rclc_examples
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_lifecycle">

rclc_lifecycle
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_parameter">

rclc_parameter
</a>
            
          
      </td>
    </tr>
  </table>
</div>

            <div class="visible-xs visible-sm">
              
              
              



<div class="list-group list-group-sm list-group-horizontal list-group-justified">
  <a class="list-group-item text-center"
     target="_blank"
     href="http://docs.ros.org/en/kilted/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       <br>
       API Docs
  </a>
  <a class="list-group-item text-center"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/rolling/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       <br>
       Browse Code
  </a>
  
  
  
  
  
  
</div>

            </div>
            



<ul class="nav nav-tabs nav-justified" id="kilted-tabs" style="margin-bottom:20px">
  <li class="better-tabs active">
    <a href="#kilted-overview" data-toggle="tab">Overview</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    
    <a href="#kilted-assets" data-toggle="tab"><span class="label label-default">0</span> Assets</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    <a href="#kilted-deps" data-toggle="tab"><span class="label label-primary">17</span> Dependencies</a>
  </li>
  <li class="better-tabs">
    
    <a href="#kilted-tutorials" data-toggle="tab"><span class="label label-default">0</span> Tutorials</a>
  </li>
  <li class="better-tabs">
    <a href="#kilted-questions" data-toggle="tab"><span id="kilted-questions-count" class="label label-primary">0</span> Q & A</a>
  </li>
</ul>

<div class="tab-content">
  <div class="tab-pane active" id="kilted-overview">
    
    <div class="row">
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h4 class="panel-title">Package Summary</h4></div>
          <div class="panel-body">
            <table class="table table-condensed">
              <tr>
                <td style="width:100px;" class="text-right"><strong>Tags</strong></td>
                <td>
                  
                  
                    <em>No category tags.</em>
                  
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Version</strong></td>
                <td>6.2.0</td>
              </tr>
              <tr>
                <td class="text-right"><strong>License</strong></td>
                <td>Apache License 2.0</td>
              </tr>
              <tr>
                <td class="text-right"><strong>Build type</strong></td>
                <td>
                  
                    <span class="label label-default">
                  
                    AMENT_CMAKE</span>
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Use</strong></td>
                <td>
                
                  <span class="label label-success">RECOMMENDED</span>
                
                </td>
              </tr>
            </table>
          </div>
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body">
            
            
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">ROS Client Library for the C language.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/ros2/rclc.git">https://github.com/ros2/rclc.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">rolling</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2024-10-30
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="No CI information available for this package.">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <em>No category tags.</em>
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/rclc/#kilted-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#kilted-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#kilted-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
      </div>
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Package Description</h3></div>
          <div class="panel-body">
            The ROS client library in C.
          </div>
          <div class="panel-heading"><h4 class="panel-title">Additional Links</h4></div>
          <div class="panel-body">
            
            
              <em>No additional links.</em>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Maintainers</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>Pablo Garrido</li>
                
              </ul>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Authors</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>William Woodall</li>
                
              </ul>
            
          </div>
        </div>
      </div>
    </div>
    
      
        <div class="row">
          <div class="col-xs-12">
            <div class="panel panel-default">
              <div class="panel-heading"><span class="glyphicon glyphicon-file"></span><a href="https://github.com/ros2/rclc/tree/rolling/rclc/README.md" title="Open in git repository">rclc/README.md</a></div>
              <div class="panel-body">
                    <div class="rendered-markdown">
<h1 id="the-rclc-package">The rclc package</h1>

<h2 id="table-of-contents">Table of contents</h2>

<ul>
  <li>
    <p><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#introduction">Introduction</a></p>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#architecture">Architecture</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#scheduling-semantics">Scheduling Semantics</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#synchronization-of-multiple-rates">Synchronization of multiple rates</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#high-priority-processing-path">High-priority processing path</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#real-time-embedded-applications">Real-time embedded applications</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#rclc-executor">rclc Executor</a>
    <ul>
      <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#features">Features</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#trigger-condition">Trigger condition</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#sequential-execution">Sequential execution</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#let-semantics">LET-Semantics</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#executor-api">Executor API</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#configuration-phase">Configuration phase</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#running-phase">Running phase</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#examples">Examples</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#synchronization-of-multiple-rates-example">Synchronization of multiple rates example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#high-priority-processing-path-example">High-priority processing path example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#real-time-embedded-applications-example">Real-time embedded applications example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#future-work">Future work</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#download">Download</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#callback-group-level-executor">Callback-group-level Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#api-changes">API Changes</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#test-bench">Test Bench</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#related-work">Related Work</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#fawkes-framework">Fawkes Framework</a></li>
    </ul>
  </li>
  <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#references">References</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Predictable execution under given real-time constraints is a crucial requirement for many robotic applications. While the service-based paradigm of ROS allows a fast integration of many different functionalities, it does not provide sufficient control over the execution management. For example, there are no mechanisms to enforce a certain execution order of callbacks within a node. Also the execution order of multiple nodes is essential for control applications in mobile robotics. Cause-effect-chains comprising of sensor acquisition, evaluation of data and actuation control should be mapped to ROS nodes executed in this order, however there are no explicit mechanisms to enforce it. Furthermore, when data recordings collected in field tests as ROS-bags are re-played, then the results are often surprisingly different due to non-determinism of process scheduling.</p>

<p>Manually setting up a particular execution order of subscriptions and publishing topics as well as defining use-case specific priorities of the corresponding Linux processes is always possible. However, this approach is error-prone, difficult to extend and requires an in-depth knowledge of the deployed ROS 2 packages in the system.</p>

<p>Therefore the goal of the Executor in micro-ROS is to support roboticists with practical and easy-to-use real-time mechanisms which provide solutions for:</p>
<ul>
  <li>Deterministic execution</li>
  <li>Real-time guarantees</li>
  <li>Integration of real-time and non real-time functionalities on one platform</li>
  <li>Specific support for RTOS and microcontrollers</li>
</ul>

<p>In ROS 1 a network thread is responsible for receiving all messages and putting them into a FIFO queue (in roscpp). That is, all callbacks were called in a FIFO manner, without any execution management. With the introduction of DDS (data distribution service) in ROS 2, the messages are buffered in DDS. In ROS 2, an Executor concept was introduced to support execution management. At the rcl-layer, a <em>wait-set</em> is configured with handles to be received and in a second step, the handles are taken from the DDS-queue. A handle is a generic term defined in rcl-layer for timers, subscriptions, services, clients and guard conditions.</p>

<p>The standard implementation of the ROS 2 Executor for the C++ API (rclcpp) has, however, certain unusual features, like precedence of timers over all other DDS handles, non-preemptive round-robin scheduling for non-timer handles and considering only one input data for each handle (even if multiple could be available). These features have the consequence, that in certain situations the standard rclcpp Executor is not deterministic and it makes guaranteeing real-time requirements very hard [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#CB2019">CB2019</a>]. We have not looked at the ROS 2 Executor implementation for Python Frontend (rclpy) because we consider a micro-controllers platform, on which typically C or C++ appliations will run.</p>

<p>Given the goals for a Real-Time Executor and the limitations of the ROS 2 standard rclcpp Executor, the challenges are:</p>
<ul>
  <li>to develop an adequate and well-defined scheduling mechanisms for the ROS 2 framework and the real-time operating system (RTOS)</li>
  <li>to define an easy-to-use interface for ROS developers</li>
  <li>to model requirements (like latencies, determinism in subsystems)</li>
  <li>mapping of ROS 2 framework and operating system schedulers (semi-automated and optimized mapping is desired as well as generic, well-understood framework mechanisms)</li>
</ul>

<p>Our approach is to provide a real-time-capable Executor for the rcl+rclc layer (as described in section <a href="https://github.com/ros2/rclc/tree/rolling/rclc/../">Introduction to Client Library</a>.) in the C programming language .</p>

<p>As the first step, we propose the rclc Executor for the rcl-layer in C programming language with several new features to support real-time and deterministic execution: It supports 1.) user-defined static sequential execution, 2) conditional execution semantics, 3) multi-threaded execution with scheduling configuration, and 4) logical execution semantics (LET). Sequential execution refers to the runtime behavior, that all callbacks are executed in a pre-defined order independent of the arrival time of messages. Conditional execution is available with a trigger condition which enables typical processing patterns in robotics (which are analyzed in detail in section <a href="https://github.com/ros2/rclc/tree/rolling/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>. Configuration of scheduling parameters for multi-threaded application accomplishes prioritized execution. The logical execution time concept (LET) provides data synchronization for fixed periodic task scheduling of embedded applications.</p>

<p>Beyond the advanced execution management mechanisms for micro-ROS, we also contributed to improving and extending the Executor concept in rclcpp for standard ROS 2: the callback group-level Executor. It is not a new Executor but rather a refinement of the ROS 2 Executor API allowing to prioritize a group of callbacks which is not possible with the ROS 2 default Executor in its current Galactic release.</p>

<h2 id="analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</h2>

<p>ROS 2 allows to bundle multiple nodes in one operating system process. To coordinate the execution of the callbacks of the nodes of a process, the Executor concept was introduced in rclcpp (and also in rclpy).</p>

<p>The ROS 2 design defines one Executor (instance of <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">rclcpp::executor::Executor</a>) per process, which is typically created either in a custom main function or by the launch system. The Executor coordinates the execution of all callbacks issued by these nodes by checking for available work (timers, services, messages, subscriptions, etc.) from the DDS queue and dispatching it to one or more threads, implemented in <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/single_threaded_executor.hpp">SingleThreadedExecutor</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp">MultiThreadedExecutor</a>, respectively.</p>

<p>The dispatching mechanism resembles the ROS 1 spin thread behavior: the Executor looks up the wait sets, which notifies it of any pending callback in the DDS queue. If there are multiple pending callbacks, the ROS 2 Executor executes them in an in the order as they were registered at the Executor.</p>

<h3 id="architecture">Architecture</h3>

<p>The following diagram depicts the relevant classes of the standard ROS 2 Executor implementation:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/executor_class_diagram.png" alt="ROS 2 Executor class diagram" width="100%">
</center>

<p>Note that an Executor instance maintains weak pointers to the NodeBaseInterfaces of the nodes only. Therefore, nodes can be destroyed safely, without notifying the Executor.</p>

<p>Also, the Executor does not maintain an explicit callback queue, but relies on the queue mechanism of the underlying DDS implementation as illustrated in the following sequence diagram:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/executor_to_dds_sequence_diagram.png" alt="Call sequence from executor to DDS" width="100%">
</center>

<p>The Executor concept, however, does not provide means for prioritization or categorization of the incoming callback calls. Moreover, it does not leverage the real-time characteristics of the underlying operating-system scheduler to have finer control on the order of executions. The overall implication of this behavior is that time-critical callbacks could suffer possible deadline misses and a degraded performance since they are serviced later than non-critical callbacks. Additionally, due to the FIFO mechanism, it is difficult to determine usable bounds on the worst-case latency that each callback execution may incur.</p>

<h3 id="scheduling-semantics">Scheduling Semantics</h3>

<p>In a recent paper [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#CB2019">CB2019</a>], the rclcpp Executor has been analyzed in detail and a response time analysis of cause-effect chains has been proposed under reservation-based scheduling. The Executor distinguishes four categories of callbacks: <em>timers</em>, which are triggered by system-level timers, <em>subscribers</em>, which are triggered by new messages on a subscribed topic, <em>services</em>, which are triggered by service requests, and <em>clients</em>, which are triggered by responses to service requests. The Executor is responsible for taking messages from the input queues of the DDS layer and executing the corresponding callback. Since it executes callbacks to completion, it is a non-preemptive scheduler, However it does not consider all ready tasks for execution, but only a snapshot, called readySet. This readySet is updated when the Executor is idle and in this step it interacts with the DDS layer updating the set of ready tasks. Then for every type of task, there are dedicated queues (timers, subscriptions, services, clients) which are processed sequentially. The following undesired properties were pointed out:</p>

<ul>
  <li>Timers have the highest priority. The Executor processes <em>timers</em> always first.  This can lead to the intrinsic effect, that in overload situations messages from the DDS queue are not processed.</li>
  <li>Non-preemptive round-robin scheduling of non-timer handles. Messages arriving during the processing of the readySet are not considered until the next update, which depends on the execution time of all remaining callbacks. This leads to priority inversion, as lower-priority callbacks may implicitly block higher-priority callbacks by prolonging the current processing of the readySet.</li>
  <li>Only one message per handle is considered. The readySet contains only one task instance, For example, even if multiple messages of the same topic are available, only one instance is processed until the Executor is idle again and the readySet is updated from the DDS layer. This aggravates priority inversion, as a backlogged callback might have to wait for multiple processing of readySets until it is considered for scheduling. This means that non-timer callback instances might be blocked by multiple instances of the same lower-priority callback.</li>
</ul>

<p>Due to these findings, the authors present an alternative approach to provide determinism and to apply well-known schedulability analyses to a ROS 2 systems. A response time analysis is described under reservation-based scheduling.</p>

<h2 id="analysis-of-processing-patterns">Analysis of processing patterns</h2>
<p>The development of an execution management mechanism for micro-ROS is based on an analysis of processing patterns commonly used in robotics and embedded systems. First, typical processing patterns in mobile robotics are presented which are used to implement deterministic behavior. Then, the processing patterns in the real-time embedded systems are analyzed, in which, as a main difference, the time-triggered paradigm is applied to accomplish real-time behavior.</p>

<h3 id="sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</h3>
<p>Now we describe common software design patterns which are used in mobile robotics to achieve deterministic behavior. For each design pattern we describe the concept and the derived requirements for a deterministic Executor.</p>

<p><strong>Concept:</strong></p>

<p>A common design paradigm in mobile robotics is a control loop, consisting of several phases: A sensing phase to aquire sensor data, a plan phase for localization and path planning and an actuation-phase to steer the mobile robot. Of course, more phases are possible, here these three phases shall serve as an example. Such a processing pipeline is shown in Figure 1.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensePlanActScheme.png" alt="Sense Plan Act Pipeline" width="60%">
</center>
<center>
Figure 1: Multiple sensors driving a Sense-Plan-Act pipeline.
</center>

<p>Typically multiple sensors are used to perceive the environment. For example an IMU and a laser scanner. The quality of localization algorithms highly depend on how old such sensor data is when it is processed. Ideally the latest data of all sensors should be processed. One way to achive this is to execute first all sensor drivers in the sense-phase and then process all algorithms in the plan-phase.</p>

<p>Currently, such a processing order cannot be defined with the default Executor of rclcpp. One could in principle design a data-driven pipeline, however if e.g. the Laser scan is needed by some other callback in the sense-phase as well as in the plan-phase, the processing order of these subscribers is arbitrary.</p>

<p>For this sense-plan-act pattern, we could define one executor for each phase. The plan-phase would be triggered only when all callbacks in the sense-phase have finished.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
</ul>

<h3 id="synchronization-of-multiple-rates">Synchronization of multiple rates</h3>

<p><strong>Concept:</strong></p>

<p>Often multiple sensors are being used to sense the environment for mobile robotics. While an IMU sensor provides data samples at a very high rate (e.g., 500 Hz), laser scans are availabe at a much slower frequency (e.g. 10Hz) determined by the revolution time. Then the challenge is, how to deterministically fuse sensor data with different frequencies. This problem is depicted in Figure 2.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensorFusion_01.png" alt="Sychronization of multiple rates" width="30%">
</center>
<center>
Figure 2: How to deterministically process multi-frequent sensor data.
</center>

<p>Due to scheduling effects, the callback for evaluating the laser scan might be called just before or just after an IMU data is received. One way to tackle this is to write additional synchronization code inside the application. Obviously, this is a cumbersome and not-portable solution.</p>

<p>An Alternative would be to evalute the IMU sample and the laser scan by synchronizing their frequency. For example by processing always 50 IMU samples with one laser scan. This approach is shown in Figure 3. A pre-processing callback aggregates the IMU samples and sends an aggregated message with 50 samples at 10Hz rate. Now both messages have the same frequency. With a trigger condition, which fires when both messages are available, the sensor fusion algorithm can expect always synchronized input data.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensorFusion_02.png" alt="Sychnronization with a trigger" width="40%">
</center>
<center>
Figure 3: Synchronization of multiple input data with a trigger.
</center>

<p>In ROS 2, this is currently not possible to be modeled because of the lack of a trigger concept in the Executors of rclcpp and rclpy. Message filters could be used to synchronize input data based on the timestamp in the header, but this is only available in rclcpp (and not in rcl). Further more, it would be more efficient to have such a trigger concept directly in the Executor.</p>

<p>Another idea would be to activly request for IMU data only when a laser scan is received. This concept is shown in Figure 4. Upon arrival of a laser scan mesage, first, a message with aggregated IMU samples is requested. Then, the laser scan is processed and later the sensor fusion algorithm. An Executor, which would support sequential execution of callbacks, could realize this idea.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensorFusion_03.png" alt="Sychronization with sequence" width="30%">
</center>
<center>
Figure 4: Synchronization with sequential processing.
</center>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
  <li>sequential procesing of callbacks</li>
</ul>

<h3 id="high-priority-processing-path">High-priority processing path</h3>
<p><strong>Concept</strong>
Often a robot has to fullfill several activities at the same time. For example following a path and avoiding obstacles. While path following is a permanent activity, obstacle avoidance is trigged by the environment and should be immediately reacted upon. Therefore one would like to specify priorities to activities. This is depicted in Figure 5:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/highPriorityPath.png" alt="HighPriorityPath" width="50%">
</center>
<center>
Figure 5: Managing high priority path with sequential order.
</center>

<p>Assuming a simplified control loop with the activities sense-plan-act, the obstacle avoidance, which might temporarily stop the robot, should be processed before the planning phase. In this example we assume that these activites are processed in one thread.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>sequential processing of callbacks</li>
</ul>

<h3 id="real-time-embedded-applications">Real-time embedded applications</h3>
<p>In embedded systems, real-time behavior is approached by using the time-triggered paradigm, which means that the processes are periodically activated. Processes can be assigned priorities to allow pre-emptions. Figure 6 shows an example, in which three processes with fixed periods are shown. The middle and lower process are preempted multiple times depicted with empty dashed boxes.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/scheduling_01.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 6: Fixed periodic preemptive scheduling.
</center>

<p>To each process one or multiple tasks can be assigned, as shown in Figure 7. These tasks are executed sequentially, which is often called cooperative scheduling.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/scheduling_02.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 7: Processes with sequentially executed tasks.
</center>

<p>While there are different ways to assign priorities to a given number of processes,
the rate-monotonic scheduling assignment, in which processes with a shorter period have a higher priority, has been shown optimal if the processor utilization is less than 69% [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#LL1973">LL1973</a>].</p>

<p>In the last decades many different scheduling approaches have been presented, however fixed-periodic preemptive scheduling is still widely used in embedded real-time systems [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#KZH2015">KZH2015</a>]. This becomes also obvious, when looking at the features of current operating systems. Like Linux, real-time operating systems, such as NuttX, Zephyr, FreeRTOS, QNX etc., support fixed-periodic preemptive scheduling and the assignment of priorities, which makes the time-triggered paradigm the dominant design principle in this domain.</p>

<p>However, data consistency is often an issue when preemptive scheduling is used and if data is being shared across multiple processes via global variables. Due to scheduling effects and varying execution times of processes, writing and reading these variables could occur sometimes sooner or later. This results in an latency jitter of update times (the timepoint at which a variable change becomes visible to other processes). Race conditions can occur when multiple processes access a variable at the same time. So solve this problem, the concept of logical-execution time (LET) was introduced in [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#HHK2001">HHK2001</a>], in which communication of data occurs only at pre-defined periodic time instances: Reading data only at the beginning of the period and writing data only at the end of the period. The cost of an additional latency delay is traded for data consistency and reduced jitter. This concept has also recently been applied to automotive applications[<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#NSP2018">NSP2018</a>].</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/scheduling_LET.png" alt="Schedule with fixed periods" width="80%">
</center>
<center>
Figure 8: Data communication without and with Logical Execution Time paradigm.
</center>

<p>An Example of the LET concept is shown in Figure 8. Assume that two processes are communicating data via one global variable. The timepoint when this data is written is at the end of the processing time. In the default case (left side), the process p<sub>3</sub> and p<sub>4</sub> receive the update. At the right side of Figure 8, the same scenario is shown with LET semantics. Here, the data is communicated only at period boundaries. In this case, the lower process communicates at the end of the period, so that always process p<sub>3</sub> and p<sub>5</sub> receive the new data.</p>

<p><strong>Concept:</strong></p>
<ul>
  <li>periodic execution of processes</li>
  <li>assignment of fixed priorities to processes</li>
  <li>preemptive scheduling of processes</li>
  <li>co-operative scheduling of tasks within a process (sequential execution)</li>
  <li>data synchronization with LET-semantics</li>
</ul>

<p>While periodic activation is possible in ROS 2 by using timers, preemptive scheduling is supported by the operating system and assigning priorities on the granularity of threads/processes that correspond to the ROS nodes; it is not possible to sequentially execute callbacks, which have no data-dependency. Furthermore data is read from the DDS queue just before the callback is executed and data is written sometime during the time the application is executed. While the <code class="language-plaintext highlighter-rouge">spin_period</code> function of the rclcpp Executor allows to check for data at a fixed period and executing those callbacks for which data is available, however, with this spin-function does not execute all callbacks irrespective wheter data is available or not. So <code class="language-plaintext highlighter-rouge">spin_period</code> is not helpful to periodically execute a number of callbacks (aka tasks within a process). So we need a mechanism that triggers the execution of multiple callbacks (aka tasks) based on a timer. Data transmission is achieved via DDS which does not allow to implement a LET-semantics. To summarize, we derive the following requirements.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>trigger the execution</li>
  <li>sequential processing of callbacks</li>
  <li>data synchronization with LET semantics</li>
</ul>

<h2 id="rclc-executor">rclc Executor</h2>

<p>The rclc Executor is a ROS 2 Executor based on the rcl-layer in C programming language. As discussed above, the default rclcpp Executor is not suitable to implement real-time applications because of three main reasons: timers are preferred over all other handles, no priorization of callback execution and the round-robin to completion execution of callbacks. On the other hand, several processing patterns have been developed as best practices to achieve non-functional requirements, such as bounded end-to-end latencies, low jitter of response times of cause-effect chains, deterministic processing and short response times even in overload situations. These processing patterns are difficult to implement with the concepts availabe in the default ROS 2 Executor, therefore we have developed a flexible Executor: the rclc Executor.</p>

<h3 id="features">Features</h3>

<p>The rclc Executor is feature-complete, i.e. it supports all event types as the default ROS 2 Executor, which are:</p>
<ul>
  <li>subscriptions</li>
  <li>timers</li>
  <li>services</li>
  <li>clients</li>
  <li>guard conditions</li>
  <li>actions</li>
  <li>lifecycle</li>
</ul>

<p>The flexible rclc Executor provides on top the following new features:</p>
<ul>
  <li>triggered execution</li>
  <li>user-defined sequential execution</li>
  <li>multi-threading and scheduling configuration (WIP)</li>
  <li>LET-semantics for data synchronization of periodic process scheduling</li>
</ul>

<p>First, a <em>trigger condition</em> allows to define when the processing of a callback shall start. This is useful to implement sense-plan-act control loops or more complex processing structures with directed acyclic graphs. Second, a user can specify the <em>processing order</em> in which these callbacks will be executed. With this feature, the pattern of sensor fusion with multiple rates, in which data is requested from a sensor based on the arrival of some other sensor, can be easily implemented. Third, the assignment of scheduling parameters (e.g., priorities) of the underlying operating system. With this feature, prioritized processing can be implemented. Finally, for periodic applications, the <em>LET Semantics</em> has been implemented to support data consistency for periodic process scheduling. These features are now described in more detail.</p>

<h4 id="sequential-execution">Sequential execution</h4>

<ul>
  <li>At configuration, the user defines the order of handles.</li>
  <li>At configuration, the user defines whether the handle shall be called only when new data is available (ON_NEW_DATA) or whether the callback shall always be called (ALWAYS).</li>
  <li>At runtime, all handles are processed in the user-defined order
    <ul>
      <li>if the configuration of handle is ON_NEW_DATA, then the corresponding callback is only called if new data is available</li>
      <li>if the configuration of the handle is ALWAYS, then the corresponding callback is always. If no data is available, then the callback is called with no data (e.g. NULL pointer).</li>
    </ul>
  </li>
</ul>

<p>Figure 9 shows three callbacks, A, B and C. Assume, they shall be executed in the order <em>B,A,C</em>. Then the user adds the callbacks to the rclc Executor in this order. Whenever new messages have arrived then the callbacks for which a new message is availabe will be always executed in the user-defined processing order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/rclc_executor_sequential_execution.png" alt="Sequential execution semantics" width="50%">
</center>
<center>
Figure 9: Sequential execution semantics.
</center>

<h4 id="trigger-condition">Trigger condition</h4>

<ul>
  <li>Given a set of handles, a trigger condition, which is based on the availability of input data of these handles, decides when the processing of all callbacks starts. This is shown in Figure 10.</li>
</ul>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_01.png" alt="Trigger condition overview" width="50%">
</center>
<center>
Figure 10: Executor with trigger condition
</center>

<ul>
  <li>Available options:
    <ul>
      <li>ALL operation: fires when input data is available for all handles</li>
      <li>ANY operation: fires when input data is available for at least one handle (OR semantics)</li>
      <li>ONE: fires when input data for a user-specified handle is available</li>
      <li>User-defined function: user can implement custom logic</li>
    </ul>
  </li>
</ul>

<p>Figure 11 shows an example of the ALL semantics. Only if all messages <em>msg_A, msg_B, msg_C</em> were received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_ALL.png" alt="Trigger condition ALL" width="30%">
</center>
<center>
Figure 11: Trigger condition ALL
</center>

<p>Figure 12 shows an example of the ANY semantics. Thas is, if any messages <em>msg_A, msg_B, msg_C</em> was received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order. This is equivalent to OR semantics.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_OR.png" alt="Trigger condition ANY" width="30%">
</center>
<center>
Figure 12: Trigger condition ANY (OR)
</center>

<p>Figure 13 shows an example of the ONE semantics. Thas is, only if message <em>msg_B</em> was received, the trigger condition is fullfilled and (potentially all) callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_ONE.png" alt="Trigger condition ONE" width="30%">
</center>
<center>
Figure 13: Trigger condition ONE
</center>

<p>Figure 14 describes the custom semantics. A custom trigger condition with could be a more complex logic of multiple messages, can be passed to the executor. This might also include hardware triggers, like interrupts.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_user_defined.png" alt="Trigger condition user-defined" width="30%">
</center>
<center>
Figure 14: Trigger condition user-defined
</center>

<h4 id="let-semantics">LET-Semantics</h4>
<ul>
  <li>Assumption: time-triggered system, the executor is activated periodically</li>
  <li>When the trigger fires, reads all input data and makes a local copy</li>
  <li>Processes all callbacks in sequential order</li>
  <li>Write output data at the end of the executors period (Note: this is not implemented yet)</li>
</ul>

<p>Additionally we have implemented the current rclcpp Executor semantics (RCLCPP):</p>
<ul>
  <li>waiting for new data for all handles (rcl_wait)</li>
  <li>using trigger condition ANY</li>
  <li>if trigger fires, start processing handles in pre-defined sequential order</li>
  <li>request from DDS-queue the new data just before the handle is executed (rcl_take)</li>
</ul>

<p>The selection of the Executor semantics is optional. The default semantics is RCLCPP.</p>

<h4 id="multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</h4>

<p>The rclc Executor has been extended for multi-threading. It supports the assignment of scheduling policies, like priorities or more advanced scheduling algorithms as reservation-based scheduling, to subscription callbacks. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, Pre-print <a href="https://github.com/ros2/rclc/tree/rolling/rclc/#SLD2021">SLD2021</a>]. The overall architecture is shown in Figure 15. One Executor thread is responsible for checking for new data from the DDS queue. For every callback, a thread is spawned with the dedicted scheduling policy provided by the operating system. The Executor then dispatches new data of a subscription to its corresponding callback function, which is then executed in its own thread by operating system.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/rclc_executor_multi_threaded.png" alt="Multi-threaded rclc Executor" width="90%">
</center>
<center>
Figure 15: multi-threaded rclc-Executor
</center>

<h3 id="executor-api">Executor API</h3>
<p>The API of the rclc Executor can be divided in two phases: Configuration and Running.</p>
<h4 id="configuration-phase">Configuration phase</h4>
<p>During the configuration phase, the user shall define:</p>
<ul>
  <li>the total number of callbacks</li>
  <li>the sequence of the callbacks</li>
  <li>trigger condition (optional, default: ANY)</li>
  <li>data communcation semantics (optional, default ROS2)</li>
</ul>

<p>As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added.</p>

<p>Also in the XRCE-DDS middleware the maximum number of handles need to be configured. See <a href="https://docs.vulcanexus.org/en/humble/rst/tutorials/micro/memory_management/memory_management.html#entity-creation">Memory Management Tutorial</a> for the defaults and configuration of the colcon.meta configuration file. To make sure that the changes were applied, you can check the defined values in the following library include file: build/rmw_microxrcedds/include/rmw_microxrcedds_c/config.h.</p>

<p>Then, the user adds handles and the corresponding callbacks (e.g. for subscriptions and timers) to the Executor. The order in which this takes place, defines later the sequential processing order during runtime.</p>

<p>For each handle the user can specify, if the callback shall be executed only if new data is available (ON_NEW_DATA) or if the callback shall always be executed (ALWAYS). The second option is useful when the callback is expected to be called at a fixed rate.</p>

<p>The trigger condition defines when the processing of these callbacks shall start. For convenience some default conditions have been defined:</p>
<ul>
  <li>trigger_any(default) : start executing if any callback has new data</li>
  <li>trigger_all : start executing if all callbacks have new data</li>
  <li>trigger_one(&amp;<code class="language-plaintext highlighter-rouge">data</code>) : start executing if <code class="language-plaintext highlighter-rouge">data</code> has been received</li>
  <li>user_defined_function: the user can also define its own function with more complex logic</li>
</ul>

<p>With trigger_any being the default, the current semantics of the rclcpp Executor is selected.</p>

<p>The data communication semantics can be</p>
<ul>
  <li>ROS2 (default)</li>
  <li>LET</li>
</ul>

<p>To be compatible with ROS2 rclcpp Executor, the existing rclcpp semantics is implemented as ROS2. That is, with the spin-function the DDS-queue is constantly monitored for new data (rcl_wait). If new data becomes available, then is fetched from DDS (rcl_take) immediately before the callback is executed. All callbacks are processed in the user-defined order, this is the only difference to the rclcpp Executor, in which no order can be specified.</p>

<p>Secondly, the LET semantics is implemented such that at the beginning of processing all available data is fetched (rcl_take) and buffered and then the callbacks are processed in the pre-defined operating on the buffered copy.</p>

<h4 id="running-phase">Running phase</h4>

<p>As the main functionality, the Executor has a <code class="language-plaintext highlighter-rouge">spin</code>-function which constantly checks for new data at the DDS-queue, like the rclcpp Executor in ROS2. If the trigger condition is satisfied then all available data from the DDS queue is processed according to the specified semantics (ROS or LET) in the user-defined sequential order. After all callbacks have been processed the DDS is checked for new data again.</p>

<p>Available spin functions are</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">spin_some</code>  - spin one time</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin_period</code> - spin with a period</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin</code> - spin indefinitly</li>
</ul>

<h3 id="examples">Examples</h3>
<p>We provide the relevant code snippets how to setup the rclc Executor for the processing patterns as described above.</p>

<h4 id="sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</h4>

<p>In this example we want to realise a sense-plan-act pipeline in a single thread. The trigger condition is demonstrated by activating
the sense-phase when both data for the Laser and IMU are available. Three executors are necessary <code class="language-plaintext highlighter-rouge">exe_sense</code>, <code class="language-plaintext highlighter-rouge">exe_plan</code> and <code class="language-plaintext highlighter-rouge">exe_act</code>. The two sensor acquisition callbacks <code class="language-plaintext highlighter-rouge">sense_Laser</code> and <code class="language-plaintext highlighter-rouge">sense_IMU</code> are registered in the Executor <code class="language-plaintext highlighter-rouge">exe_sense</code>.
The trigger condition ALL is responsible to activate the sense-phase only when all data for these two callbacks are available. Finally all three Executors are spinning using a <code class="language-plaintext highlighter-rouge">while</code>-loop and the <code class="language-plaintext highlighter-rouge">spin_some</code> function.</p>

<p>The definitions of callbacks are omitted.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act;
rcle_let_executor_t exe_sense, exe_plan, exe_act;
// initialize executors
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
rclc_executor_init(&amp;exe_plan, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_act, &amp;context, 1, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb1, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_let_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);
// executor for plan-phase
rclc_executor_add_subscription(&amp;exe_plan, &amp;plan, &amp;my_sub_cb3, ON_NEW_DATA);
// executor for act-phase
rclc_executor_add_subscription(&amp;exe_act, &amp;act, &amp;my_sub_cb4, ON_NEW_DATA);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_sense);
  rclc_executor_spin_some(&amp;exe_plan);
  rclc_executor_spin_some(&amp;exe_act);
}

</code></pre>

<h4 id="synchronization-of-multiple-rates-example">Synchronization of multiple rates example</h4>

<p>The sensor fusion synchronizing the multiple rates with a trigger is shown below.</p>

<pre><code class="language-C">...
rcl_subscription_t aggr_IMU, sense_Laser, sense_IMU;
rcle_let_executor_t exe_aggr, exe_sense;
// initialize executors
rclc_executor_init(&amp;exe_aggr, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for aggregate IMU data
rclc_executor_add_subscription(&amp;exe_aggr, &amp;aggr_IMU, &amp;my_sub_cb1, ON_NEW_DATA);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb3, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_aggr);
  rclc_executor_spin_some(&amp;exe_sense);
}

</code></pre>

<p>The setup for the sensor fusion using sequential execution is shown below.
Note that the sequetial order is <code class="language-plaintext highlighter-rouge">sense_IMU</code>, which will request the aggregated IMU message, and then <code class="language-plaintext highlighter-rouge">sense_Laser</code>
while the trigger will fire, when a laser message is received.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU;
rcle_let_executor_t exe_sense;
// initialize executor
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe_sense);

</code></pre>
<h4 id="high-priority-processing-path-example">High priority processing path example</h4>

<p>This example shows the sequential processing order to execute the obstacle avoidance <code class="language-plaintext highlighter-rouge">obst_avoid</code>
after the callbacks of the sense-phase and before the callback of the planning phase <code class="language-plaintext highlighter-rouge">plan</code>.
The control loop is started when a laser message is received. Then an aggregated IMU message is requested,
like in the example above. Then all the other callbacks are always executed. This assumes that these callbacks
communicate via a global data structure. Race conditions cannot occur, because the callbacks
run all in one thread.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act, obst_avoid;
rcle_let_executor_t exe;
// initialize executors
rclc_executor_init(&amp;exe, &amp;context, 5, ...);
// define processing order
rclc_executor_add_subscription(&amp;exe, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe, &amp;obst_avoid, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;plan, &amp;my_sub_cb4, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;act, &amp;my_sub_cb5, ALWAYS);
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="real-time-embedded-applications-example">Real-time embedded applications example</h4>

<p>With seqential execution the co-operative scheduling of tasks within a process can be modeled. The trigger condition is used to periodically activate the process which will then execute all callbacks in a pre-defined order. Data will be communicated using the LET-semantics. Every Executor is executed in its own tread, to which an appropriate priority can be assigned.</p>

<p>In the following example, the Executor is setup with 4 handles. We assume a process has three subscriptions <code class="language-plaintext highlighter-rouge">sub1</code>, <code class="language-plaintext highlighter-rouge">sub2</code>, <code class="language-plaintext highlighter-rouge">sub3</code>. The sequential processing order is given by the order as they are added to the Executor. A timer <code class="language-plaintext highlighter-rouge">timer</code> defines the period.  The <code class="language-plaintext highlighter-rouge">trigger_one</code> with the paramter <code class="language-plaintext highlighter-rouge">timer</code> is used, so that whenever the timer is ready, all callbacks are processed. Finally the data communication semantics LET is defined.</p>

<pre><code class="language-C">#include "rcl_executor/let_executor.h"

// define subscription callback
void my_sub_cb1(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb2(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb3(const void * msgin)
{
  // ...
}

// define timer callback
void my_timer_cb(rcl_timer_t * timer, int64_t last_call_time)
{
  // ...
}

// necessary ROS 2 objects
rcl_context_t context;   
rcl_node_t node;
rcl_subscription_t sub1, sub2, sub3;
rcl_timer_t timer;
rcle_let_executor_t exe;

// define ROS context
context = rcl_get_zero_initialized_context();
// initialize ROS node
rcl_node_init(&amp;node, &amp;context,...);
// create subscriptions
rcl_subscription_init(&amp;sub1, &amp;node, ...);
rcl_subscription_init(&amp;sub2, &amp;node, ...);
rcl_subscription_init(&amp;sub3, &amp;node, ...);
// create a timer
rcl_timer_init(&amp;timer, &amp;my_timer_cb, ... );
// initialize executor with four handles
rclc_executor_init(&amp;exe, &amp;context, 4, ...);
// define static execution order of handles
rclc_executor_add_subscription(&amp;exe, &amp;sub1, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub2, &amp;my_sub_cb2, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub3, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_timer(&amp;exe, &amp;timer);
// trigger when handle 'timer' is ready
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;timer);
// select LET-semantics
rclc_executor_data_comm_semantics(&amp;exe, LET);
// spin forever
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</h4>
<p>The rclc Executor has been presented at the workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at <a href="https://roscon.ros.org/world/2021/">ROS World 2021</a> (i.e. the online version of ROSCon)[<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#S2021">S2021</a>]. A <a href="https://github.com/ros-realtime/reference-system">Reference System</a> for testing and benchmarking ROS Executors has been developed for this workshop. The application of the rclc Executor on the reference system with the trigger condition can be found in the <a href="https://github.com/ros-realtime/reference-system/tree/rclc_executor">rclc-executor branch of the Reference System</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/IazrPF3RN1U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>The slides can be downloaded <a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">here</a>. All information and the videos and slides of the other talks of the workshop can be found at <a href="https://www.apex.ai/roscon-21">www.apex.ai/roscon-21</a>.</p>

<h3 id="future-work">Future work</h3>

<ul>
  <li>Full LET semantics (writing data at the end of the period)
    <ul>
      <li>one publisher that periodically publishes</li>
      <li>if Executors are running in multiple threads,
publishing needs to be atomic</li>
    </ul>
  </li>
  <li>Multi-threaded executor with assignment of scheduling policies of unerlying operating system. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, pre-print <a href="https://github.com/ros2/rclc/tree/rolling/rclc/#SLD2021">SLD2021</a>].</li>
</ul>

<h3 id="download">Download</h3>
<p>The rclc Executor can be downloaded from the <a href="https://github.com/ros2/rclc">ros2/rclc repository</a>. It is available for the ROS 2 versions Foxy, Galactic and Rolling. The repository provides several packages including the <a href="https://github.com/ros2/rclc/tree/master/rclc">rclc Executor</a> and an <a href="https://github.com/ros2/rclc/tree/master/rclc_examples">rclc_examples package</a> with several application examples.</p>

<h2 id="callback-group-level-executor">Callback-group-level Executor</h2>

<p>The Callback-group-level Executor was an early prototype for a refined rclcpp Executor API developed in micro-ROS. It has been derived from the default rclcpp Executor and addresses some of the aforementioned deficits. Most important, it was used to validate that the underlying layers (rcl, rmw, rmw_adapter, DDS) allow for multiple Executor instances without any negative interferences.</p>

<p>As the default rclcpp Executor works at a node-level granularity  which is a limitation given that a node may issue different callbacks needing different real-time guarantees - we decided to refine the API for more fine-grained control over the scheduling of callbacks on the granularity of callback groups using. We leverage the callback-group concept existing in rclcpp by introducing real-time profiles such as RT-CRITICAL and BEST-EFFORT in the callback-group API (i.e. rclcpp/callback_group.hpp). Each callback needing specific real-time guarantees, when created, may therefore be associated with a dedicated callback group. With this in place, we enhanced the Executor and depending classes (e.g., for memory allocation) to operate at a finer callback-group granularity. This allows a single node to have callbacks with different real-time profiles assigned to different Executor instances - within one process.</p>

<p>Thus, an Executor instance can be dedicated to specific callback group(s) and the Executors thread(s) can be prioritized according to the real-time requirements of these groups. For example, all time-critical callbacks are handled by an RT-CRITICAL Executor instance running at the highest scheduler priority.</p>

<p>The following Figure illustrates this approach with two nodes served by three Callback-group-level Executors in one process:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/cbg-executor_sample_system.png" alt="Sample system with two nodes and three Callback-group-level Executors in one process" width="60%">
</center>

<p>The different callbacks of the Drive-Base node are distributed to different Executors (visualized by the color red, yellow and green).  For example the onCmdVel and publishWheelTicks callback are scheduled by the same Executor (yellow). Callbacks from different nodes can be serviced by the same Executor.</p>

<h3 id="api-changes">API Changes</h3>

<p>In this section, we describe the necessary changes to the Executor API:</p>
<ul>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/callback_group.hpp">include/rclcpp/callback_group.hpp</a>:</p>

    <ul>
      <li>Introduced an enum to distinguish up to three real-time classes (requirements) per node (RealTimeCritical, SoftRealTime, BestEffort)</li>
      <li>Changed association with Executor instance from nodes to callback groups.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">include/rclcpp/executor.hpp</a></p>

    <ul>
      <li>
        <p>Added functions to add and remove individual callback groups in addition to whole nodes.</p>
      </li>
      <li>
        <p>Replaced private vector of nodes with a map from callback groups to nodes.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/memory_strategy.hpp">include/rclcpp/memory_strategy.hpp</a></p>

    <ul>
      <li>Changed all functions that expect a vector of nodes to the just mentioned map.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node.hpp">include/rclcpp/node.hpp</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node_interfaces/node_base.hpp">include/rclcpp/node_interfaces/node_base.hpp</a></p>

    <ul>
      <li>Extended arguments of create_callback_group function for the real-time class.</li>
      <li>Removed the get_associated_with_executor_atomic function.</li>
    </ul>
  </li>
</ul>

<p>The callback-group-level executor has been merged into ROS 2 rclcpp in <a href="https://github.com/ros2/rclcpp/pull/1218/commits">pull request 1218</a>.</p>

<h3 id="test-bench">Test Bench</h3>

<p>As a proof of concept, we implemented a small test bench in the present package cbg-executor_ping-pong_cpp. The test bench comprises a Ping node and a Pong node which exchange real-time and best-effort messages simultaneously with each other. Each class of messages is handled with a dedicated Executor, as illustrated in the following Figure.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/ping_pong_diagram.png" alt="Architecture for the Callback-group-level Executor test bench" width="100%">
</center>

<p>With the test bench, we validated the functioning of the approach.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/cbg_executor_demo_plot.png" alt="Results from Callback-group-level Executor test bench" width="80%">
</center>

<p>In this example, the callback for the high priority task (red line) consumes 10ms and the low priority task (blue line) 40ms in the Pong Node. With a ping rate of 20 Hz, the CPU saturates (10ms*20+40ms*20=1000ms). With higher frequencies the high priorty task can continue to send its pong message, while the low priority pong task degrades. With a frequency of 100Hz the high priority task requires 100% CPU utilization. With higher ping rates it keeps sending pong messages with 100Hz, while the low priority task does not get any CPU ressources any more and cannot send any messages.</p>

<p>The test bench is provided in the <a href="https://github.com/ros2/examples/tree/master/rclcpp/executors/cbg_executor">cbg_executor_demo</a>.</p>

<h2 id="related-work">Related Work</h2>

<p>In this section, we provide an overview to related approaches and link to the corresponding APIs.</p>

<h3 id="fawkes-framework">Fawkes Framework</h3>

<p><a href="http://www.fawkesrobotics.org/">Fawkes</a> is a robotic software framework, which supports synchronization points for sense-plan-act like execution. It has been developed by RWTH Aachen since 2006. Source code is available at <a href="https://github.com/fawkesrobotics">github.com/fawkesrobotics</a>.</p>

<h4 id="synchronization">Synchronization</h4>
<p>Fawkes provides developers different synchronization points, which are very useful for defining an execution order of a typical sense-plan-act application. These ten synchronization points (wake-up hooks) are the following (cf. <a href="https://github.com/fawkesrobotics/fawkes/blob/master/src/libs/aspect/blocked_timing.h">libs/aspect/blocked_timing.h</a>):</p>

<ul>
  <li>WAKEUP_HOOK_PRE_LOOP</li>
  <li>WAKEUP_HOOK_SENSOR_ACQUIRE</li>
  <li>WAKEUP_HOOK_SENSOR_PREPARE</li>
  <li>WAKEUP_HOOK_SENSOR_PROCESS</li>
  <li>WAKEUP_HOOK_WORLDSTATE</li>
  <li>WAKEUP_HOOK_THINK</li>
  <li>WAKEUP_HOOK_SKILL</li>
  <li>WAKEUP_HOOK_ACT</li>
  <li>WAKEUP_HOOK_ACT_EXEC</li>
  <li>WAKEUP_HOOK_POST_LOOP</li>
</ul>

<h4 id="configuration-at-compile-time">Configuration at compile time</h4>
<p>At compile time, a desired synchronization point is defined as a constructor parameter for a module. For example, assuming that <code class="language-plaintext highlighter-rouge">mapLaserGenThread</code> shall be executed in SENSOR_ACQUIRE, the constructor is implemented as:</p>

<pre><code class="language-C++">MapLaserGenThread::MapLaserGenThread()
  :: Thread("MapLaserGenThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE),
     TransformAspect(TransformAspect::BOTH_DEFER_PUBLISHER, "Map Laser Odometry")

</code></pre>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">NaoQiButtonThread</code> shall be executed in the SENSOR_PROCESS hook, the constructor is:</p>

<pre><code class="language-C++">NaoQiButtonThread::NaoQiButtonThread()
  :: Thread("NaoQiButtonThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS)

</code></pre>

<h4 id="runtime-execution">Runtime execution</h4>
<p>At runtime, the <em>Executor</em> iterates through the list of synchronization points and executes all registered threads until completion. Then, the threads of the next synchronization point are called.</p>

<p>A module (thread) can be configured independent of these sense-plan-act synchronization points. This has the effect, that this thread is executed in parallel to this chain.</p>

<p>The high level overview of the Fawkes framework is shown in the next figure. At compile-time the configuration of the sense-plan act wakeup hook is done (upper part), while at run-time the scheduler iterates through this list of wakeup-hooks (lower part):</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/fawkes_executor_diagram.png" alt="Sequence diagram for Fawkes Executor" width="50%">
</center>

<p>Hence, at run-time, the hooks are executed as a fixed static schedule without preemption. Multiple threads registered in the same hook are executed in parallel.</p>

<p>Orthogonal to the sequential execution of sense-plan-act like applications, it is possible to define further constraints on the execution order by means of a <code class="language-plaintext highlighter-rouge">Barrier</code>. A barrier defines a number of threads, which need to have finished before the thread can start, which owns the barrier.</p>

<p>These concepts are implemented by the following main classes:</p>

<ul>
  <li>
<em>Wakeup hook</em> by <code class="language-plaintext highlighter-rouge">SyncPoint</code> and <code class="language-plaintext highlighter-rouge">SyncPointManager</code>, which manages a list of synchronization points.</li>
  <li>
<em>Executor</em> by the class <code class="language-plaintext highlighter-rouge">FawkesMainThread</code>, which is the scheduler, responsible for calling the user threads.</li>
  <li>
<code class="language-plaintext highlighter-rouge">ThreadManager</code>, which is derived from <code class="language-plaintext highlighter-rouge">BlockedTimingExecutor</code>, provides the necessary API to add and remove threads to wakeup hooks as well as for sequential execution of the wakeup-hooks.</li>
  <li>
<code class="language-plaintext highlighter-rouge">Barrier</code> is an object similar to <code class="language-plaintext highlighter-rouge">condition_variable</code> in C++.</li>
</ul>

<h4 id="discussion">Discussion</h4>

<p>All threads are executed with the same priority. If multiple sense-plan-act chains shall be executed with different priorities, e.g. to prefer execution of emergency-stop over normal operation, then this framework reaches its limits.</p>

<p>Also, different execution frequencies cannot be modeled by a single instance of this sense-plan-act chain. However, in robotics the fastest sensor will drive the chain and all other hooks are executed with the same frequency.</p>

<p>The option to execute threads independent of the predefined wakeup-hooks is very useful, e.g. for diagnostics. The concept of the Barrier is useful for satisfying functional dependencies which need to be considered in the execution order.</p>

<h2 id="references">References</h2>
<ul>
  <li>
    <p>[S2021]<a name="S2021"></a> J. Staschulat, Micro-ROS: The rclc Executor, in Workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at ROS World, Oct. 2021, [<a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">slides</a>] [<a href="https://www.youtube.com/embed/IazrPF3RN1U">Video</a>]</p>
  </li>
  <li>
    <p>[SLD2021]<a name="SLD2021"></a> J. Staschulat, R. Lange and D. N. Dasari, Budget-based real-time Executor for Micro-ROS, arXiv Pre-Print, May 2021. [<a href="https://arxiv.org/abs/2105.05590">paper</a>]</p>
  </li>
  <li>
    <p>[L2020]<a name="L2020"></a> Ralph Lange: Advanced Execution Management with ROS 2, ROS-Industrial Conference, Dec 2020 <a href="https://micro-ros.github.io/download/2020-12-16_Advanced_Execution_Management_with_ROS_2.pdf">[Slides]</a></p>
  </li>
  <li>
    <p>[SLL2020]<a name="SLL2020"></a> J. Staschulat, I. Ltkebohle and R. Lange, The rclc Executor: Domain-specific deterministic scheduling mechanisms for ROS applications on microcontrollers: work-in-progress, 2020 International Conference on Embedded Software (EMSOFT), Singapore, Singapore, 2020, pp. 18-19. <a href="https://ieeexplore.ieee.org/document/9244014">[Paper]</a> <a href="https://whova.com/embedded/session/eswe_202009/1145800/">[Video]</a></p>
  </li>
  <li>
    <p>[CB2019]<a name="CB2019"> </a> D. Casini, T. Bla, I. Ltkebohle, B. Brandenburg: Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling, in Euromicro-Conference on Real-Time Systems 2019. <a href="http://drops.dagstuhl.de/opus/volltexte/2019/10743/">[Paper]</a> <a href="https://t-blass.de/talks/ECRTS2019.pdf">[slides]</a></p>
  </li>
  <li>
    <p>[L2018]<a name="L2018"></a> Ralph Lange: Callback-group-level Executor for ROS 2. Lightning talk at ROSCon 2018. Madrid, Spain. Sep 2018. <a href="https://roscon.ros.org/2018/presentations/ROSCon2018_Lightning1_4.pdf">[Slides]</a> <a href="https://vimeo.com/292707644">[Video]</a></p>
  </li>
  <li>
    <p>[EK2018]<a name="EK2018"></a> R. Ernst, S. Kuntz, S. Quinton, M. Simons: The Logical Execution Time Paradigm: New Perspectives for Multicore Systems, February 25-28 2018 (Dagstuhl Seminar 18092). <a href="http://drops.dagstuhl.de/opus/volltexte/2018/9293/pdf/dagrep_v008_i002_p122_18092.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[NSP2018]<a name="NSP2018"></a> A. Naderlinger, S. Resmerita, and W. Pree: LET for Legacy and Model-based Applications,
Proceedings of The Logical Execution Time Paradigm: New Perspectives for Multicore Systems (Dagstuhl Seminar 18092), Wadern, Germany, February 2018.</p>
  </li>
  <li>
    <p>[BP2017]<a name="BP2017"></a> A. Biondi, P. Pazzaglia, A. Balsini,  M. D. Natale: Logical Execution Time Implementation and Memory Optimization Issues in AUTOSAR Applications for Multicores, International Worshop on Analysis Tools and Methodologies for Embedded and Real-Time Systems (WATERS2017), Dubrovnik, Croatia.<a href="https://pdfs.semanticscholar.org/4a9e/b9a616c25fd0b4a4f7810924e73eee0e7515.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[KZH2015]<a name="KZH2015"></a> S. Kramer, D. Ziegenbein, and A. Hamann: Real World Automotive Benchmarks For Free, International Workshop on Analysis Tools and Methodologies for Embedded adn Real-Time Sysems (WATERS), 2015.</p>
  </li>
  <li>
    <p>[HHK2001]<a name="HHK2001"></a> Henzinger T.A., Horowitz B., Kirsch C.M. (2001) Giotto: A Time-Triggered Language for Embedded Programming. In: Henzinger T.A., Kirsch C.M. (eds) Embedded Software. EMSOFT 2001. Lecture Notes in Computer Science, vol 2211. Springer, Berlin, Heidelberg</p>
  </li>
  <li>
    <p>[LL1973]<a name="LL1973"></a> Liu, C. L.; Layland, J.:Scheduling algorithms for multiprogramming in a hard real-time environment, Journal of the ACM, 20 (1): 4661, 1973.</p>
  </li>
</ul>
</div>
              </div>
            </div>
          </div>
        </div>
      
    
    <div class="row">
      <div class="col-xs-12">
        <div class="panel panel-default">
          <div class="panel-heading"><span class="glyphicon glyphicon-list"></span> CHANGELOG</div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="changelog-for-package-rclc">Changelog for package rclc</h1>

<h2 id="620-2024-10-15">6.2.0 (2024-10-15)</h2>

<ul>
  <li>added CI status for iron builds (#377)</li>
  <li>rclc_executor: improve enum type names (#379)</li>
  <li>fix rclc_example: memory leaking in msg.data allocation (backport
#386) (#387)</li>
  <li>updated ci versions (#396)</li>
  <li>updated ros-tooling versions (#407)</li>
</ul>

<h2 id="610-2023-06-15">6.1.0 (2023-06-15)</h2>

<ul>
  <li>Data structures interfaces for multi-threaded executor (#355)</li>
  <li>update ros-tooling versions (#361)</li>
  <li>updated actions/checkout version (#367)</li>
  <li>updated branch names to rolling (#370)</li>
</ul>

<h2 id="309-2023-03-22">3.0.9 (2023-03-22)</h2>

<ul>
  <li>Added build status of bloom-releases for Humble distribution (#291)</li>
  <li>[rolling] updated ros-tooling versions (#289)</li>
  <li>github action: updated os-version to ubuntu-22.04 (backport #295)
(#296)</li>
  <li>Added documentation (#301)</li>
  <li>Drop build dependency on std_msgs (#314)</li>
  <li>Updated &lt;ros-tooling/setup-ros@0.4.2&gt; and
&lt;ros-tooling/action-ros-ci@0.2.7&gt; (#318)</li>
  <li>Removed build status for Galactic in README (EOL November 2022)
(#321)</li>
  <li>Update documentation about number_of_handles (#326)</li>
  <li>executor.h: Fix a few docs typos (#338)</li>
</ul>

<h2 id="308-2022-04-14">3.0.8 (2022-04-14)</h2>

<ul>
  <li>Remove duplicate typedefs. (#249)</li>
  <li>Add rmw dependencies due to EventsExecutor PR in rcl (#255)</li>
  <li>Fix action client &amp; server deallocation (#257)</li>
  <li>updated documentation: build status for Rolling (#266)</li>
  <li>Update action client goal callback signature (#282)</li>
  <li>Upgrade parameters (#274)</li>
</ul>

<h2 id="307-2022-02-17">3.0.7 (2022-02-17)</h2>

<ul>
  <li>Fix enum naming for avoid collision (#242)</li>
  <li>Added dependency for package performance-test-fixture (#245)</li>
</ul>

<h2 id="306-2022-01-25">3.0.6 (2022-01-25)</h2>

<ul>
  <li>executor ignore canceled timers (#220)</li>
  <li>uddated documentation README.md (#229)</li>
  <li>resolved error in unit test see issue #230 (#231)</li>
  <li>Add thread dependency to examples (Rolling) (#237) (resolves in
this package only cpplint errors)</li>
</ul>

<h2 id="305-2021-11-23">3.0.5 (2021-11-23)</h2>

<ul>
  <li>Fix data_available reset for timer (backport #215) (#217)</li>
</ul>

<h2 id="304-2021-11-17">3.0.4 (2021-11-17)</h2>

<ul>
  <li>Ignoring unsuccessful SERVICE_TAKE (#175)</li>
  <li>Add rclc_parameter Quality Declaration (#144)</li>
  <li>use-ros2-testing (#185)</li>
  <li>Fix: printf in executor spin (#195)</li>
  <li>Fix init options handling (#202) (#205)</li>
  <li>Remove init options from support (#203)</li>
  <li>RCLC Actions Implementation (#170)</li>
  <li>Add rcl_action as build export dependency (#211)</li>
</ul>

<h2 id="303-2021-07-28">3.0.3 (2021-07-28)</h2>

<ul>
  <li>Checking for valid ROS context in spin_some</li>
  <li>Refactoring executor (removing callback_type)</li>
  <li>Fixing codecov config</li>
</ul>

<h2 id="302-2021-07-26">3.0.2 (2021-07-26)</h2>

<ul>
  <li>Updated codecov to ignore test folders</li>
  <li>Updated bloom release status table</li>
</ul>

<h2 id="301-2021-07-17">3.0.1 (2021-07-17)</h2>

<ul>
  <li>Added rclc_parameter package</li>
  <li>Added quality of service entity creation API</li>
  <li>Added executor prepare API</li>
  <li>Added support for removing subscription from executor</li>
  <li>Added support for subscription with context</li>
  <li>Added quality declaration statement</li>
  <li>Updated compatability function for sleep</li>
  <li>Removed duplicate NOTICE files</li>
</ul>

<h2 id="200-2021-04-23">2.0.0 (2021-04-23)</h2>

<ul>
  <li>Added codecov support</li>
  <li>New API of rcl_lifecycle in Rolling required major version bump</li>
</ul>

<h2 id="101-2021-03-29">1.0.1 (2021-03-29)</h2>

<ul>
  <li>Windows port</li>
  <li>Compatibility sleep function (Windows, POSIX-OS)</li>
  <li>Fixed RCL lifecycle API change for Rolling</li>
</ul>

<h2 id="100-2021-03-04">1.0.0 (2021-03-04)</h2>

<ul>
  <li>Service callbacks with context</li>
  <li>Fixed minor issues unit tests</li>
  <li>Upgraded setup_ros action (ci jobs)</li>
  <li>Removed Eloquent from ci jobs</li>
</ul>

<h2 id="017-2021-01-20">0.1.7 (2021-01-20)</h2>

<ul>
  <li>Corrected corrupted changelog</li>
</ul>

<h2 id="016-2021-01-20">0.1.6 (2021-01-20)</h2>

<ul>
  <li>Fixed issues due to Github Action timing delays on cloud build</li>
  <li>Fixed missing package dependency in Github Action for Eloquent</li>
</ul>

<h2 id="015-2020-12-11">0.1.5 (2020-12-11)</h2>

<ul>
  <li>Added support for services,clients and guard_conditions to rclc
executor</li>
  <li>Added table for bloom release status in README file</li>
</ul>

<h2 id="014-2020-11-25">0.1.4 (2020-11-25)</h2>

<ul>
  <li>Fixed error in bloom release</li>
</ul>

<h2 id="013-2020-11-23">0.1.3 (2020-11-23)</h2>

<ul>
  <li>Added rclc_lifecycle package</li>
  <li>Change maintainer information</li>
  <li>Minor fixes, updated unit tests</li>
</ul>

<h2 id="012-2020-05-19">0.1.2 (2020-05-19)</h2>

<ul>
  <li>Fixed compiler errors for bloom release</li>
</ul>

<h2 id="011-2020-05-14">0.1.1 (2020-05-14)</h2>

<ul>
  <li>Initial release</li>
</ul>
</div>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="kilted-tutorials">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Wiki Tutorials</h3>
      </div>
      <div class="panel-body">
        
        <em>This package does not provide any links to tutorials in it's <a href="https://index.ros.org/contribute/metadata/">rosindex metadata</a>.</em>
        <em>You can check on the <a href="http://wiki.ros.org/rclc/Tutorials" target="_blank">ROS Wiki Tutorials</a> page for the package.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="kilted-deps">
    <div class="row">
      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Package Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th class="text-center">Deps</th>
                  <th style="width: 100%">Name</th>
                </thead>
                <tbody>
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl#kilted">rcl  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl_action#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl_action#kilted">rcl_action  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcutils#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcutils#kilted">rcutils  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_generator_c#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_generator_c#kilted">rosidl_generator_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_typesupport_c#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_typesupport_c#kilted">rosidl_typesupport_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_ros#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_ros#kilted">ament_cmake_ros  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_gtest#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_gtest#kilted">ament_cmake_gtest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_pytest#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_pytest#kilted">ament_cmake_pytest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_auto#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_auto#kilted">ament_lint_auto  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_common#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_common#kilted">ament_lint_common  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/launch_testing#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/launch_testing#kilted">launch_testing  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/osrf_testing_tools_cpp#kilted-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/osrf_testing_tools_cpp#kilted">osrf_testing_tools_cpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/std_msgs#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/std_msgs#kilted">std_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/test_msgs#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/test_msgs#kilted">test_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/example_interfaces#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/example_interfaces#kilted">example_interfaces  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp#kilted">rclcpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp_action#kilted-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp_action#kilted">rclcpp_action  </a></td>
                      </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
          <div class="panel-heading">
            <h3 class="panel-title">System Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <em>No direct system dependencies.</em>
            
          </div>
        </div>
      </div>

      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Dependant Packages</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th>Name</th>
                  <th class="text-center">Deps</th>
                </thead>
                <tbody>
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_common_diagnostics#kilted">micro_ros_common_diagnostics</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_common_diagnostics#kilted-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_diagnostic_updater#kilted">micro_ros_diagnostic_updater</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_diagnostic_updater#kilted-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_examples#kilted">rclc_examples</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_examples#kilted-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_lifecycle#kilted">rclc_lifecycle</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_lifecycle#kilted-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_parameter#kilted">rclc_parameter</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_parameter#kilted-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="kilted-assets">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Launch files</h3>
      </div>
      <div class="panel-body">
        
          <em>No launch files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Messages</h3>
      </div>
      <div class="panel-body">
        
          <em>No message files found.</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Services</h3>
      </div>
      <div class="panel-body">
        
          <em>No service files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Plugins</h3>
      </div>
      <div class="panel-body">
        
          <em>No plugins found.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="kilted-questions">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Recent questions tagged <kbd>rclc</kbd> at <strong><a href="https://robotics.stackexchange.com/" target="_blank">Robotics Stack Exchange</a></strong></h3>      </div>
      <div id="kilted-question-list" class="panel-body" style="display: none;"></div>
      <div id="kilted-no-question-list" class="panel-body" style="display: none;">
        <p>No questions yet, you can ask one <a href="https://robotics.stackexchange.com/questions/tagged/rclc+kilted">here</a>.</p>
      </div>
      <div id="kilted-get-question-fail" class="panel-body alert alert-warning" style="display: none;">
        <p>Failed to get question list, you can ticket an issue <a href="https://github.com/ros-infrastructure/rosindex/issues/new" target="_blank" class="alert-link">here</a> </p>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript" src="/js/package_body_tabs.js"></script>

<script src=/js/contribution_suggestions.js></script>
<script type="text/javascript">
jQuery(function() {
    // Update the count on the links to the contribution suggestions
    updateContributionSuggestionsCountOnPackage('https://github.com/ros2/rclc.git');
});
</script>

          </div>
          <div class="col-md-2 hidden-xs hidden-sm">
            
            
            



<div class="list-group list-group-sm ">
  <a class="list-group-item"
     target="_blank"
     href="http://docs.ros.org/en/kilted/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       
       API Docs
  </a>
  <a class="list-group-item"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/rolling/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       
       Browse Code
  </a>
  
  
  
  
  
  
</div>

          </div>
        </div>
      
    </div>
  </div>

  <div class="distro distro-rolling">
    <div class="container-fluid">
      
        
        
        

        <div class="row">
          <div class="col-md-10">
            

<div class="well well-sm">
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px" src="/assets/package.png">
      </td>
      <td>
        <h3 style="margin-top: 5px">
          <a style="text-decoration:none" href="/p/rclc">rclc</a> <small>package from <a style="text-decoration:none" href="/r/rclc/github-ros2-rclc">rclc</a> repo</small>
        </h3>
          
            
            
              <span class="label label-default pkg-label">

rclc
</span>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_examples">

rclc_examples
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_lifecycle">

rclc_lifecycle
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_parameter">

rclc_parameter
</a>
            
          
      </td>
    </tr>
  </table>
</div>

            <div class="visible-xs visible-sm">
              
              
              



<div class="list-group list-group-sm list-group-horizontal list-group-justified">
  <a class="list-group-item text-center"
     target="_blank"
     href="http://docs.ros.org/en/rolling/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       <br>
       API Docs
  </a>
  <a class="list-group-item text-center"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/rolling/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       <br>
       Browse Code
  </a>
  
  
  
  
  
  
</div>

            </div>
            



<ul class="nav nav-tabs nav-justified" id="rolling-tabs" style="margin-bottom:20px">
  <li class="better-tabs active">
    <a href="#rolling-overview" data-toggle="tab">Overview</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    
    <a href="#rolling-assets" data-toggle="tab"><span class="label label-default">0</span> Assets</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    <a href="#rolling-deps" data-toggle="tab"><span class="label label-primary">17</span> Dependencies</a>
  </li>
  <li class="better-tabs">
    
    <a href="#rolling-tutorials" data-toggle="tab"><span class="label label-default">0</span> Tutorials</a>
  </li>
  <li class="better-tabs">
    <a href="#rolling-questions" data-toggle="tab"><span id="rolling-questions-count" class="label label-primary">0</span> Q & A</a>
  </li>
</ul>

<div class="tab-content">
  <div class="tab-pane active" id="rolling-overview">
    
    <div class="row">
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h4 class="panel-title">Package Summary</h4></div>
          <div class="panel-body">
            <table class="table table-condensed">
              <tr>
                <td style="width:100px;" class="text-right"><strong>Tags</strong></td>
                <td>
                  
                  
                    <em>No category tags.</em>
                  
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Version</strong></td>
                <td>6.2.0</td>
              </tr>
              <tr>
                <td class="text-right"><strong>License</strong></td>
                <td>Apache License 2.0</td>
              </tr>
              <tr>
                <td class="text-right"><strong>Build type</strong></td>
                <td>
                  
                    <span class="label label-default">
                  
                    AMENT_CMAKE</span>
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Use</strong></td>
                <td>
                
                  <span class="label label-success">RECOMMENDED</span>
                
                </td>
              </tr>
            </table>
          </div>
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body">
            
            
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">ROS Client Library for the C language.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/ros2/rclc.git">https://github.com/ros2/rclc.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">rolling</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2024-10-30
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="No CI information available for this package.">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <em>No category tags.</em>
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/rclc/#rolling-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#rolling-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#rolling-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
      </div>
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Package Description</h3></div>
          <div class="panel-body">
            The ROS client library in C.
          </div>
          <div class="panel-heading"><h4 class="panel-title">Additional Links</h4></div>
          <div class="panel-body">
            
            
              <em>No additional links.</em>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Maintainers</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>Pablo Garrido</li>
                
              </ul>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Authors</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>William Woodall</li>
                
              </ul>
            
          </div>
        </div>
      </div>
    </div>
    
      
        <div class="row">
          <div class="col-xs-12">
            <div class="panel panel-default">
              <div class="panel-heading"><span class="glyphicon glyphicon-file"></span><a href="https://github.com/ros2/rclc/tree/rolling/rclc/README.md" title="Open in git repository">rclc/README.md</a></div>
              <div class="panel-body">
                    <div class="rendered-markdown">
<h1 id="the-rclc-package">The rclc package</h1>

<h2 id="table-of-contents">Table of contents</h2>

<ul>
  <li>
    <p><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#introduction">Introduction</a></p>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#architecture">Architecture</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#scheduling-semantics">Scheduling Semantics</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#synchronization-of-multiple-rates">Synchronization of multiple rates</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#high-priority-processing-path">High-priority processing path</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#real-time-embedded-applications">Real-time embedded applications</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#rclc-executor">rclc Executor</a>
    <ul>
      <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#features">Features</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#trigger-condition">Trigger condition</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#sequential-execution">Sequential execution</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#let-semantics">LET-Semantics</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#executor-api">Executor API</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#configuration-phase">Configuration phase</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#running-phase">Running phase</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#examples">Examples</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#synchronization-of-multiple-rates-example">Synchronization of multiple rates example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#high-priority-processing-path-example">High-priority processing path example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#real-time-embedded-applications-example">Real-time embedded applications example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#future-work">Future work</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#download">Download</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#callback-group-level-executor">Callback-group-level Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#api-changes">API Changes</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#test-bench">Test Bench</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#related-work">Related Work</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#fawkes-framework">Fawkes Framework</a></li>
    </ul>
  </li>
  <li><a href="https://github.com/ros2/rclc/tree/rolling/rclc/#references">References</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Predictable execution under given real-time constraints is a crucial requirement for many robotic applications. While the service-based paradigm of ROS allows a fast integration of many different functionalities, it does not provide sufficient control over the execution management. For example, there are no mechanisms to enforce a certain execution order of callbacks within a node. Also the execution order of multiple nodes is essential for control applications in mobile robotics. Cause-effect-chains comprising of sensor acquisition, evaluation of data and actuation control should be mapped to ROS nodes executed in this order, however there are no explicit mechanisms to enforce it. Furthermore, when data recordings collected in field tests as ROS-bags are re-played, then the results are often surprisingly different due to non-determinism of process scheduling.</p>

<p>Manually setting up a particular execution order of subscriptions and publishing topics as well as defining use-case specific priorities of the corresponding Linux processes is always possible. However, this approach is error-prone, difficult to extend and requires an in-depth knowledge of the deployed ROS 2 packages in the system.</p>

<p>Therefore the goal of the Executor in micro-ROS is to support roboticists with practical and easy-to-use real-time mechanisms which provide solutions for:</p>
<ul>
  <li>Deterministic execution</li>
  <li>Real-time guarantees</li>
  <li>Integration of real-time and non real-time functionalities on one platform</li>
  <li>Specific support for RTOS and microcontrollers</li>
</ul>

<p>In ROS 1 a network thread is responsible for receiving all messages and putting them into a FIFO queue (in roscpp). That is, all callbacks were called in a FIFO manner, without any execution management. With the introduction of DDS (data distribution service) in ROS 2, the messages are buffered in DDS. In ROS 2, an Executor concept was introduced to support execution management. At the rcl-layer, a <em>wait-set</em> is configured with handles to be received and in a second step, the handles are taken from the DDS-queue. A handle is a generic term defined in rcl-layer for timers, subscriptions, services, clients and guard conditions.</p>

<p>The standard implementation of the ROS 2 Executor for the C++ API (rclcpp) has, however, certain unusual features, like precedence of timers over all other DDS handles, non-preemptive round-robin scheduling for non-timer handles and considering only one input data for each handle (even if multiple could be available). These features have the consequence, that in certain situations the standard rclcpp Executor is not deterministic and it makes guaranteeing real-time requirements very hard [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#CB2019">CB2019</a>]. We have not looked at the ROS 2 Executor implementation for Python Frontend (rclpy) because we consider a micro-controllers platform, on which typically C or C++ appliations will run.</p>

<p>Given the goals for a Real-Time Executor and the limitations of the ROS 2 standard rclcpp Executor, the challenges are:</p>
<ul>
  <li>to develop an adequate and well-defined scheduling mechanisms for the ROS 2 framework and the real-time operating system (RTOS)</li>
  <li>to define an easy-to-use interface for ROS developers</li>
  <li>to model requirements (like latencies, determinism in subsystems)</li>
  <li>mapping of ROS 2 framework and operating system schedulers (semi-automated and optimized mapping is desired as well as generic, well-understood framework mechanisms)</li>
</ul>

<p>Our approach is to provide a real-time-capable Executor for the rcl+rclc layer (as described in section <a href="https://github.com/ros2/rclc/tree/rolling/rclc/../">Introduction to Client Library</a>.) in the C programming language .</p>

<p>As the first step, we propose the rclc Executor for the rcl-layer in C programming language with several new features to support real-time and deterministic execution: It supports 1.) user-defined static sequential execution, 2) conditional execution semantics, 3) multi-threaded execution with scheduling configuration, and 4) logical execution semantics (LET). Sequential execution refers to the runtime behavior, that all callbacks are executed in a pre-defined order independent of the arrival time of messages. Conditional execution is available with a trigger condition which enables typical processing patterns in robotics (which are analyzed in detail in section <a href="https://github.com/ros2/rclc/tree/rolling/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>. Configuration of scheduling parameters for multi-threaded application accomplishes prioritized execution. The logical execution time concept (LET) provides data synchronization for fixed periodic task scheduling of embedded applications.</p>

<p>Beyond the advanced execution management mechanisms for micro-ROS, we also contributed to improving and extending the Executor concept in rclcpp for standard ROS 2: the callback group-level Executor. It is not a new Executor but rather a refinement of the ROS 2 Executor API allowing to prioritize a group of callbacks which is not possible with the ROS 2 default Executor in its current Galactic release.</p>

<h2 id="analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</h2>

<p>ROS 2 allows to bundle multiple nodes in one operating system process. To coordinate the execution of the callbacks of the nodes of a process, the Executor concept was introduced in rclcpp (and also in rclpy).</p>

<p>The ROS 2 design defines one Executor (instance of <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">rclcpp::executor::Executor</a>) per process, which is typically created either in a custom main function or by the launch system. The Executor coordinates the execution of all callbacks issued by these nodes by checking for available work (timers, services, messages, subscriptions, etc.) from the DDS queue and dispatching it to one or more threads, implemented in <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/single_threaded_executor.hpp">SingleThreadedExecutor</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp">MultiThreadedExecutor</a>, respectively.</p>

<p>The dispatching mechanism resembles the ROS 1 spin thread behavior: the Executor looks up the wait sets, which notifies it of any pending callback in the DDS queue. If there are multiple pending callbacks, the ROS 2 Executor executes them in an in the order as they were registered at the Executor.</p>

<h3 id="architecture">Architecture</h3>

<p>The following diagram depicts the relevant classes of the standard ROS 2 Executor implementation:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/executor_class_diagram.png" alt="ROS 2 Executor class diagram" width="100%">
</center>

<p>Note that an Executor instance maintains weak pointers to the NodeBaseInterfaces of the nodes only. Therefore, nodes can be destroyed safely, without notifying the Executor.</p>

<p>Also, the Executor does not maintain an explicit callback queue, but relies on the queue mechanism of the underlying DDS implementation as illustrated in the following sequence diagram:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/executor_to_dds_sequence_diagram.png" alt="Call sequence from executor to DDS" width="100%">
</center>

<p>The Executor concept, however, does not provide means for prioritization or categorization of the incoming callback calls. Moreover, it does not leverage the real-time characteristics of the underlying operating-system scheduler to have finer control on the order of executions. The overall implication of this behavior is that time-critical callbacks could suffer possible deadline misses and a degraded performance since they are serviced later than non-critical callbacks. Additionally, due to the FIFO mechanism, it is difficult to determine usable bounds on the worst-case latency that each callback execution may incur.</p>

<h3 id="scheduling-semantics">Scheduling Semantics</h3>

<p>In a recent paper [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#CB2019">CB2019</a>], the rclcpp Executor has been analyzed in detail and a response time analysis of cause-effect chains has been proposed under reservation-based scheduling. The Executor distinguishes four categories of callbacks: <em>timers</em>, which are triggered by system-level timers, <em>subscribers</em>, which are triggered by new messages on a subscribed topic, <em>services</em>, which are triggered by service requests, and <em>clients</em>, which are triggered by responses to service requests. The Executor is responsible for taking messages from the input queues of the DDS layer and executing the corresponding callback. Since it executes callbacks to completion, it is a non-preemptive scheduler, However it does not consider all ready tasks for execution, but only a snapshot, called readySet. This readySet is updated when the Executor is idle and in this step it interacts with the DDS layer updating the set of ready tasks. Then for every type of task, there are dedicated queues (timers, subscriptions, services, clients) which are processed sequentially. The following undesired properties were pointed out:</p>

<ul>
  <li>Timers have the highest priority. The Executor processes <em>timers</em> always first.  This can lead to the intrinsic effect, that in overload situations messages from the DDS queue are not processed.</li>
  <li>Non-preemptive round-robin scheduling of non-timer handles. Messages arriving during the processing of the readySet are not considered until the next update, which depends on the execution time of all remaining callbacks. This leads to priority inversion, as lower-priority callbacks may implicitly block higher-priority callbacks by prolonging the current processing of the readySet.</li>
  <li>Only one message per handle is considered. The readySet contains only one task instance, For example, even if multiple messages of the same topic are available, only one instance is processed until the Executor is idle again and the readySet is updated from the DDS layer. This aggravates priority inversion, as a backlogged callback might have to wait for multiple processing of readySets until it is considered for scheduling. This means that non-timer callback instances might be blocked by multiple instances of the same lower-priority callback.</li>
</ul>

<p>Due to these findings, the authors present an alternative approach to provide determinism and to apply well-known schedulability analyses to a ROS 2 systems. A response time analysis is described under reservation-based scheduling.</p>

<h2 id="analysis-of-processing-patterns">Analysis of processing patterns</h2>
<p>The development of an execution management mechanism for micro-ROS is based on an analysis of processing patterns commonly used in robotics and embedded systems. First, typical processing patterns in mobile robotics are presented which are used to implement deterministic behavior. Then, the processing patterns in the real-time embedded systems are analyzed, in which, as a main difference, the time-triggered paradigm is applied to accomplish real-time behavior.</p>

<h3 id="sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</h3>
<p>Now we describe common software design patterns which are used in mobile robotics to achieve deterministic behavior. For each design pattern we describe the concept and the derived requirements for a deterministic Executor.</p>

<p><strong>Concept:</strong></p>

<p>A common design paradigm in mobile robotics is a control loop, consisting of several phases: A sensing phase to aquire sensor data, a plan phase for localization and path planning and an actuation-phase to steer the mobile robot. Of course, more phases are possible, here these three phases shall serve as an example. Such a processing pipeline is shown in Figure 1.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensePlanActScheme.png" alt="Sense Plan Act Pipeline" width="60%">
</center>
<center>
Figure 1: Multiple sensors driving a Sense-Plan-Act pipeline.
</center>

<p>Typically multiple sensors are used to perceive the environment. For example an IMU and a laser scanner. The quality of localization algorithms highly depend on how old such sensor data is when it is processed. Ideally the latest data of all sensors should be processed. One way to achive this is to execute first all sensor drivers in the sense-phase and then process all algorithms in the plan-phase.</p>

<p>Currently, such a processing order cannot be defined with the default Executor of rclcpp. One could in principle design a data-driven pipeline, however if e.g. the Laser scan is needed by some other callback in the sense-phase as well as in the plan-phase, the processing order of these subscribers is arbitrary.</p>

<p>For this sense-plan-act pattern, we could define one executor for each phase. The plan-phase would be triggered only when all callbacks in the sense-phase have finished.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
</ul>

<h3 id="synchronization-of-multiple-rates">Synchronization of multiple rates</h3>

<p><strong>Concept:</strong></p>

<p>Often multiple sensors are being used to sense the environment for mobile robotics. While an IMU sensor provides data samples at a very high rate (e.g., 500 Hz), laser scans are availabe at a much slower frequency (e.g. 10Hz) determined by the revolution time. Then the challenge is, how to deterministically fuse sensor data with different frequencies. This problem is depicted in Figure 2.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensorFusion_01.png" alt="Sychronization of multiple rates" width="30%">
</center>
<center>
Figure 2: How to deterministically process multi-frequent sensor data.
</center>

<p>Due to scheduling effects, the callback for evaluating the laser scan might be called just before or just after an IMU data is received. One way to tackle this is to write additional synchronization code inside the application. Obviously, this is a cumbersome and not-portable solution.</p>

<p>An Alternative would be to evalute the IMU sample and the laser scan by synchronizing their frequency. For example by processing always 50 IMU samples with one laser scan. This approach is shown in Figure 3. A pre-processing callback aggregates the IMU samples and sends an aggregated message with 50 samples at 10Hz rate. Now both messages have the same frequency. With a trigger condition, which fires when both messages are available, the sensor fusion algorithm can expect always synchronized input data.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensorFusion_02.png" alt="Sychnronization with a trigger" width="40%">
</center>
<center>
Figure 3: Synchronization of multiple input data with a trigger.
</center>

<p>In ROS 2, this is currently not possible to be modeled because of the lack of a trigger concept in the Executors of rclcpp and rclpy. Message filters could be used to synchronize input data based on the timestamp in the header, but this is only available in rclcpp (and not in rcl). Further more, it would be more efficient to have such a trigger concept directly in the Executor.</p>

<p>Another idea would be to activly request for IMU data only when a laser scan is received. This concept is shown in Figure 4. Upon arrival of a laser scan mesage, first, a message with aggregated IMU samples is requested. Then, the laser scan is processed and later the sensor fusion algorithm. An Executor, which would support sequential execution of callbacks, could realize this idea.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/sensorFusion_03.png" alt="Sychronization with sequence" width="30%">
</center>
<center>
Figure 4: Synchronization with sequential processing.
</center>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
  <li>sequential procesing of callbacks</li>
</ul>

<h3 id="high-priority-processing-path">High-priority processing path</h3>
<p><strong>Concept</strong>
Often a robot has to fullfill several activities at the same time. For example following a path and avoiding obstacles. While path following is a permanent activity, obstacle avoidance is trigged by the environment and should be immediately reacted upon. Therefore one would like to specify priorities to activities. This is depicted in Figure 5:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/highPriorityPath.png" alt="HighPriorityPath" width="50%">
</center>
<center>
Figure 5: Managing high priority path with sequential order.
</center>

<p>Assuming a simplified control loop with the activities sense-plan-act, the obstacle avoidance, which might temporarily stop the robot, should be processed before the planning phase. In this example we assume that these activites are processed in one thread.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>sequential processing of callbacks</li>
</ul>

<h3 id="real-time-embedded-applications">Real-time embedded applications</h3>
<p>In embedded systems, real-time behavior is approached by using the time-triggered paradigm, which means that the processes are periodically activated. Processes can be assigned priorities to allow pre-emptions. Figure 6 shows an example, in which three processes with fixed periods are shown. The middle and lower process are preempted multiple times depicted with empty dashed boxes.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/scheduling_01.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 6: Fixed periodic preemptive scheduling.
</center>

<p>To each process one or multiple tasks can be assigned, as shown in Figure 7. These tasks are executed sequentially, which is often called cooperative scheduling.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/scheduling_02.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 7: Processes with sequentially executed tasks.
</center>

<p>While there are different ways to assign priorities to a given number of processes,
the rate-monotonic scheduling assignment, in which processes with a shorter period have a higher priority, has been shown optimal if the processor utilization is less than 69% [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#LL1973">LL1973</a>].</p>

<p>In the last decades many different scheduling approaches have been presented, however fixed-periodic preemptive scheduling is still widely used in embedded real-time systems [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#KZH2015">KZH2015</a>]. This becomes also obvious, when looking at the features of current operating systems. Like Linux, real-time operating systems, such as NuttX, Zephyr, FreeRTOS, QNX etc., support fixed-periodic preemptive scheduling and the assignment of priorities, which makes the time-triggered paradigm the dominant design principle in this domain.</p>

<p>However, data consistency is often an issue when preemptive scheduling is used and if data is being shared across multiple processes via global variables. Due to scheduling effects and varying execution times of processes, writing and reading these variables could occur sometimes sooner or later. This results in an latency jitter of update times (the timepoint at which a variable change becomes visible to other processes). Race conditions can occur when multiple processes access a variable at the same time. So solve this problem, the concept of logical-execution time (LET) was introduced in [<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#HHK2001">HHK2001</a>], in which communication of data occurs only at pre-defined periodic time instances: Reading data only at the beginning of the period and writing data only at the end of the period. The cost of an additional latency delay is traded for data consistency and reduced jitter. This concept has also recently been applied to automotive applications[<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#NSP2018">NSP2018</a>].</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/scheduling_LET.png" alt="Schedule with fixed periods" width="80%">
</center>
<center>
Figure 8: Data communication without and with Logical Execution Time paradigm.
</center>

<p>An Example of the LET concept is shown in Figure 8. Assume that two processes are communicating data via one global variable. The timepoint when this data is written is at the end of the processing time. In the default case (left side), the process p<sub>3</sub> and p<sub>4</sub> receive the update. At the right side of Figure 8, the same scenario is shown with LET semantics. Here, the data is communicated only at period boundaries. In this case, the lower process communicates at the end of the period, so that always process p<sub>3</sub> and p<sub>5</sub> receive the new data.</p>

<p><strong>Concept:</strong></p>
<ul>
  <li>periodic execution of processes</li>
  <li>assignment of fixed priorities to processes</li>
  <li>preemptive scheduling of processes</li>
  <li>co-operative scheduling of tasks within a process (sequential execution)</li>
  <li>data synchronization with LET-semantics</li>
</ul>

<p>While periodic activation is possible in ROS 2 by using timers, preemptive scheduling is supported by the operating system and assigning priorities on the granularity of threads/processes that correspond to the ROS nodes; it is not possible to sequentially execute callbacks, which have no data-dependency. Furthermore data is read from the DDS queue just before the callback is executed and data is written sometime during the time the application is executed. While the <code class="language-plaintext highlighter-rouge">spin_period</code> function of the rclcpp Executor allows to check for data at a fixed period and executing those callbacks for which data is available, however, with this spin-function does not execute all callbacks irrespective wheter data is available or not. So <code class="language-plaintext highlighter-rouge">spin_period</code> is not helpful to periodically execute a number of callbacks (aka tasks within a process). So we need a mechanism that triggers the execution of multiple callbacks (aka tasks) based on a timer. Data transmission is achieved via DDS which does not allow to implement a LET-semantics. To summarize, we derive the following requirements.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>trigger the execution</li>
  <li>sequential processing of callbacks</li>
  <li>data synchronization with LET semantics</li>
</ul>

<h2 id="rclc-executor">rclc Executor</h2>

<p>The rclc Executor is a ROS 2 Executor based on the rcl-layer in C programming language. As discussed above, the default rclcpp Executor is not suitable to implement real-time applications because of three main reasons: timers are preferred over all other handles, no priorization of callback execution and the round-robin to completion execution of callbacks. On the other hand, several processing patterns have been developed as best practices to achieve non-functional requirements, such as bounded end-to-end latencies, low jitter of response times of cause-effect chains, deterministic processing and short response times even in overload situations. These processing patterns are difficult to implement with the concepts availabe in the default ROS 2 Executor, therefore we have developed a flexible Executor: the rclc Executor.</p>

<h3 id="features">Features</h3>

<p>The rclc Executor is feature-complete, i.e. it supports all event types as the default ROS 2 Executor, which are:</p>
<ul>
  <li>subscriptions</li>
  <li>timers</li>
  <li>services</li>
  <li>clients</li>
  <li>guard conditions</li>
  <li>actions</li>
  <li>lifecycle</li>
</ul>

<p>The flexible rclc Executor provides on top the following new features:</p>
<ul>
  <li>triggered execution</li>
  <li>user-defined sequential execution</li>
  <li>multi-threading and scheduling configuration (WIP)</li>
  <li>LET-semantics for data synchronization of periodic process scheduling</li>
</ul>

<p>First, a <em>trigger condition</em> allows to define when the processing of a callback shall start. This is useful to implement sense-plan-act control loops or more complex processing structures with directed acyclic graphs. Second, a user can specify the <em>processing order</em> in which these callbacks will be executed. With this feature, the pattern of sensor fusion with multiple rates, in which data is requested from a sensor based on the arrival of some other sensor, can be easily implemented. Third, the assignment of scheduling parameters (e.g., priorities) of the underlying operating system. With this feature, prioritized processing can be implemented. Finally, for periodic applications, the <em>LET Semantics</em> has been implemented to support data consistency for periodic process scheduling. These features are now described in more detail.</p>

<h4 id="sequential-execution">Sequential execution</h4>

<ul>
  <li>At configuration, the user defines the order of handles.</li>
  <li>At configuration, the user defines whether the handle shall be called only when new data is available (ON_NEW_DATA) or whether the callback shall always be called (ALWAYS).</li>
  <li>At runtime, all handles are processed in the user-defined order
    <ul>
      <li>if the configuration of handle is ON_NEW_DATA, then the corresponding callback is only called if new data is available</li>
      <li>if the configuration of the handle is ALWAYS, then the corresponding callback is always. If no data is available, then the callback is called with no data (e.g. NULL pointer).</li>
    </ul>
  </li>
</ul>

<p>Figure 9 shows three callbacks, A, B and C. Assume, they shall be executed in the order <em>B,A,C</em>. Then the user adds the callbacks to the rclc Executor in this order. Whenever new messages have arrived then the callbacks for which a new message is availabe will be always executed in the user-defined processing order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/rclc_executor_sequential_execution.png" alt="Sequential execution semantics" width="50%">
</center>
<center>
Figure 9: Sequential execution semantics.
</center>

<h4 id="trigger-condition">Trigger condition</h4>

<ul>
  <li>Given a set of handles, a trigger condition, which is based on the availability of input data of these handles, decides when the processing of all callbacks starts. This is shown in Figure 10.</li>
</ul>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_01.png" alt="Trigger condition overview" width="50%">
</center>
<center>
Figure 10: Executor with trigger condition
</center>

<ul>
  <li>Available options:
    <ul>
      <li>ALL operation: fires when input data is available for all handles</li>
      <li>ANY operation: fires when input data is available for at least one handle (OR semantics)</li>
      <li>ONE: fires when input data for a user-specified handle is available</li>
      <li>User-defined function: user can implement custom logic</li>
    </ul>
  </li>
</ul>

<p>Figure 11 shows an example of the ALL semantics. Only if all messages <em>msg_A, msg_B, msg_C</em> were received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_ALL.png" alt="Trigger condition ALL" width="30%">
</center>
<center>
Figure 11: Trigger condition ALL
</center>

<p>Figure 12 shows an example of the ANY semantics. Thas is, if any messages <em>msg_A, msg_B, msg_C</em> was received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order. This is equivalent to OR semantics.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_OR.png" alt="Trigger condition ANY" width="30%">
</center>
<center>
Figure 12: Trigger condition ANY (OR)
</center>

<p>Figure 13 shows an example of the ONE semantics. Thas is, only if message <em>msg_B</em> was received, the trigger condition is fullfilled and (potentially all) callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_ONE.png" alt="Trigger condition ONE" width="30%">
</center>
<center>
Figure 13: Trigger condition ONE
</center>

<p>Figure 14 describes the custom semantics. A custom trigger condition with could be a more complex logic of multiple messages, can be passed to the executor. This might also include hardware triggers, like interrupts.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/trigger_user_defined.png" alt="Trigger condition user-defined" width="30%">
</center>
<center>
Figure 14: Trigger condition user-defined
</center>

<h4 id="let-semantics">LET-Semantics</h4>
<ul>
  <li>Assumption: time-triggered system, the executor is activated periodically</li>
  <li>When the trigger fires, reads all input data and makes a local copy</li>
  <li>Processes all callbacks in sequential order</li>
  <li>Write output data at the end of the executors period (Note: this is not implemented yet)</li>
</ul>

<p>Additionally we have implemented the current rclcpp Executor semantics (RCLCPP):</p>
<ul>
  <li>waiting for new data for all handles (rcl_wait)</li>
  <li>using trigger condition ANY</li>
  <li>if trigger fires, start processing handles in pre-defined sequential order</li>
  <li>request from DDS-queue the new data just before the handle is executed (rcl_take)</li>
</ul>

<p>The selection of the Executor semantics is optional. The default semantics is RCLCPP.</p>

<h4 id="multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</h4>

<p>The rclc Executor has been extended for multi-threading. It supports the assignment of scheduling policies, like priorities or more advanced scheduling algorithms as reservation-based scheduling, to subscription callbacks. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, Pre-print <a href="https://github.com/ros2/rclc/tree/rolling/rclc/#SLD2021">SLD2021</a>]. The overall architecture is shown in Figure 15. One Executor thread is responsible for checking for new data from the DDS queue. For every callback, a thread is spawned with the dedicted scheduling policy provided by the operating system. The Executor then dispatches new data of a subscription to its corresponding callback function, which is then executed in its own thread by operating system.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/rclc_executor_multi_threaded.png" alt="Multi-threaded rclc Executor" width="90%">
</center>
<center>
Figure 15: multi-threaded rclc-Executor
</center>

<h3 id="executor-api">Executor API</h3>
<p>The API of the rclc Executor can be divided in two phases: Configuration and Running.</p>
<h4 id="configuration-phase">Configuration phase</h4>
<p>During the configuration phase, the user shall define:</p>
<ul>
  <li>the total number of callbacks</li>
  <li>the sequence of the callbacks</li>
  <li>trigger condition (optional, default: ANY)</li>
  <li>data communcation semantics (optional, default ROS2)</li>
</ul>

<p>As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added.</p>

<p>Also in the XRCE-DDS middleware the maximum number of handles need to be configured. See <a href="https://docs.vulcanexus.org/en/humble/rst/tutorials/micro/memory_management/memory_management.html#entity-creation">Memory Management Tutorial</a> for the defaults and configuration of the colcon.meta configuration file. To make sure that the changes were applied, you can check the defined values in the following library include file: build/rmw_microxrcedds/include/rmw_microxrcedds_c/config.h.</p>

<p>Then, the user adds handles and the corresponding callbacks (e.g. for subscriptions and timers) to the Executor. The order in which this takes place, defines later the sequential processing order during runtime.</p>

<p>For each handle the user can specify, if the callback shall be executed only if new data is available (ON_NEW_DATA) or if the callback shall always be executed (ALWAYS). The second option is useful when the callback is expected to be called at a fixed rate.</p>

<p>The trigger condition defines when the processing of these callbacks shall start. For convenience some default conditions have been defined:</p>
<ul>
  <li>trigger_any(default) : start executing if any callback has new data</li>
  <li>trigger_all : start executing if all callbacks have new data</li>
  <li>trigger_one(&amp;<code class="language-plaintext highlighter-rouge">data</code>) : start executing if <code class="language-plaintext highlighter-rouge">data</code> has been received</li>
  <li>user_defined_function: the user can also define its own function with more complex logic</li>
</ul>

<p>With trigger_any being the default, the current semantics of the rclcpp Executor is selected.</p>

<p>The data communication semantics can be</p>
<ul>
  <li>ROS2 (default)</li>
  <li>LET</li>
</ul>

<p>To be compatible with ROS2 rclcpp Executor, the existing rclcpp semantics is implemented as ROS2. That is, with the spin-function the DDS-queue is constantly monitored for new data (rcl_wait). If new data becomes available, then is fetched from DDS (rcl_take) immediately before the callback is executed. All callbacks are processed in the user-defined order, this is the only difference to the rclcpp Executor, in which no order can be specified.</p>

<p>Secondly, the LET semantics is implemented such that at the beginning of processing all available data is fetched (rcl_take) and buffered and then the callbacks are processed in the pre-defined operating on the buffered copy.</p>

<h4 id="running-phase">Running phase</h4>

<p>As the main functionality, the Executor has a <code class="language-plaintext highlighter-rouge">spin</code>-function which constantly checks for new data at the DDS-queue, like the rclcpp Executor in ROS2. If the trigger condition is satisfied then all available data from the DDS queue is processed according to the specified semantics (ROS or LET) in the user-defined sequential order. After all callbacks have been processed the DDS is checked for new data again.</p>

<p>Available spin functions are</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">spin_some</code>  - spin one time</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin_period</code> - spin with a period</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin</code> - spin indefinitly</li>
</ul>

<h3 id="examples">Examples</h3>
<p>We provide the relevant code snippets how to setup the rclc Executor for the processing patterns as described above.</p>

<h4 id="sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</h4>

<p>In this example we want to realise a sense-plan-act pipeline in a single thread. The trigger condition is demonstrated by activating
the sense-phase when both data for the Laser and IMU are available. Three executors are necessary <code class="language-plaintext highlighter-rouge">exe_sense</code>, <code class="language-plaintext highlighter-rouge">exe_plan</code> and <code class="language-plaintext highlighter-rouge">exe_act</code>. The two sensor acquisition callbacks <code class="language-plaintext highlighter-rouge">sense_Laser</code> and <code class="language-plaintext highlighter-rouge">sense_IMU</code> are registered in the Executor <code class="language-plaintext highlighter-rouge">exe_sense</code>.
The trigger condition ALL is responsible to activate the sense-phase only when all data for these two callbacks are available. Finally all three Executors are spinning using a <code class="language-plaintext highlighter-rouge">while</code>-loop and the <code class="language-plaintext highlighter-rouge">spin_some</code> function.</p>

<p>The definitions of callbacks are omitted.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act;
rcle_let_executor_t exe_sense, exe_plan, exe_act;
// initialize executors
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
rclc_executor_init(&amp;exe_plan, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_act, &amp;context, 1, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb1, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_let_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);
// executor for plan-phase
rclc_executor_add_subscription(&amp;exe_plan, &amp;plan, &amp;my_sub_cb3, ON_NEW_DATA);
// executor for act-phase
rclc_executor_add_subscription(&amp;exe_act, &amp;act, &amp;my_sub_cb4, ON_NEW_DATA);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_sense);
  rclc_executor_spin_some(&amp;exe_plan);
  rclc_executor_spin_some(&amp;exe_act);
}

</code></pre>

<h4 id="synchronization-of-multiple-rates-example">Synchronization of multiple rates example</h4>

<p>The sensor fusion synchronizing the multiple rates with a trigger is shown below.</p>

<pre><code class="language-C">...
rcl_subscription_t aggr_IMU, sense_Laser, sense_IMU;
rcle_let_executor_t exe_aggr, exe_sense;
// initialize executors
rclc_executor_init(&amp;exe_aggr, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for aggregate IMU data
rclc_executor_add_subscription(&amp;exe_aggr, &amp;aggr_IMU, &amp;my_sub_cb1, ON_NEW_DATA);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb3, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_aggr);
  rclc_executor_spin_some(&amp;exe_sense);
}

</code></pre>

<p>The setup for the sensor fusion using sequential execution is shown below.
Note that the sequetial order is <code class="language-plaintext highlighter-rouge">sense_IMU</code>, which will request the aggregated IMU message, and then <code class="language-plaintext highlighter-rouge">sense_Laser</code>
while the trigger will fire, when a laser message is received.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU;
rcle_let_executor_t exe_sense;
// initialize executor
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe_sense);

</code></pre>
<h4 id="high-priority-processing-path-example">High priority processing path example</h4>

<p>This example shows the sequential processing order to execute the obstacle avoidance <code class="language-plaintext highlighter-rouge">obst_avoid</code>
after the callbacks of the sense-phase and before the callback of the planning phase <code class="language-plaintext highlighter-rouge">plan</code>.
The control loop is started when a laser message is received. Then an aggregated IMU message is requested,
like in the example above. Then all the other callbacks are always executed. This assumes that these callbacks
communicate via a global data structure. Race conditions cannot occur, because the callbacks
run all in one thread.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act, obst_avoid;
rcle_let_executor_t exe;
// initialize executors
rclc_executor_init(&amp;exe, &amp;context, 5, ...);
// define processing order
rclc_executor_add_subscription(&amp;exe, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe, &amp;obst_avoid, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;plan, &amp;my_sub_cb4, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;act, &amp;my_sub_cb5, ALWAYS);
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="real-time-embedded-applications-example">Real-time embedded applications example</h4>

<p>With seqential execution the co-operative scheduling of tasks within a process can be modeled. The trigger condition is used to periodically activate the process which will then execute all callbacks in a pre-defined order. Data will be communicated using the LET-semantics. Every Executor is executed in its own tread, to which an appropriate priority can be assigned.</p>

<p>In the following example, the Executor is setup with 4 handles. We assume a process has three subscriptions <code class="language-plaintext highlighter-rouge">sub1</code>, <code class="language-plaintext highlighter-rouge">sub2</code>, <code class="language-plaintext highlighter-rouge">sub3</code>. The sequential processing order is given by the order as they are added to the Executor. A timer <code class="language-plaintext highlighter-rouge">timer</code> defines the period.  The <code class="language-plaintext highlighter-rouge">trigger_one</code> with the paramter <code class="language-plaintext highlighter-rouge">timer</code> is used, so that whenever the timer is ready, all callbacks are processed. Finally the data communication semantics LET is defined.</p>

<pre><code class="language-C">#include "rcl_executor/let_executor.h"

// define subscription callback
void my_sub_cb1(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb2(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb3(const void * msgin)
{
  // ...
}

// define timer callback
void my_timer_cb(rcl_timer_t * timer, int64_t last_call_time)
{
  // ...
}

// necessary ROS 2 objects
rcl_context_t context;   
rcl_node_t node;
rcl_subscription_t sub1, sub2, sub3;
rcl_timer_t timer;
rcle_let_executor_t exe;

// define ROS context
context = rcl_get_zero_initialized_context();
// initialize ROS node
rcl_node_init(&amp;node, &amp;context,...);
// create subscriptions
rcl_subscription_init(&amp;sub1, &amp;node, ...);
rcl_subscription_init(&amp;sub2, &amp;node, ...);
rcl_subscription_init(&amp;sub3, &amp;node, ...);
// create a timer
rcl_timer_init(&amp;timer, &amp;my_timer_cb, ... );
// initialize executor with four handles
rclc_executor_init(&amp;exe, &amp;context, 4, ...);
// define static execution order of handles
rclc_executor_add_subscription(&amp;exe, &amp;sub1, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub2, &amp;my_sub_cb2, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub3, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_timer(&amp;exe, &amp;timer);
// trigger when handle 'timer' is ready
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;timer);
// select LET-semantics
rclc_executor_data_comm_semantics(&amp;exe, LET);
// spin forever
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</h4>
<p>The rclc Executor has been presented at the workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at <a href="https://roscon.ros.org/world/2021/">ROS World 2021</a> (i.e. the online version of ROSCon)[<a href="https://github.com/ros2/rclc/tree/rolling/rclc/#S2021">S2021</a>]. A <a href="https://github.com/ros-realtime/reference-system">Reference System</a> for testing and benchmarking ROS Executors has been developed for this workshop. The application of the rclc Executor on the reference system with the trigger condition can be found in the <a href="https://github.com/ros-realtime/reference-system/tree/rclc_executor">rclc-executor branch of the Reference System</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/IazrPF3RN1U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>The slides can be downloaded <a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">here</a>. All information and the videos and slides of the other talks of the workshop can be found at <a href="https://www.apex.ai/roscon-21">www.apex.ai/roscon-21</a>.</p>

<h3 id="future-work">Future work</h3>

<ul>
  <li>Full LET semantics (writing data at the end of the period)
    <ul>
      <li>one publisher that periodically publishes</li>
      <li>if Executors are running in multiple threads,
publishing needs to be atomic</li>
    </ul>
  </li>
  <li>Multi-threaded executor with assignment of scheduling policies of unerlying operating system. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, pre-print <a href="https://github.com/ros2/rclc/tree/rolling/rclc/#SLD2021">SLD2021</a>].</li>
</ul>

<h3 id="download">Download</h3>
<p>The rclc Executor can be downloaded from the <a href="https://github.com/ros2/rclc">ros2/rclc repository</a>. It is available for the ROS 2 versions Foxy, Galactic and Rolling. The repository provides several packages including the <a href="https://github.com/ros2/rclc/tree/master/rclc">rclc Executor</a> and an <a href="https://github.com/ros2/rclc/tree/master/rclc_examples">rclc_examples package</a> with several application examples.</p>

<h2 id="callback-group-level-executor">Callback-group-level Executor</h2>

<p>The Callback-group-level Executor was an early prototype for a refined rclcpp Executor API developed in micro-ROS. It has been derived from the default rclcpp Executor and addresses some of the aforementioned deficits. Most important, it was used to validate that the underlying layers (rcl, rmw, rmw_adapter, DDS) allow for multiple Executor instances without any negative interferences.</p>

<p>As the default rclcpp Executor works at a node-level granularity  which is a limitation given that a node may issue different callbacks needing different real-time guarantees - we decided to refine the API for more fine-grained control over the scheduling of callbacks on the granularity of callback groups using. We leverage the callback-group concept existing in rclcpp by introducing real-time profiles such as RT-CRITICAL and BEST-EFFORT in the callback-group API (i.e. rclcpp/callback_group.hpp). Each callback needing specific real-time guarantees, when created, may therefore be associated with a dedicated callback group. With this in place, we enhanced the Executor and depending classes (e.g., for memory allocation) to operate at a finer callback-group granularity. This allows a single node to have callbacks with different real-time profiles assigned to different Executor instances - within one process.</p>

<p>Thus, an Executor instance can be dedicated to specific callback group(s) and the Executors thread(s) can be prioritized according to the real-time requirements of these groups. For example, all time-critical callbacks are handled by an RT-CRITICAL Executor instance running at the highest scheduler priority.</p>

<p>The following Figure illustrates this approach with two nodes served by three Callback-group-level Executors in one process:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/cbg-executor_sample_system.png" alt="Sample system with two nodes and three Callback-group-level Executors in one process" width="60%">
</center>

<p>The different callbacks of the Drive-Base node are distributed to different Executors (visualized by the color red, yellow and green).  For example the onCmdVel and publishWheelTicks callback are scheduled by the same Executor (yellow). Callbacks from different nodes can be serviced by the same Executor.</p>

<h3 id="api-changes">API Changes</h3>

<p>In this section, we describe the necessary changes to the Executor API:</p>
<ul>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/callback_group.hpp">include/rclcpp/callback_group.hpp</a>:</p>

    <ul>
      <li>Introduced an enum to distinguish up to three real-time classes (requirements) per node (RealTimeCritical, SoftRealTime, BestEffort)</li>
      <li>Changed association with Executor instance from nodes to callback groups.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">include/rclcpp/executor.hpp</a></p>

    <ul>
      <li>
        <p>Added functions to add and remove individual callback groups in addition to whole nodes.</p>
      </li>
      <li>
        <p>Replaced private vector of nodes with a map from callback groups to nodes.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/memory_strategy.hpp">include/rclcpp/memory_strategy.hpp</a></p>

    <ul>
      <li>Changed all functions that expect a vector of nodes to the just mentioned map.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node.hpp">include/rclcpp/node.hpp</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node_interfaces/node_base.hpp">include/rclcpp/node_interfaces/node_base.hpp</a></p>

    <ul>
      <li>Extended arguments of create_callback_group function for the real-time class.</li>
      <li>Removed the get_associated_with_executor_atomic function.</li>
    </ul>
  </li>
</ul>

<p>The callback-group-level executor has been merged into ROS 2 rclcpp in <a href="https://github.com/ros2/rclcpp/pull/1218/commits">pull request 1218</a>.</p>

<h3 id="test-bench">Test Bench</h3>

<p>As a proof of concept, we implemented a small test bench in the present package cbg-executor_ping-pong_cpp. The test bench comprises a Ping node and a Pong node which exchange real-time and best-effort messages simultaneously with each other. Each class of messages is handled with a dedicated Executor, as illustrated in the following Figure.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/ping_pong_diagram.png" alt="Architecture for the Callback-group-level Executor test bench" width="100%">
</center>

<p>With the test bench, we validated the functioning of the approach.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/cbg_executor_demo_plot.png" alt="Results from Callback-group-level Executor test bench" width="80%">
</center>

<p>In this example, the callback for the high priority task (red line) consumes 10ms and the low priority task (blue line) 40ms in the Pong Node. With a ping rate of 20 Hz, the CPU saturates (10ms*20+40ms*20=1000ms). With higher frequencies the high priorty task can continue to send its pong message, while the low priority pong task degrades. With a frequency of 100Hz the high priority task requires 100% CPU utilization. With higher ping rates it keeps sending pong messages with 100Hz, while the low priority task does not get any CPU ressources any more and cannot send any messages.</p>

<p>The test bench is provided in the <a href="https://github.com/ros2/examples/tree/master/rclcpp/executors/cbg_executor">cbg_executor_demo</a>.</p>

<h2 id="related-work">Related Work</h2>

<p>In this section, we provide an overview to related approaches and link to the corresponding APIs.</p>

<h3 id="fawkes-framework">Fawkes Framework</h3>

<p><a href="http://www.fawkesrobotics.org/">Fawkes</a> is a robotic software framework, which supports synchronization points for sense-plan-act like execution. It has been developed by RWTH Aachen since 2006. Source code is available at <a href="https://github.com/fawkesrobotics">github.com/fawkesrobotics</a>.</p>

<h4 id="synchronization">Synchronization</h4>
<p>Fawkes provides developers different synchronization points, which are very useful for defining an execution order of a typical sense-plan-act application. These ten synchronization points (wake-up hooks) are the following (cf. <a href="https://github.com/fawkesrobotics/fawkes/blob/master/src/libs/aspect/blocked_timing.h">libs/aspect/blocked_timing.h</a>):</p>

<ul>
  <li>WAKEUP_HOOK_PRE_LOOP</li>
  <li>WAKEUP_HOOK_SENSOR_ACQUIRE</li>
  <li>WAKEUP_HOOK_SENSOR_PREPARE</li>
  <li>WAKEUP_HOOK_SENSOR_PROCESS</li>
  <li>WAKEUP_HOOK_WORLDSTATE</li>
  <li>WAKEUP_HOOK_THINK</li>
  <li>WAKEUP_HOOK_SKILL</li>
  <li>WAKEUP_HOOK_ACT</li>
  <li>WAKEUP_HOOK_ACT_EXEC</li>
  <li>WAKEUP_HOOK_POST_LOOP</li>
</ul>

<h4 id="configuration-at-compile-time">Configuration at compile time</h4>
<p>At compile time, a desired synchronization point is defined as a constructor parameter for a module. For example, assuming that <code class="language-plaintext highlighter-rouge">mapLaserGenThread</code> shall be executed in SENSOR_ACQUIRE, the constructor is implemented as:</p>

<pre><code class="language-C++">MapLaserGenThread::MapLaserGenThread()
  :: Thread("MapLaserGenThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE),
     TransformAspect(TransformAspect::BOTH_DEFER_PUBLISHER, "Map Laser Odometry")

</code></pre>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">NaoQiButtonThread</code> shall be executed in the SENSOR_PROCESS hook, the constructor is:</p>

<pre><code class="language-C++">NaoQiButtonThread::NaoQiButtonThread()
  :: Thread("NaoQiButtonThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS)

</code></pre>

<h4 id="runtime-execution">Runtime execution</h4>
<p>At runtime, the <em>Executor</em> iterates through the list of synchronization points and executes all registered threads until completion. Then, the threads of the next synchronization point are called.</p>

<p>A module (thread) can be configured independent of these sense-plan-act synchronization points. This has the effect, that this thread is executed in parallel to this chain.</p>

<p>The high level overview of the Fawkes framework is shown in the next figure. At compile-time the configuration of the sense-plan act wakeup hook is done (upper part), while at run-time the scheduler iterates through this list of wakeup-hooks (lower part):</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/rolling/rclc/png/fawkes_executor_diagram.png" alt="Sequence diagram for Fawkes Executor" width="50%">
</center>

<p>Hence, at run-time, the hooks are executed as a fixed static schedule without preemption. Multiple threads registered in the same hook are executed in parallel.</p>

<p>Orthogonal to the sequential execution of sense-plan-act like applications, it is possible to define further constraints on the execution order by means of a <code class="language-plaintext highlighter-rouge">Barrier</code>. A barrier defines a number of threads, which need to have finished before the thread can start, which owns the barrier.</p>

<p>These concepts are implemented by the following main classes:</p>

<ul>
  <li>
<em>Wakeup hook</em> by <code class="language-plaintext highlighter-rouge">SyncPoint</code> and <code class="language-plaintext highlighter-rouge">SyncPointManager</code>, which manages a list of synchronization points.</li>
  <li>
<em>Executor</em> by the class <code class="language-plaintext highlighter-rouge">FawkesMainThread</code>, which is the scheduler, responsible for calling the user threads.</li>
  <li>
<code class="language-plaintext highlighter-rouge">ThreadManager</code>, which is derived from <code class="language-plaintext highlighter-rouge">BlockedTimingExecutor</code>, provides the necessary API to add and remove threads to wakeup hooks as well as for sequential execution of the wakeup-hooks.</li>
  <li>
<code class="language-plaintext highlighter-rouge">Barrier</code> is an object similar to <code class="language-plaintext highlighter-rouge">condition_variable</code> in C++.</li>
</ul>

<h4 id="discussion">Discussion</h4>

<p>All threads are executed with the same priority. If multiple sense-plan-act chains shall be executed with different priorities, e.g. to prefer execution of emergency-stop over normal operation, then this framework reaches its limits.</p>

<p>Also, different execution frequencies cannot be modeled by a single instance of this sense-plan-act chain. However, in robotics the fastest sensor will drive the chain and all other hooks are executed with the same frequency.</p>

<p>The option to execute threads independent of the predefined wakeup-hooks is very useful, e.g. for diagnostics. The concept of the Barrier is useful for satisfying functional dependencies which need to be considered in the execution order.</p>

<h2 id="references">References</h2>
<ul>
  <li>
    <p>[S2021]<a name="S2021"></a> J. Staschulat, Micro-ROS: The rclc Executor, in Workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at ROS World, Oct. 2021, [<a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">slides</a>] [<a href="https://www.youtube.com/embed/IazrPF3RN1U">Video</a>]</p>
  </li>
  <li>
    <p>[SLD2021]<a name="SLD2021"></a> J. Staschulat, R. Lange and D. N. Dasari, Budget-based real-time Executor for Micro-ROS, arXiv Pre-Print, May 2021. [<a href="https://arxiv.org/abs/2105.05590">paper</a>]</p>
  </li>
  <li>
    <p>[L2020]<a name="L2020"></a> Ralph Lange: Advanced Execution Management with ROS 2, ROS-Industrial Conference, Dec 2020 <a href="https://micro-ros.github.io/download/2020-12-16_Advanced_Execution_Management_with_ROS_2.pdf">[Slides]</a></p>
  </li>
  <li>
    <p>[SLL2020]<a name="SLL2020"></a> J. Staschulat, I. Ltkebohle and R. Lange, The rclc Executor: Domain-specific deterministic scheduling mechanisms for ROS applications on microcontrollers: work-in-progress, 2020 International Conference on Embedded Software (EMSOFT), Singapore, Singapore, 2020, pp. 18-19. <a href="https://ieeexplore.ieee.org/document/9244014">[Paper]</a> <a href="https://whova.com/embedded/session/eswe_202009/1145800/">[Video]</a></p>
  </li>
  <li>
    <p>[CB2019]<a name="CB2019"> </a> D. Casini, T. Bla, I. Ltkebohle, B. Brandenburg: Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling, in Euromicro-Conference on Real-Time Systems 2019. <a href="http://drops.dagstuhl.de/opus/volltexte/2019/10743/">[Paper]</a> <a href="https://t-blass.de/talks/ECRTS2019.pdf">[slides]</a></p>
  </li>
  <li>
    <p>[L2018]<a name="L2018"></a> Ralph Lange: Callback-group-level Executor for ROS 2. Lightning talk at ROSCon 2018. Madrid, Spain. Sep 2018. <a href="https://roscon.ros.org/2018/presentations/ROSCon2018_Lightning1_4.pdf">[Slides]</a> <a href="https://vimeo.com/292707644">[Video]</a></p>
  </li>
  <li>
    <p>[EK2018]<a name="EK2018"></a> R. Ernst, S. Kuntz, S. Quinton, M. Simons: The Logical Execution Time Paradigm: New Perspectives for Multicore Systems, February 25-28 2018 (Dagstuhl Seminar 18092). <a href="http://drops.dagstuhl.de/opus/volltexte/2018/9293/pdf/dagrep_v008_i002_p122_18092.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[NSP2018]<a name="NSP2018"></a> A. Naderlinger, S. Resmerita, and W. Pree: LET for Legacy and Model-based Applications,
Proceedings of The Logical Execution Time Paradigm: New Perspectives for Multicore Systems (Dagstuhl Seminar 18092), Wadern, Germany, February 2018.</p>
  </li>
  <li>
    <p>[BP2017]<a name="BP2017"></a> A. Biondi, P. Pazzaglia, A. Balsini,  M. D. Natale: Logical Execution Time Implementation and Memory Optimization Issues in AUTOSAR Applications for Multicores, International Worshop on Analysis Tools and Methodologies for Embedded and Real-Time Systems (WATERS2017), Dubrovnik, Croatia.<a href="https://pdfs.semanticscholar.org/4a9e/b9a616c25fd0b4a4f7810924e73eee0e7515.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[KZH2015]<a name="KZH2015"></a> S. Kramer, D. Ziegenbein, and A. Hamann: Real World Automotive Benchmarks For Free, International Workshop on Analysis Tools and Methodologies for Embedded adn Real-Time Sysems (WATERS), 2015.</p>
  </li>
  <li>
    <p>[HHK2001]<a name="HHK2001"></a> Henzinger T.A., Horowitz B., Kirsch C.M. (2001) Giotto: A Time-Triggered Language for Embedded Programming. In: Henzinger T.A., Kirsch C.M. (eds) Embedded Software. EMSOFT 2001. Lecture Notes in Computer Science, vol 2211. Springer, Berlin, Heidelberg</p>
  </li>
  <li>
    <p>[LL1973]<a name="LL1973"></a> Liu, C. L.; Layland, J.:Scheduling algorithms for multiprogramming in a hard real-time environment, Journal of the ACM, 20 (1): 4661, 1973.</p>
  </li>
</ul>
</div>
              </div>
            </div>
          </div>
        </div>
      
    
    <div class="row">
      <div class="col-xs-12">
        <div class="panel panel-default">
          <div class="panel-heading"><span class="glyphicon glyphicon-list"></span> CHANGELOG</div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="changelog-for-package-rclc">Changelog for package rclc</h1>

<h2 id="620-2024-10-15">6.2.0 (2024-10-15)</h2>

<ul>
  <li>added CI status for iron builds (#377)</li>
  <li>rclc_executor: improve enum type names (#379)</li>
  <li>fix rclc_example: memory leaking in msg.data allocation (backport
#386) (#387)</li>
  <li>updated ci versions (#396)</li>
  <li>updated ros-tooling versions (#407)</li>
</ul>

<h2 id="610-2023-06-15">6.1.0 (2023-06-15)</h2>

<ul>
  <li>Data structures interfaces for multi-threaded executor (#355)</li>
  <li>update ros-tooling versions (#361)</li>
  <li>updated actions/checkout version (#367)</li>
  <li>updated branch names to rolling (#370)</li>
</ul>

<h2 id="309-2023-03-22">3.0.9 (2023-03-22)</h2>

<ul>
  <li>Added build status of bloom-releases for Humble distribution (#291)</li>
  <li>[rolling] updated ros-tooling versions (#289)</li>
  <li>github action: updated os-version to ubuntu-22.04 (backport #295)
(#296)</li>
  <li>Added documentation (#301)</li>
  <li>Drop build dependency on std_msgs (#314)</li>
  <li>Updated &lt;ros-tooling/setup-ros@0.4.2&gt; and
&lt;ros-tooling/action-ros-ci@0.2.7&gt; (#318)</li>
  <li>Removed build status for Galactic in README (EOL November 2022)
(#321)</li>
  <li>Update documentation about number_of_handles (#326)</li>
  <li>executor.h: Fix a few docs typos (#338)</li>
</ul>

<h2 id="308-2022-04-14">3.0.8 (2022-04-14)</h2>

<ul>
  <li>Remove duplicate typedefs. (#249)</li>
  <li>Add rmw dependencies due to EventsExecutor PR in rcl (#255)</li>
  <li>Fix action client &amp; server deallocation (#257)</li>
  <li>updated documentation: build status for Rolling (#266)</li>
  <li>Update action client goal callback signature (#282)</li>
  <li>Upgrade parameters (#274)</li>
</ul>

<h2 id="307-2022-02-17">3.0.7 (2022-02-17)</h2>

<ul>
  <li>Fix enum naming for avoid collision (#242)</li>
  <li>Added dependency for package performance-test-fixture (#245)</li>
</ul>

<h2 id="306-2022-01-25">3.0.6 (2022-01-25)</h2>

<ul>
  <li>executor ignore canceled timers (#220)</li>
  <li>uddated documentation README.md (#229)</li>
  <li>resolved error in unit test see issue #230 (#231)</li>
  <li>Add thread dependency to examples (Rolling) (#237) (resolves in
this package only cpplint errors)</li>
</ul>

<h2 id="305-2021-11-23">3.0.5 (2021-11-23)</h2>

<ul>
  <li>Fix data_available reset for timer (backport #215) (#217)</li>
</ul>

<h2 id="304-2021-11-17">3.0.4 (2021-11-17)</h2>

<ul>
  <li>Ignoring unsuccessful SERVICE_TAKE (#175)</li>
  <li>Add rclc_parameter Quality Declaration (#144)</li>
  <li>use-ros2-testing (#185)</li>
  <li>Fix: printf in executor spin (#195)</li>
  <li>Fix init options handling (#202) (#205)</li>
  <li>Remove init options from support (#203)</li>
  <li>RCLC Actions Implementation (#170)</li>
  <li>Add rcl_action as build export dependency (#211)</li>
</ul>

<h2 id="303-2021-07-28">3.0.3 (2021-07-28)</h2>

<ul>
  <li>Checking for valid ROS context in spin_some</li>
  <li>Refactoring executor (removing callback_type)</li>
  <li>Fixing codecov config</li>
</ul>

<h2 id="302-2021-07-26">3.0.2 (2021-07-26)</h2>

<ul>
  <li>Updated codecov to ignore test folders</li>
  <li>Updated bloom release status table</li>
</ul>

<h2 id="301-2021-07-17">3.0.1 (2021-07-17)</h2>

<ul>
  <li>Added rclc_parameter package</li>
  <li>Added quality of service entity creation API</li>
  <li>Added executor prepare API</li>
  <li>Added support for removing subscription from executor</li>
  <li>Added support for subscription with context</li>
  <li>Added quality declaration statement</li>
  <li>Updated compatability function for sleep</li>
  <li>Removed duplicate NOTICE files</li>
</ul>

<h2 id="200-2021-04-23">2.0.0 (2021-04-23)</h2>

<ul>
  <li>Added codecov support</li>
  <li>New API of rcl_lifecycle in Rolling required major version bump</li>
</ul>

<h2 id="101-2021-03-29">1.0.1 (2021-03-29)</h2>

<ul>
  <li>Windows port</li>
  <li>Compatibility sleep function (Windows, POSIX-OS)</li>
  <li>Fixed RCL lifecycle API change for Rolling</li>
</ul>

<h2 id="100-2021-03-04">1.0.0 (2021-03-04)</h2>

<ul>
  <li>Service callbacks with context</li>
  <li>Fixed minor issues unit tests</li>
  <li>Upgraded setup_ros action (ci jobs)</li>
  <li>Removed Eloquent from ci jobs</li>
</ul>

<h2 id="017-2021-01-20">0.1.7 (2021-01-20)</h2>

<ul>
  <li>Corrected corrupted changelog</li>
</ul>

<h2 id="016-2021-01-20">0.1.6 (2021-01-20)</h2>

<ul>
  <li>Fixed issues due to Github Action timing delays on cloud build</li>
  <li>Fixed missing package dependency in Github Action for Eloquent</li>
</ul>

<h2 id="015-2020-12-11">0.1.5 (2020-12-11)</h2>

<ul>
  <li>Added support for services,clients and guard_conditions to rclc
executor</li>
  <li>Added table for bloom release status in README file</li>
</ul>

<h2 id="014-2020-11-25">0.1.4 (2020-11-25)</h2>

<ul>
  <li>Fixed error in bloom release</li>
</ul>

<h2 id="013-2020-11-23">0.1.3 (2020-11-23)</h2>

<ul>
  <li>Added rclc_lifecycle package</li>
  <li>Change maintainer information</li>
  <li>Minor fixes, updated unit tests</li>
</ul>

<h2 id="012-2020-05-19">0.1.2 (2020-05-19)</h2>

<ul>
  <li>Fixed compiler errors for bloom release</li>
</ul>

<h2 id="011-2020-05-14">0.1.1 (2020-05-14)</h2>

<ul>
  <li>Initial release</li>
</ul>
</div>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="rolling-tutorials">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Wiki Tutorials</h3>
      </div>
      <div class="panel-body">
        
        <em>This package does not provide any links to tutorials in it's <a href="https://index.ros.org/contribute/metadata/">rosindex metadata</a>.</em>
        <em>You can check on the <a href="http://wiki.ros.org/rclc/Tutorials" target="_blank">ROS Wiki Tutorials</a> page for the package.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="rolling-deps">
    <div class="row">
      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Package Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th class="text-center">Deps</th>
                  <th style="width: 100%">Name</th>
                </thead>
                <tbody>
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl#rolling">rcl  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl_action#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl_action#rolling">rcl_action  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcutils#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcutils#rolling">rcutils  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_generator_c#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_generator_c#rolling">rosidl_generator_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_typesupport_c#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_typesupport_c#rolling">rosidl_typesupport_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_ros#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_ros#rolling">ament_cmake_ros  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_gtest#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_gtest#rolling">ament_cmake_gtest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_pytest#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_pytest#rolling">ament_cmake_pytest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_auto#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_auto#rolling">ament_lint_auto  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_common#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_common#rolling">ament_lint_common  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/launch_testing#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/launch_testing#rolling">launch_testing  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/osrf_testing_tools_cpp#rolling-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/osrf_testing_tools_cpp#rolling">osrf_testing_tools_cpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/std_msgs#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/std_msgs#rolling">std_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/test_msgs#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/test_msgs#rolling">test_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/example_interfaces#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/example_interfaces#rolling">example_interfaces  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp#rolling">rclcpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp_action#rolling-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp_action#rolling">rclcpp_action  </a></td>
                      </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
          <div class="panel-heading">
            <h3 class="panel-title">System Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <em>No direct system dependencies.</em>
            
          </div>
        </div>
      </div>

      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Dependant Packages</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th>Name</th>
                  <th class="text-center">Deps</th>
                </thead>
                <tbody>
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_common_diagnostics#rolling">micro_ros_common_diagnostics</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_common_diagnostics#rolling-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_diagnostic_updater#rolling">micro_ros_diagnostic_updater</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_diagnostic_updater#rolling-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_examples#rolling">rclc_examples</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_examples#rolling-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_lifecycle#rolling">rclc_lifecycle</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_lifecycle#rolling-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_parameter#rolling">rclc_parameter</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_parameter#rolling-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="rolling-assets">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Launch files</h3>
      </div>
      <div class="panel-body">
        
          <em>No launch files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Messages</h3>
      </div>
      <div class="panel-body">
        
          <em>No message files found.</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Services</h3>
      </div>
      <div class="panel-body">
        
          <em>No service files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Plugins</h3>
      </div>
      <div class="panel-body">
        
          <em>No plugins found.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="rolling-questions">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Recent questions tagged <kbd>rclc</kbd> at <strong><a href="https://robotics.stackexchange.com/" target="_blank">Robotics Stack Exchange</a></strong></h3>      </div>
      <div id="rolling-question-list" class="panel-body" style="display: none;"></div>
      <div id="rolling-no-question-list" class="panel-body" style="display: none;">
        <p>No questions yet, you can ask one <a href="https://robotics.stackexchange.com/questions/tagged/rclc+rolling">here</a>.</p>
      </div>
      <div id="rolling-get-question-fail" class="panel-body alert alert-warning" style="display: none;">
        <p>Failed to get question list, you can ticket an issue <a href="https://github.com/ros-infrastructure/rosindex/issues/new" target="_blank" class="alert-link">here</a> </p>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript" src="/js/package_body_tabs.js"></script>

<script src=/js/contribution_suggestions.js></script>
<script type="text/javascript">
jQuery(function() {
    // Update the count on the links to the contribution suggestions
    updateContributionSuggestionsCountOnPackage('https://github.com/ros2/rclc.git');
});
</script>

          </div>
          <div class="col-md-2 hidden-xs hidden-sm">
            
            
            



<div class="list-group list-group-sm ">
  <a class="list-group-item"
     target="_blank"
     href="http://docs.ros.org/en/rolling/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       
       API Docs
  </a>
  <a class="list-group-item"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/rolling/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       
       Browse Code
  </a>
  
  
  
  
  
  
</div>

          </div>
        </div>
      
    </div>
  </div>

  <div class="distro distro-github">
    <div class="container-fluid">
      
        
        
        

        <div class="row">
          <div class="col-md-10">
            

<div class="well well-sm">
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px" src="/assets/package.png">
      </td>
      <td>
        <h3 style="margin-top: 5px">
          <a style="text-decoration:none" href="/p/rclc">rclc</a> <small>package from <a style="text-decoration:none" href="/r/intravisor/github-lsds-intravisor">intravisor</a> repo</small>
        </h3>
          
            
            
              <a class="label label-primary pkg-label" href="/p/actionlib_msgs">

actionlib_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/common_interfaces">

common_interfaces
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/diagnostic_msgs">

diagnostic_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/geometry_msgs">

geometry_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/nav_msgs">

nav_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/sensor_msgs">

sensor_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/sensor_msgs_py">

sensor_msgs_py
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/shape_msgs">

shape_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/std_msgs">

std_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/std_srvs">

std_srvs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/stereo_msgs">

stereo_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/trajectory_msgs">

trajectory_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/visualization_msgs">

visualization_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/complex_msgs">

complex_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/micro_ros_demos_rclc">

micro_ros_demos_rclc
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rcl">

rcl
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rcl_action">

rcl_action
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rcl_lifecycle">

rcl_lifecycle
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rcl_yaml_param_parser">

rcl_yaml_param_parser
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/action_msgs">

action_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/builtin_interfaces">

builtin_interfaces
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/composition_interfaces">

composition_interfaces
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/lifecycle_msgs">

lifecycle_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rcl_interfaces">

rcl_interfaces
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosgraph_msgs">

rosgraph_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/statistics_msgs">

statistics_msgs
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/test_msgs">

test_msgs
</a>
            
          
            
            
              <span class="label label-default pkg-label">

rclc
</span>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_examples">

rclc_examples
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_lifecycle">

rclc_lifecycle
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_parameter">

rclc_parameter
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rcutils">

rcutils
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rmw">

rmw
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rmw_implementation_cmake">

rmw_implementation_cmake
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rmw_microxrcedds">

rmw_microxrcedds
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_adapter">

rosidl_adapter
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_cli">

rosidl_cli
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_cmake">

rosidl_cmake
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_generator_c">

rosidl_generator_c
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_generator_cpp">

rosidl_generator_cpp
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_generator_tests">

rosidl_generator_tests
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_parser">

rosidl_parser
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_pycommon">

rosidl_pycommon
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_runtime_c">

rosidl_runtime_c
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_runtime_cpp">

rosidl_runtime_cpp
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_typesupport_interface">

rosidl_typesupport_interface
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_typesupport_introspection_c">

rosidl_typesupport_introspection_c
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_typesupport_introspection_cpp">

rosidl_typesupport_introspection_cpp
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_typesupport_introspection_tests">

rosidl_typesupport_introspection_tests
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_typesupport_microxrcedds_c">

rosidl_typesupport_microxrcedds_c
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_typesupport_microxrcedds_cpp">

rosidl_typesupport_microxrcedds_cpp
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_typesupport_microxrcedds_c_tests">

rosidl_typesupport_microxrcedds_c_tests
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_typesupport_microxrcedds_cpp_tests">

rosidl_typesupport_microxrcedds_cpp_tests
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rosidl_typesupport_microxrcedds_test_msg">

rosidl_typesupport_microxrcedds_test_msg
</a>
            
          
      </td>
    </tr>
  </table>
</div>

            <div class="visible-xs visible-sm">
              
              
              



<div class="list-group list-group-sm list-group-horizontal list-group-justified">
  <a class="list-group-item text-center"
     target="_blank"
     href="http://docs.ros.org/en/github/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       <br>
       API Docs
  </a>
  <a class="list-group-item text-center"
     target="_blank"
     href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       <br>
       Browse Code
  </a>
  
  
  
  
  
  
</div>

            </div>
            



<ul class="nav nav-tabs nav-justified" id="github-tabs" style="margin-bottom:20px">
  <li class="better-tabs active">
    <a href="#github-overview" data-toggle="tab">Overview</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    
    <a href="#github-assets" data-toggle="tab"><span class="label label-default">0</span> Assets</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    <a href="#github-deps" data-toggle="tab"><span class="label label-primary">17</span> Dependencies</a>
  </li>
  <li class="better-tabs">
    
    <a href="#github-tutorials" data-toggle="tab"><span class="label label-default">0</span> Tutorials</a>
  </li>
  <li class="better-tabs">
    <a href="#github-questions" data-toggle="tab"><span id="github-questions-count" class="label label-primary">0</span> Q & A</a>
  </li>
</ul>

<div class="tab-content">
  <div class="tab-pane active" id="github-overview">
    
    <div class="row">
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h4 class="panel-title">Package Summary</h4></div>
          <div class="panel-body">
            <table class="table table-condensed">
              <tr>
                <td style="width:100px;" class="text-right"><strong>Tags</strong></td>
                <td>
                  
                  
                    <em>No category tags.</em>
                  
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Version</strong></td>
                <td>3.0.8</td>
              </tr>
              <tr>
                <td class="text-right"><strong>License</strong></td>
                <td>Apache License 2.0</td>
              </tr>
              <tr>
                <td class="text-right"><strong>Build type</strong></td>
                <td>
                  
                    <span class="label label-default">
                  
                    AMENT_CMAKE</span>
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Use</strong></td>
                <td>
                
                  <span class="label label-success">RECOMMENDED</span>
                
                </td>
              </tr>
            </table>
          </div>
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body">
            
            
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">Virtualisation platform using CHERI for isolation and sharing</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/lsds/intravisor.git">https://github.com/lsds/intravisor.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">main</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2024-06-05
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          <span class="label label-warning">UNKNOWN
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="No CI information available for this package.">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-default">UNRELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <em>No category tags.</em>
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/intravisor/#github-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/intravisor/#github-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/intravisor/#github-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
      </div>
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Package Description</h3></div>
          <div class="panel-body">
            The ROS client library in C.
          </div>
          <div class="panel-heading"><h4 class="panel-title">Additional Links</h4></div>
          <div class="panel-body">
            
            
              <em>No additional links.</em>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Maintainers</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>Pablo Garrido</li>
                
              </ul>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Authors</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>William Woodall</li>
                
              </ul>
            
          </div>
        </div>
      </div>
    </div>
    
      
        <div class="row">
          <div class="col-xs-12">
            <div class="panel panel-default">
              <div class="panel-heading"><span class="glyphicon glyphicon-file"></span><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/README.md" title="Open in git repository">runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/README.md</a></div>
              <div class="panel-body">
                    <div class="rendered-markdown">
<h1 id="the-rclc-package">The rclc package</h1>

<h2 id="table-of-contents">Table of contents</h2>

<ul>
  <li>
    <p><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#introduction">Introduction</a></p>
  </li>
  <li>
<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</a>
    <ul>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#architecture">Architecture</a></li>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#scheduling-semantics">Scheduling Semantics</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>
    <ul>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</a></li>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#synchronization-of-multiple-rates">Synchronization of multiple rates</a></li>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#high-priority-processing-path">High-priority processing path</a></li>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#real-time-embedded-applications">Real-time embedded applications</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#rclc-executor">rclc Executor</a>
    <ul>
      <li>
<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#features">Features</a>
        <ul>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#trigger-condition">Trigger condition</a></li>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#sequential-execution">Sequential execution</a></li>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#let-semantics">LET-Semantics</a></li>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#executor-api">Executor API</a>
        <ul>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#configuration-phase">Configuration phase</a></li>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#running-phase">Running phase</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#examples">Examples</a>
        <ul>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</a></li>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#synchronization-of-multiple-rates-example">Synchronization of multiple rates example</a></li>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#high-priority-processing-path-example">High-priority processing path example</a></li>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#real-time-embedded-applications-example">Real-time embedded applications example</a></li>
          <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#future-work">Future work</a></li>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#download">Download</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#callback-group-level-executor">Callback-group-level Executor</a>
    <ul>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#api-changes">API Changes</a></li>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#test-bench">Test Bench</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#related-work">Related Work</a>
    <ul>
      <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#fawkes-framework">Fawkes Framework</a></li>
    </ul>
  </li>
  <li><a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#references">References</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Predictable execution under given real-time constraints is a crucial requirement for many robotic applications. While the service-based paradigm of ROS allows a fast integration of many different functionalities, it does not provide sufficient control over the execution management. For example, there are no mechanisms to enforce a certain execution order of callbacks within a node. Also the execution order of multiple nodes is essential for control applications in mobile robotics. Cause-effect-chains comprising of sensor acquisition, evaluation of data and actuation control should be mapped to ROS nodes executed in this order, however there are no explicit mechanisms to enforce it. Furthermore, when data recordings collected in field tests as ROS-bags are re-played, then the results are often surprisingly different due to non-determinism of process scheduling.</p>

<p>Manually setting up a particular execution order of subscriptions and publishing topics as well as defining use-case specific priorities of the corresponding Linux processes is always possible. However, this approach is error-prone, difficult to extend and requires an in-depth knowledge of the deployed ROS 2 packages in the system.</p>

<p>Therefore the goal of the Executor in micro-ROS is to support roboticists with practical and easy-to-use real-time mechanisms which provide solutions for:</p>
<ul>
  <li>Deterministic execution</li>
  <li>Real-time guarantees</li>
  <li>Integration of real-time and non real-time functionalities on one platform</li>
  <li>Specific support for RTOS and microcontrollers</li>
</ul>

<p>In ROS 1 a network thread is responsible for receiving all messages and putting them into a FIFO queue (in roscpp). That is, all callbacks were called in a FIFO manner, without any execution management. With the introduction of DDS (data distribution service) in ROS 2, the messages are buffered in DDS. In ROS 2, an Executor concept was introduced to support execution management. At the rcl-layer, a <em>wait-set</em> is configured with handles to be received and in a second step, the handles are taken from the DDS-queue. A handle is a generic term defined in rcl-layer for timers, subscriptions, services, clients and guard conditions.</p>

<p>The standard implementation of the ROS 2 Executor for the C++ API (rclcpp) has, however, certain unusual features, like precedence of timers over all other DDS handles, non-preemptive round-robin scheduling for non-timer handles and considering only one input data for each handle (even if multiple could be available). These features have the consequence, that in certain situations the standard rclcpp Executor is not deterministic and it makes guaranteeing real-time requirements very hard [<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#CB2019">CB2019</a>]. We have not looked at the ROS 2 Executor implementation for Python Frontend (rclpy) because we consider a micro-controllers platform, on which typically C or C++ appliations will run.</p>

<p>Given the goals for a Real-Time Executor and the limitations of the ROS 2 standard rclcpp Executor, the challenges are:</p>
<ul>
  <li>to develop an adequate and well-defined scheduling mechanisms for the ROS 2 framework and the real-time operating system (RTOS)</li>
  <li>to define an easy-to-use interface for ROS developers</li>
  <li>to model requirements (like latencies, determinism in subsystems)</li>
  <li>mapping of ROS 2 framework and operating system schedulers (semi-automated and optimized mapping is desired as well as generic, well-understood framework mechanisms)</li>
</ul>

<p>Our approach is to provide a real-time-capable Executor for the rcl+rclc layer (as described in section <a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/../">Introduction to Client Library</a>.) in the C programming language .</p>

<p>As the first step, we propose the rclc Executor for the rcl-layer in C programming language with several new features to support real-time and deterministic execution: It supports 1.) user-defined static sequential execution, 2) conditional execution semantics, 3) multi-threaded execution with scheduling configuration, and 4) logical execution semantics (LET). Sequential execution refers to the runtime behavior, that all callbacks are executed in a pre-defined order independent of the arrival time of messages. Conditional execution is available with a trigger condition which enables typical processing patterns in robotics (which are analyzed in detail in section <a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>. Configuration of scheduling parameters for multi-threaded application accomplishes prioritized execution. The logical execution time concept (LET) provides data synchronization for fixed periodic task scheduling of embedded applications.</p>

<p>Beyond the advanced execution management mechanisms for micro-ROS, we also contributed to improving and extending the Executor concept in rclcpp for standard ROS 2: the callback group-level Executor. It is not a new Executor but rather a refinement of the ROS 2 Executor API allowing to prioritize a group of callbacks which is not possible with the ROS 2 default Executor in its current Galactic release.</p>

<h2 id="analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</h2>

<p>ROS 2 allows to bundle multiple nodes in one operating system process. To coordinate the execution of the callbacks of the nodes of a process, the Executor concept was introduced in rclcpp (and also in rclpy).</p>

<p>The ROS 2 design defines one Executor (instance of <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">rclcpp::executor::Executor</a>) per process, which is typically created either in a custom main function or by the launch system. The Executor coordinates the execution of all callbacks issued by these nodes by checking for available work (timers, services, messages, subscriptions, etc.) from the DDS queue and dispatching it to one or more threads, implemented in <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/single_threaded_executor.hpp">SingleThreadedExecutor</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp">MultiThreadedExecutor</a>, respectively.</p>

<p>The dispatching mechanism resembles the ROS 1 spin thread behavior: the Executor looks up the wait sets, which notifies it of any pending callback in the DDS queue. If there are multiple pending callbacks, the ROS 2 Executor executes them in an in the order as they were registered at the Executor.</p>

<h3 id="architecture">Architecture</h3>

<p>The following diagram depicts the relevant classes of the standard ROS 2 Executor implementation:</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/executor_class_diagram.png" alt="ROS 2 Executor class diagram" width="100%">
</center>

<p>Note that an Executor instance maintains weak pointers to the NodeBaseInterfaces of the nodes only. Therefore, nodes can be destroyed safely, without notifying the Executor.</p>

<p>Also, the Executor does not maintain an explicit callback queue, but relies on the queue mechanism of the underlying DDS implementation as illustrated in the following sequence diagram:</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/executor_to_dds_sequence_diagram.png" alt="Call sequence from executor to DDS" width="100%">
</center>

<p>The Executor concept, however, does not provide means for prioritization or categorization of the incoming callback calls. Moreover, it does not leverage the real-time characteristics of the underlying operating-system scheduler to have finer control on the order of executions. The overall implication of this behavior is that time-critical callbacks could suffer possible deadline misses and a degraded performance since they are serviced later than non-critical callbacks. Additionally, due to the FIFO mechanism, it is difficult to determine usable bounds on the worst-case latency that each callback execution may incur.</p>

<h3 id="scheduling-semantics">Scheduling Semantics</h3>

<p>In a recent paper [<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#CB2019">CB2019</a>], the rclcpp Executor has been analyzed in detail and a response time analysis of cause-effect chains has been proposed under reservation-based scheduling. The Executor distinguishes four categories of callbacks: <em>timers</em>, which are triggered by system-level timers, <em>subscribers</em>, which are triggered by new messages on a subscribed topic, <em>services</em>, which are triggered by service requests, and <em>clients</em>, which are triggered by responses to service requests. The Executor is responsible for taking messages from the input queues of the DDS layer and executing the corresponding callback. Since it executes callbacks to completion, it is a non-preemptive scheduler, However it does not consider all ready tasks for execution, but only a snapshot, called readySet. This readySet is updated when the Executor is idle and in this step it interacts with the DDS layer updating the set of ready tasks. Then for every type of task, there are dedicated queues (timers, subscriptions, services, clients) which are processed sequentially. The following undesired properties were pointed out:</p>

<ul>
  <li>Timers have the highest priority. The Executor processes <em>timers</em> always first.  This can lead to the intrinsic effect, that in overload situations messages from the DDS queue are not processed.</li>
  <li>Non-preemptive round-robin scheduling of non-timer handles. Messages arriving during the processing of the readySet are not considered until the next update, which depends on the execution time of all remaining callbacks. This leads to priority inversion, as lower-priority callbacks may implicitly block higher-priority callbacks by prolonging the current processing of the readySet.</li>
  <li>Only one message per handle is considered. The readySet contains only one task instance, For example, even if multiple messages of the same topic are available, only one instance is processed until the Executor is idle again and the readySet is updated from the DDS layer. This aggravates priority inversion, as a backlogged callback might have to wait for multiple processing of readySets until it is considered for scheduling. This means that non-timer callback instances might be blocked by multiple instances of the same lower-priority callback.</li>
</ul>

<p>Due to these findings, the authors present an alternative approach to provide determinism and to apply well-known schedulability analyses to a ROS 2 systems. A response time analysis is described under reservation-based scheduling.</p>

<h2 id="analysis-of-processing-patterns">Analysis of processing patterns</h2>
<p>The development of an execution management mechanism for micro-ROS is based on an analysis of processing patterns commonly used in robotics and embedded systems. First, typical processing patterns in mobile robotics are presented which are used to implement deterministic behavior. Then, the processing patterns in the real-time embedded systems are analyzed, in which, as a main difference, the time-triggered paradigm is applied to accomplish real-time behavior.</p>

<h3 id="sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</h3>
<p>Now we describe common software design patterns which are used in mobile robotics to achieve deterministic behavior. For each design pattern we describe the concept and the derived requirements for a deterministic Executor.</p>

<p><strong>Concept:</strong></p>

<p>A common design paradigm in mobile robotics is a control loop, consisting of several phases: A sensing phase to aquire sensor data, a plan phase for localization and path planning and an actuation-phase to steer the mobile robot. Of course, more phases are possible, here these three phases shall serve as an example. Such a processing pipeline is shown in Figure 1.</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/sensePlanActScheme.png" alt="Sense Plan Act Pipeline" width="60%">
</center>
<center>
Figure 1: Multiple sensors driving a Sense-Plan-Act pipeline.
</center>

<p>Typically multiple sensors are used to perceive the environment. For example an IMU and a laser scanner. The quality of localization algorithms highly depend on how old such sensor data is when it is processed. Ideally the latest data of all sensors should be processed. One way to achive this is to execute first all sensor drivers in the sense-phase and then process all algorithms in the plan-phase.</p>

<p>Currently, such a processing order cannot be defined with the default Executor of rclcpp. One could in principle design a data-driven pipeline, however if e.g. the Laser scan is needed by some other callback in the sense-phase as well as in the plan-phase, the processing order of these subscribers is arbitrary.</p>

<p>For this sense-plan-act pattern, we could define one executor for each phase. The plan-phase would be triggered only when all callbacks in the sense-phase have finished.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
</ul>

<h3 id="synchronization-of-multiple-rates">Synchronization of multiple rates</h3>

<p><strong>Concept:</strong></p>

<p>Often multiple sensors are being used to sense the environment for mobile robotics. While an IMU sensor provides data samples at a very high rate (e.g., 500 Hz), laser scans are availabe at a much slower frequency (e.g. 10Hz) determined by the revolution time. Then the challenge is, how to deterministically fuse sensor data with different frequencies. This problem is depicted in Figure 2.</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/sensorFusion_01.png" alt="Sychronization of multiple rates" width="30%">
</center>
<center>
Figure 2: How to deterministically process multi-frequent sensor data.
</center>

<p>Due to scheduling effects, the callback for evaluating the laser scan might be called just before or just after an IMU data is received. One way to tackle this is to write additional synchronization code inside the application. Obviously, this is a cumbersome and not-portable solution.</p>

<p>An Alternative would be to evalute the IMU sample and the laser scan by synchronizing their frequency. For example by processing always 50 IMU samples with one laser scan. This approach is shown in Figure 3. A pre-processing callback aggregates the IMU samples and sends an aggregated message with 50 samples at 10Hz rate. Now both messages have the same frequency. With a trigger condition, which fires when both messages are available, the sensor fusion algorithm can expect always synchronized input data.</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/sensorFusion_02.png" alt="Sychnronization with a trigger" width="40%">
</center>
<center>
Figure 3: Synchronization of multiple input data with a trigger.
</center>

<p>In ROS 2, this is currently not possible to be modeled because of the lack of a trigger concept in the Executors of rclcpp and rclpy. Message filters could be used to synchronize input data based on the timestamp in the header, but this is only available in rclcpp (and not in rcl). Further more, it would be more efficient to have such a trigger concept directly in the Executor.</p>

<p>Another idea would be to activly request for IMU data only when a laser scan is received. This concept is shown in Figure 4. Upon arrival of a laser scan mesage, first, a message with aggregated IMU samples is requested. Then, the laser scan is processed and later the sensor fusion algorithm. An Executor, which would support sequential execution of callbacks, could realize this idea.</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/sensorFusion_03.png" alt="Sychronization with sequence" width="30%">
</center>
<center>
Figure 4: Synchronization with sequential processing.
</center>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
  <li>sequential procesing of callbacks</li>
</ul>

<h3 id="high-priority-processing-path">High-priority processing path</h3>
<p><strong>Concept</strong>
Often a robot has to fullfill several activities at the same time. For example following a path and avoiding obstacles. While path following is a permanent activity, obstacle avoidance is trigged by the environment and should be immediately reacted upon. Therefore one would like to specify priorities to activities. This is depicted in Figure 5:</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/highPriorityPath.png" alt="HighPriorityPath" width="50%">
</center>
<center>
Figure 5: Managing high priority path with sequential order.
</center>

<p>Assuming a simplified control loop with the activities sense-plan-act, the obstacle avoidance, which might temporarily stop the robot, should be processed before the planning phase. In this example we assume that these activites are processed in one thread.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>sequential processing of callbacks</li>
</ul>

<h3 id="real-time-embedded-applications">Real-time embedded applications</h3>
<p>In embedded systems, real-time behavior is approached by using the time-triggered paradigm, which means that the processes are periodically activated. Processes can be assigned priorities to allow pre-emptions. Figure 6 shows an example, in which three processes with fixed periods are shown. The middle and lower process are preempted multiple times depicted with empty dashed boxes.</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/scheduling_01.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 6: Fixed periodic preemptive scheduling.
</center>

<p>To each process one or multiple tasks can be assigned, as shown in Figure 7. These tasks are executed sequentially, which is often called cooperative scheduling.</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/scheduling_02.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 7: Processes with sequentially executed tasks.
</center>

<p>While there are different ways to assign priorities to a given number of processes,
the rate-monotonic scheduling assignment, in which processes with a shorter period have a higher priority, has been shown optimal if the processor utilization is less than 69% [<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#LL1973">LL1973</a>].</p>

<p>In the last decades many different scheduling approaches have been presented, however fixed-periodic preemptive scheduling is still widely used in embedded real-time systems [<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#KZH2015">KZH2015</a>]. This becomes also obvious, when looking at the features of current operating systems. Like Linux, real-time operating systems, such as NuttX, Zephyr, FreeRTOS, QNX etc., support fixed-periodic preemptive scheduling and the assignment of priorities, which makes the time-triggered paradigm the dominant design principle in this domain.</p>

<p>However, data consistency is often an issue when preemptive scheduling is used and if data is being shared across multiple processes via global variables. Due to scheduling effects and varying execution times of processes, writing and reading these variables could occur sometimes sooner or later. This results in an latency jitter of update times (the timepoint at which a variable change becomes visible to other processes). Race conditions can occur when multiple processes access a variable at the same time. So solve this problem, the concept of logical-execution time (LET) was introduced in [<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#HHK2001">HHK2001</a>], in which communication of data occurs only at pre-defined periodic time instances: Reading data only at the beginning of the period and writing data only at the end of the period. The cost of an additional latency delay is traded for data consistency and reduced jitter. This concept has also recently been applied to automotive applications[<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#NSP2018">NSP2018</a>].</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/scheduling_LET.png" alt="Schedule with fixed periods" width="80%">
</center>
<center>
Figure 8: Data communication without and with Logical Execution Time paradigm.
</center>

<p>An Example of the LET concept is shown in Figure 8. Assume that two processes are communicating data via one global variable. The timepoint when this data is written is at the end of the processing time. In the default case (left side), the process p<sub>3</sub> and p<sub>4</sub> receive the update. At the right side of Figure 8, the same scenario is shown with LET semantics. Here, the data is communicated only at period boundaries. In this case, the lower process communicates at the end of the period, so that always process p<sub>3</sub> and p<sub>5</sub> receive the new data.</p>

<p><strong>Concept:</strong></p>
<ul>
  <li>periodic execution of processes</li>
  <li>assignment of fixed priorities to processes</li>
  <li>preemptive scheduling of processes</li>
  <li>co-operative scheduling of tasks within a process (sequential execution)</li>
  <li>data synchronization with LET-semantics</li>
</ul>

<p>While periodic activation is possible in ROS 2 by using timers, preemptive scheduling is supported by the operating system and assigning priorities on the granularity of threads/processes that correspond to the ROS nodes; it is not possible to sequentially execute callbacks, which have no data-dependency. Furthermore data is read from the DDS queue just before the callback is executed and data is written sometime during the time the application is executed. While the <code class="language-plaintext highlighter-rouge">spin_period</code> function of the rclcpp Executor allows to check for data at a fixed period and executing those callbacks for which data is available, however, with this spin-function does not execute all callbacks irrespective wheter data is available or not. So <code class="language-plaintext highlighter-rouge">spin_period</code> is not helpful to periodically execute a number of callbacks (aka tasks within a process). So we need a mechanism that triggers the execution of multiple callbacks (aka tasks) based on a timer. Data transmission is achieved via DDS which does not allow to implement a LET-semantics. To summarize, we derive the following requirements.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>trigger the execution</li>
  <li>sequential processing of callbacks</li>
  <li>data synchronization with LET semantics</li>
</ul>

<h2 id="rclc-executor">rclc Executor</h2>

<p>The rclc Executor is a ROS 2 Executor based on the rcl-layer in C programming language. As discussed above, the default rclcpp Executor is not suitable to implement real-time applications because of three main reasons: timers are preferred over all other handles, no priorization of callback execution and the round-robin to completion execution of callbacks. On the other hand, several processing patterns have been developed as best practices to achieve non-functional requirements, such as bounded end-to-end latencies, low jitter of response times of cause-effect chains, deterministic processing and short response times even in overload situations. These processing patterns are difficult to implement with the concepts availabe in the default ROS 2 Executor, therefore we have developed a flexible Executor: the rclc Executor.</p>

<h3 id="features">Features</h3>

<p>The rclc Executor is feature-complete, i.e. it supports all event types as the default ROS 2 Executor, which are:</p>
<ul>
  <li>subscriptions</li>
  <li>timers</li>
  <li>services</li>
  <li>clients</li>
  <li>guard conditions</li>
  <li>actions</li>
  <li>lifecycle</li>
</ul>

<p>The flexible rclc Executor provides on top the following new features:</p>
<ul>
  <li>triggered execution</li>
  <li>user-defined sequential execution</li>
  <li>multi-threading and scheduling configuration (WIP)</li>
  <li>LET-semantics for data synchronization of periodic process scheduling</li>
</ul>

<p>First, a <em>trigger condition</em> allows to define when the processing of a callback shall start. This is useful to implement sense-plan-act control loops or more complex processing structures with directed acyclic graphs. Second, a user can specify the <em>processing order</em> in which these callbacks will be executed. With this feature, the pattern of sensor fusion with multiple rates, in which data is requested from a sensor based on the arrival of some other sensor, can be easily implemented. Third, the assignment of scheduling parameters (e.g., priorities) of the underlying operating system. With this feature, prioritized processing can be implemented. Finally, for periodic applications, the <em>LET Semantics</em> has been implemented to support data consistency for periodic process scheduling. These features are now described in more detail.</p>

<h4 id="sequential-execution">Sequential execution</h4>

<ul>
  <li>At configuration, the user defines the order of handles.</li>
  <li>At configuration, the user defines whether the handle shall be called only when new data is available (ON_NEW_DATA) or whether the callback shall always be called (ALWAYS).</li>
  <li>At runtime, all handles are processed in the user-defined order
    <ul>
      <li>if the configuration of handle is ON_NEW_DATA, then the corresponding callback is only called if new data is available</li>
      <li>if the configuration of the handle is ALWAYS, then the corresponding callback is always. If no data is available, then the callback is called with no data (e.g. NULL pointer).</li>
    </ul>
  </li>
</ul>

<p>Figure 9 shows three callbacks, A, B and C. Assume, they shall be executed in the order <em>B,A,C</em>. Then the user adds the callbacks to the rclc Executor in this order. Whenever new messages have arrived then the callbacks for which a new message is availabe will be always executed in the user-defined processing order.</p>
<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/rclc_executor_sequential_execution.png" alt="Sequential execution semantics" width="50%">
</center>
<center>
Figure 9: Sequential execution semantics.
</center>

<h4 id="trigger-condition">Trigger condition</h4>

<ul>
  <li>Given a set of handles, a trigger condition, which is based on the availability of input data of these handles, decides when the processing of all callbacks starts. This is shown in Figure 10.</li>
</ul>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/trigger_01.png" alt="Trigger condition overview" width="50%">
</center>
<center>
Figure 10: Executor with trigger condition
</center>

<ul>
  <li>Available options:
    <ul>
      <li>ALL operation: fires when input data is available for all handles</li>
      <li>ANY operation: fires when input data is available for at least one handle (OR semantics)</li>
      <li>ONE: fires when input data for a user-specified handle is available</li>
      <li>User-defined function: user can implement custom logic</li>
    </ul>
  </li>
</ul>

<p>Figure 11 shows an example of the ALL semantics. Only if all messages <em>msg_A, msg_B, msg_C</em> were received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/trigger_ALL.png" alt="Trigger condition ALL" width="30%">
</center>
<center>
Figure 11: Trigger condition ALL
</center>

<p>Figure 12 shows an example of the ANY semantics. Thas is, if any messages <em>msg_A, msg_B, msg_C</em> was received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order. This is equivalent to OR semantics.</p>
<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/trigger_OR.png" alt="Trigger condition ANY" width="30%">
</center>
<center>
Figure 12: Trigger condition ANY (OR)
</center>

<p>Figure 13 shows an example of the ONE semantics. Thas is, only if message <em>msg_B</em> was received, the trigger condition is fullfilled and (potentially all) callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/trigger_ONE.png" alt="Trigger condition ONE" width="30%">
</center>
<center>
Figure 13: Trigger condition ONE
</center>

<p>Figure 14 describes the custom semantics. A custom trigger condition with could be a more complex logic of multiple messages, can be passed to the executor. This might also include hardware triggers, like interrupts.</p>
<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/trigger_user_defined.png" alt="Trigger condition user-defined" width="30%">
</center>
<center>
Figure 14: Trigger condition user-defined
</center>

<h4 id="let-semantics">LET-Semantics</h4>
<ul>
  <li>Assumption: time-triggered system, the executor is activated periodically</li>
  <li>When the trigger fires, reads all input data and makes a local copy</li>
  <li>Processes all callbacks in sequential order</li>
  <li>Write output data at the end of the executors period (Note: this is not implemented yet)</li>
</ul>

<p>Additionally we have implemented the current rclcpp Executor semantics (RCLCPP):</p>
<ul>
  <li>waiting for new data for all handles (rcl_wait)</li>
  <li>using trigger condition ANY</li>
  <li>if trigger fires, start processing handles in pre-defined sequential order</li>
  <li>request from DDS-queue the new data just before the handle is executed (rcl_take)</li>
</ul>

<p>The selection of the Executor semantics is optional. The default semantics is RCLCPP.</p>

<h4 id="multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</h4>

<p>The rclc Executor has been extended for multi-threading. It supports the assignment of scheduling policies, like priorities or more advanced scheduling algorithms as reservation-based scheduling, to subscription callbacks. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, Pre-print <a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#SLD2021">SLD2021</a>]. The overall architecture is shown in Figure 15. One Executor thread is responsible for checking for new data from the DDS queue. For every callback, a thread is spawned with the dedicted scheduling policy provided by the operating system. The Executor then dispatches new data of a subscription to its corresponding callback function, which is then executed in its own thread by operating system.</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/rclc_executor_multi_threaded.png" alt="Multi-threaded rclc Executor" width="90%">
</center>
<center>
Figure 15: multi-threaded rclc-Executor
</center>

<h3 id="executor-api">Executor API</h3>
<p>The API of the rclc Executor can be divided in two phases: Configuration and Running.</p>
<h4 id="configuration-phase">Configuration phase</h4>
<p>During the configuration phase, the user shall define:</p>
<ul>
  <li>the total number of callbacks</li>
  <li>the sequence of the callbacks</li>
  <li>trigger condition (optional, default: ANY)</li>
  <li>data communcation semantics (optional, default ROS2)</li>
</ul>

<p>As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added.</p>

<p>Then, the user adds handles and the corresponding callbacks (e.g. for subscriptions and timers) to the Executor. The order in which this takes place, defines later the sequential processing order during runtime.</p>

<p>For each handle the user can specify, if the callback shall be executed only if new data is available (ON_NEW_DATA) or if the callback shall always be executed (ALWAYS). The second option is useful when the callback is expected to be called at a fixed rate.</p>

<p>The trigger condition defines when the processing of these callbacks shall start. For convenience some default conditions have been defined:</p>
<ul>
  <li>trigger_any(default) : start executing if any callback has new data</li>
  <li>trigger_all : start executing if all callbacks have new data</li>
  <li>trigger_one(&amp;<code class="language-plaintext highlighter-rouge">data</code>) : start executing if <code class="language-plaintext highlighter-rouge">data</code> has been received</li>
  <li>user_defined_function: the user can also define its own function with more complex logic</li>
</ul>

<p>With trigger_any being the default, the current semantics of the rclcpp Executor is selected.</p>

<p>The data communication semantics can be</p>
<ul>
  <li>ROS2 (default)</li>
  <li>LET</li>
</ul>

<p>To be compatible with ROS2 rclcpp Executor, the existing rclcpp semantics is implemented as ROS2. That is, with the spin-function the DDS-queue is constantly monitored for new data (rcl_wait). If new data becomes available, then is fetched from DDS (rcl_take) immediately before the callback is executed. All callbacks are processed in the user-defined order, this is the only difference to the rclcpp Executor, in which no order can be specified.</p>

<p>Secondly, the LET semantics is implemented such that at the beginning of processing all available data is fetched (rcl_take) and buffered and then the callbacks are processed in the pre-defined operating on the buffered copy.</p>

<h4 id="running-phase">Running phase</h4>

<p>As the main functionality, the Executor has a <code class="language-plaintext highlighter-rouge">spin</code>-function which constantly checks for new data at the DDS-queue, like the rclcpp Executor in ROS2. If the trigger condition is satisfied then all available data from the DDS queue is processed according to the specified semantics (ROS or LET) in the user-defined sequential order. After all callbacks have been processed the DDS is checked for new data again.</p>

<p>Available spin functions are</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">spin_some</code>  - spin one time</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin_period</code> - spin with a period</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin</code> - spin indefinitly</li>
</ul>

<h3 id="examples">Examples</h3>
<p>We provide the relevant code snippets how to setup the rclc Executor for the processing patterns as described above.</p>

<h4 id="sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</h4>

<p>In this example we want to realise a sense-plan-act pipeline in a single thread. The trigger condition is demonstrated by activating
the sense-phase when both data for the Laser and IMU are available. Three executors are necessary <code class="language-plaintext highlighter-rouge">exe_sense</code>, <code class="language-plaintext highlighter-rouge">exe_plan</code> and <code class="language-plaintext highlighter-rouge">exe_act</code>. The two sensor acquisition callbacks <code class="language-plaintext highlighter-rouge">sense_Laser</code> and <code class="language-plaintext highlighter-rouge">sense_IMU</code> are registered in the Executor <code class="language-plaintext highlighter-rouge">exe_sense</code>.
The trigger condition ALL is responsible to activate the sense-phase only when all data for these two callbacks are available. Finally all three Executors are spinning using a <code class="language-plaintext highlighter-rouge">while</code>-loop and the <code class="language-plaintext highlighter-rouge">spin_some</code> function.</p>

<p>The definitions of callbacks are omitted.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act;
rcle_let_executor_t exe_sense, exe_plan, exe_act;
// initialize executors
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
rclc_executor_init(&amp;exe_plan, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_act, &amp;context, 1, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb1, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_let_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);
// executor for plan-phase
rclc_executor_add_subscription(&amp;exe_plan, &amp;plan, &amp;my_sub_cb3, ON_NEW_DATA);
// executor for act-phase
rclc_executor_add_subscription(&amp;exe_act, &amp;act, &amp;my_sub_cb4, ON_NEW_DATA);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_sense);
  rclc_executor_spin_some(&amp;exe_plan);
  rclc_executor_spin_some(&amp;exe_act);
}

</code></pre>

<h4 id="synchronization-of-multiple-rates-example">Synchronization of multiple rates example</h4>

<p>The sensor fusion synchronizing the multiple rates with a trigger is shown below.</p>

<pre><code class="language-C">...
rcl_subscription_t aggr_IMU, sense_Laser, sense_IMU;
rcle_let_executor_t exe_aggr, exe_sense;
// initialize executors
rclc_executor_init(&amp;exe_aggr, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for aggregate IMU data
rclc_executor_add_subscription(&amp;exe_aggr, &amp;aggr_IMU, &amp;my_sub_cb1, ON_NEW_DATA);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb3, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_aggr);
  rclc_executor_spin_some(&amp;exe_sense);
}

</code></pre>

<p>The setup for the sensor fusion using sequential execution is shown below.
Note that the sequetial order is <code class="language-plaintext highlighter-rouge">sense_IMU</code>, which will request the aggregated IMU message, and then <code class="language-plaintext highlighter-rouge">sense_Laser</code>
while the trigger will fire, when a laser message is received.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU;
rcle_let_executor_t exe_sense;
// initialize executor
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe_sense);

</code></pre>
<h4 id="high-priority-processing-path-example">High priority processing path example</h4>

<p>This example shows the sequential processing order to execute the obstacle avoidance <code class="language-plaintext highlighter-rouge">obst_avoid</code>
after the callbacks of the sense-phase and before the callback of the planning phase <code class="language-plaintext highlighter-rouge">plan</code>.
The control loop is started when a laser message is received. Then an aggregated IMU message is requested,
like in the example above. Then all the other callbacks are always executed. This assumes that these callbacks
communicate via a global data structure. Race conditions cannot occur, because the callbacks
run all in one thread.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act, obst_avoid;
rcle_let_executor_t exe;
// initialize executors
rclc_executor_init(&amp;exe, &amp;context, 5, ...);
// define processing order
rclc_executor_add_subscription(&amp;exe, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe, &amp;obst_avoid, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;plan, &amp;my_sub_cb4, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;act, &amp;my_sub_cb5, ALWAYS);
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="real-time-embedded-applications-example">Real-time embedded applications example</h4>

<p>With seqential execution the co-operative scheduling of tasks within a process can be modeled. The trigger condition is used to periodically activate the process which will then execute all callbacks in a pre-defined order. Data will be communicated using the LET-semantics. Every Executor is executed in its own tread, to which an appropriate priority can be assigned.</p>

<p>In the following example, the Executor is setup with 4 handles. We assume a process has three subscriptions <code class="language-plaintext highlighter-rouge">sub1</code>, <code class="language-plaintext highlighter-rouge">sub2</code>, <code class="language-plaintext highlighter-rouge">sub3</code>. The sequential processing order is given by the order as they are added to the Executor. A timer <code class="language-plaintext highlighter-rouge">timer</code> defines the period.  The <code class="language-plaintext highlighter-rouge">trigger_one</code> with the paramter <code class="language-plaintext highlighter-rouge">timer</code> is used, so that whenever the timer is ready, all callbacks are processed. Finally the data communication semantics LET is defined.</p>

<pre><code class="language-C">#include "rcl_executor/let_executor.h"

// define subscription callback
void my_sub_cb1(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb2(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb3(const void * msgin)
{
  // ...
}

// define timer callback
void my_timer_cb(rcl_timer_t * timer, int64_t last_call_time)
{
  // ...
}

// necessary ROS 2 objects
rcl_context_t context;   
rcl_node_t node;
rcl_subscription_t sub1, sub2, sub3;
rcl_timer_t timer;
rcle_let_executor_t exe;

// define ROS context
context = rcl_get_zero_initialized_context();
// initialize ROS node
rcl_node_init(&amp;node, &amp;context,...);
// create subscriptions
rcl_subscription_init(&amp;sub1, &amp;node, ...);
rcl_subscription_init(&amp;sub2, &amp;node, ...);
rcl_subscription_init(&amp;sub3, &amp;node, ...);
// create a timer
rcl_timer_init(&amp;timer, &amp;my_timer_cb, ... );
// initialize executor with four handles
rclc_executor_init(&amp;exe, &amp;context, 4, ...);
// define static execution order of handles
rclc_executor_add_subscription(&amp;exe, &amp;sub1, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub2, &amp;my_sub_cb2, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub3, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_timer(&amp;exe, &amp;timer);
// trigger when handle 'timer' is ready
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;timer);
// select LET-semantics
rclc_executor_data_comm_semantics(&amp;exe, LET);
// spin forever
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</h4>
<p>The rclc Executor has been presented at the workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at <a href="https://roscon.ros.org/world/2021/">ROS World 2021</a> (i.e. the online version of ROSCon)[<a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#S2021">S2021</a>]. A <a href="https://github.com/ros-realtime/reference-system">Reference System</a> for testing and benchmarking ROS Executors has been developed for this workshop. The application of the rclc Executor on the reference system with the trigger condition can be found in the <a href="https://github.com/ros-realtime/reference-system/tree/rclc_executor">rclc-executor branch of the Reference System</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/IazrPF3RN1U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>The slides can be downloaded <a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">here</a>. All information and the videos and slides of the other talks of the workshop can be found at <a href="https://www.apex.ai/roscon-21">www.apex.ai/roscon-21</a>.</p>

<h3 id="future-work">Future work</h3>

<ul>
  <li>Full LET semantics (writing data at the end of the period)
    <ul>
      <li>one publisher that periodically publishes</li>
      <li>if Executors are running in multiple threads,
publishing needs to be atomic</li>
    </ul>
  </li>
  <li>Multi-threaded executor with assignment of scheduling policies of unerlying operating system. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, pre-print <a href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/#SLD2021">SLD2021</a>].</li>
</ul>

<h3 id="download">Download</h3>
<p>The rclc Executor can be downloaded from the <a href="https://github.com/ros2/rclc">ros2/rclc repository</a>. It is available for the ROS 2 versions Foxy, Galactic and Rolling. The repository provides several packages including the <a href="https://github.com/ros2/rclc/tree/master/rclc">rclc Executor</a> and an <a href="https://github.com/ros2/rclc/tree/master/rclc_examples">rclc_examples package</a> with several application examples.</p>

<h2 id="callback-group-level-executor">Callback-group-level Executor</h2>

<p>The Callback-group-level Executor was an early prototype for a refined rclcpp Executor API developed in micro-ROS. It has been derived from the default rclcpp Executor and addresses some of the aforementioned deficits. Most important, it was used to validate that the underlying layers (rcl, rmw, rmw_adapter, DDS) allow for multiple Executor instances without any negative interferences.</p>

<p>As the default rclcpp Executor works at a node-level granularity  which is a limitation given that a node may issue different callbacks needing different real-time guarantees - we decided to refine the API for more fine-grained control over the scheduling of callbacks on the granularity of callback groups using. We leverage the callback-group concept existing in rclcpp by introducing real-time profiles such as RT-CRITICAL and BEST-EFFORT in the callback-group API (i.e. rclcpp/callback_group.hpp). Each callback needing specific real-time guarantees, when created, may therefore be associated with a dedicated callback group. With this in place, we enhanced the Executor and depending classes (e.g., for memory allocation) to operate at a finer callback-group granularity. This allows a single node to have callbacks with different real-time profiles assigned to different Executor instances - within one process.</p>

<p>Thus, an Executor instance can be dedicated to specific callback group(s) and the Executors thread(s) can be prioritized according to the real-time requirements of these groups. For example, all time-critical callbacks are handled by an RT-CRITICAL Executor instance running at the highest scheduler priority.</p>

<p>The following Figure illustrates this approach with two nodes served by three Callback-group-level Executors in one process:</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/cbg-executor_sample_system.png" alt="Sample system with two nodes and three Callback-group-level Executors in one process" width="60%">
</center>

<p>The different callbacks of the Drive-Base node are distributed to different Executors (visualized by the color red, yellow and green).  For example the onCmdVel and publishWheelTicks callback are scheduled by the same Executor (yellow). Callbacks from different nodes can be serviced by the same Executor.</p>

<h3 id="api-changes">API Changes</h3>

<p>In this section, we describe the necessary changes to the Executor API:</p>
<ul>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/callback_group.hpp">include/rclcpp/callback_group.hpp</a>:</p>

    <ul>
      <li>Introduced an enum to distinguish up to three real-time classes (requirements) per node (RealTimeCritical, SoftRealTime, BestEffort)</li>
      <li>Changed association with Executor instance from nodes to callback groups.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">include/rclcpp/executor.hpp</a></p>

    <ul>
      <li>
        <p>Added functions to add and remove individual callback groups in addition to whole nodes.</p>
      </li>
      <li>
        <p>Replaced private vector of nodes with a map from callback groups to nodes.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/memory_strategy.hpp">include/rclcpp/memory_strategy.hpp</a></p>

    <ul>
      <li>Changed all functions that expect a vector of nodes to the just mentioned map.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node.hpp">include/rclcpp/node.hpp</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node_interfaces/node_base.hpp">include/rclcpp/node_interfaces/node_base.hpp</a></p>

    <ul>
      <li>Extended arguments of create_callback_group function for the real-time class.</li>
      <li>Removed the get_associated_with_executor_atomic function.</li>
    </ul>
  </li>
</ul>

<p>The callback-group-level executor has been merged into ROS 2 rclcpp in <a href="https://github.com/ros2/rclcpp/pull/1218/commits">pull request 1218</a>.</p>

<h3 id="test-bench">Test Bench</h3>

<p>As a proof of concept, we implemented a small test bench in the present package cbg-executor_ping-pong_cpp. The test bench comprises a Ping node and a Pong node which exchange real-time and best-effort messages simultaneously with each other. Each class of messages is handled with a dedicated Executor, as illustrated in the following Figure.</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/ping_pong_diagram.png" alt="Architecture for the Callback-group-level Executor test bench" width="100%">
</center>

<p>With the test bench, we validated the functioning of the approach.</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/cbg_executor_demo_plot.png" alt="Results from Callback-group-level Executor test bench" width="80%">
</center>

<p>In this example, the callback for the high priority task (red line) consumes 10ms and the low priority task (blue line) 40ms in the Pong Node. With a ping rate of 20 Hz, the CPU saturates (10ms*20+40ms*20=1000ms). With higher frequencies the high priorty task can continue to send its pong message, while the low priority pong task degrades. With a frequency of 100Hz the high priority task requires 100% CPU utilization. With higher ping rates it keeps sending pong messages with 100Hz, while the low priority task does not get any CPU ressources any more and cannot send any messages.</p>

<p>The test bench is provided in the <a href="https://github.com/ros2/examples/tree/master/rclcpp/executors/cbg_executor">cbg_executor_demo</a>.</p>

<h2 id="related-work">Related Work</h2>

<p>In this section, we provide an overview to related approaches and link to the corresponding APIs.</p>

<h3 id="fawkes-framework">Fawkes Framework</h3>

<p><a href="http://www.fawkesrobotics.org/">Fawkes</a> is a robotic software framework, which supports synchronization points for sense-plan-act like execution. It has been developed by RWTH Aachen since 2006. Source code is available at <a href="https://github.com/fawkesrobotics">github.com/fawkesrobotics</a>.</p>

<h4 id="synchronization">Synchronization</h4>
<p>Fawkes provides developers different synchronization points, which are very useful for defining an execution order of a typical sense-plan-act application. These ten synchronization points (wake-up hooks) are the following (cf. <a href="https://github.com/fawkesrobotics/fawkes/blob/master/src/libs/aspect/blocked_timing.h">libs/aspect/blocked_timing.h</a>):</p>

<ul>
  <li>WAKEUP_HOOK_PRE_LOOP</li>
  <li>WAKEUP_HOOK_SENSOR_ACQUIRE</li>
  <li>WAKEUP_HOOK_SENSOR_PREPARE</li>
  <li>WAKEUP_HOOK_SENSOR_PROCESS</li>
  <li>WAKEUP_HOOK_WORLDSTATE</li>
  <li>WAKEUP_HOOK_THINK</li>
  <li>WAKEUP_HOOK_SKILL</li>
  <li>WAKEUP_HOOK_ACT</li>
  <li>WAKEUP_HOOK_ACT_EXEC</li>
  <li>WAKEUP_HOOK_POST_LOOP</li>
</ul>

<h4 id="configuration-at-compile-time">Configuration at compile time</h4>
<p>At compile time, a desired synchronization point is defined as a constructor parameter for a module. For example, assuming that <code class="language-plaintext highlighter-rouge">mapLaserGenThread</code> shall be executed in SENSOR_ACQUIRE, the constructor is implemented as:</p>

<pre><code class="language-C++">MapLaserGenThread::MapLaserGenThread()
  :: Thread("MapLaserGenThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE),
     TransformAspect(TransformAspect::BOTH_DEFER_PUBLISHER, "Map Laser Odometry")

</code></pre>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">NaoQiButtonThread</code> shall be executed in the SENSOR_PROCESS hook, the constructor is:</p>

<pre><code class="language-C++">NaoQiButtonThread::NaoQiButtonThread()
  :: Thread("NaoQiButtonThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS)

</code></pre>

<h4 id="runtime-execution">Runtime execution</h4>
<p>At runtime, the <em>Executor</em> iterates through the list of synchronization points and executes all registered threads until completion. Then, the threads of the next synchronization point are called.</p>

<p>A module (thread) can be configured independent of these sense-plan-act synchronization points. This has the effect, that this thread is executed in parallel to this chain.</p>

<p>The high level overview of the Fawkes framework is shown in the next figure. At compile-time the configuration of the sense-plan act wakeup hook is done (upper part), while at run-time the scheduler iterates through this list of wakeup-hooks (lower part):</p>

<center>
<img src="https://raw.githubusercontent.com/lsds/intravisor/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc/png/fawkes_executor_diagram.png" alt="Sequence diagram for Fawkes Executor" width="50%">
</center>

<p>Hence, at run-time, the hooks are executed as a fixed static schedule without preemption. Multiple threads registered in the same hook are executed in parallel.</p>

<p>Orthogonal to the sequential execution of sense-plan-act like applications, it is possible to define further constraints on the execution order by means of a <code class="language-plaintext highlighter-rouge">Barrier</code>. A barrier defines a number of threads, which need to have finished before the thread can start, which owns the barrier.</p>

<p>These concepts are implemented by the following main classes:</p>

<ul>
  <li>
<em>Wakeup hook</em> by <code class="language-plaintext highlighter-rouge">SyncPoint</code> and <code class="language-plaintext highlighter-rouge">SyncPointManager</code>, which manages a list of synchronization points.</li>
  <li>
<em>Executor</em> by the class <code class="language-plaintext highlighter-rouge">FawkesMainThread</code>, which is the scheduler, responsible for calling the user threads.</li>
  <li>
<code class="language-plaintext highlighter-rouge">ThreadManager</code>, which is derived from <code class="language-plaintext highlighter-rouge">BlockedTimingExecutor</code>, provides the necessary API to add and remove threads to wakeup hooks as well as for sequential execution of the wakeup-hooks.</li>
  <li>
<code class="language-plaintext highlighter-rouge">Barrier</code> is an object similar to <code class="language-plaintext highlighter-rouge">condition_variable</code> in C++.</li>
</ul>

<h4 id="discussion">Discussion</h4>

<p>All threads are executed with the same priority. If multiple sense-plan-act chains shall be executed with different priorities, e.g. to prefer execution of emergency-stop over normal operation, then this framework reaches its limits.</p>

<p>Also, different execution frequencies cannot be modeled by a single instance of this sense-plan-act chain. However, in robotics the fastest sensor will drive the chain and all other hooks are executed with the same frequency.</p>

<p>The option to execute threads independent of the predefined wakeup-hooks is very useful, e.g. for diagnostics. The concept of the Barrier is useful for satisfying functional dependencies which need to be considered in the execution order.</p>

<h2 id="references">References</h2>
<ul>
  <li>
    <p>[S2021]<a name="S2021"></a> J. Staschulat, Micro-ROS: The rclc Executor, in Workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at ROS World, Oct. 2021, [<a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">slides</a>] [<a href="https://www.youtube.com/embed/IazrPF3RN1U">Video</a>]</p>
  </li>
  <li>
    <p>[SLD2021]<a name="SLD2021"></a> J. Staschulat, R. Lange and D. N. Dasari, Budget-based real-time Executor for Micro-ROS, arXiv Pre-Print, May 2021. [<a href="https://arxiv.org/abs/2105.05590">paper</a>]</p>
  </li>
  <li>
    <p>[L2020]<a name="L2020"></a> Ralph Lange: Advanced Execution Management with ROS 2, ROS-Industrial Conference, Dec 2020 <a href="https://micro-ros.github.io/download/2020-12-16_Advanced_Execution_Management_with_ROS_2.pdf">[Slides]</a></p>
  </li>
  <li>
    <p>[SLL2020]<a name="SLL2020"></a> J. Staschulat, I. Ltkebohle and R. Lange, The rclc Executor: Domain-specific deterministic scheduling mechanisms for ROS applications on microcontrollers: work-in-progress, 2020 International Conference on Embedded Software (EMSOFT), Singapore, Singapore, 2020, pp. 18-19. <a href="https://ieeexplore.ieee.org/document/9244014">[Paper]</a> <a href="https://whova.com/embedded/session/eswe_202009/1145800/">[Video]</a></p>
  </li>
  <li>
    <p>[CB2019]<a name="CB2019"> </a> D. Casini, T. Bla, I. Ltkebohle, B. Brandenburg: Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling, in Euromicro-Conference on Real-Time Systems 2019. <a href="http://drops.dagstuhl.de/opus/volltexte/2019/10743/">[Paper]</a> <a href="https://t-blass.de/talks/ECRTS2019.pdf">[slides]</a></p>
  </li>
  <li>
    <p>[L2018]<a name="L2018"></a> Ralph Lange: Callback-group-level Executor for ROS 2. Lightning talk at ROSCon 2018. Madrid, Spain. Sep 2018. <a href="https://roscon.ros.org/2018/presentations/ROSCon2018_Lightning1_4.pdf">[Slides]</a> <a href="https://vimeo.com/292707644">[Video]</a></p>
  </li>
  <li>
    <p>[EK2018]<a name="EK2018"></a> R. Ernst, S. Kuntz, S. Quinton, M. Simons: The Logical Execution Time Paradigm: New Perspectives for Multicore Systems, February 25-28 2018 (Dagstuhl Seminar 18092). <a href="http://drops.dagstuhl.de/opus/volltexte/2018/9293/pdf/dagrep_v008_i002_p122_18092.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[NSP2018]<a name="NSP2018"></a> A. Naderlinger, S. Resmerita, and W. Pree: LET for Legacy and Model-based Applications,
Proceedings of The Logical Execution Time Paradigm: New Perspectives for Multicore Systems (Dagstuhl Seminar 18092), Wadern, Germany, February 2018.</p>
  </li>
  <li>
    <p>[BP2017]<a name="BP2017"></a> A. Biondi, P. Pazzaglia, A. Balsini,  M. D. Natale: Logical Execution Time Implementation and Memory Optimization Issues in AUTOSAR Applications for Multicores, International Worshop on Analysis Tools and Methodologies for Embedded and Real-Time Systems (WATERS2017), Dubrovnik, Croatia.<a href="https://pdfs.semanticscholar.org/4a9e/b9a616c25fd0b4a4f7810924e73eee0e7515.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[KZH2015]<a name="KZH2015"></a> S. Kramer, D. Ziegenbein, and A. Hamann: Real World Automotive Benchmarks For Free, International Workshop on Analysis Tools and Methodologies for Embedded adn Real-Time Sysems (WATERS), 2015.</p>
  </li>
  <li>
    <p>[HHK2001]<a name="HHK2001"></a> Henzinger T.A., Horowitz B., Kirsch C.M. (2001) Giotto: A Time-Triggered Language for Embedded Programming. In: Henzinger T.A., Kirsch C.M. (eds) Embedded Software. EMSOFT 2001. Lecture Notes in Computer Science, vol 2211. Springer, Berlin, Heidelberg</p>
  </li>
  <li>
    <p>[LL1973]<a name="LL1973"></a> Liu, C. L.; Layland, J.:Scheduling algorithms for multiprogramming in a hard real-time environment, Journal of the ACM, 20 (1): 4661, 1973.</p>
  </li>
</ul>
</div>
              </div>
            </div>
          </div>
        </div>
      
    
    <div class="row">
      <div class="col-xs-12">
        <div class="panel panel-default">
          <div class="panel-heading"><span class="glyphicon glyphicon-list"></span> CHANGELOG</div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="changelog-for-package-rclc">Changelog for package rclc</h1>

<h2 id="308-2022-04-14">3.0.8 (2022-04-14)</h2>

<ul>
  <li>Remove duplicate typedefs. (#249)</li>
  <li>Add rmw dependencies due to EventsExecutor PR in rcl (#255)</li>
  <li>Fix action client &amp; server deallocation (#257)</li>
  <li>updated documentation: build status for Rolling (#266)</li>
  <li>Update action client goal callback signature (#282)</li>
  <li>Upgrade parameters (#274)</li>
</ul>

<h2 id="307-2022-02-17">3.0.7 (2022-02-17)</h2>

<ul>
  <li>Fix enum naming for avoid collision (#242)</li>
  <li>Added dependency for package performance-test-fixture (#245)</li>
</ul>

<h2 id="306-2022-01-25">3.0.6 (2022-01-25)</h2>

<ul>
  <li>executor ignore canceled timers (#220)</li>
  <li>uddated documentation README.md (#229)</li>
  <li>resolved error in unit test see issue #230 (#231)</li>
  <li>Add thread dependency to examples (Rolling) (#237) (resolves in
this package only cpplint errors)</li>
</ul>

<h2 id="305-2021-11-23">3.0.5 (2021-11-23)</h2>

<ul>
  <li>Fix data_available reset for timer (backport #215) (#217)</li>
</ul>

<h2 id="304-2021-11-17">3.0.4 (2021-11-17)</h2>

<ul>
  <li>Ignoring unsuccessful SERVICE_TAKE (#175)</li>
  <li>Add rclc_parameter Quality Declaration (#144)</li>
  <li>use-ros2-testing (#185)</li>
  <li>Fix: printf in executor spin (#195)</li>
  <li>Fix init options handling (#202) (#205)</li>
  <li>Remove init options from support (#203)</li>
  <li>RCLC Actions Implementation (#170)</li>
  <li>Add rcl_action as build export dependency (#211)</li>
</ul>

<h2 id="303-2021-07-28">3.0.3 (2021-07-28)</h2>

<ul>
  <li>Checking for valid ROS context in spin_some</li>
  <li>Refactoring executor (removing callback_type)</li>
  <li>Fixing codecov config</li>
</ul>

<h2 id="302-2021-07-26">3.0.2 (2021-07-26)</h2>

<ul>
  <li>Updated codecov to ignore test folders</li>
  <li>Updated bloom release status table</li>
</ul>

<h2 id="301-2021-07-17">3.0.1 (2021-07-17)</h2>

<ul>
  <li>Added rclc_parameter package</li>
  <li>Added quality of service entity creation API</li>
  <li>Added executor prepare API</li>
  <li>Added support for removing subscription from executor</li>
  <li>Added support for subscription with context</li>
  <li>Added quality declaration statement</li>
  <li>Updated compatability function for sleep</li>
  <li>Removed duplicate NOTICE files</li>
</ul>

<h2 id="200-2021-04-23">2.0.0 (2021-04-23)</h2>

<ul>
  <li>Added codecov support</li>
  <li>New API of rcl_lifecycle in Rolling required major version bump</li>
</ul>

<h2 id="101-2021-03-29">1.0.1 (2021-03-29)</h2>

<ul>
  <li>Windows port</li>
  <li>Compatibility sleep function (Windows, POSIX-OS)</li>
  <li>Fixed RCL lifecycle API change for Rolling</li>
</ul>

<h2 id="100-2021-03-04">1.0.0 (2021-03-04)</h2>

<ul>
  <li>Service callbacks with context</li>
  <li>Fixed minor issues unit tests</li>
  <li>Upgraded setup_ros action (ci jobs)</li>
  <li>Removed Eloquent from ci jobs</li>
</ul>

<h2 id="017-2021-01-20">0.1.7 (2021-01-20)</h2>

<ul>
  <li>Corrected corrupted changelog</li>
</ul>

<h2 id="016-2021-01-20">0.1.6 (2021-01-20)</h2>

<ul>
  <li>Fixed issues due to Github Action timing delays on cloud build</li>
  <li>Fixed missing package dependency in Github Action for Eloquent</li>
</ul>

<h2 id="015-2020-12-11">0.1.5 (2020-12-11)</h2>

<ul>
  <li>Added support for services,clients and guard_conditions to rclc
executor</li>
  <li>Added table for bloom release status in README file</li>
</ul>

<h2 id="014-2020-11-25">0.1.4 (2020-11-25)</h2>

<ul>
  <li>Fixed error in bloom release</li>
</ul>

<h2 id="013-2020-11-23">0.1.3 (2020-11-23)</h2>

<ul>
  <li>Added rclc_lifecycle package</li>
  <li>Change maintainer information</li>
  <li>Minor fixes, updated unit tests</li>
</ul>

<h2 id="012-2020-05-19">0.1.2 (2020-05-19)</h2>

<ul>
  <li>Fixed compiler errors for bloom release</li>
</ul>

<h2 id="011-2020-05-14">0.1.1 (2020-05-14)</h2>

<ul>
  <li>Initial release</li>
</ul>
</div>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="github-tutorials">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Wiki Tutorials</h3>
      </div>
      <div class="panel-body">
        
        <em>This package does not provide any links to tutorials in it's <a href="https://index.ros.org/contribute/metadata/">rosindex metadata</a>.</em>
        <em>You can check on the <a href="http://wiki.ros.org/rclc/Tutorials" target="_blank">ROS Wiki Tutorials</a> page for the package.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="github-deps">
    <div class="row">
      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Package Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th class="text-center">Deps</th>
                  <th style="width: 100%">Name</th>
                </thead>
                <tbody>
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl#github-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl#github">rcl  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl_action#github-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl_action#github">rcl_action  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcutils#github-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcutils#github">rcutils  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_generator_c#github-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_generator_c#github">rosidl_generator_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_typesupport_c#github-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_typesupport_c#github">rosidl_typesupport_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_ros#github-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_ros#github">ament_cmake_ros  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_gtest#github-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_gtest#github">ament_cmake_gtest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_pytest#github-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_pytest#github">ament_cmake_pytest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_auto#github-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_auto#github">ament_lint_auto  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_common#github-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_common#github">ament_lint_common  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/launch_testing#github-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/launch_testing#github">launch_testing  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/osrf_testing_tools_cpp#github-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/osrf_testing_tools_cpp#github">osrf_testing_tools_cpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/std_msgs#github-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/std_msgs#github">std_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/test_msgs#github-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/test_msgs#github">test_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/example_interfaces#github-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/example_interfaces#github">example_interfaces  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp#github-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp#github">rclcpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp_action#github-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp_action#github">rclcpp_action  </a></td>
                      </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
          <div class="panel-heading">
            <h3 class="panel-title">System Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <em>No direct system dependencies.</em>
            
          </div>
        </div>
      </div>

      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Dependant Packages</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th>Name</th>
                  <th class="text-center">Deps</th>
                </thead>
                <tbody>
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_demos_rclc#github">micro_ros_demos_rclc</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_demos_rclc#github-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                    <tr>
                      <td><a href="/p/micro_ros_demos_rclc#github">micro_ros_demos_rclc</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_demos_rclc#github-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_examples#github">rclc_examples</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_examples#github-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_lifecycle#github">rclc_lifecycle</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_lifecycle#github-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_parameter#github">rclc_parameter</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_parameter#github-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/listener_c#github">listener_c</a></td>
                      <td class="text-center">
                        
                        <a href="/p/listener_c#github-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/pub_int32_c#github">pub_int32_c</a></td>
                      <td class="text-center">
                        
                        <a href="/p/pub_int32_c#github-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/sub_int32_c#github">sub_int32_c</a></td>
                      <td class="text-center">
                        
                        <a href="/p/sub_int32_c#github-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/talker_c#github">talker_c</a></td>
                      <td class="text-center">
                        
                        <a href="/p/talker_c#github-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/fluent_bit_plugins#github">fluent_bit_plugins</a></td>
                      <td class="text-center">
                        
                        <a href="/p/fluent_bit_plugins#github-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/fluent_bit_vendor#github">fluent_bit_vendor</a></td>
                      <td class="text-center">
                        
                        <a href="/p/fluent_bit_vendor#github-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/ros2socketcan_bridge#github">ros2socketcan_bridge</a></td>
                      <td class="text-center">
                        
                        <a href="/p/ros2socketcan_bridge#github-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="github-assets">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Launch files</h3>
      </div>
      <div class="panel-body">
        
          <em>No launch files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Messages</h3>
      </div>
      <div class="panel-body">
        
          <em>No message files found.</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Services</h3>
      </div>
      <div class="panel-body">
        
          <em>No service files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Plugins</h3>
      </div>
      <div class="panel-body">
        
          <em>No plugins found.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="github-questions">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Recent questions tagged <kbd>rclc</kbd> at <strong><a href="https://robotics.stackexchange.com/" target="_blank">Robotics Stack Exchange</a></strong></h3>      </div>
      <div id="github-question-list" class="panel-body" style="display: none;"></div>
      <div id="github-no-question-list" class="panel-body" style="display: none;">
        <p>No questions yet, you can ask one <a href="https://robotics.stackexchange.com/questions/tagged/rclc+github">here</a>.</p>
      </div>
      <div id="github-get-question-fail" class="panel-body alert alert-warning" style="display: none;">
        <p>Failed to get question list, you can ticket an issue <a href="https://github.com/ros-infrastructure/rosindex/issues/new" target="_blank" class="alert-link">here</a> </p>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript" src="/js/package_body_tabs.js"></script>

<script src=/js/contribution_suggestions.js></script>
<script type="text/javascript">
jQuery(function() {
    // Update the count on the links to the contribution suggestions
    updateContributionSuggestionsCountOnPackage('https://github.com/lsds/intravisor.git');
});
</script>

          </div>
          <div class="col-md-2 hidden-xs hidden-sm">
            
            
            



<div class="list-group list-group-sm ">
  <a class="list-group-item"
     target="_blank"
     href="http://docs.ros.org/en/github/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       
       API Docs
  </a>
  <a class="list-group-item"
     target="_blank"
     href="https://github.com/lsds/intravisor/tree/main/runtime/musl-uni/single/apps/uros2/uros2/rclc/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       
       Browse Code
  </a>
  
  
  
  
  
  
</div>

          </div>
        </div>
      
    </div>
  </div>

  <div class="distro distro-noetic">
    <div class="container-fluid">
      
          <div class="alert alert-warning">No version for distro <strong>noetic</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>

  <div class="distro distro-galactic">
    <div class="container-fluid">
      
        
        
        

        <div class="row">
          <div class="col-md-10">
            

<div class="well well-sm">
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px" src="/assets/package.png">
      </td>
      <td>
        <h3 style="margin-top: 5px">
          <a style="text-decoration:none" href="/p/rclc">rclc</a> <small>package from <a style="text-decoration:none" href="/r/rclc/github-ros2-rclc">rclc</a> repo</small>
        </h3>
          
            
            
              <span class="label label-default pkg-label">

rclc
</span>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_examples">

rclc_examples
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_lifecycle">

rclc_lifecycle
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_parameter">

rclc_parameter
</a>
            
          
      </td>
    </tr>
  </table>
</div>

            <div class="visible-xs visible-sm">
              
              
              



<div class="list-group list-group-sm list-group-horizontal list-group-justified">
  <a class="list-group-item text-center"
     target="_blank"
     href="http://docs.ros.org/en/galactic/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       <br>
       API Docs
  </a>
  <a class="list-group-item text-center"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/galactic/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       <br>
       Browse Code
  </a>
  
  
  
  
  
  
</div>

            </div>
            



<ul class="nav nav-tabs nav-justified" id="galactic-tabs" style="margin-bottom:20px">
  <li class="better-tabs active">
    <a href="#galactic-overview" data-toggle="tab">Overview</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    
    <a href="#galactic-assets" data-toggle="tab"><span class="label label-default">0</span> Assets</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    <a href="#galactic-deps" data-toggle="tab"><span class="label label-primary">14</span> Dependencies</a>
  </li>
  <li class="better-tabs">
    
    <a href="#galactic-tutorials" data-toggle="tab"><span class="label label-default">0</span> Tutorials</a>
  </li>
  <li class="better-tabs">
    <a href="#galactic-questions" data-toggle="tab"><span id="galactic-questions-count" class="label label-primary">0</span> Q & A</a>
  </li>
</ul>

<div class="tab-content">
  <div class="tab-pane active" id="galactic-overview">
    
    <div class="row">
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h4 class="panel-title">Package Summary</h4></div>
          <div class="panel-body">
            <table class="table table-condensed">
              <tr>
                <td style="width:100px;" class="text-right"><strong>Tags</strong></td>
                <td>
                  
                  
                    <em>No category tags.</em>
                  
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Version</strong></td>
                <td>2.0.6</td>
              </tr>
              <tr>
                <td class="text-right"><strong>License</strong></td>
                <td>Apache License 2.0</td>
              </tr>
              <tr>
                <td class="text-right"><strong>Build type</strong></td>
                <td>
                  
                    <span class="label label-default">
                  
                    AMENT_CMAKE</span>
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Use</strong></td>
                <td>
                
                  <span class="label label-success">RECOMMENDED</span>
                
                </td>
              </tr>
            </table>
          </div>
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body">
            
            
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">ROS Client Library for the C language.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/ros2/rclc.git">https://github.com/ros2/rclc.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">galactic</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2023-01-25
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="No CI information available for this package.">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <em>No category tags.</em>
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/rclc/#galactic-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#galactic-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#galactic-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
      </div>
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Package Description</h3></div>
          <div class="panel-body">
            The ROS client library in C.
          </div>
          <div class="panel-heading"><h4 class="panel-title">Additional Links</h4></div>
          <div class="panel-body">
            
            
              <em>No additional links.</em>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Maintainers</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>Pablo Garrido</li>
                
              </ul>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Authors</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>William Woodall</li>
                
              </ul>
            
          </div>
        </div>
      </div>
    </div>
    
      
        <div class="row">
          <div class="col-xs-12">
            <div class="panel panel-default">
              <div class="panel-heading"><span class="glyphicon glyphicon-file"></span><a href="https://github.com/ros2/rclc/tree/galactic/rclc/README.md" title="Open in git repository">rclc/README.md</a></div>
              <div class="panel-body">
                    <div class="rendered-markdown">
<h1 id="the-rclc-package">The rclc package</h1>

<h2 id="table-of-contents">Table of contents</h2>

<ul>
  <li>
    <p><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#introduction">Introduction</a></p>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#architecture">Architecture</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#scheduling-semantics">Scheduling Semantics</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#synchronization-of-multiple-rates">Synchronization of multiple rates</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#high-priority-processing-path">High-priority processing path</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#real-time-embedded-applications">Real-time embedded applications</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#rclc-executor">rclc Executor</a>
    <ul>
      <li>
<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#features">Features</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#trigger-condition">Trigger condition</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#sequential-execution">Sequential execution</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#let-semantics">LET-Semantics</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#executor-api">Executor API</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#configuration-phase">Configuration phase</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#running-phase">Running phase</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#examples">Examples</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#synchronization-of-multiple-rates-example">Synchronization of multiple rates example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#high-priority-processing-path-example">High-priority processing path example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#real-time-embedded-applications-example">Real-time embedded applications example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#future-work">Future work</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#download">Download</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#callback-group-level-executor">Callback-group-level Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#api-changes">API Changes</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#test-bench">Test Bench</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#related-work">Related Work</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#fawkes-framework">Fawkes Framework</a></li>
    </ul>
  </li>
  <li><a href="https://github.com/ros2/rclc/tree/galactic/rclc/#references">References</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Predictable execution under given real-time constraints is a crucial requirement for many robotic applications. While the service-based paradigm of ROS allows a fast integration of many different functionalities, it does not provide sufficient control over the execution management. For example, there are no mechanisms to enforce a certain execution order of callbacks within a node. Also the execution order of multiple nodes is essential for control applications in mobile robotics. Cause-effect-chains comprising of sensor acquisition, evaluation of data and actuation control should be mapped to ROS nodes executed in this order, however there are no explicit mechanisms to enforce it. Furthermore, when data recordings collected in field tests as ROS-bags are re-played, then the results are often surprisingly different due to non-determinism of process scheduling.</p>

<p>Manually setting up a particular execution order of subscriptions and publishing topics as well as defining use-case specific priorities of the corresponding Linux processes is always possible. However, this approach is error-prone, difficult to extend and requires an in-depth knowledge of the deployed ROS 2 packages in the system.</p>

<p>Therefore the goal of the Executor in micro-ROS is to support roboticists with practical and easy-to-use real-time mechanisms which provide solutions for:</p>
<ul>
  <li>Deterministic execution</li>
  <li>Real-time guarantees</li>
  <li>Integration of real-time and non real-time functionalities on one platform</li>
  <li>Specific support for RTOS and microcontrollers</li>
</ul>

<p>In ROS 1 a network thread is responsible for receiving all messages and putting them into a FIFO queue (in roscpp). That is, all callbacks were called in a FIFO manner, without any execution management. With the introduction of DDS (data distribution service) in ROS 2, the messages are buffered in DDS. In ROS 2, an Executor concept was introduced to support execution management. At the rcl-layer, a <em>wait-set</em> is configured with handles to be received and in a second step, the handles are taken from the DDS-queue. A handle is a generic term defined in rcl-layer for timers, subscriptions, services, clients and guard conditions.</p>

<p>The standard implementation of the ROS 2 Executor for the C++ API (rclcpp) has, however, certain unusual features, like precedence of timers over all other DDS handles, non-preemptive round-robin scheduling for non-timer handles and considering only one input data for each handle (even if multiple could be available). These features have the consequence, that in certain situations the standard rclcpp Executor is not deterministic and it makes guaranteeing real-time requirements very hard [<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#CB2019">CB2019</a>]. We have not looked at the ROS 2 Executor implementation for Python Frontend (rclpy) because we consider a micro-controllers platform, on which typically C or C++ appliations will run.</p>

<p>Given the goals for a Real-Time Executor and the limitations of the ROS 2 standard rclcpp Executor, the challenges are:</p>
<ul>
  <li>to develop an adequate and well-defined scheduling mechanisms for the ROS 2 framework and the real-time operating system (RTOS)</li>
  <li>to define an easy-to-use interface for ROS developers</li>
  <li>to model requirements (like latencies, determinism in subsystems)</li>
  <li>mapping of ROS 2 framework and operating system schedulers (semi-automated and optimized mapping is desired as well as generic, well-understood framework mechanisms)</li>
</ul>

<p>Our approach is to provide a real-time-capable Executor for the rcl+rclc layer (as described in section <a href="https://github.com/ros2/rclc/tree/galactic/rclc/../">Introduction to Client Library</a>.) in the C programming language .</p>

<p>As the first step, we propose the rclc Executor for the rcl-layer in C programming language with several new features to support real-time and deterministic execution: It supports 1.) user-defined static sequential execution, 2) conditional execution semantics, 3) multi-threaded execution with scheduling configuration, and 4) logical execution semantics (LET). Sequential execution refers to the runtime behavior, that all callbacks are executed in a pre-defined order independent of the arrival time of messages. Conditional execution is available with a trigger condition which enables typical processing patterns in robotics (which are analyzed in detail in section <a href="https://github.com/ros2/rclc/tree/galactic/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>. Configuration of scheduling parameters for multi-threaded application accomplishes prioritized execution. The logical execution time concept (LET) provides data synchronization for fixed periodic task scheduling of embedded applications.</p>

<p>Beyond the advanced execution management mechanisms for micro-ROS, we also contributed to improving and extending the Executor concept in rclcpp for standard ROS 2: the callback group-level Executor. It is not a new Executor but rather a refinement of the ROS 2 Executor API allowing to prioritize a group of callbacks which is not possible with the ROS 2 default Executor in its current Galactic release.</p>

<h2 id="analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</h2>

<p>ROS 2 allows to bundle multiple nodes in one operating system process. To coordinate the execution of the callbacks of the nodes of a process, the Executor concept was introduced in rclcpp (and also in rclpy).</p>

<p>The ROS 2 design defines one Executor (instance of <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">rclcpp::executor::Executor</a>) per process, which is typically created either in a custom main function or by the launch system. The Executor coordinates the execution of all callbacks issued by these nodes by checking for available work (timers, services, messages, subscriptions, etc.) from the DDS queue and dispatching it to one or more threads, implemented in <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/single_threaded_executor.hpp">SingleThreadedExecutor</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp">MultiThreadedExecutor</a>, respectively.</p>

<p>The dispatching mechanism resembles the ROS 1 spin thread behavior: the Executor looks up the wait sets, which notifies it of any pending callback in the DDS queue. If there are multiple pending callbacks, the ROS 2 Executor executes them in an in the order as they were registered at the Executor.</p>

<h3 id="architecture">Architecture</h3>

<p>The following diagram depicts the relevant classes of the standard ROS 2 Executor implementation:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/executor_class_diagram.png" alt="ROS 2 Executor class diagram" width="100%">
</center>

<p>Note that an Executor instance maintains weak pointers to the NodeBaseInterfaces of the nodes only. Therefore, nodes can be destroyed safely, without notifying the Executor.</p>

<p>Also, the Executor does not maintain an explicit callback queue, but relies on the queue mechanism of the underlying DDS implementation as illustrated in the following sequence diagram:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/executor_to_dds_sequence_diagram.png" alt="Call sequence from executor to DDS" width="100%">
</center>

<p>The Executor concept, however, does not provide means for prioritization or categorization of the incoming callback calls. Moreover, it does not leverage the real-time characteristics of the underlying operating-system scheduler to have finer control on the order of executions. The overall implication of this behavior is that time-critical callbacks could suffer possible deadline misses and a degraded performance since they are serviced later than non-critical callbacks. Additionally, due to the FIFO mechanism, it is difficult to determine usable bounds on the worst-case latency that each callback execution may incur.</p>

<h3 id="scheduling-semantics">Scheduling Semantics</h3>

<p>In a recent paper [<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#CB2019">CB2019</a>], the rclcpp Executor has been analyzed in detail and a response time analysis of cause-effect chains has been proposed under reservation-based scheduling. The Executor distinguishes four categories of callbacks: <em>timers</em>, which are triggered by system-level timers, <em>subscribers</em>, which are triggered by new messages on a subscribed topic, <em>services</em>, which are triggered by service requests, and <em>clients</em>, which are triggered by responses to service requests. The Executor is responsible for taking messages from the input queues of the DDS layer and executing the corresponding callback. Since it executes callbacks to completion, it is a non-preemptive scheduler, However it does not consider all ready tasks for execution, but only a snapshot, called readySet. This readySet is updated when the Executor is idle and in this step it interacts with the DDS layer updating the set of ready tasks. Then for every type of task, there are dedicated queues (timers, subscriptions, services, clients) which are processed sequentially. The following undesired properties were pointed out:</p>

<ul>
  <li>Timers have the highest priority. The Executor processes <em>timers</em> always first.  This can lead to the intrinsic effect, that in overload situations messages from the DDS queue are not processed.</li>
  <li>Non-preemptive round-robin scheduling of non-timer handles. Messages arriving during the processing of the readySet are not considered until the next update, which depends on the execution time of all remaining callbacks. This leads to priority inversion, as lower-priority callbacks may implicitly block higher-priority callbacks by prolonging the current processing of the readySet.</li>
  <li>Only one message per handle is considered. The readySet contains only one task instance, For example, even if multiple messages of the same topic are available, only one instance is processed until the Executor is idle again and the readySet is updated from the DDS layer. This aggravates priority inversion, as a backlogged callback might have to wait for multiple processing of readySets until it is considered for scheduling. This means that non-timer callback instances might be blocked by multiple instances of the same lower-priority callback.</li>
</ul>

<p>Due to these findings, the authors present an alternative approach to provide determinism and to apply well-known schedulability analyses to a ROS 2 systems. A response time analysis is described under reservation-based scheduling.</p>

<h2 id="analysis-of-processing-patterns">Analysis of processing patterns</h2>
<p>The development of an execution management mechanism for micro-ROS is based on an analysis of processing patterns commonly used in robotics and embedded systems. First, typical processing patterns in mobile robotics are presented which are used to implement deterministic behavior. Then, the processing patterns in the real-time embedded systems are analyzed, in which, as a main difference, the time-triggered paradigm is applied to accomplish real-time behavior.</p>

<h3 id="sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</h3>
<p>Now we describe common software design patterns which are used in mobile robotics to achieve deterministic behavior. For each design pattern we describe the concept and the derived requirements for a deterministic Executor.</p>

<p><strong>Concept:</strong></p>

<p>A common design paradigm in mobile robotics is a control loop, consisting of several phases: A sensing phase to aquire sensor data, a plan phase for localization and path planning and an actuation-phase to steer the mobile robot. Of course, more phases are possible, here these three phases shall serve as an example. Such a processing pipeline is shown in Figure 1.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/sensePlanActScheme.png" alt="Sense Plan Act Pipeline" width="60%">
</center>
<center>
Figure 1: Multiple sensors driving a Sense-Plan-Act pipeline.
</center>

<p>Typically multiple sensors are used to perceive the environment. For example an IMU and a laser scanner. The quality of localization algorithms highly depend on how old such sensor data is when it is processed. Ideally the latest data of all sensors should be processed. One way to achive this is to execute first all sensor drivers in the sense-phase and then process all algorithms in the plan-phase.</p>

<p>Currently, such a processing order cannot be defined with the default Executor of rclcpp. One could in principle design a data-driven pipeline, however if e.g. the Laser scan is needed by some other callback in the sense-phase as well as in the plan-phase, the processing order of these subscribers is arbitrary.</p>

<p>For this sense-plan-act pattern, we could define one executor for each phase. The plan-phase would be triggered only when all callbacks in the sense-phase have finished.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
</ul>

<h3 id="synchronization-of-multiple-rates">Synchronization of multiple rates</h3>

<p><strong>Concept:</strong></p>

<p>Often multiple sensors are being used to sense the environment for mobile robotics. While an IMU sensor provides data samples at a very high rate (e.g., 500 Hz), laser scans are availabe at a much slower frequency (e.g. 10Hz) determined by the revolution time. Then the challenge is, how to deterministically fuse sensor data with different frequencies. This problem is depicted in Figure 2.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/sensorFusion_01.png" alt="Sychronization of multiple rates" width="30%">
</center>
<center>
Figure 2: How to deterministically process multi-frequent sensor data.
</center>

<p>Due to scheduling effects, the callback for evaluating the laser scan might be called just before or just after an IMU data is received. One way to tackle this is to write additional synchronization code inside the application. Obviously, this is a cumbersome and not-portable solution.</p>

<p>An Alternative would be to evalute the IMU sample and the laser scan by synchronizing their frequency. For example by processing always 50 IMU samples with one laser scan. This approach is shown in Figure 3. A pre-processing callback aggregates the IMU samples and sends an aggregated message with 50 samples at 10Hz rate. Now both messages have the same frequency. With a trigger condition, which fires when both messages are available, the sensor fusion algorithm can expect always synchronized input data.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/sensorFusion_02.png" alt="Sychnronization with a trigger" width="40%">
</center>
<center>
Figure 3: Synchronization of multiple input data with a trigger.
</center>

<p>In ROS 2, this is currently not possible to be modeled because of the lack of a trigger concept in the Executors of rclcpp and rclpy. Message filters could be used to synchronize input data based on the timestamp in the header, but this is only available in rclcpp (and not in rcl). Further more, it would be more efficient to have such a trigger concept directly in the Executor.</p>

<p>Another idea would be to activly request for IMU data only when a laser scan is received. This concept is shown in Figure 4. Upon arrival of a laser scan mesage, first, a message with aggregated IMU samples is requested. Then, the laser scan is processed and later the sensor fusion algorithm. An Executor, which would support sequential execution of callbacks, could realize this idea.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/sensorFusion_03.png" alt="Sychronization with sequence" width="30%">
</center>
<center>
Figure 4: Synchronization with sequential processing.
</center>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
  <li>sequential procesing of callbacks</li>
</ul>

<h3 id="high-priority-processing-path">High-priority processing path</h3>
<p><strong>Concept</strong>
Often a robot has to fullfill several activities at the same time. For example following a path and avoiding obstacles. While path following is a permanent activity, obstacle avoidance is trigged by the environment and should be immediately reacted upon. Therefore one would like to specify priorities to activities. This is depicted in Figure 5:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/highPriorityPath.png" alt="HighPriorityPath" width="50%">
</center>
<center>
Figure 5: Managing high priority path with sequential order.
</center>

<p>Assuming a simplified control loop with the activities sense-plan-act, the obstacle avoidance, which might temporarily stop the robot, should be processed before the planning phase. In this example we assume that these activites are processed in one thread.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>sequential processing of callbacks</li>
</ul>

<h3 id="real-time-embedded-applications">Real-time embedded applications</h3>
<p>In embedded systems, real-time behavior is approached by using the time-triggered paradigm, which means that the processes are periodically activated. Processes can be assigned priorities to allow pre-emptions. Figure 6 shows an example, in which three processes with fixed periods are shown. The middle and lower process are preempted multiple times depicted with empty dashed boxes.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/scheduling_01.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 6: Fixed periodic preemptive scheduling.
</center>

<p>To each process one or multiple tasks can be assigned, as shown in Figure 7. These tasks are executed sequentially, which is often called cooperative scheduling.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/scheduling_02.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 7: Processes with sequentially executed tasks.
</center>

<p>While there are different ways to assign priorities to a given number of processes,
the rate-monotonic scheduling assignment, in which processes with a shorter period have a higher priority, has been shown optimal if the processor utilization is less than 69% [<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#LL1973">LL1973</a>].</p>

<p>In the last decades many different scheduling approaches have been presented, however fixed-periodic preemptive scheduling is still widely used in embedded real-time systems [<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#KZH2015">KZH2015</a>]. This becomes also obvious, when looking at the features of current operating systems. Like Linux, real-time operating systems, such as NuttX, Zephyr, FreeRTOS, QNX etc., support fixed-periodic preemptive scheduling and the assignment of priorities, which makes the time-triggered paradigm the dominant design principle in this domain.</p>

<p>However, data consistency is often an issue when preemptive scheduling is used and if data is being shared across multiple processes via global variables. Due to scheduling effects and varying execution times of processes, writing and reading these variables could occur sometimes sooner or later. This results in an latency jitter of update times (the timepoint at which a variable change becomes visible to other processes). Race conditions can occur when multiple processes access a variable at the same time. So solve this problem, the concept of logical-execution time (LET) was introduced in [<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#HHK2001">HHK2001</a>], in which communication of data occurs only at pre-defined periodic time instances: Reading data only at the beginning of the period and writing data only at the end of the period. The cost of an additional latency delay is traded for data consistency and reduced jitter. This concept has also recently been applied to automotive applications[<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#NSP2018">NSP2018</a>].</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/scheduling_LET.png" alt="Schedule with fixed periods" width="80%">
</center>
<center>
Figure 8: Data communication without and with Logical Execution Time paradigm.
</center>

<p>An Example of the LET concept is shown in Figure 8. Assume that two processes are communicating data via one global variable. The timepoint when this data is written is at the end of the processing time. In the default case (left side), the process p<sub>3</sub> and p<sub>4</sub> receive the update. At the right side of Figure 8, the same scenario is shown with LET semantics. Here, the data is communicated only at period boundaries. In this case, the lower process communicates at the end of the period, so that always process p<sub>3</sub> and p<sub>5</sub> receive the new data.</p>

<p><strong>Concept:</strong></p>
<ul>
  <li>periodic execution of processes</li>
  <li>assignment of fixed priorities to processes</li>
  <li>preemptive scheduling of processes</li>
  <li>co-operative scheduling of tasks within a process (sequential execution)</li>
  <li>data synchronization with LET-semantics</li>
</ul>

<p>While periodic activation is possible in ROS 2 by using timers, preemptive scheduling is supported by the operating system and assigning priorities on the granularity of threads/processes that correspond to the ROS nodes; it is not possible to sequentially execute callbacks, which have no data-dependency. Furthermore data is read from the DDS queue just before the callback is executed and data is written sometime during the time the application is executed. While the <code class="language-plaintext highlighter-rouge">spin_period</code> function of the rclcpp Executor allows to check for data at a fixed period and executing those callbacks for which data is available, however, with this spin-function does not execute all callbacks irrespective wheter data is available or not. So <code class="language-plaintext highlighter-rouge">spin_period</code> is not helpful to periodically execute a number of callbacks (aka tasks within a process). So we need a mechanism that triggers the execution of multiple callbacks (aka tasks) based on a timer. Data transmission is achieved via DDS which does not allow to implement a LET-semantics. To summarize, we derive the following requirements.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>trigger the execution</li>
  <li>sequential processing of callbacks</li>
  <li>data synchronization with LET semantics</li>
</ul>

<h2 id="rclc-executor">rclc Executor</h2>

<p>The rclc Executor is a ROS 2 Executor based on the rcl-layer in C programming language. As discussed above, the default rclcpp Executor is not suitable to implement real-time applications because of three main reasons: timers are preferred over all other handles, no priorization of callback execution and the round-robin to completion execution of callbacks. On the other hand, several processing patterns have been developed as best practices to achieve non-functional requirements, such as bounded end-to-end latencies, low jitter of response times of cause-effect chains, deterministic processing and short response times even in overload situations. These processing patterns are difficult to implement with the concepts availabe in the default ROS 2 Executor, therefore we have developed a flexible Executor: the rclc Executor.</p>

<h3 id="features">Features</h3>

<p>The rclc Executor is feature-complete, i.e. it supports all event types as the default ROS 2 Executor, which are:</p>
<ul>
  <li>subscriptions</li>
  <li>timers</li>
  <li>services</li>
  <li>clients</li>
  <li>guard conditions</li>
  <li>actions</li>
  <li>lifecycle</li>
</ul>

<p>The flexible rclc Executor provides on top the following new features:</p>
<ul>
  <li>triggered execution</li>
  <li>user-defined sequential execution</li>
  <li>multi-threading and scheduling configuration (WIP)</li>
  <li>LET-semantics for data synchronization of periodic process scheduling</li>
</ul>

<p>First, a <em>trigger condition</em> allows to define when the processing of a callback shall start. This is useful to implement sense-plan-act control loops or more complex processing structures with directed acyclic graphs. Second, a user can specify the <em>processing order</em> in which these callbacks will be executed. With this feature, the pattern of sensor fusion with multiple rates, in which data is requested from a sensor based on the arrival of some other sensor, can be easily implemented. Third, the assignment of scheduling parameters (e.g., priorities) of the underlying operating system. With this feature, prioritized processing can be implemented. Finally, for periodic applications, the <em>LET Semantics</em> has been implemented to support data consistency for periodic process scheduling. These features are now described in more detail.</p>

<h4 id="sequential-execution">Sequential execution</h4>

<ul>
  <li>At configuration, the user defines the order of handles.</li>
  <li>At configuration, the user defines whether the handle shall be called only when new data is available (ON_NEW_DATA) or whether the callback shall always be called (ALWAYS).</li>
  <li>At runtime, all handles are processed in the user-defined order
    <ul>
      <li>if the configuration of handle is ON_NEW_DATA, then the corresponding callback is only called if new data is available</li>
      <li>if the configuration of the handle is ALWAYS, then the corresponding callback is always. If no data is available, then the callback is called with no data (e.g. NULL pointer).</li>
    </ul>
  </li>
</ul>

<p>Figure 9 shows three callbacks, A, B and C. Assume, they shall be executed in the order <em>B,A,C</em>. Then the user adds the callbacks to the rclc Executor in this order. Whenever new messages have arrived then the callbacks for which a new message is availabe will be always executed in the user-defined processing order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/rclc_executor_sequential_execution.png" alt="Sequential execution semantics" width="50%">
</center>
<center>
Figure 9: Sequential execution semantics.
</center>

<h4 id="trigger-condition">Trigger condition</h4>

<ul>
  <li>Given a set of handles, a trigger condition, which is based on the availability of input data of these handles, decides when the processing of all callbacks starts. This is shown in Figure 10.</li>
</ul>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/trigger_01.png" alt="Trigger condition overview" width="50%">
</center>
<center>
Figure 10: Executor with trigger condition
</center>

<ul>
  <li>Available options:
    <ul>
      <li>ALL operation: fires when input data is available for all handles</li>
      <li>ANY operation: fires when input data is available for at least one handle (OR semantics)</li>
      <li>ONE: fires when input data for a user-specified handle is available</li>
      <li>User-defined function: user can implement custom logic</li>
    </ul>
  </li>
</ul>

<p>Figure 11 shows an example of the ALL semantics. Only if all messages <em>msg_A, msg_B, msg_C</em> were received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/trigger_ALL.png" alt="Trigger condition ALL" width="30%">
</center>
<center>
Figure 11: Trigger condition ALL
</center>

<p>Figure 12 shows an example of the ANY semantics. Thas is, if any messages <em>msg_A, msg_B, msg_C</em> was received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order. This is equivalent to OR semantics.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/trigger_OR.png" alt="Trigger condition ANY" width="30%">
</center>
<center>
Figure 12: Trigger condition ANY (OR)
</center>

<p>Figure 13 shows an example of the ONE semantics. Thas is, only if message <em>msg_B</em> was received, the trigger condition is fullfilled and (potentially all) callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/trigger_ONE.png" alt="Trigger condition ONE" width="30%">
</center>
<center>
Figure 13: Trigger condition ONE
</center>

<p>Figure 14 describes the custom semantics. A custom trigger condition with could be a more complex logic of multiple messages, can be passed to the executor. This might also include hardware triggers, like interrupts.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/trigger_user_defined.png" alt="Trigger condition user-defined" width="30%">
</center>
<center>
Figure 14: Trigger condition user-defined
</center>

<h4 id="let-semantics">LET-Semantics</h4>
<ul>
  <li>Assumption: time-triggered system, the executor is activated periodically</li>
  <li>When the trigger fires, reads all input data and makes a local copy</li>
  <li>Processes all callbacks in sequential order</li>
  <li>Write output data at the end of the executors period (Note: this is not implemented yet)</li>
</ul>

<p>Additionally we have implemented the current rclcpp Executor semantics (RCLCPP):</p>
<ul>
  <li>waiting for new data for all handles (rcl_wait)</li>
  <li>using trigger condition ANY</li>
  <li>if trigger fires, start processing handles in pre-defined sequential order</li>
  <li>request from DDS-queue the new data just before the handle is executed (rcl_take)</li>
</ul>

<p>The selection of the Executor semantics is optional. The default semantics is RCLCPP.</p>

<h4 id="multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</h4>

<p>The rclc Executor has been extended for multi-threading. It supports the assignment of scheduling policies, like priorities or more advanced scheduling algorithms as reservation-based scheduling, to subscription callbacks. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, Pre-print <a href="https://github.com/ros2/rclc/tree/galactic/rclc/#SLD2021">SLD2021</a>]. The overall architecture is shown in Figure 15. One Executor thread is responsible for checking for new data from the DDS queue. For every callback, a thread is spawned with the dedicted scheduling policy provided by the operating system. The Executor then dispatches new data of a subscription to its corresponding callback function, which is then executed in its own thread by operating system.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/rclc_executor_multi_threaded.png" alt="Multi-threaded rclc Executor" width="90%">
</center>
<center>
Figure 15: multi-threaded rclc-Executor
</center>

<h3 id="executor-api">Executor API</h3>
<p>The API of the rclc Executor can be divided in two phases: Configuration and Running.</p>
<h4 id="configuration-phase">Configuration phase</h4>
<p>During the configuration phase, the user shall define:</p>
<ul>
  <li>the total number of callbacks</li>
  <li>the sequence of the callbacks</li>
  <li>trigger condition (optional, default: ANY)</li>
  <li>data communcation semantics (optional, default ROS2)</li>
</ul>

<p>As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added.</p>

<p>Then, the user adds handles and the corresponding callbacks (e.g. for subscriptions and timers) to the Executor. The order in which this takes place, defines later the sequential processing order during runtime.</p>

<p>For each handle the user can specify, if the callback shall be executed only if new data is available (ON_NEW_DATA) or if the callback shall always be executed (ALWAYS). The second option is useful when the callback is expected to be called at a fixed rate.</p>

<p>The trigger condition defines when the processing of these callbacks shall start. For convenience some default conditions have been defined:</p>
<ul>
  <li>trigger_any(default) : start executing if any callback has new data</li>
  <li>trigger_all : start executing if all callbacks have new data</li>
  <li>trigger_one(&amp;<code class="language-plaintext highlighter-rouge">data</code>) : start executing if <code class="language-plaintext highlighter-rouge">data</code> has been received</li>
  <li>user_defined_function: the user can also define its own function with more complex logic</li>
</ul>

<p>With trigger_any being the default, the current semantics of the rclcpp Executor is selected.</p>

<p>The data communication semantics can be</p>
<ul>
  <li>ROS2 (default)</li>
  <li>LET</li>
</ul>

<p>To be compatible with ROS2 rclcpp Executor, the existing rclcpp semantics is implemented as ROS2. That is, with the spin-function the DDS-queue is constantly monitored for new data (rcl_wait). If new data becomes available, then is fetched from DDS (rcl_take) immediately before the callback is executed. All callbacks are processed in the user-defined order, this is the only difference to the rclcpp Executor, in which no order can be specified.</p>

<p>Secondly, the LET semantics is implemented such that at the beginning of processing all available data is fetched (rcl_take) and buffered and then the callbacks are processed in the pre-defined operating on the buffered copy.</p>

<h4 id="running-phase">Running phase</h4>

<p>As the main functionality, the Executor has a <code class="language-plaintext highlighter-rouge">spin</code>-function which constantly checks for new data at the DDS-queue, like the rclcpp Executor in ROS2. If the trigger condition is satisfied then all available data from the DDS queue is processed according to the specified semantics (ROS or LET) in the user-defined sequential order. After all callbacks have been processed the DDS is checked for new data again.</p>

<p>Available spin functions are</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">spin_some</code>  - spin one time</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin_period</code> - spin with a period</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin</code> - spin indefinitly</li>
</ul>

<h3 id="examples">Examples</h3>
<p>We provide the relevant code snippets how to setup the rclc Executor for the processing patterns as described above.</p>

<h4 id="sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</h4>

<p>In this example we want to realise a sense-plan-act pipeline in a single thread. The trigger condition is demonstrated by activating
the sense-phase when both data for the Laser and IMU are available. Three executors are necessary <code class="language-plaintext highlighter-rouge">exe_sense</code>, <code class="language-plaintext highlighter-rouge">exe_plan</code> and <code class="language-plaintext highlighter-rouge">exe_act</code>. The two sensor acquisition callbacks <code class="language-plaintext highlighter-rouge">sense_Laser</code> and <code class="language-plaintext highlighter-rouge">sense_IMU</code> are registered in the Executor <code class="language-plaintext highlighter-rouge">exe_sense</code>.
The trigger condition ALL is responsible to activate the sense-phase only when all data for these two callbacks are available. Finally all three Executors are spinning using a <code class="language-plaintext highlighter-rouge">while</code>-loop and the <code class="language-plaintext highlighter-rouge">spin_some</code> function.</p>

<p>The definitions of callbacks are omitted.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act;
rcle_let_executor_t exe_sense, exe_plan, exe_act;
// initialize executors
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
rclc_executor_init(&amp;exe_plan, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_act, &amp;context, 1, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb1, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_let_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);
// executor for plan-phase
rclc_executor_add_subscription(&amp;exe_plan, &amp;plan, &amp;my_sub_cb3, ON_NEW_DATA);
// executor for act-phase
rclc_executor_add_subscription(&amp;exe_act, &amp;act, &amp;my_sub_cb4, ON_NEW_DATA);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_sense);
  rclc_executor_spin_some(&amp;exe_plan);
  rclc_executor_spin_some(&amp;exe_act);
}

</code></pre>

<h4 id="synchronization-of-multiple-rates-example">Synchronization of multiple rates example</h4>

<p>The sensor fusion synchronizing the multiple rates with a trigger is shown below.</p>

<pre><code class="language-C">...
rcl_subscription_t aggr_IMU, sense_Laser, sense_IMU;
rcle_let_executor_t exe_aggr, exe_sense;
// initialize executors
rclc_executor_init(&amp;exe_aggr, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for aggregate IMU data
rclc_executor_add_subscription(&amp;exe_aggr, &amp;aggr_IMU, &amp;my_sub_cb1, ON_NEW_DATA);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb3, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_aggr);
  rclc_executor_spin_some(&amp;exe_sense);
}

</code></pre>

<p>The setup for the sensor fusion using sequential execution is shown below.
Note that the sequetial order is <code class="language-plaintext highlighter-rouge">sense_IMU</code>, which will request the aggregated IMU message, and then <code class="language-plaintext highlighter-rouge">sense_Laser</code>
while the trigger will fire, when a laser message is received.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU;
rcle_let_executor_t exe_sense;
// initialize executor
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe_sense);

</code></pre>
<h4 id="high-priority-processing-path-example">High priority processing path example</h4>

<p>This example shows the sequential processing order to execute the obstacle avoidance <code class="language-plaintext highlighter-rouge">obst_avoid</code>
after the callbacks of the sense-phase and before the callback of the planning phase <code class="language-plaintext highlighter-rouge">plan</code>.
The control loop is started when a laser message is received. Then an aggregated IMU message is requested,
like in the example above. Then all the other callbacks are always executed. This assumes that these callbacks
communicate via a global data structure. Race conditions cannot occur, because the callbacks
run all in one thread.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act, obst_avoid;
rcle_let_executor_t exe;
// initialize executors
rclc_executor_init(&amp;exe, &amp;context, 5, ...);
// define processing order
rclc_executor_add_subscription(&amp;exe, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe, &amp;obst_avoid, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;plan, &amp;my_sub_cb4, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;act, &amp;my_sub_cb5, ALWAYS);
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="real-time-embedded-applications-example">Real-time embedded applications example</h4>

<p>With seqential execution the co-operative scheduling of tasks within a process can be modeled. The trigger condition is used to periodically activate the process which will then execute all callbacks in a pre-defined order. Data will be communicated using the LET-semantics. Every Executor is executed in its own tread, to which an appropriate priority can be assigned.</p>

<p>In the following example, the Executor is setup with 4 handles. We assume a process has three subscriptions <code class="language-plaintext highlighter-rouge">sub1</code>, <code class="language-plaintext highlighter-rouge">sub2</code>, <code class="language-plaintext highlighter-rouge">sub3</code>. The sequential processing order is given by the order as they are added to the Executor. A timer <code class="language-plaintext highlighter-rouge">timer</code> defines the period.  The <code class="language-plaintext highlighter-rouge">trigger_one</code> with the paramter <code class="language-plaintext highlighter-rouge">timer</code> is used, so that whenever the timer is ready, all callbacks are processed. Finally the data communication semantics LET is defined.</p>

<pre><code class="language-C">#include "rcl_executor/let_executor.h"

// define subscription callback
void my_sub_cb1(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb2(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb3(const void * msgin)
{
  // ...
}

// define timer callback
void my_timer_cb(rcl_timer_t * timer, int64_t last_call_time)
{
  // ...
}

// necessary ROS 2 objects
rcl_context_t context;   
rcl_node_t node;
rcl_subscription_t sub1, sub2, sub3;
rcl_timer_t timer;
rcle_let_executor_t exe;

// define ROS context
context = rcl_get_zero_initialized_context();
// initialize ROS node
rcl_node_init(&amp;node, &amp;context,...);
// create subscriptions
rcl_subscription_init(&amp;sub1, &amp;node, ...);
rcl_subscription_init(&amp;sub2, &amp;node, ...);
rcl_subscription_init(&amp;sub3, &amp;node, ...);
// create a timer
rcl_timer_init(&amp;timer, &amp;my_timer_cb, ... );
// initialize executor with four handles
rclc_executor_init(&amp;exe, &amp;context, 4, ...);
// define static execution order of handles
rclc_executor_add_subscription(&amp;exe, &amp;sub1, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub2, &amp;my_sub_cb2, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub3, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_timer(&amp;exe, &amp;timer);
// trigger when handle 'timer' is ready
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;timer);
// select LET-semantics
rclc_executor_data_comm_semantics(&amp;exe, LET);
// spin forever
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</h4>
<p>The rclc Executor has been presented at the workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at <a href="https://roscon.ros.org/world/2021/">ROS World 2021</a> (i.e. the online version of ROSCon)[<a href="https://github.com/ros2/rclc/tree/galactic/rclc/#S2021">S2021</a>]. A <a href="https://github.com/ros-realtime/reference-system">Reference System</a> for testing and benchmarking ROS Executors has been developed for this workshop. The application of the rclc Executor on the reference system with the trigger condition can be found in the <a href="https://github.com/ros-realtime/reference-system/tree/rclc_executor">rclc-executor branch of the Reference System</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/IazrPF3RN1U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>The slides can be downloaded <a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">here</a>. All information and the videos and slides of the other talks of the workshop can be found at <a href="https://www.apex.ai/roscon-21">www.apex.ai/roscon-21</a>.</p>

<h3 id="future-work">Future work</h3>

<ul>
  <li>Full LET semantics (writing data at the end of the period)
    <ul>
      <li>one publisher that periodically publishes</li>
      <li>if Executors are running in multiple threads,
publishing needs to be atomic</li>
    </ul>
  </li>
  <li>Multi-threaded executor with assignment of scheduling policies of unerlying operating system. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, pre-print <a href="https://github.com/ros2/rclc/tree/galactic/rclc/#SLD2021">SLD2021</a>].</li>
</ul>

<h3 id="download">Download</h3>
<p>The rclc Executor can be downloaded from the <a href="https://github.com/ros2/rclc">ros2/rclc repository</a>. It is available for the ROS 2 versions Foxy, Galactic and Rolling. The repository provides several packages including the <a href="https://github.com/ros2/rclc/tree/master/rclc">rclc Executor</a> and an <a href="https://github.com/ros2/rclc/tree/master/rclc_examples">rclc_examples package</a> with several application examples.</p>

<h2 id="callback-group-level-executor">Callback-group-level Executor</h2>

<p>The Callback-group-level Executor was an early prototype for a refined rclcpp Executor API developed in micro-ROS. It has been derived from the default rclcpp Executor and addresses some of the aforementioned deficits. Most important, it was used to validate that the underlying layers (rcl, rmw, rmw_adapter, DDS) allow for multiple Executor instances without any negative interferences.</p>

<p>As the default rclcpp Executor works at a node-level granularity  which is a limitation given that a node may issue different callbacks needing different real-time guarantees - we decided to refine the API for more fine-grained control over the scheduling of callbacks on the granularity of callback groups using. We leverage the callback-group concept existing in rclcpp by introducing real-time profiles such as RT-CRITICAL and BEST-EFFORT in the callback-group API (i.e. rclcpp/callback_group.hpp). Each callback needing specific real-time guarantees, when created, may therefore be associated with a dedicated callback group. With this in place, we enhanced the Executor and depending classes (e.g., for memory allocation) to operate at a finer callback-group granularity. This allows a single node to have callbacks with different real-time profiles assigned to different Executor instances - within one process.</p>

<p>Thus, an Executor instance can be dedicated to specific callback group(s) and the Executors thread(s) can be prioritized according to the real-time requirements of these groups. For example, all time-critical callbacks are handled by an RT-CRITICAL Executor instance running at the highest scheduler priority.</p>

<p>The following Figure illustrates this approach with two nodes served by three Callback-group-level Executors in one process:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/cbg-executor_sample_system.png" alt="Sample system with two nodes and three Callback-group-level Executors in one process" width="60%">
</center>

<p>The different callbacks of the Drive-Base node are distributed to different Executors (visualized by the color red, yellow and green).  For example the onCmdVel and publishWheelTicks callback are scheduled by the same Executor (yellow). Callbacks from different nodes can be serviced by the same Executor.</p>

<h3 id="api-changes">API Changes</h3>

<p>In this section, we describe the necessary changes to the Executor API:</p>
<ul>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/callback_group.hpp">include/rclcpp/callback_group.hpp</a>:</p>

    <ul>
      <li>Introduced an enum to distinguish up to three real-time classes (requirements) per node (RealTimeCritical, SoftRealTime, BestEffort)</li>
      <li>Changed association with Executor instance from nodes to callback groups.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">include/rclcpp/executor.hpp</a></p>

    <ul>
      <li>
        <p>Added functions to add and remove individual callback groups in addition to whole nodes.</p>
      </li>
      <li>
        <p>Replaced private vector of nodes with a map from callback groups to nodes.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/memory_strategy.hpp">include/rclcpp/memory_strategy.hpp</a></p>

    <ul>
      <li>Changed all functions that expect a vector of nodes to the just mentioned map.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node.hpp">include/rclcpp/node.hpp</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node_interfaces/node_base.hpp">include/rclcpp/node_interfaces/node_base.hpp</a></p>

    <ul>
      <li>Extended arguments of create_callback_group function for the real-time class.</li>
      <li>Removed the get_associated_with_executor_atomic function.</li>
    </ul>
  </li>
</ul>

<p>The callback-group-level executor has been merged into ROS 2 rclcpp in <a href="https://github.com/ros2/rclcpp/pull/1218/commits">pull request 1218</a>.</p>

<h3 id="test-bench">Test Bench</h3>

<p>As a proof of concept, we implemented a small test bench in the present package cbg-executor_ping-pong_cpp. The test bench comprises a Ping node and a Pong node which exchange real-time and best-effort messages simultaneously with each other. Each class of messages is handled with a dedicated Executor, as illustrated in the following Figure.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/ping_pong_diagram.png" alt="Architecture for the Callback-group-level Executor test bench" width="100%">
</center>

<p>With the test bench, we validated the functioning of the approach.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/cbg_executor_demo_plot.png" alt="Results from Callback-group-level Executor test bench" width="80%">
</center>

<p>In this example, the callback for the high priority task (red line) consumes 10ms and the low priority task (blue line) 40ms in the Pong Node. With a ping rate of 20 Hz, the CPU saturates (10ms*20+40ms*20=1000ms). With higher frequencies the high priorty task can continue to send its pong message, while the low priority pong task degrades. With a frequency of 100Hz the high priority task requires 100% CPU utilization. With higher ping rates it keeps sending pong messages with 100Hz, while the low priority task does not get any CPU ressources any more and cannot send any messages.</p>

<p>The test bench is provided in the <a href="https://github.com/ros2/examples/tree/master/rclcpp/executors/cbg_executor">cbg_executor_demo</a>.</p>

<h2 id="related-work">Related Work</h2>

<p>In this section, we provide an overview to related approaches and link to the corresponding APIs.</p>

<h3 id="fawkes-framework">Fawkes Framework</h3>

<p><a href="http://www.fawkesrobotics.org/">Fawkes</a> is a robotic software framework, which supports synchronization points for sense-plan-act like execution. It has been developed by RWTH Aachen since 2006. Source code is available at <a href="https://github.com/fawkesrobotics">github.com/fawkesrobotics</a>.</p>

<h4 id="synchronization">Synchronization</h4>
<p>Fawkes provides developers different synchronization points, which are very useful for defining an execution order of a typical sense-plan-act application. These ten synchronization points (wake-up hooks) are the following (cf. <a href="https://github.com/fawkesrobotics/fawkes/blob/master/src/libs/aspect/blocked_timing.h">libs/aspect/blocked_timing.h</a>):</p>

<ul>
  <li>WAKEUP_HOOK_PRE_LOOP</li>
  <li>WAKEUP_HOOK_SENSOR_ACQUIRE</li>
  <li>WAKEUP_HOOK_SENSOR_PREPARE</li>
  <li>WAKEUP_HOOK_SENSOR_PROCESS</li>
  <li>WAKEUP_HOOK_WORLDSTATE</li>
  <li>WAKEUP_HOOK_THINK</li>
  <li>WAKEUP_HOOK_SKILL</li>
  <li>WAKEUP_HOOK_ACT</li>
  <li>WAKEUP_HOOK_ACT_EXEC</li>
  <li>WAKEUP_HOOK_POST_LOOP</li>
</ul>

<h4 id="configuration-at-compile-time">Configuration at compile time</h4>
<p>At compile time, a desired synchronization point is defined as a constructor parameter for a module. For example, assuming that <code class="language-plaintext highlighter-rouge">mapLaserGenThread</code> shall be executed in SENSOR_ACQUIRE, the constructor is implemented as:</p>

<pre><code class="language-C++">MapLaserGenThread::MapLaserGenThread()
  :: Thread("MapLaserGenThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE),
     TransformAspect(TransformAspect::BOTH_DEFER_PUBLISHER, "Map Laser Odometry")

</code></pre>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">NaoQiButtonThread</code> shall be executed in the SENSOR_PROCESS hook, the constructor is:</p>

<pre><code class="language-C++">NaoQiButtonThread::NaoQiButtonThread()
  :: Thread("NaoQiButtonThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS)

</code></pre>

<h4 id="runtime-execution">Runtime execution</h4>
<p>At runtime, the <em>Executor</em> iterates through the list of synchronization points and executes all registered threads until completion. Then, the threads of the next synchronization point are called.</p>

<p>A module (thread) can be configured independent of these sense-plan-act synchronization points. This has the effect, that this thread is executed in parallel to this chain.</p>

<p>The high level overview of the Fawkes framework is shown in the next figure. At compile-time the configuration of the sense-plan act wakeup hook is done (upper part), while at run-time the scheduler iterates through this list of wakeup-hooks (lower part):</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/galactic/rclc/png/fawkes_executor_diagram.png" alt="Sequence diagram for Fawkes Executor" width="50%">
</center>

<p>Hence, at run-time, the hooks are executed as a fixed static schedule without preemption. Multiple threads registered in the same hook are executed in parallel.</p>

<p>Orthogonal to the sequential execution of sense-plan-act like applications, it is possible to define further constraints on the execution order by means of a <code class="language-plaintext highlighter-rouge">Barrier</code>. A barrier defines a number of threads, which need to have finished before the thread can start, which owns the barrier.</p>

<p>These concepts are implemented by the following main classes:</p>

<ul>
  <li>
<em>Wakeup hook</em> by <code class="language-plaintext highlighter-rouge">SyncPoint</code> and <code class="language-plaintext highlighter-rouge">SyncPointManager</code>, which manages a list of synchronization points.</li>
  <li>
<em>Executor</em> by the class <code class="language-plaintext highlighter-rouge">FawkesMainThread</code>, which is the scheduler, responsible for calling the user threads.</li>
  <li>
<code class="language-plaintext highlighter-rouge">ThreadManager</code>, which is derived from <code class="language-plaintext highlighter-rouge">BlockedTimingExecutor</code>, provides the necessary API to add and remove threads to wakeup hooks as well as for sequential execution of the wakeup-hooks.</li>
  <li>
<code class="language-plaintext highlighter-rouge">Barrier</code> is an object similar to <code class="language-plaintext highlighter-rouge">condition_variable</code> in C++.</li>
</ul>

<h4 id="discussion">Discussion</h4>

<p>All threads are executed with the same priority. If multiple sense-plan-act chains shall be executed with different priorities, e.g. to prefer execution of emergency-stop over normal operation, then this framework reaches its limits.</p>

<p>Also, different execution frequencies cannot be modeled by a single instance of this sense-plan-act chain. However, in robotics the fastest sensor will drive the chain and all other hooks are executed with the same frequency.</p>

<p>The option to execute threads independent of the predefined wakeup-hooks is very useful, e.g. for diagnostics. The concept of the Barrier is useful for satisfying functional dependencies which need to be considered in the execution order.</p>

<!--
### Orocos

TODO INSERT DESCRIPTION ON PARTIAL ORDER SCHEDULING.


### CoSiMA

TODO INSERT DESCRIPTION ON MODEL-BASED APPROACH BY COSIMA (ON TOP OF OROCOS) FROM FOLLOWING PAPER:

D. L. Wigand, P. Mohammadi, E. M. Hoffman, N. G. Tsagarakis, J. J. Steil and S. Wrede, "An open-source architecture for simulation, execution and analysis of real-time robotics systems," 2018 IEEE International Conference on Simulation, Modeling, and Programming for Autonomous Robots (SIMPAR), Brisbane, QLD, 2018, pp. 93-100.
doi: 10.1109/SIMPAR.2018.8376277
URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8376277&isnumber=8376259
-->

<h2 id="references">References</h2>
<ul>
  <li>
    <p>[S2021]<a name="S2021"></a> J. Staschulat, Micro-ROS: The rclc Executor, in Workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at ROS World, Oct. 2021, [<a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">slides</a>] [<a href="https://www.youtube.com/embed/IazrPF3RN1U">Video</a>]</p>
  </li>
  <li>
    <p>[SLD2021]<a name="SLD2021"></a> J. Staschulat, R. Lange and D. N. Dasari, Budget-based real-time Executor for Micro-ROS, arXiv Pre-Print, May 2021. [<a href="https://arxiv.org/abs/2105.05590">paper</a>]</p>
  </li>
  <li>
    <p>[L2020]<a name="L2020"></a> Ralph Lange: Advanced Execution Management with ROS 2, ROS-Industrial Conference, Dec 2020 <a href="https://micro-ros.github.io/download/2020-12-16_Advanced_Execution_Management_with_ROS_2.pdf">[Slides]</a></p>
  </li>
  <li>
    <p>[SLL2020]<a name="SLL2020"></a> J. Staschulat, I. Ltkebohle and R. Lange, The rclc Executor: Domain-specific deterministic scheduling mechanisms for ROS applications on microcontrollers: work-in-progress, 2020 International Conference on Embedded Software (EMSOFT), Singapore, Singapore, 2020, pp. 18-19. <a href="https://ieeexplore.ieee.org/document/9244014">[Paper]</a> <a href="https://whova.com/embedded/session/eswe_202009/1145800/">[Video]</a></p>
  </li>
  <li>
    <p>[CB2019]<a name="CB2019"> </a> D. Casini, T. Bla, I. Ltkebohle, B. Brandenburg: Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling, in Euromicro-Conference on Real-Time Systems 2019. <a href="http://drops.dagstuhl.de/opus/volltexte/2019/10743/">[Paper]</a> <a href="https://t-blass.de/talks/ECRTS2019.pdf">[slides]</a></p>
  </li>
  <li>
    <p>[L2018]<a name="L2018"></a> Ralph Lange: Callback-group-level Executor for ROS 2. Lightning talk at ROSCon 2018. Madrid, Spain. Sep 2018. <a href="https://roscon.ros.org/2018/presentations/ROSCon2018_Lightning1_4.pdf">[Slides]</a> <a href="https://vimeo.com/292707644">[Video]</a></p>
  </li>
  <li>
    <p>[EK2018]<a name="EK2018"></a> R. Ernst, S. Kuntz, S. Quinton, M. Simons: The Logical Execution Time Paradigm: New Perspectives for Multicore Systems, February 25-28 2018 (Dagstuhl Seminar 18092). <a href="http://drops.dagstuhl.de/opus/volltexte/2018/9293/pdf/dagrep_v008_i002_p122_18092.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[NSP2018]<a name="NSP2018"></a> A. Naderlinger, S. Resmerita, and W. Pree: LET for Legacy and Model-based Applications,
Proceedings of The Logical Execution Time Paradigm: New Perspectives for Multicore Systems (Dagstuhl Seminar 18092), Wadern, Germany, February 2018.</p>
  </li>
  <li>
    <p>[BP2017]<a name="BP2017"></a> A. Biondi, P. Pazzaglia, A. Balsini,  M. D. Natale: Logical Execution Time Implementation and Memory Optimization Issues in AUTOSAR Applications for Multicores, International Worshop on Analysis Tools and Methodologies for Embedded and Real-Time Systems (WATERS2017), Dubrovnik, Croatia.<a href="https://pdfs.semanticscholar.org/4a9e/b9a616c25fd0b4a4f7810924e73eee0e7515.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[KZH2015]<a name="KZH2015"></a> S. Kramer, D. Ziegenbein, and A. Hamann: Real World Automotive Benchmarks For Free, International Workshop on Analysis Tools and Methodologies for Embedded adn Real-Time Sysems (WATERS), 2015.</p>
  </li>
  <li>
    <p>[HHK2001]<a name="HHK2001"></a> Henzinger T.A., Horowitz B., Kirsch C.M. (2001) Giotto: A Time-Triggered Language for Embedded Programming. In: Henzinger T.A., Kirsch C.M. (eds) Embedded Software. EMSOFT 2001. Lecture Notes in Computer Science, vol 2211. Springer, Berlin, Heidelberg</p>
  </li>
  <li>
    <p>[LL1973]<a name="LL1973"></a> Liu, C. L.; Layland, J.:Scheduling algorithms for multiprogramming in a hard real-time environment, Journal of the ACM, 20 (1): 4661, 1973.</p>
  </li>
</ul>
</div>
              </div>
            </div>
          </div>
        </div>
      
    
    <div class="row">
      <div class="col-xs-12">
        <div class="panel panel-default">
          <div class="panel-heading"><span class="glyphicon glyphicon-list"></span> CHANGELOG</div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="changelog-for-package-rclc">Changelog for package rclc</h1>

<h2 id="206-2022-01-25">2.0.6 (2022-01-25)</h2>

<ul>
  <li>[backport galactic, foxy] data_available optimization (#212)</li>
  <li>Fix data_available reset for timer (#215) (#216)</li>
  <li>Executor ignore canceled timers (#220) (#221)</li>
  <li>Resolved error in unit test see issue #230 (#231) (#232)</li>
  <li>Updated documentation README.md (#229)</li>
</ul>

<h2 id="205-2021-11-08">2.0.5 (2021-11-08)</h2>

<ul>
  <li>Fix printf in executor spin</li>
  <li>Fix init options handling</li>
</ul>

<h2 id="204-2021-08-19">2.0.4 (2021-08-19)</h2>

<ul>
  <li>Refactoring: remove callback_type</li>
  <li>Improvement: Checking for valid ROS context in spin_some</li>
  <li>Bug fix: Ignoring unsuccessful SERVICE_TAKE</li>
  <li>Bug fix: Updated ci workflow dependency on galactic</li>
  <li>Improvement: Updated codecov configuration to ignore unit tests</li>
</ul>

<h2 id="203-2021-07-26">2.0.3 (2021-07-26)</h2>

<ul>
  <li>Updated codecov to ignore test folders</li>
  <li>Updated bloom release status table</li>
</ul>

<h2 id="202-2021-07-17">2.0.2 (2021-07-17)</h2>

<ul>
  <li>Added rclc_parameter package</li>
  <li>Added quality of service entity creation API</li>
  <li>Addded executor_prepare API</li>
  <li>Added support for removing subscription from executor</li>
  <li>Added support for subscription with context</li>
  <li>Updated compatability function for sleep</li>
  <li>Removed duplicate NOTICE files</li>
</ul>

<h2 id="201-2021-05-28">2.0.1 (2021-05-28)</h2>

<ul>
  <li>added quality declaration</li>
</ul>

<h2 id="200-2021-04-23">2.0.0 (2021-04-23)</h2>

<ul>
  <li>added codecov support</li>
  <li>new API of rcl_lifecycle in Rolling required major version bump</li>
</ul>

<h2 id="101-2021-03-29">1.0.1 (2021-03-29)</h2>

<ul>
  <li>Windows port</li>
  <li>Compatibility sleep function (Windows, POSIX-OS)</li>
  <li>Fixed RCL lifecycle API change for Rolling</li>
</ul>

<h2 id="100-2021-03-04">1.0.0 (2021-03-04)</h2>

<ul>
  <li>service callbacks with context</li>
  <li>fixed minor issues unit tests</li>
  <li>upgraded setup_ros action (ci jobs)</li>
  <li>removed Eloquent from ci jobs</li>
</ul>

<h2 id="017-2021-01-20">0.1.7 (2021-01-20)</h2>

<ul>
  <li>Corrected corrupted changelog</li>
</ul>

<h2 id="016-2021-01-20">0.1.6 (2021-01-20)</h2>

<ul>
  <li>Fixed issues due to Github Action timing delays on cloud build</li>
  <li>Fixed missing package dependency in Github Action for Eloquent</li>
</ul>

<h2 id="015-2020-12-11">0.1.5 (2020-12-11)</h2>

<ul>
  <li>Added support for services,clients and guard_conditions to rclc
executor</li>
  <li>Added table for bloom release status in README file</li>
</ul>

<h2 id="014-2020-11-25">0.1.4 (2020-11-25)</h2>

<ul>
  <li>Fixed error in bloom release</li>
</ul>

<h2 id="013-2020-11-23">0.1.3 (2020-11-23)</h2>

<ul>
  <li>Added rclc_lifecycle package</li>
  <li>Change maintainer information</li>
  <li>Minor fixes, updated unit tests</li>
</ul>

<h2 id="012-2020-05-19">0.1.2 (2020-05-19)</h2>

<ul>
  <li>Fixed compiler errors for bloom release</li>
</ul>

<h2 id="011-2020-05-14">0.1.1 (2020-05-14)</h2>

<ul>
  <li>Initial release</li>
</ul>
</div>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="galactic-tutorials">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Wiki Tutorials</h3>
      </div>
      <div class="panel-body">
        
        <em>This package does not provide any links to tutorials in it's <a href="https://index.ros.org/contribute/metadata/">rosindex metadata</a>.</em>
        <em>You can check on the <a href="http://wiki.ros.org/rclc/Tutorials" target="_blank">ROS Wiki Tutorials</a> page for the package.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="galactic-deps">
    <div class="row">
      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Package Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th class="text-center">Deps</th>
                  <th style="width: 100%">Name</th>
                </thead>
                <tbody>
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl#galactic">rcl  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcutils#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcutils#galactic">rcutils  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_generator_c#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_generator_c#galactic">rosidl_generator_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_typesupport_c#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_typesupport_c#galactic">rosidl_typesupport_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_ros#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_ros#galactic">ament_cmake_ros  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_gtest#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_gtest#galactic">ament_cmake_gtest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_pytest#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_pytest#galactic">ament_cmake_pytest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_auto#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_auto#galactic">ament_lint_auto  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_common#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_common#galactic">ament_lint_common  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/launch_testing#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/launch_testing#galactic">launch_testing  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/osrf_testing_tools_cpp#galactic-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/osrf_testing_tools_cpp#galactic">osrf_testing_tools_cpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/std_msgs#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/std_msgs#galactic">std_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/test_msgs#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/test_msgs#galactic">test_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/example_interfaces#galactic-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/example_interfaces#galactic">example_interfaces  </a></td>
                      </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
          <div class="panel-heading">
            <h3 class="panel-title">System Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <em>No direct system dependencies.</em>
            
          </div>
        </div>
      </div>

      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Dependant Packages</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th>Name</th>
                  <th class="text-center">Deps</th>
                </thead>
                <tbody>
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_common_diagnostics#galactic">micro_ros_common_diagnostics</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_common_diagnostics#galactic-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_diagnostic_updater#galactic">micro_ros_diagnostic_updater</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_diagnostic_updater#galactic-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_examples#galactic">rclc_examples</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_examples#galactic-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_lifecycle#galactic">rclc_lifecycle</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_lifecycle#galactic-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_parameter#galactic">rclc_parameter</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_parameter#galactic-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="galactic-assets">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Launch files</h3>
      </div>
      <div class="panel-body">
        
          <em>No launch files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Messages</h3>
      </div>
      <div class="panel-body">
        
          <em>No message files found.</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Services</h3>
      </div>
      <div class="panel-body">
        
          <em>No service files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Plugins</h3>
      </div>
      <div class="panel-body">
        
          <em>No plugins found.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="galactic-questions">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Recent questions tagged <kbd>rclc</kbd> at <strong><a href="https://robotics.stackexchange.com/" target="_blank">Robotics Stack Exchange</a></strong></h3>      </div>
      <div id="galactic-question-list" class="panel-body" style="display: none;"></div>
      <div id="galactic-no-question-list" class="panel-body" style="display: none;">
        <p>No questions yet, you can ask one <a href="https://robotics.stackexchange.com/questions/tagged/rclc+galactic">here</a>.</p>
      </div>
      <div id="galactic-get-question-fail" class="panel-body alert alert-warning" style="display: none;">
        <p>Failed to get question list, you can ticket an issue <a href="https://github.com/ros-infrastructure/rosindex/issues/new" target="_blank" class="alert-link">here</a> </p>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript" src="/js/package_body_tabs.js"></script>

<script src=/js/contribution_suggestions.js></script>
<script type="text/javascript">
jQuery(function() {
    // Update the count on the links to the contribution suggestions
    updateContributionSuggestionsCountOnPackage('https://github.com/ros2/rclc.git');
});
</script>

          </div>
          <div class="col-md-2 hidden-xs hidden-sm">
            
            
            



<div class="list-group list-group-sm ">
  <a class="list-group-item"
     target="_blank"
     href="http://docs.ros.org/en/galactic/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       
       API Docs
  </a>
  <a class="list-group-item"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/galactic/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       
       Browse Code
  </a>
  
  
  
  
  
  
</div>

          </div>
        </div>
      
    </div>
  </div>

  <div class="distro distro-iron">
    <div class="container-fluid">
      
        
        
        

        <div class="row">
          <div class="col-md-10">
            

<div class="well well-sm">
  
  <table class="table">
    <tr>
      <td width="100px" class="text-center">
        <img style="width: 80px" src="/assets/package.png">
      </td>
      <td>
        <h3 style="margin-top: 5px">
          <a style="text-decoration:none" href="/p/rclc">rclc</a> <small>package from <a style="text-decoration:none" href="/r/rclc/github-ros2-rclc">rclc</a> repo</small>
        </h3>
          
            
            
              <span class="label label-default pkg-label">

rclc
</span>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_examples">

rclc_examples
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_lifecycle">

rclc_lifecycle
</a>
            
          
            
            
              <a class="label label-primary pkg-label" href="/p/rclc_parameter">

rclc_parameter
</a>
            
          
      </td>
    </tr>
  </table>
</div>

            <div class="visible-xs visible-sm">
              
              
              



<div class="list-group list-group-sm list-group-horizontal list-group-justified">
  <a class="list-group-item text-center"
     target="_blank"
     href="http://docs.ros.org/en/iron/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       <br>
       API Docs
  </a>
  <a class="list-group-item text-center"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/iron/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       <br>
       Browse Code
  </a>
  
  
  
  
  
  
</div>

            </div>
            



<ul class="nav nav-tabs nav-justified" id="iron-tabs" style="margin-bottom:20px">
  <li class="better-tabs active">
    <a href="#iron-overview" data-toggle="tab">Overview</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    
    <a href="#iron-assets" data-toggle="tab"><span class="label label-default">0</span> Assets</a>
  </li>
  <li class="better-tabs">
    
    
    
    
    <a href="#iron-deps" data-toggle="tab"><span class="label label-primary">17</span> Dependencies</a>
  </li>
  <li class="better-tabs">
    
    <a href="#iron-tutorials" data-toggle="tab"><span class="label label-default">0</span> Tutorials</a>
  </li>
  <li class="better-tabs">
    <a href="#iron-questions" data-toggle="tab"><span id="iron-questions-count" class="label label-primary">0</span> Q & A</a>
  </li>
</ul>

<div class="tab-content">
  <div class="tab-pane active" id="iron-overview">
    
    <div class="row">
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h4 class="panel-title">Package Summary</h4></div>
          <div class="panel-body">
            <table class="table table-condensed">
              <tr>
                <td style="width:100px;" class="text-right"><strong>Tags</strong></td>
                <td>
                  
                  
                    <em>No category tags.</em>
                  
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Version</strong></td>
                <td>5.0.1</td>
              </tr>
              <tr>
                <td class="text-right"><strong>License</strong></td>
                <td>Apache License 2.0</td>
              </tr>
              <tr>
                <td class="text-right"><strong>Build type</strong></td>
                <td>
                  
                    <span class="label label-default">
                  
                    AMENT_CMAKE</span>
                </td>
              </tr>
              <tr>
                <td class="text-right"><strong>Use</strong></td>
                <td>
                
                  <span class="label label-success">RECOMMENDED</span>
                
                </td>
              </tr>
            </table>
          </div>
          <div class="panel-heading"><h3 class="panel-title">Repository Summary</h3></div>
          <div class="panel-body">
            
            
            
  <link rel="stylesheet" href="/css/ci-status.css">
  <table class="table table-condensed">
    <tr>
      <td class="text-right"><b>Description</b></td>
      <td><span class="label label-default">ROS Client Library for the C language.</span></td>
    </tr>
    <tr>
      <td style="width:100px;" class="text-right"><b>Checkout URI</b></td>
      <td><a class="label label-default" href="https://github.com/ros2/rclc.git">https://github.com/ros2/rclc.git</a></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Type</b></td>
      <td><span class="label label-default">git</span></td>
    </tr>
    <tr>
      <td class="text-right"><b>VCS Version</b></td>
      <td><span class="label label-default">iron</span></td>
    </tr>
    <tr>
      <td style="white-space: nowrap;" class="text-right"><b>Last Updated</b></div>
      <td>
        
          <span class="label label-default"><span class="glyphicon glyphicon-time"></span> 2023-12-14
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Dev Status</b></td>
      <td>
        
          
            <span class="label label-success">
          
          DEVELOPED
        </span>
      </td>
    </tr>
              <tr>
                <td class="text-right"><b>CI status</b></td>
                <td class="ci-status">
                  
                  
                    <span class="label label-default" title="No CI information available for this package.">No Continuous Integration</span>
                  
                </td>
              </tr>
    <tr>
      <td class="text-right"><b>Released</b></td>
      <td>
        
          <span class="label label-primary"><span class="glyphicon glyphicon-flash"></span> RELEASED
        </span>
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Tags</b></td>
      <td>
        
        
          <em>No category tags.</em>
        
      </td>
    </tr>
    <tr>
      <td class="text-right"><b>Contributing</b></td>
      <td>
        <a class="label label-primary" href="/r/rclc/#iron-contribute-lists-help-wanted">
          Help Wanted (<span class="contribute-lists-help-wanted-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#iron-contribute-lists-good-first-issue">
          Good First Issues (<span class="contribute-lists-good-first-issue-count">0</span>)
        </a>
        <br>
        <a class="label label-primary" href="/r/rclc/#iron-contribute-lists-pull-requests">
          Pull Requests to Review (<span class="contribute-lists-pull-requests-count">0</span>)
        </a>
      </td>
    </tr>
  </table>

          </div>
        </div>
      </div>
      <div class="col-xs-12 col-sm-6 col-md-6 col-lg-6">
        <div class="panel panel-default">
          <div class="panel-heading"><h3 class="panel-title">Package Description</h3></div>
          <div class="panel-body">
            The ROS client library in C.
          </div>
          <div class="panel-heading"><h4 class="panel-title">Additional Links</h4></div>
          <div class="panel-body">
            
            
              <em>No additional links.</em>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Maintainers</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>Pablo Garrido</li>
                
              </ul>
            
          </div>
          <div class="panel-heading"><h4 class="panel-title">Authors</h4></div>
          <div class="panel-body">
            
            
              <ul class="list-unstyled">
                
                  <li>Jan Staschulat</li>
                
                  <li>William Woodall</li>
                
              </ul>
            
          </div>
        </div>
      </div>
    </div>
    
      
        <div class="row">
          <div class="col-xs-12">
            <div class="panel panel-default">
              <div class="panel-heading"><span class="glyphicon glyphicon-file"></span><a href="https://github.com/ros2/rclc/tree/iron/rclc/README.md" title="Open in git repository">rclc/README.md</a></div>
              <div class="panel-body">
                    <div class="rendered-markdown">
<h1 id="the-rclc-package">The rclc package</h1>

<h2 id="table-of-contents">Table of contents</h2>

<ul>
  <li>
    <p><a href="https://github.com/ros2/rclc/tree/iron/rclc/#introduction">Introduction</a></p>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/iron/rclc/#analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#architecture">Architecture</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#scheduling-semantics">Scheduling Semantics</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/iron/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#synchronization-of-multiple-rates">Synchronization of multiple rates</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#high-priority-processing-path">High-priority processing path</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#real-time-embedded-applications">Real-time embedded applications</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/iron/rclc/#rclc-executor">rclc Executor</a>
    <ul>
      <li>
<a href="https://github.com/ros2/rclc/tree/iron/rclc/#features">Features</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#trigger-condition">Trigger condition</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#sequential-execution">Sequential execution</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#let-semantics">LET-Semantics</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/iron/rclc/#executor-api">Executor API</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#configuration-phase">Configuration phase</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#running-phase">Running phase</a></li>
        </ul>
      </li>
      <li>
<a href="https://github.com/ros2/rclc/tree/iron/rclc/#examples">Examples</a>
        <ul>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#synchronization-of-multiple-rates-example">Synchronization of multiple rates example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#high-priority-processing-path-example">High-priority processing path example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#real-time-embedded-applications-example">Real-time embedded applications example</a></li>
          <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</a></li>
        </ul>
      </li>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#future-work">Future work</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#download">Download</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/iron/rclc/#callback-group-level-executor">Callback-group-level Executor</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#api-changes">API Changes</a></li>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#test-bench">Test Bench</a></li>
    </ul>
  </li>
  <li>
<a href="https://github.com/ros2/rclc/tree/iron/rclc/#related-work">Related Work</a>
    <ul>
      <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#fawkes-framework">Fawkes Framework</a></li>
    </ul>
  </li>
  <li><a href="https://github.com/ros2/rclc/tree/iron/rclc/#references">References</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Predictable execution under given real-time constraints is a crucial requirement for many robotic applications. While the service-based paradigm of ROS allows a fast integration of many different functionalities, it does not provide sufficient control over the execution management. For example, there are no mechanisms to enforce a certain execution order of callbacks within a node. Also the execution order of multiple nodes is essential for control applications in mobile robotics. Cause-effect-chains comprising of sensor acquisition, evaluation of data and actuation control should be mapped to ROS nodes executed in this order, however there are no explicit mechanisms to enforce it. Furthermore, when data recordings collected in field tests as ROS-bags are re-played, then the results are often surprisingly different due to non-determinism of process scheduling.</p>

<p>Manually setting up a particular execution order of subscriptions and publishing topics as well as defining use-case specific priorities of the corresponding Linux processes is always possible. However, this approach is error-prone, difficult to extend and requires an in-depth knowledge of the deployed ROS 2 packages in the system.</p>

<p>Therefore the goal of the Executor in micro-ROS is to support roboticists with practical and easy-to-use real-time mechanisms which provide solutions for:</p>
<ul>
  <li>Deterministic execution</li>
  <li>Real-time guarantees</li>
  <li>Integration of real-time and non real-time functionalities on one platform</li>
  <li>Specific support for RTOS and microcontrollers</li>
</ul>

<p>In ROS 1 a network thread is responsible for receiving all messages and putting them into a FIFO queue (in roscpp). That is, all callbacks were called in a FIFO manner, without any execution management. With the introduction of DDS (data distribution service) in ROS 2, the messages are buffered in DDS. In ROS 2, an Executor concept was introduced to support execution management. At the rcl-layer, a <em>wait-set</em> is configured with handles to be received and in a second step, the handles are taken from the DDS-queue. A handle is a generic term defined in rcl-layer for timers, subscriptions, services, clients and guard conditions.</p>

<p>The standard implementation of the ROS 2 Executor for the C++ API (rclcpp) has, however, certain unusual features, like precedence of timers over all other DDS handles, non-preemptive round-robin scheduling for non-timer handles and considering only one input data for each handle (even if multiple could be available). These features have the consequence, that in certain situations the standard rclcpp Executor is not deterministic and it makes guaranteeing real-time requirements very hard [<a href="https://github.com/ros2/rclc/tree/iron/rclc/#CB2019">CB2019</a>]. We have not looked at the ROS 2 Executor implementation for Python Frontend (rclpy) because we consider a micro-controllers platform, on which typically C or C++ appliations will run.</p>

<p>Given the goals for a Real-Time Executor and the limitations of the ROS 2 standard rclcpp Executor, the challenges are:</p>
<ul>
  <li>to develop an adequate and well-defined scheduling mechanisms for the ROS 2 framework and the real-time operating system (RTOS)</li>
  <li>to define an easy-to-use interface for ROS developers</li>
  <li>to model requirements (like latencies, determinism in subsystems)</li>
  <li>mapping of ROS 2 framework and operating system schedulers (semi-automated and optimized mapping is desired as well as generic, well-understood framework mechanisms)</li>
</ul>

<p>Our approach is to provide a real-time-capable Executor for the rcl+rclc layer (as described in section <a href="https://github.com/ros2/rclc/tree/iron/rclc/../">Introduction to Client Library</a>.) in the C programming language .</p>

<p>As the first step, we propose the rclc Executor for the rcl-layer in C programming language with several new features to support real-time and deterministic execution: It supports 1.) user-defined static sequential execution, 2) conditional execution semantics, 3) multi-threaded execution with scheduling configuration, and 4) logical execution semantics (LET). Sequential execution refers to the runtime behavior, that all callbacks are executed in a pre-defined order independent of the arrival time of messages. Conditional execution is available with a trigger condition which enables typical processing patterns in robotics (which are analyzed in detail in section <a href="https://github.com/ros2/rclc/tree/iron/rclc/#analysis-of-processing-patterns">Analysis of processing patterns</a>. Configuration of scheduling parameters for multi-threaded application accomplishes prioritized execution. The logical execution time concept (LET) provides data synchronization for fixed periodic task scheduling of embedded applications.</p>

<p>Beyond the advanced execution management mechanisms for micro-ROS, we also contributed to improving and extending the Executor concept in rclcpp for standard ROS 2: the callback group-level Executor. It is not a new Executor but rather a refinement of the ROS 2 Executor API allowing to prioritize a group of callbacks which is not possible with the ROS 2 default Executor in its current Galactic release.</p>

<h2 id="analysis-of-rclcpp-standard-executor">Analysis of rclcpp standard Executor</h2>

<p>ROS 2 allows to bundle multiple nodes in one operating system process. To coordinate the execution of the callbacks of the nodes of a process, the Executor concept was introduced in rclcpp (and also in rclpy).</p>

<p>The ROS 2 design defines one Executor (instance of <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">rclcpp::executor::Executor</a>) per process, which is typically created either in a custom main function or by the launch system. The Executor coordinates the execution of all callbacks issued by these nodes by checking for available work (timers, services, messages, subscriptions, etc.) from the DDS queue and dispatching it to one or more threads, implemented in <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/single_threaded_executor.hpp">SingleThreadedExecutor</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executors/multi_threaded_executor.hpp">MultiThreadedExecutor</a>, respectively.</p>

<p>The dispatching mechanism resembles the ROS 1 spin thread behavior: the Executor looks up the wait sets, which notifies it of any pending callback in the DDS queue. If there are multiple pending callbacks, the ROS 2 Executor executes them in an in the order as they were registered at the Executor.</p>

<h3 id="architecture">Architecture</h3>

<p>The following diagram depicts the relevant classes of the standard ROS 2 Executor implementation:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/executor_class_diagram.png" alt="ROS 2 Executor class diagram" width="100%">
</center>

<p>Note that an Executor instance maintains weak pointers to the NodeBaseInterfaces of the nodes only. Therefore, nodes can be destroyed safely, without notifying the Executor.</p>

<p>Also, the Executor does not maintain an explicit callback queue, but relies on the queue mechanism of the underlying DDS implementation as illustrated in the following sequence diagram:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/executor_to_dds_sequence_diagram.png" alt="Call sequence from executor to DDS" width="100%">
</center>

<p>The Executor concept, however, does not provide means for prioritization or categorization of the incoming callback calls. Moreover, it does not leverage the real-time characteristics of the underlying operating-system scheduler to have finer control on the order of executions. The overall implication of this behavior is that time-critical callbacks could suffer possible deadline misses and a degraded performance since they are serviced later than non-critical callbacks. Additionally, due to the FIFO mechanism, it is difficult to determine usable bounds on the worst-case latency that each callback execution may incur.</p>

<h3 id="scheduling-semantics">Scheduling Semantics</h3>

<p>In a recent paper [<a href="https://github.com/ros2/rclc/tree/iron/rclc/#CB2019">CB2019</a>], the rclcpp Executor has been analyzed in detail and a response time analysis of cause-effect chains has been proposed under reservation-based scheduling. The Executor distinguishes four categories of callbacks: <em>timers</em>, which are triggered by system-level timers, <em>subscribers</em>, which are triggered by new messages on a subscribed topic, <em>services</em>, which are triggered by service requests, and <em>clients</em>, which are triggered by responses to service requests. The Executor is responsible for taking messages from the input queues of the DDS layer and executing the corresponding callback. Since it executes callbacks to completion, it is a non-preemptive scheduler, However it does not consider all ready tasks for execution, but only a snapshot, called readySet. This readySet is updated when the Executor is idle and in this step it interacts with the DDS layer updating the set of ready tasks. Then for every type of task, there are dedicated queues (timers, subscriptions, services, clients) which are processed sequentially. The following undesired properties were pointed out:</p>

<ul>
  <li>Timers have the highest priority. The Executor processes <em>timers</em> always first.  This can lead to the intrinsic effect, that in overload situations messages from the DDS queue are not processed.</li>
  <li>Non-preemptive round-robin scheduling of non-timer handles. Messages arriving during the processing of the readySet are not considered until the next update, which depends on the execution time of all remaining callbacks. This leads to priority inversion, as lower-priority callbacks may implicitly block higher-priority callbacks by prolonging the current processing of the readySet.</li>
  <li>Only one message per handle is considered. The readySet contains only one task instance, For example, even if multiple messages of the same topic are available, only one instance is processed until the Executor is idle again and the readySet is updated from the DDS layer. This aggravates priority inversion, as a backlogged callback might have to wait for multiple processing of readySets until it is considered for scheduling. This means that non-timer callback instances might be blocked by multiple instances of the same lower-priority callback.</li>
</ul>

<p>Due to these findings, the authors present an alternative approach to provide determinism and to apply well-known schedulability analyses to a ROS 2 systems. A response time analysis is described under reservation-based scheduling.</p>

<h2 id="analysis-of-processing-patterns">Analysis of processing patterns</h2>
<p>The development of an execution management mechanism for micro-ROS is based on an analysis of processing patterns commonly used in robotics and embedded systems. First, typical processing patterns in mobile robotics are presented which are used to implement deterministic behavior. Then, the processing patterns in the real-time embedded systems are analyzed, in which, as a main difference, the time-triggered paradigm is applied to accomplish real-time behavior.</p>

<h3 id="sense-plan-act-pipeline-in-robotics">Sense-plan-act pipeline in robotics</h3>
<p>Now we describe common software design patterns which are used in mobile robotics to achieve deterministic behavior. For each design pattern we describe the concept and the derived requirements for a deterministic Executor.</p>

<p><strong>Concept:</strong></p>

<p>A common design paradigm in mobile robotics is a control loop, consisting of several phases: A sensing phase to aquire sensor data, a plan phase for localization and path planning and an actuation-phase to steer the mobile robot. Of course, more phases are possible, here these three phases shall serve as an example. Such a processing pipeline is shown in Figure 1.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/sensePlanActScheme.png" alt="Sense Plan Act Pipeline" width="60%">
</center>
<center>
Figure 1: Multiple sensors driving a Sense-Plan-Act pipeline.
</center>

<p>Typically multiple sensors are used to perceive the environment. For example an IMU and a laser scanner. The quality of localization algorithms highly depend on how old such sensor data is when it is processed. Ideally the latest data of all sensors should be processed. One way to achive this is to execute first all sensor drivers in the sense-phase and then process all algorithms in the plan-phase.</p>

<p>Currently, such a processing order cannot be defined with the default Executor of rclcpp. One could in principle design a data-driven pipeline, however if e.g. the Laser scan is needed by some other callback in the sense-phase as well as in the plan-phase, the processing order of these subscribers is arbitrary.</p>

<p>For this sense-plan-act pattern, we could define one executor for each phase. The plan-phase would be triggered only when all callbacks in the sense-phase have finished.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
</ul>

<h3 id="synchronization-of-multiple-rates">Synchronization of multiple rates</h3>

<p><strong>Concept:</strong></p>

<p>Often multiple sensors are being used to sense the environment for mobile robotics. While an IMU sensor provides data samples at a very high rate (e.g., 500 Hz), laser scans are availabe at a much slower frequency (e.g. 10Hz) determined by the revolution time. Then the challenge is, how to deterministically fuse sensor data with different frequencies. This problem is depicted in Figure 2.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/sensorFusion_01.png" alt="Sychronization of multiple rates" width="30%">
</center>
<center>
Figure 2: How to deterministically process multi-frequent sensor data.
</center>

<p>Due to scheduling effects, the callback for evaluating the laser scan might be called just before or just after an IMU data is received. One way to tackle this is to write additional synchronization code inside the application. Obviously, this is a cumbersome and not-portable solution.</p>

<p>An Alternative would be to evalute the IMU sample and the laser scan by synchronizing their frequency. For example by processing always 50 IMU samples with one laser scan. This approach is shown in Figure 3. A pre-processing callback aggregates the IMU samples and sends an aggregated message with 50 samples at 10Hz rate. Now both messages have the same frequency. With a trigger condition, which fires when both messages are available, the sensor fusion algorithm can expect always synchronized input data.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/sensorFusion_02.png" alt="Sychnronization with a trigger" width="40%">
</center>
<center>
Figure 3: Synchronization of multiple input data with a trigger.
</center>

<p>In ROS 2, this is currently not possible to be modeled because of the lack of a trigger concept in the Executors of rclcpp and rclpy. Message filters could be used to synchronize input data based on the timestamp in the header, but this is only available in rclcpp (and not in rcl). Further more, it would be more efficient to have such a trigger concept directly in the Executor.</p>

<p>Another idea would be to activly request for IMU data only when a laser scan is received. This concept is shown in Figure 4. Upon arrival of a laser scan mesage, first, a message with aggregated IMU samples is requested. Then, the laser scan is processed and later the sensor fusion algorithm. An Executor, which would support sequential execution of callbacks, could realize this idea.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/sensorFusion_03.png" alt="Sychronization with sequence" width="30%">
</center>
<center>
Figure 4: Synchronization with sequential processing.
</center>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>triggered execution</li>
  <li>sequential procesing of callbacks</li>
</ul>

<h3 id="high-priority-processing-path">High-priority processing path</h3>
<p><strong>Concept</strong>
Often a robot has to fullfill several activities at the same time. For example following a path and avoiding obstacles. While path following is a permanent activity, obstacle avoidance is trigged by the environment and should be immediately reacted upon. Therefore one would like to specify priorities to activities. This is depicted in Figure 5:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/highPriorityPath.png" alt="HighPriorityPath" width="50%">
</center>
<center>
Figure 5: Managing high priority path with sequential order.
</center>

<p>Assuming a simplified control loop with the activities sense-plan-act, the obstacle avoidance, which might temporarily stop the robot, should be processed before the planning phase. In this example we assume that these activites are processed in one thread.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>sequential processing of callbacks</li>
</ul>

<h3 id="real-time-embedded-applications">Real-time embedded applications</h3>
<p>In embedded systems, real-time behavior is approached by using the time-triggered paradigm, which means that the processes are periodically activated. Processes can be assigned priorities to allow pre-emptions. Figure 6 shows an example, in which three processes with fixed periods are shown. The middle and lower process are preempted multiple times depicted with empty dashed boxes.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/scheduling_01.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 6: Fixed periodic preemptive scheduling.
</center>

<p>To each process one or multiple tasks can be assigned, as shown in Figure 7. These tasks are executed sequentially, which is often called cooperative scheduling.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/scheduling_02.png" alt="Schedule with fixed periods" width="30%">
</center>
<center>
Figure 7: Processes with sequentially executed tasks.
</center>

<p>While there are different ways to assign priorities to a given number of processes,
the rate-monotonic scheduling assignment, in which processes with a shorter period have a higher priority, has been shown optimal if the processor utilization is less than 69% [<a href="https://github.com/ros2/rclc/tree/iron/rclc/#LL1973">LL1973</a>].</p>

<p>In the last decades many different scheduling approaches have been presented, however fixed-periodic preemptive scheduling is still widely used in embedded real-time systems [<a href="https://github.com/ros2/rclc/tree/iron/rclc/#KZH2015">KZH2015</a>]. This becomes also obvious, when looking at the features of current operating systems. Like Linux, real-time operating systems, such as NuttX, Zephyr, FreeRTOS, QNX etc., support fixed-periodic preemptive scheduling and the assignment of priorities, which makes the time-triggered paradigm the dominant design principle in this domain.</p>

<p>However, data consistency is often an issue when preemptive scheduling is used and if data is being shared across multiple processes via global variables. Due to scheduling effects and varying execution times of processes, writing and reading these variables could occur sometimes sooner or later. This results in an latency jitter of update times (the timepoint at which a variable change becomes visible to other processes). Race conditions can occur when multiple processes access a variable at the same time. So solve this problem, the concept of logical-execution time (LET) was introduced in [<a href="https://github.com/ros2/rclc/tree/iron/rclc/#HHK2001">HHK2001</a>], in which communication of data occurs only at pre-defined periodic time instances: Reading data only at the beginning of the period and writing data only at the end of the period. The cost of an additional latency delay is traded for data consistency and reduced jitter. This concept has also recently been applied to automotive applications[<a href="https://github.com/ros2/rclc/tree/iron/rclc/#NSP2018">NSP2018</a>].</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/scheduling_LET.png" alt="Schedule with fixed periods" width="80%">
</center>
<center>
Figure 8: Data communication without and with Logical Execution Time paradigm.
</center>

<p>An Example of the LET concept is shown in Figure 8. Assume that two processes are communicating data via one global variable. The timepoint when this data is written is at the end of the processing time. In the default case (left side), the process p<sub>3</sub> and p<sub>4</sub> receive the update. At the right side of Figure 8, the same scenario is shown with LET semantics. Here, the data is communicated only at period boundaries. In this case, the lower process communicates at the end of the period, so that always process p<sub>3</sub> and p<sub>5</sub> receive the new data.</p>

<p><strong>Concept:</strong></p>
<ul>
  <li>periodic execution of processes</li>
  <li>assignment of fixed priorities to processes</li>
  <li>preemptive scheduling of processes</li>
  <li>co-operative scheduling of tasks within a process (sequential execution)</li>
  <li>data synchronization with LET-semantics</li>
</ul>

<p>While periodic activation is possible in ROS 2 by using timers, preemptive scheduling is supported by the operating system and assigning priorities on the granularity of threads/processes that correspond to the ROS nodes; it is not possible to sequentially execute callbacks, which have no data-dependency. Furthermore data is read from the DDS queue just before the callback is executed and data is written sometime during the time the application is executed. While the <code class="language-plaintext highlighter-rouge">spin_period</code> function of the rclcpp Executor allows to check for data at a fixed period and executing those callbacks for which data is available, however, with this spin-function does not execute all callbacks irrespective wheter data is available or not. So <code class="language-plaintext highlighter-rouge">spin_period</code> is not helpful to periodically execute a number of callbacks (aka tasks within a process). So we need a mechanism that triggers the execution of multiple callbacks (aka tasks) based on a timer. Data transmission is achieved via DDS which does not allow to implement a LET-semantics. To summarize, we derive the following requirements.</p>

<p><strong>Derived requirements:</strong></p>
<ul>
  <li>trigger the execution</li>
  <li>sequential processing of callbacks</li>
  <li>data synchronization with LET semantics</li>
</ul>

<h2 id="rclc-executor">rclc Executor</h2>

<p>The rclc Executor is a ROS 2 Executor based on the rcl-layer in C programming language. As discussed above, the default rclcpp Executor is not suitable to implement real-time applications because of three main reasons: timers are preferred over all other handles, no priorization of callback execution and the round-robin to completion execution of callbacks. On the other hand, several processing patterns have been developed as best practices to achieve non-functional requirements, such as bounded end-to-end latencies, low jitter of response times of cause-effect chains, deterministic processing and short response times even in overload situations. These processing patterns are difficult to implement with the concepts availabe in the default ROS 2 Executor, therefore we have developed a flexible Executor: the rclc Executor.</p>

<h3 id="features">Features</h3>

<p>The rclc Executor is feature-complete, i.e. it supports all event types as the default ROS 2 Executor, which are:</p>
<ul>
  <li>subscriptions</li>
  <li>timers</li>
  <li>services</li>
  <li>clients</li>
  <li>guard conditions</li>
  <li>actions</li>
  <li>lifecycle</li>
</ul>

<p>The flexible rclc Executor provides on top the following new features:</p>
<ul>
  <li>triggered execution</li>
  <li>user-defined sequential execution</li>
  <li>multi-threading and scheduling configuration (WIP)</li>
  <li>LET-semantics for data synchronization of periodic process scheduling</li>
</ul>

<p>First, a <em>trigger condition</em> allows to define when the processing of a callback shall start. This is useful to implement sense-plan-act control loops or more complex processing structures with directed acyclic graphs. Second, a user can specify the <em>processing order</em> in which these callbacks will be executed. With this feature, the pattern of sensor fusion with multiple rates, in which data is requested from a sensor based on the arrival of some other sensor, can be easily implemented. Third, the assignment of scheduling parameters (e.g., priorities) of the underlying operating system. With this feature, prioritized processing can be implemented. Finally, for periodic applications, the <em>LET Semantics</em> has been implemented to support data consistency for periodic process scheduling. These features are now described in more detail.</p>

<h4 id="sequential-execution">Sequential execution</h4>

<ul>
  <li>At configuration, the user defines the order of handles.</li>
  <li>At configuration, the user defines whether the handle shall be called only when new data is available (ON_NEW_DATA) or whether the callback shall always be called (ALWAYS).</li>
  <li>At runtime, all handles are processed in the user-defined order
    <ul>
      <li>if the configuration of handle is ON_NEW_DATA, then the corresponding callback is only called if new data is available</li>
      <li>if the configuration of the handle is ALWAYS, then the corresponding callback is always. If no data is available, then the callback is called with no data (e.g. NULL pointer).</li>
    </ul>
  </li>
</ul>

<p>Figure 9 shows three callbacks, A, B and C. Assume, they shall be executed in the order <em>B,A,C</em>. Then the user adds the callbacks to the rclc Executor in this order. Whenever new messages have arrived then the callbacks for which a new message is availabe will be always executed in the user-defined processing order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/rclc_executor_sequential_execution.png" alt="Sequential execution semantics" width="50%">
</center>
<center>
Figure 9: Sequential execution semantics.
</center>

<h4 id="trigger-condition">Trigger condition</h4>

<ul>
  <li>Given a set of handles, a trigger condition, which is based on the availability of input data of these handles, decides when the processing of all callbacks starts. This is shown in Figure 10.</li>
</ul>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/trigger_01.png" alt="Trigger condition overview" width="50%">
</center>
<center>
Figure 10: Executor with trigger condition
</center>

<ul>
  <li>Available options:
    <ul>
      <li>ALL operation: fires when input data is available for all handles</li>
      <li>ANY operation: fires when input data is available for at least one handle (OR semantics)</li>
      <li>ONE: fires when input data for a user-specified handle is available</li>
      <li>User-defined function: user can implement custom logic</li>
    </ul>
  </li>
</ul>

<p>Figure 11 shows an example of the ALL semantics. Only if all messages <em>msg_A, msg_B, msg_C</em> were received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/trigger_ALL.png" alt="Trigger condition ALL" width="30%">
</center>
<center>
Figure 11: Trigger condition ALL
</center>

<p>Figure 12 shows an example of the ANY semantics. Thas is, if any messages <em>msg_A, msg_B, msg_C</em> was received, then trigger condition is fullfilled and the callbacks are processed in a user-defined order. This is equivalent to OR semantics.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/trigger_OR.png" alt="Trigger condition ANY" width="30%">
</center>
<center>
Figure 12: Trigger condition ANY (OR)
</center>

<p>Figure 13 shows an example of the ONE semantics. Thas is, only if message <em>msg_B</em> was received, the trigger condition is fullfilled and (potentially all) callbacks are processed in a user-defined order.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/trigger_ONE.png" alt="Trigger condition ONE" width="30%">
</center>
<center>
Figure 13: Trigger condition ONE
</center>

<p>Figure 14 describes the custom semantics. A custom trigger condition with could be a more complex logic of multiple messages, can be passed to the executor. This might also include hardware triggers, like interrupts.</p>
<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/trigger_user_defined.png" alt="Trigger condition user-defined" width="30%">
</center>
<center>
Figure 14: Trigger condition user-defined
</center>

<h4 id="let-semantics">LET-Semantics</h4>
<ul>
  <li>Assumption: time-triggered system, the executor is activated periodically</li>
  <li>When the trigger fires, reads all input data and makes a local copy</li>
  <li>Processes all callbacks in sequential order</li>
  <li>Write output data at the end of the executors period (Note: this is not implemented yet)</li>
</ul>

<p>Additionally we have implemented the current rclcpp Executor semantics (RCLCPP):</p>
<ul>
  <li>waiting for new data for all handles (rcl_wait)</li>
  <li>using trigger condition ANY</li>
  <li>if trigger fires, start processing handles in pre-defined sequential order</li>
  <li>request from DDS-queue the new data just before the handle is executed (rcl_take)</li>
</ul>

<p>The selection of the Executor semantics is optional. The default semantics is RCLCPP.</p>

<h4 id="multi-threading-and-scheduling-configuration">Multi-threading and scheduling configuration</h4>

<p>The rclc Executor has been extended for multi-threading. It supports the assignment of scheduling policies, like priorities or more advanced scheduling algorithms as reservation-based scheduling, to subscription callbacks. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, Pre-print <a href="https://github.com/ros2/rclc/tree/iron/rclc/#SLD2021">SLD2021</a>]. The overall architecture is shown in Figure 15. One Executor thread is responsible for checking for new data from the DDS queue. For every callback, a thread is spawned with the dedicted scheduling policy provided by the operating system. The Executor then dispatches new data of a subscription to its corresponding callback function, which is then executed in its own thread by operating system.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/rclc_executor_multi_threaded.png" alt="Multi-threaded rclc Executor" width="90%">
</center>
<center>
Figure 15: multi-threaded rclc-Executor
</center>

<h3 id="executor-api">Executor API</h3>
<p>The API of the rclc Executor can be divided in two phases: Configuration and Running.</p>
<h4 id="configuration-phase">Configuration phase</h4>
<p>During the configuration phase, the user shall define:</p>
<ul>
  <li>the total number of callbacks</li>
  <li>the sequence of the callbacks</li>
  <li>trigger condition (optional, default: ANY)</li>
  <li>data communcation semantics (optional, default ROS2)</li>
</ul>

<p>As the Executor is intended for embedded controllers, dynamic memory management is crucial. Therefore at initialization of the rclc Executor, the user defines the total number of callbacks. The necessary dynamic memory will be allocated only in this phase and no more memory in the running phase. This makes this Executor static in the sense, that during runtime no additional callbacks can be added.</p>

<p>Also in the XRCE-DDS middleware the maximum number of handles need to be configured. See <a href="https://docs.vulcanexus.org/en/humble/rst/tutorials/micro/memory_management/memory_management.html#entity-creation">Memory Management Tutorial</a> for the defaults and configuration of the colcon.meta configuration file. To make sure that the changes were applied, you can check the defined values in the following library include file: build/rmw_microxrcedds/include/rmw_microxrcedds_c/config.h.</p>

<p>Then, the user adds handles and the corresponding callbacks (e.g. for subscriptions and timers) to the Executor. The order in which this takes place, defines later the sequential processing order during runtime.</p>

<p>For each handle the user can specify, if the callback shall be executed only if new data is available (ON_NEW_DATA) or if the callback shall always be executed (ALWAYS). The second option is useful when the callback is expected to be called at a fixed rate.</p>

<p>The trigger condition defines when the processing of these callbacks shall start. For convenience some default conditions have been defined:</p>
<ul>
  <li>trigger_any(default) : start executing if any callback has new data</li>
  <li>trigger_all : start executing if all callbacks have new data</li>
  <li>trigger_one(&amp;<code class="language-plaintext highlighter-rouge">data</code>) : start executing if <code class="language-plaintext highlighter-rouge">data</code> has been received</li>
  <li>user_defined_function: the user can also define its own function with more complex logic</li>
</ul>

<p>With trigger_any being the default, the current semantics of the rclcpp Executor is selected.</p>

<p>The data communication semantics can be</p>
<ul>
  <li>ROS2 (default)</li>
  <li>LET</li>
</ul>

<p>To be compatible with ROS2 rclcpp Executor, the existing rclcpp semantics is implemented as ROS2. That is, with the spin-function the DDS-queue is constantly monitored for new data (rcl_wait). If new data becomes available, then is fetched from DDS (rcl_take) immediately before the callback is executed. All callbacks are processed in the user-defined order, this is the only difference to the rclcpp Executor, in which no order can be specified.</p>

<p>Secondly, the LET semantics is implemented such that at the beginning of processing all available data is fetched (rcl_take) and buffered and then the callbacks are processed in the pre-defined operating on the buffered copy.</p>

<h4 id="running-phase">Running phase</h4>

<p>As the main functionality, the Executor has a <code class="language-plaintext highlighter-rouge">spin</code>-function which constantly checks for new data at the DDS-queue, like the rclcpp Executor in ROS2. If the trigger condition is satisfied then all available data from the DDS queue is processed according to the specified semantics (ROS or LET) in the user-defined sequential order. After all callbacks have been processed the DDS is checked for new data again.</p>

<p>Available spin functions are</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">spin_some</code>  - spin one time</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin_period</code> - spin with a period</li>
  <li>
<code class="language-plaintext highlighter-rouge">spin</code> - spin indefinitly</li>
</ul>

<h3 id="examples">Examples</h3>
<p>We provide the relevant code snippets how to setup the rclc Executor for the processing patterns as described above.</p>

<h4 id="sense-plan-act-pipeline-in-robotics-example">Sense-plan-act pipeline in robotics example</h4>

<p>In this example we want to realise a sense-plan-act pipeline in a single thread. The trigger condition is demonstrated by activating
the sense-phase when both data for the Laser and IMU are available. Three executors are necessary <code class="language-plaintext highlighter-rouge">exe_sense</code>, <code class="language-plaintext highlighter-rouge">exe_plan</code> and <code class="language-plaintext highlighter-rouge">exe_act</code>. The two sensor acquisition callbacks <code class="language-plaintext highlighter-rouge">sense_Laser</code> and <code class="language-plaintext highlighter-rouge">sense_IMU</code> are registered in the Executor <code class="language-plaintext highlighter-rouge">exe_sense</code>.
The trigger condition ALL is responsible to activate the sense-phase only when all data for these two callbacks are available. Finally all three Executors are spinning using a <code class="language-plaintext highlighter-rouge">while</code>-loop and the <code class="language-plaintext highlighter-rouge">spin_some</code> function.</p>

<p>The definitions of callbacks are omitted.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act;
rcle_let_executor_t exe_sense, exe_plan, exe_act;
// initialize executors
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
rclc_executor_init(&amp;exe_plan, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_act, &amp;context, 1, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb1, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_let_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);
// executor for plan-phase
rclc_executor_add_subscription(&amp;exe_plan, &amp;plan, &amp;my_sub_cb3, ON_NEW_DATA);
// executor for act-phase
rclc_executor_add_subscription(&amp;exe_act, &amp;act, &amp;my_sub_cb4, ON_NEW_DATA);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_sense);
  rclc_executor_spin_some(&amp;exe_plan);
  rclc_executor_spin_some(&amp;exe_act);
}

</code></pre>

<h4 id="synchronization-of-multiple-rates-example">Synchronization of multiple rates example</h4>

<p>The sensor fusion synchronizing the multiple rates with a trigger is shown below.</p>

<pre><code class="language-C">...
rcl_subscription_t aggr_IMU, sense_Laser, sense_IMU;
rcle_let_executor_t exe_aggr, exe_sense;
// initialize executors
rclc_executor_init(&amp;exe_aggr, &amp;context, 1, ...);
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for aggregate IMU data
rclc_executor_add_subscription(&amp;exe_aggr, &amp;aggr_IMU, &amp;my_sub_cb1, ON_NEW_DATA);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb3, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_all, NULL);

// spin all executors
while (true) {
  rclc_executor_spin_some(&amp;exe_aggr);
  rclc_executor_spin_some(&amp;exe_sense);
}

</code></pre>

<p>The setup for the sensor fusion using sequential execution is shown below.
Note that the sequetial order is <code class="language-plaintext highlighter-rouge">sense_IMU</code>, which will request the aggregated IMU message, and then <code class="language-plaintext highlighter-rouge">sense_Laser</code>
while the trigger will fire, when a laser message is received.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU;
rcle_let_executor_t exe_sense;
// initialize executor
rclc_executor_init(&amp;exe_sense, &amp;context, 2, ...);
// executor for sense-phase
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe_sense, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_set_trigger(&amp;exe_sense, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe_sense);

</code></pre>
<h4 id="high-priority-processing-path-example">High priority processing path example</h4>

<p>This example shows the sequential processing order to execute the obstacle avoidance <code class="language-plaintext highlighter-rouge">obst_avoid</code>
after the callbacks of the sense-phase and before the callback of the planning phase <code class="language-plaintext highlighter-rouge">plan</code>.
The control loop is started when a laser message is received. Then an aggregated IMU message is requested,
like in the example above. Then all the other callbacks are always executed. This assumes that these callbacks
communicate via a global data structure. Race conditions cannot occur, because the callbacks
run all in one thread.</p>

<pre><code class="language-C">...
rcl_subscription_t sense_Laser, sense_IMU, plan, act, obst_avoid;
rcle_let_executor_t exe;
// initialize executors
rclc_executor_init(&amp;exe, &amp;context, 5, ...);
// define processing order
rclc_executor_add_subscription(&amp;exe, &amp;sense_IMU, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sense_Laser, &amp;my_sub_cb2, ON_NEW_DATA);
rclc_executor_add_subscription(&amp;exe, &amp;obst_avoid, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;plan, &amp;my_sub_cb4, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;act, &amp;my_sub_cb5, ALWAYS);
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;sense_Laser);
// spin
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="real-time-embedded-applications-example">Real-time embedded applications example</h4>

<p>With seqential execution the co-operative scheduling of tasks within a process can be modeled. The trigger condition is used to periodically activate the process which will then execute all callbacks in a pre-defined order. Data will be communicated using the LET-semantics. Every Executor is executed in its own tread, to which an appropriate priority can be assigned.</p>

<p>In the following example, the Executor is setup with 4 handles. We assume a process has three subscriptions <code class="language-plaintext highlighter-rouge">sub1</code>, <code class="language-plaintext highlighter-rouge">sub2</code>, <code class="language-plaintext highlighter-rouge">sub3</code>. The sequential processing order is given by the order as they are added to the Executor. A timer <code class="language-plaintext highlighter-rouge">timer</code> defines the period.  The <code class="language-plaintext highlighter-rouge">trigger_one</code> with the paramter <code class="language-plaintext highlighter-rouge">timer</code> is used, so that whenever the timer is ready, all callbacks are processed. Finally the data communication semantics LET is defined.</p>

<pre><code class="language-C">#include "rcl_executor/let_executor.h"

// define subscription callback
void my_sub_cb1(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb2(const void * msgin)
{
  // ...
}
// define subscription callback
void my_sub_cb3(const void * msgin)
{
  // ...
}

// define timer callback
void my_timer_cb(rcl_timer_t * timer, int64_t last_call_time)
{
  // ...
}

// necessary ROS 2 objects
rcl_context_t context;   
rcl_node_t node;
rcl_subscription_t sub1, sub2, sub3;
rcl_timer_t timer;
rcle_let_executor_t exe;

// define ROS context
context = rcl_get_zero_initialized_context();
// initialize ROS node
rcl_node_init(&amp;node, &amp;context,...);
// create subscriptions
rcl_subscription_init(&amp;sub1, &amp;node, ...);
rcl_subscription_init(&amp;sub2, &amp;node, ...);
rcl_subscription_init(&amp;sub3, &amp;node, ...);
// create a timer
rcl_timer_init(&amp;timer, &amp;my_timer_cb, ... );
// initialize executor with four handles
rclc_executor_init(&amp;exe, &amp;context, 4, ...);
// define static execution order of handles
rclc_executor_add_subscription(&amp;exe, &amp;sub1, &amp;my_sub_cb1, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub2, &amp;my_sub_cb2, ALWAYS);
rclc_executor_add_subscription(&amp;exe, &amp;sub3, &amp;my_sub_cb3, ALWAYS);
rclc_executor_add_timer(&amp;exe, &amp;timer);
// trigger when handle 'timer' is ready
rclc_executor_set_trigger(&amp;exe, rclc_executor_trigger_one, &amp;timer);
// select LET-semantics
rclc_executor_data_comm_semantics(&amp;exe, LET);
// spin forever
rclc_executor_spin(&amp;exe);

</code></pre>

<h4 id="ros-2-executor-workshop-reference-system">ROS 2 Executor Workshop Reference System</h4>
<p>The rclc Executor has been presented at the workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at <a href="https://roscon.ros.org/world/2021/">ROS World 2021</a> (i.e. the online version of ROSCon)[<a href="https://github.com/ros2/rclc/tree/iron/rclc/#S2021">S2021</a>]. A <a href="https://github.com/ros-realtime/reference-system">Reference System</a> for testing and benchmarking ROS Executors has been developed for this workshop. The application of the rclc Executor on the reference system with the trigger condition can be found in the <a href="https://github.com/ros-realtime/reference-system/tree/rclc_executor">rclc-executor branch of the Reference System</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/IazrPF3RN1U" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>The slides can be downloaded <a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">here</a>. All information and the videos and slides of the other talks of the workshop can be found at <a href="https://www.apex.ai/roscon-21">www.apex.ai/roscon-21</a>.</p>

<h3 id="future-work">Future work</h3>

<ul>
  <li>Full LET semantics (writing data at the end of the period)
    <ul>
      <li>one publisher that periodically publishes</li>
      <li>if Executors are running in multiple threads,
publishing needs to be atomic</li>
    </ul>
  </li>
  <li>Multi-threaded executor with assignment of scheduling policies of unerlying operating system. [<a href="https://github.com/ros2/rclc/pull/87">Pull Request</a>, pre-print <a href="https://github.com/ros2/rclc/tree/iron/rclc/#SLD2021">SLD2021</a>].</li>
</ul>

<h3 id="download">Download</h3>
<p>The rclc Executor can be downloaded from the <a href="https://github.com/ros2/rclc">ros2/rclc repository</a>. It is available for the ROS 2 versions Foxy, Galactic and Rolling. The repository provides several packages including the <a href="https://github.com/ros2/rclc/tree/master/rclc">rclc Executor</a> and an <a href="https://github.com/ros2/rclc/tree/master/rclc_examples">rclc_examples package</a> with several application examples.</p>

<h2 id="callback-group-level-executor">Callback-group-level Executor</h2>

<p>The Callback-group-level Executor was an early prototype for a refined rclcpp Executor API developed in micro-ROS. It has been derived from the default rclcpp Executor and addresses some of the aforementioned deficits. Most important, it was used to validate that the underlying layers (rcl, rmw, rmw_adapter, DDS) allow for multiple Executor instances without any negative interferences.</p>

<p>As the default rclcpp Executor works at a node-level granularity  which is a limitation given that a node may issue different callbacks needing different real-time guarantees - we decided to refine the API for more fine-grained control over the scheduling of callbacks on the granularity of callback groups using. We leverage the callback-group concept existing in rclcpp by introducing real-time profiles such as RT-CRITICAL and BEST-EFFORT in the callback-group API (i.e. rclcpp/callback_group.hpp). Each callback needing specific real-time guarantees, when created, may therefore be associated with a dedicated callback group. With this in place, we enhanced the Executor and depending classes (e.g., for memory allocation) to operate at a finer callback-group granularity. This allows a single node to have callbacks with different real-time profiles assigned to different Executor instances - within one process.</p>

<p>Thus, an Executor instance can be dedicated to specific callback group(s) and the Executors thread(s) can be prioritized according to the real-time requirements of these groups. For example, all time-critical callbacks are handled by an RT-CRITICAL Executor instance running at the highest scheduler priority.</p>

<p>The following Figure illustrates this approach with two nodes served by three Callback-group-level Executors in one process:</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/cbg-executor_sample_system.png" alt="Sample system with two nodes and three Callback-group-level Executors in one process" width="60%">
</center>

<p>The different callbacks of the Drive-Base node are distributed to different Executors (visualized by the color red, yellow and green).  For example the onCmdVel and publishWheelTicks callback are scheduled by the same Executor (yellow). Callbacks from different nodes can be serviced by the same Executor.</p>

<h3 id="api-changes">API Changes</h3>

<p>In this section, we describe the necessary changes to the Executor API:</p>
<ul>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/callback_group.hpp">include/rclcpp/callback_group.hpp</a>:</p>

    <ul>
      <li>Introduced an enum to distinguish up to three real-time classes (requirements) per node (RealTimeCritical, SoftRealTime, BestEffort)</li>
      <li>Changed association with Executor instance from nodes to callback groups.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/executor.hpp">include/rclcpp/executor.hpp</a></p>

    <ul>
      <li>
        <p>Added functions to add and remove individual callback groups in addition to whole nodes.</p>
      </li>
      <li>
        <p>Replaced private vector of nodes with a map from callback groups to nodes.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/memory_strategy.hpp">include/rclcpp/memory_strategy.hpp</a></p>

    <ul>
      <li>Changed all functions that expect a vector of nodes to the just mentioned map.</li>
    </ul>
  </li>
  <li>
    <p><a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node.hpp">include/rclcpp/node.hpp</a> and <a href="https://github.com/ros2/rclcpp/blob/master/rclcpp/include/rclcpp/node_interfaces/node_base.hpp">include/rclcpp/node_interfaces/node_base.hpp</a></p>

    <ul>
      <li>Extended arguments of create_callback_group function for the real-time class.</li>
      <li>Removed the get_associated_with_executor_atomic function.</li>
    </ul>
  </li>
</ul>

<p>The callback-group-level executor has been merged into ROS 2 rclcpp in <a href="https://github.com/ros2/rclcpp/pull/1218/commits">pull request 1218</a>.</p>

<h3 id="test-bench">Test Bench</h3>

<p>As a proof of concept, we implemented a small test bench in the present package cbg-executor_ping-pong_cpp. The test bench comprises a Ping node and a Pong node which exchange real-time and best-effort messages simultaneously with each other. Each class of messages is handled with a dedicated Executor, as illustrated in the following Figure.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/ping_pong_diagram.png" alt="Architecture for the Callback-group-level Executor test bench" width="100%">
</center>

<p>With the test bench, we validated the functioning of the approach.</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/cbg_executor_demo_plot.png" alt="Results from Callback-group-level Executor test bench" width="80%">
</center>

<p>In this example, the callback for the high priority task (red line) consumes 10ms and the low priority task (blue line) 40ms in the Pong Node. With a ping rate of 20 Hz, the CPU saturates (10ms*20+40ms*20=1000ms). With higher frequencies the high priorty task can continue to send its pong message, while the low priority pong task degrades. With a frequency of 100Hz the high priority task requires 100% CPU utilization. With higher ping rates it keeps sending pong messages with 100Hz, while the low priority task does not get any CPU ressources any more and cannot send any messages.</p>

<p>The test bench is provided in the <a href="https://github.com/ros2/examples/tree/master/rclcpp/executors/cbg_executor">cbg_executor_demo</a>.</p>

<h2 id="related-work">Related Work</h2>

<p>In this section, we provide an overview to related approaches and link to the corresponding APIs.</p>

<h3 id="fawkes-framework">Fawkes Framework</h3>

<p><a href="http://www.fawkesrobotics.org/">Fawkes</a> is a robotic software framework, which supports synchronization points for sense-plan-act like execution. It has been developed by RWTH Aachen since 2006. Source code is available at <a href="https://github.com/fawkesrobotics">github.com/fawkesrobotics</a>.</p>

<h4 id="synchronization">Synchronization</h4>
<p>Fawkes provides developers different synchronization points, which are very useful for defining an execution order of a typical sense-plan-act application. These ten synchronization points (wake-up hooks) are the following (cf. <a href="https://github.com/fawkesrobotics/fawkes/blob/master/src/libs/aspect/blocked_timing.h">libs/aspect/blocked_timing.h</a>):</p>

<ul>
  <li>WAKEUP_HOOK_PRE_LOOP</li>
  <li>WAKEUP_HOOK_SENSOR_ACQUIRE</li>
  <li>WAKEUP_HOOK_SENSOR_PREPARE</li>
  <li>WAKEUP_HOOK_SENSOR_PROCESS</li>
  <li>WAKEUP_HOOK_WORLDSTATE</li>
  <li>WAKEUP_HOOK_THINK</li>
  <li>WAKEUP_HOOK_SKILL</li>
  <li>WAKEUP_HOOK_ACT</li>
  <li>WAKEUP_HOOK_ACT_EXEC</li>
  <li>WAKEUP_HOOK_POST_LOOP</li>
</ul>

<h4 id="configuration-at-compile-time">Configuration at compile time</h4>
<p>At compile time, a desired synchronization point is defined as a constructor parameter for a module. For example, assuming that <code class="language-plaintext highlighter-rouge">mapLaserGenThread</code> shall be executed in SENSOR_ACQUIRE, the constructor is implemented as:</p>

<pre><code class="language-C++">MapLaserGenThread::MapLaserGenThread()
  :: Thread("MapLaserGenThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_ACQUIRE),
     TransformAspect(TransformAspect::BOTH_DEFER_PUBLISHER, "Map Laser Odometry")

</code></pre>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">NaoQiButtonThread</code> shall be executed in the SENSOR_PROCESS hook, the constructor is:</p>

<pre><code class="language-C++">NaoQiButtonThread::NaoQiButtonThread()
  :: Thread("NaoQiButtonThread", Thread::OPMODE_WAITFORWAKEUP),
     BlockedTimingAspect(BlockedTimingAspect::WAKEUP_HOOK_SENSOR_PROCESS)

</code></pre>

<h4 id="runtime-execution">Runtime execution</h4>
<p>At runtime, the <em>Executor</em> iterates through the list of synchronization points and executes all registered threads until completion. Then, the threads of the next synchronization point are called.</p>

<p>A module (thread) can be configured independent of these sense-plan-act synchronization points. This has the effect, that this thread is executed in parallel to this chain.</p>

<p>The high level overview of the Fawkes framework is shown in the next figure. At compile-time the configuration of the sense-plan act wakeup hook is done (upper part), while at run-time the scheduler iterates through this list of wakeup-hooks (lower part):</p>

<center>
<img src="https://raw.githubusercontent.com/ros2/rclc/iron/rclc/png/fawkes_executor_diagram.png" alt="Sequence diagram for Fawkes Executor" width="50%">
</center>

<p>Hence, at run-time, the hooks are executed as a fixed static schedule without preemption. Multiple threads registered in the same hook are executed in parallel.</p>

<p>Orthogonal to the sequential execution of sense-plan-act like applications, it is possible to define further constraints on the execution order by means of a <code class="language-plaintext highlighter-rouge">Barrier</code>. A barrier defines a number of threads, which need to have finished before the thread can start, which owns the barrier.</p>

<p>These concepts are implemented by the following main classes:</p>

<ul>
  <li>
<em>Wakeup hook</em> by <code class="language-plaintext highlighter-rouge">SyncPoint</code> and <code class="language-plaintext highlighter-rouge">SyncPointManager</code>, which manages a list of synchronization points.</li>
  <li>
<em>Executor</em> by the class <code class="language-plaintext highlighter-rouge">FawkesMainThread</code>, which is the scheduler, responsible for calling the user threads.</li>
  <li>
<code class="language-plaintext highlighter-rouge">ThreadManager</code>, which is derived from <code class="language-plaintext highlighter-rouge">BlockedTimingExecutor</code>, provides the necessary API to add and remove threads to wakeup hooks as well as for sequential execution of the wakeup-hooks.</li>
  <li>
<code class="language-plaintext highlighter-rouge">Barrier</code> is an object similar to <code class="language-plaintext highlighter-rouge">condition_variable</code> in C++.</li>
</ul>

<h4 id="discussion">Discussion</h4>

<p>All threads are executed with the same priority. If multiple sense-plan-act chains shall be executed with different priorities, e.g. to prefer execution of emergency-stop over normal operation, then this framework reaches its limits.</p>

<p>Also, different execution frequencies cannot be modeled by a single instance of this sense-plan-act chain. However, in robotics the fastest sensor will drive the chain and all other hooks are executed with the same frequency.</p>

<p>The option to execute threads independent of the predefined wakeup-hooks is very useful, e.g. for diagnostics. The concept of the Barrier is useful for satisfying functional dependencies which need to be considered in the execution order.</p>

<h2 id="references">References</h2>
<ul>
  <li>
    <p>[S2021]<a name="S2021"></a> J. Staschulat, Micro-ROS: The rclc Executor, in Workshop ROS 2 Executor: How to make it efficient, real-time and deterministic? at ROS World, Oct. 2021, [<a href="https://ec2a4d36-bac8-4759-b25e-bb1f794177f4.filesusr.com/ugd/984e93_749e27b917a54b45b9ccb5be930841b8.pdf">slides</a>] [<a href="https://www.youtube.com/embed/IazrPF3RN1U">Video</a>]</p>
  </li>
  <li>
    <p>[SLD2021]<a name="SLD2021"></a> J. Staschulat, R. Lange and D. N. Dasari, Budget-based real-time Executor for Micro-ROS, arXiv Pre-Print, May 2021. [<a href="https://arxiv.org/abs/2105.05590">paper</a>]</p>
  </li>
  <li>
    <p>[L2020]<a name="L2020"></a> Ralph Lange: Advanced Execution Management with ROS 2, ROS-Industrial Conference, Dec 2020 <a href="https://micro-ros.github.io/download/2020-12-16_Advanced_Execution_Management_with_ROS_2.pdf">[Slides]</a></p>
  </li>
  <li>
    <p>[SLL2020]<a name="SLL2020"></a> J. Staschulat, I. Ltkebohle and R. Lange, The rclc Executor: Domain-specific deterministic scheduling mechanisms for ROS applications on microcontrollers: work-in-progress, 2020 International Conference on Embedded Software (EMSOFT), Singapore, Singapore, 2020, pp. 18-19. <a href="https://ieeexplore.ieee.org/document/9244014">[Paper]</a> <a href="https://whova.com/embedded/session/eswe_202009/1145800/">[Video]</a></p>
  </li>
  <li>
    <p>[CB2019]<a name="CB2019"> </a> D. Casini, T. Bla, I. Ltkebohle, B. Brandenburg: Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling, in Euromicro-Conference on Real-Time Systems 2019. <a href="http://drops.dagstuhl.de/opus/volltexte/2019/10743/">[Paper]</a> <a href="https://t-blass.de/talks/ECRTS2019.pdf">[slides]</a></p>
  </li>
  <li>
    <p>[L2018]<a name="L2018"></a> Ralph Lange: Callback-group-level Executor for ROS 2. Lightning talk at ROSCon 2018. Madrid, Spain. Sep 2018. <a href="https://roscon.ros.org/2018/presentations/ROSCon2018_Lightning1_4.pdf">[Slides]</a> <a href="https://vimeo.com/292707644">[Video]</a></p>
  </li>
  <li>
    <p>[EK2018]<a name="EK2018"></a> R. Ernst, S. Kuntz, S. Quinton, M. Simons: The Logical Execution Time Paradigm: New Perspectives for Multicore Systems, February 25-28 2018 (Dagstuhl Seminar 18092). <a href="http://drops.dagstuhl.de/opus/volltexte/2018/9293/pdf/dagrep_v008_i002_p122_18092.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[NSP2018]<a name="NSP2018"></a> A. Naderlinger, S. Resmerita, and W. Pree: LET for Legacy and Model-based Applications,
Proceedings of The Logical Execution Time Paradigm: New Perspectives for Multicore Systems (Dagstuhl Seminar 18092), Wadern, Germany, February 2018.</p>
  </li>
  <li>
    <p>[BP2017]<a name="BP2017"></a> A. Biondi, P. Pazzaglia, A. Balsini,  M. D. Natale: Logical Execution Time Implementation and Memory Optimization Issues in AUTOSAR Applications for Multicores, International Worshop on Analysis Tools and Methodologies for Embedded and Real-Time Systems (WATERS2017), Dubrovnik, Croatia.<a href="https://pdfs.semanticscholar.org/4a9e/b9a616c25fd0b4a4f7810924e73eee0e7515.pdf">[Paper]</a></p>
  </li>
  <li>
    <p>[KZH2015]<a name="KZH2015"></a> S. Kramer, D. Ziegenbein, and A. Hamann: Real World Automotive Benchmarks For Free, International Workshop on Analysis Tools and Methodologies for Embedded adn Real-Time Sysems (WATERS), 2015.</p>
  </li>
  <li>
    <p>[HHK2001]<a name="HHK2001"></a> Henzinger T.A., Horowitz B., Kirsch C.M. (2001) Giotto: A Time-Triggered Language for Embedded Programming. In: Henzinger T.A., Kirsch C.M. (eds) Embedded Software. EMSOFT 2001. Lecture Notes in Computer Science, vol 2211. Springer, Berlin, Heidelberg</p>
  </li>
  <li>
    <p>[LL1973]<a name="LL1973"></a> Liu, C. L.; Layland, J.:Scheduling algorithms for multiprogramming in a hard real-time environment, Journal of the ACM, 20 (1): 4661, 1973.</p>
  </li>
</ul>
</div>
              </div>
            </div>
          </div>
        </div>
      
    
    <div class="row">
      <div class="col-xs-12">
        <div class="panel panel-default">
          <div class="panel-heading"><span class="glyphicon glyphicon-list"></span> CHANGELOG</div>
          <div class="panel-body">
            
              <div class="rendered-markdown">
<h1 id="changelog-for-package-rclc">Changelog for package rclc</h1>

<h2 id="501-2023-06-15">5.0.1 (2023-06-15)</h2>

<ul>
  <li>Data structures interfaces for multi-threaded executor (#355)</li>
  <li>Updated ros-tooling versions (#361)</li>
  <li>Updated actions/checkout version (#367)</li>
  <li>Updated branch and distribution name to iron (#371)</li>
</ul>

<h2 id="309-2023-03-22">3.0.9 (2023-03-22)</h2>

<ul>
  <li>Added build status of bloom-releases for Humble distribution (#291)</li>
  <li>[rolling] updated ros-tooling versions (#289)</li>
  <li>github action: updated os-version to ubuntu-22.04 (backport #295)
(#296)</li>
  <li>Added documentation (#301)</li>
  <li>Drop build dependency on std_msgs (#314)</li>
  <li>Updated &lt;ros-tooling/setup-ros@0.4.2&gt; and
&lt;ros-tooling/action-ros-ci@0.2.7&gt; (#318)</li>
  <li>Removed build status for Galactic in README (EOL November 2022)
(#321)</li>
  <li>Update documentation about number_of_handles (#326)</li>
  <li>executor.h: Fix a few docs typos (#338)</li>
</ul>

<h2 id="308-2022-04-14">3.0.8 (2022-04-14)</h2>

<ul>
  <li>Remove duplicate typedefs. (#249)</li>
  <li>Add rmw dependencies due to EventsExecutor PR in rcl (#255)</li>
  <li>Fix action client &amp; server deallocation (#257)</li>
  <li>updated documentation: build status for Rolling (#266)</li>
  <li>Update action client goal callback signature (#282)</li>
  <li>Upgrade parameters (#274)</li>
</ul>

<h2 id="307-2022-02-17">3.0.7 (2022-02-17)</h2>

<ul>
  <li>Fix enum naming for avoid collision (#242)</li>
  <li>Added dependency for package performance-test-fixture (#245)</li>
</ul>

<h2 id="306-2022-01-25">3.0.6 (2022-01-25)</h2>

<ul>
  <li>executor ignore canceled timers (#220)</li>
  <li>uddated documentation README.md (#229)</li>
  <li>resolved error in unit test see issue #230 (#231)</li>
  <li>Add thread dependency to examples (Rolling) (#237) (resolves in
this package only cpplint errors)</li>
</ul>

<h2 id="305-2021-11-23">3.0.5 (2021-11-23)</h2>

<ul>
  <li>Fix data_available reset for timer (backport #215) (#217)</li>
</ul>

<h2 id="304-2021-11-17">3.0.4 (2021-11-17)</h2>

<ul>
  <li>Ignoring unsuccessful SERVICE_TAKE (#175)</li>
  <li>Add rclc_parameter Quality Declaration (#144)</li>
  <li>use-ros2-testing (#185)</li>
  <li>Fix: printf in executor spin (#195)</li>
  <li>Fix init options handling (#202) (#205)</li>
  <li>Remove init options from support (#203)</li>
  <li>RCLC Actions Implementation (#170)</li>
  <li>Add rcl_action as build export dependency (#211)</li>
</ul>

<h2 id="303-2021-07-28">3.0.3 (2021-07-28)</h2>

<ul>
  <li>Checking for valid ROS context in spin_some</li>
  <li>Refactoring executor (removing callback_type)</li>
  <li>Fixing codecov config</li>
</ul>

<h2 id="302-2021-07-26">3.0.2 (2021-07-26)</h2>

<ul>
  <li>Updated codecov to ignore test folders</li>
  <li>Updated bloom release status table</li>
</ul>

<h2 id="301-2021-07-17">3.0.1 (2021-07-17)</h2>

<ul>
  <li>Added rclc_parameter package</li>
  <li>Added quality of service entity creation API</li>
  <li>Added executor prepare API</li>
  <li>Added support for removing subscription from executor</li>
  <li>Added support for subscription with context</li>
  <li>Added quality declaration statement</li>
  <li>Updated compatability function for sleep</li>
  <li>Removed duplicate NOTICE files</li>
</ul>

<h2 id="200-2021-04-23">2.0.0 (2021-04-23)</h2>

<ul>
  <li>Added codecov support</li>
  <li>New API of rcl_lifecycle in Rolling required major version bump</li>
</ul>

<h2 id="101-2021-03-29">1.0.1 (2021-03-29)</h2>

<ul>
  <li>Windows port</li>
  <li>Compatibility sleep function (Windows, POSIX-OS)</li>
  <li>Fixed RCL lifecycle API change for Rolling</li>
</ul>

<h2 id="100-2021-03-04">1.0.0 (2021-03-04)</h2>

<ul>
  <li>Service callbacks with context</li>
  <li>Fixed minor issues unit tests</li>
  <li>Upgraded setup_ros action (ci jobs)</li>
  <li>Removed Eloquent from ci jobs</li>
</ul>

<h2 id="017-2021-01-20">0.1.7 (2021-01-20)</h2>

<ul>
  <li>Corrected corrupted changelog</li>
</ul>

<h2 id="016-2021-01-20">0.1.6 (2021-01-20)</h2>

<ul>
  <li>Fixed issues due to Github Action timing delays on cloud build</li>
  <li>Fixed missing package dependency in Github Action for Eloquent</li>
</ul>

<h2 id="015-2020-12-11">0.1.5 (2020-12-11)</h2>

<ul>
  <li>Added support for services,clients and guard_conditions to rclc
executor</li>
  <li>Added table for bloom release status in README file</li>
</ul>

<h2 id="014-2020-11-25">0.1.4 (2020-11-25)</h2>

<ul>
  <li>Fixed error in bloom release</li>
</ul>

<h2 id="013-2020-11-23">0.1.3 (2020-11-23)</h2>

<ul>
  <li>Added rclc_lifecycle package</li>
  <li>Change maintainer information</li>
  <li>Minor fixes, updated unit tests</li>
</ul>

<h2 id="012-2020-05-19">0.1.2 (2020-05-19)</h2>

<ul>
  <li>Fixed compiler errors for bloom release</li>
</ul>

<h2 id="011-2020-05-14">0.1.1 (2020-05-14)</h2>

<ul>
  <li>Initial release</li>
</ul>
</div>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="iron-tutorials">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Wiki Tutorials</h3>
      </div>
      <div class="panel-body">
        
        <em>This package does not provide any links to tutorials in it's <a href="https://index.ros.org/contribute/metadata/">rosindex metadata</a>.</em>
        <em>You can check on the <a href="http://wiki.ros.org/rclc/Tutorials" target="_blank">ROS Wiki Tutorials</a> page for the package.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="iron-deps">
    <div class="row">
      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Package Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th class="text-center">Deps</th>
                  <th style="width: 100%">Name</th>
                </thead>
                <tbody>
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl#iron">rcl  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcl_action#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcl_action#iron">rcl_action  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rcutils#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rcutils#iron">rcutils  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_generator_c#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_generator_c#iron">rosidl_generator_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rosidl_typesupport_c#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rosidl_typesupport_c#iron">rosidl_typesupport_c  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_ros#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_ros#iron">ament_cmake_ros  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_gtest#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_gtest#iron">ament_cmake_gtest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_cmake_pytest#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_cmake_pytest#iron">ament_cmake_pytest  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_auto#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_auto#iron">ament_lint_auto  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/ament_lint_common#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/ament_lint_common#iron">ament_lint_common  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/launch_testing#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/launch_testing#iron">launch_testing  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/osrf_testing_tools_cpp#iron-deps" class="endoftree">
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/osrf_testing_tools_cpp#iron">osrf_testing_tools_cpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/std_msgs#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/std_msgs#iron">std_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/test_msgs#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/test_msgs#iron">test_msgs  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/example_interfaces#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/example_interfaces#iron">example_interfaces  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp#iron">rclcpp  </a></td>
                      </tr>
                    
                  
                    
                    
                      <tr>
                        <td class="text-center">
                          
                          <a href="/p/rclcpp_action#iron-deps" >
                            <span class="glyphicon glyphicon-arrow-left" title="Package dependencies"></span>
                          </a>
                        </td>
                        <td><a href="/p/rclcpp_action#iron">rclcpp_action  </a></td>
                      </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
          <div class="panel-heading">
            <h3 class="panel-title">System Dependencies</h3>
          </div>
          <div class="panel-body">
            
              <em>No direct system dependencies.</em>
            
          </div>
        </div>
      </div>

      <div class="col-sm-6">
        <div class="panel panel-default">
          <div class="panel-heading">
            <h3 class="panel-title">Dependant Packages</h3>
          </div>
          <div class="panel-body">
            
              <table class="table table-condensed table-striped">
                <thead>
                  <th>Name</th>
                  <th class="text-center">Deps</th>
                </thead>
                <tbody>
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_common_diagnostics#iron">micro_ros_common_diagnostics</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_common_diagnostics#iron-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/micro_ros_diagnostic_updater#iron">micro_ros_diagnostic_updater</a></td>
                      <td class="text-center">
                        
                        <a href="/p/micro_ros_diagnostic_updater#iron-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_examples#iron">rclc_examples</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_examples#iron-deps" class="endoftree">
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_lifecycle#iron">rclc_lifecycle</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_lifecycle#iron-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                    
                    
                    <tr>
                      <td><a href="/p/rclc_parameter#iron">rclc_parameter</a></td>
                      <td class="text-center">
                        
                        <a href="/p/rclc_parameter#iron-deps" >
                          <span class="glyphicon glyphicon-arrow-right"></span>
                        </a>
                      </td>
                    </tr>
                    
                  
                </tbody>
              </table>
            
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tab-pane" id="iron-assets">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Launch files</h3>
      </div>
      <div class="panel-body">
        
          <em>No launch files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Messages</h3>
      </div>
      <div class="panel-body">
        
          <em>No message files found.</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Services</h3>
      </div>
      <div class="panel-body">
        
          <em>No service files found</em>
        
      </div>
    </div>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Plugins</h3>
      </div>
      <div class="panel-body">
        
          <em>No plugins found.</em>
        
      </div>
    </div>
  </div>

  <div class="tab-pane" id="iron-questions">
    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">Recent questions tagged <kbd>rclc</kbd> at <strong><a href="https://robotics.stackexchange.com/" target="_blank">Robotics Stack Exchange</a></strong></h3>      </div>
      <div id="iron-question-list" class="panel-body" style="display: none;"></div>
      <div id="iron-no-question-list" class="panel-body" style="display: none;">
        <p>No questions yet, you can ask one <a href="https://robotics.stackexchange.com/questions/tagged/rclc+iron">here</a>.</p>
      </div>
      <div id="iron-get-question-fail" class="panel-body alert alert-warning" style="display: none;">
        <p>Failed to get question list, you can ticket an issue <a href="https://github.com/ros-infrastructure/rosindex/issues/new" target="_blank" class="alert-link">here</a> </p>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript" src="/js/package_body_tabs.js"></script>

<script src=/js/contribution_suggestions.js></script>
<script type="text/javascript">
jQuery(function() {
    // Update the count on the links to the contribution suggestions
    updateContributionSuggestionsCountOnPackage('https://github.com/ros2/rclc.git');
});
</script>

          </div>
          <div class="col-md-2 hidden-xs hidden-sm">
            
            
            



<div class="list-group list-group-sm ">
  <a class="list-group-item"
     target="_blank"
     href="http://docs.ros.org/en/iron/p/rclc"
     title="View API documentation on docs.ros.org"
     >
       <span style="margin-right: 5px;" class="glyphicon glyphicon-file"></span>
       
       API Docs
  </a>
  <a class="list-group-item"
     target="_blank"
     href="https://github.com/ros2/rclc/tree/iron/rclc"
     title="View source code on repository">
       <span class="glyphicon glyphicon-folder-open" style="margin-right:5px;"></span>
       
       Browse Code
  </a>
  
  
  
  
  
  
</div>

          </div>
        </div>
      
    </div>
  </div>

  <div class="distro distro-melodic">
    <div class="container-fluid">
      
          <div class="alert alert-warning">No version for distro <strong>melodic</strong>. Known supported distros are highlighted in the buttons above.</div>
      
    </div>
  </div>



<script id="question-list-template" type="text/html">
  <p>
    Browse <a href="https://robotics.stackexchange.com/questions/tagged/rclc?tab=Newest">recent questions</a>
    or see the <a href="https://robotics.stackexchange.com/questions/tagged/rclc?tab=Votes">highest voted ones</a>.
  </p>
  
  <table class="table table-striped">
    <thead>
      <tr>
        <th scope="col">Title</th>
        <th scope="col">Answered?</th>
        <th scope="col">Created</th>
        <th scope="col">Active</th>
      </tr>
    </thead>
    <tbody>
      {{#questions}}
      <tr>
        <th scope="row"><a href="{{link}}">{{title}}</a><br><small>Tags: {{strtags}}</small></th>
        <th>{{answered}}</th>
        <th>{{created}}</th>
        <th>{{active}}</th>
      </tr>
      {{/questions}}
    </tbody>
  </table>
  {{#has_more}}
  <hr>
  <h4>Additional questions are available at
    <a href="https://robotics.stackexchange.com/questions/tagged/{{name}}?tab=Newest">Robotics Stack Exchange</a>
  </h4>
  {{/has_more}}
  
</script>

<script type="text/javascript" src="/js/mustache.js"></script>
<script type="text/javascript">
  jQuery(function() {
    jQuery.getJSON(url="https://api.stackexchange.com/2.3/questions?order=desc&site=robotics" +
                       "&tagged=rclc&pagesize=50&sort=activity")
    .done(function(feed) {
      if (feed.items.length > 0) {
        var question_count_str = (feed.has_more ? '>' : '') + String(feed.items.length)
        const questions = feed.items.map(
          function(question) {
            question.id = Math.round(Math.random() * 99999.0);
            question.created = (new Date(question.creation_date * 1000)).toDateString()
            question.active = (new Date(question.last_activity_date * 1000)).toDateString()
            question.answered = question.is_answered ? "Yes" : "No"
            question.strtags = question.tags.join(' ')
            return question;
          });
        const template = jQuery("#question-list-template").text();
        Mustache.parse(template);
        var rendered = Mustache.render(
          template, 
          { questions: questions,
            has_more: feed.has_more,
            name: "rclc"
          }
        );
      }
      //   TODO(tfoote) Resolve images
      //   jQuery("#-question-list img").each(function() {
      //     if (jQuery(this).attr("src").startsWith("/upfiles")) {
      //        jQuery(this).attr("src", "https://answers.ros.org" + jQuery(this).attr("src"));
      //     }
      //   });
      
      if (feed.items.length > 0) {
        jQuery("#humble-question-list").html(rendered);
        jQuery("#humble-question-list").show();
      } else {
        jQuery("#humble-no-question-list").show();
      }
      jQuery("#humble-questions-count").text(question_count_str);
      
      if (feed.items.length > 0) {
        jQuery("#jazzy-question-list").html(rendered);
        jQuery("#jazzy-question-list").show();
      } else {
        jQuery("#jazzy-no-question-list").show();
      }
      jQuery("#jazzy-questions-count").text(question_count_str);
      
      if (feed.items.length > 0) {
        jQuery("#kilted-question-list").html(rendered);
        jQuery("#kilted-question-list").show();
      } else {
        jQuery("#kilted-no-question-list").show();
      }
      jQuery("#kilted-questions-count").text(question_count_str);
      
      if (feed.items.length > 0) {
        jQuery("#rolling-question-list").html(rendered);
        jQuery("#rolling-question-list").show();
      } else {
        jQuery("#rolling-no-question-list").show();
      }
      jQuery("#rolling-questions-count").text(question_count_str);
      
      if (feed.items.length > 0) {
        jQuery("#github-question-list").html(rendered);
        jQuery("#github-question-list").show();
      } else {
        jQuery("#github-no-question-list").show();
      }
      jQuery("#github-questions-count").text(question_count_str);
      
      if (feed.items.length > 0) {
        jQuery("#noetic-question-list").html(rendered);
        jQuery("#noetic-question-list").show();
      } else {
        jQuery("#noetic-no-question-list").show();
      }
      jQuery("#noetic-questions-count").text(question_count_str);
      
      if (feed.items.length > 0) {
        jQuery("#galactic-question-list").html(rendered);
        jQuery("#galactic-question-list").show();
      } else {
        jQuery("#galactic-no-question-list").show();
      }
      jQuery("#galactic-questions-count").text(question_count_str);
      
      if (feed.items.length > 0) {
        jQuery("#iron-question-list").html(rendered);
        jQuery("#iron-question-list").show();
      } else {
        jQuery("#iron-no-question-list").show();
      }
      jQuery("#iron-questions-count").text(question_count_str);
      
      if (feed.items.length > 0) {
        jQuery("#melodic-question-list").html(rendered);
        jQuery("#melodic-question-list").show();
      } else {
        jQuery("#melodic-no-question-list").show();
      }
      jQuery("#melodic-questions-count").text(question_count_str);
      
    })
    .fail(function(jqxhr, textStatus, error) {
      console.error("Failed to get question data: " + jqxhr.responseText);
      
      jQuery("#humble-get-question-fail").show();
      
      jQuery("#jazzy-get-question-fail").show();
      
      jQuery("#kilted-get-question-fail").show();
      
      jQuery("#rolling-get-question-fail").show();
      
      jQuery("#github-get-question-fail").show();
      
      jQuery("#noetic-get-question-fail").show();
      
      jQuery("#galactic-get-question-fail").show();
      
      jQuery("#iron-get-question-fail").show();
      
      jQuery("#melodic-get-question-fail").show();
      
    });
  });
</script>


<script type="text/javascript">
  $(document).ready(function() {
    setupDistroSwitch("humble");
  });
</script>

      </div>
    </div>

    <footer class="site-footer">
  <div class="wrapper">
    <div class="container-fluid">
      <div style="float:left;">
        
          <a href="https://github.com/rkent/rosindex" title="Find rosindex in Github">
          <span class="icon  icon--github">
            <svg viewBox="0 0 16 16">
              <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
            </svg>
          </span>

          <span class="username">rkent/rosindex</span>
        </a>
        <em class="hidden-xs">| generated on 2025-05-05</em>
      
      </div>
      <div style="float:right;">
        <p class="text"><span class="hidden-xs">a community-maintained index of robotics software
 | </span><a href="/privacy.txt">privacy</a></p>
      </div>
    </div>
  </div>

</footer>


  </body>

</html>
